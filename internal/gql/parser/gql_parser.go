// Code generated from ../internal/gql/grammar/GQL.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // GQL
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type GQLParser struct {
	*antlr.BaseParser
}

var GQLParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func gqlParserInit() {
	staticData := &GQLParserStaticData
	staticData.LiteralNames = []string{
		"", "'CHECK'", "'PRIMARY'", "'KEY'", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "'ABS'", "'ACOS'", "'ALL'",
		"'ALL_DIFFERENT'", "'AND'", "'ANY'", "'ARRAY'", "'AS'", "'ASC'", "'ASCENDING'",
		"'ASIN'", "'AT'", "'ATAN'", "'AVG'", "'BIG'", "'BIGINT'", "'BINARY'",
		"'BOOL'", "'BOOLEAN'", "'BOTH'", "'BTRIM'", "'BY'", "'BYTE_LENGTH'",
		"'BYTES'", "'CALL'", "'CARDINALITY'", "'CASE'", "'CAST'", "'CEIL'",
		"'CEILING'", "'CHAR'", "'CHAR_LENGTH'", "'CHARACTER_LENGTH'", "'CHARACTERISTICS'",
		"'CLOSE'", "'COALESCE'", "'COLLECT_LIST'", "'COMMIT'", "'COPY'", "'COS'",
		"'COSH'", "'COT'", "'COUNT'", "'CREATE'", "'CURRENT_DATE'", "'CURRENT_GRAPH'",
		"'CURRENT_PROPERTY_GRAPH'", "'CURRENT_SCHEMA'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'",
		"'DATE'", "'DATETIME'", "'DAY'", "'DEC'", "'DECIMAL'", "'DEGREES'",
		"'DELETE'", "'DESC'", "'DESCENDING'", "'DETACH'", "'DISTINCT'", "'DOUBLE'",
		"'DROP'", "'DURATION'", "'DURATION_BETWEEN'", "'ELEMENT_ID'", "'ELSE'",
		"'END'", "'EXCEPT'", "'EXISTS'", "'EXP'", "'FILTER'", "'FINISH'", "'FLOAT'",
		"'FLOAT16'", "'FLOAT32'", "'FLOAT64'", "'FLOAT128'", "'FLOAT256'", "'FLOOR'",
		"'FOR'", "'FROM'", "'GROUP'", "'HAVING'", "'HOME_GRAPH'", "'HOME_PROPERTY_GRAPH'",
		"'HOME_SCHEMA'", "'HOUR'", "'IF'", "'IN'", "'INSERT'", "'INT'", "'INTEGER'",
		"'INT8'", "'INTEGER8'", "'INT16'", "'INTEGER16'", "'INT32'", "'INTEGER32'",
		"'INT64'", "'INTEGER64'", "'INT128'", "'INTEGER128'", "'INT256'", "'INTEGER256'",
		"'INTERSECT'", "'INTERVAL'", "'IS'", "'LEADING'", "'LEFT'", "'LET'",
		"'LIKE'", "'LIMIT'", "'LIST'", "'LN'", "'LOCAL'", "'LOCAL_DATETIME'",
		"'LOCAL_TIME'", "'LOCAL_TIMESTAMP'", "'LOG'", "'LOG10'", "'LOWER'",
		"'LTRIM'", "'MATCH'", "'MAX'", "'MIN'", "'MINUTE'", "'MOD'", "'MONTH'",
		"'NEXT'", "'NODETACH'", "'NORMALIZE'", "'NOT'", "'NOTHING'", "'NULL'",
		"'NULLS'", "'NULLIF'", "'OCTET_LENGTH'", "'OF'", "'OFFSET'", "'OPTIONAL'",
		"'OR'", "'ORDER'", "'OTHERWISE'", "'PARAMETER'", "'PARAMETERS'", "'PATH'",
		"'PATH_LENGTH'", "'PATHS'", "'PERCENTILE_CONT'", "'PERCENTILE_DISC'",
		"'POWER'", "'PRECISION'", "'PROPERTY_EXISTS'", "'RADIANS'", "'REAL'",
		"'RECORD'", "'REMOVE'", "'REPLACE'", "'RESET'", "'RETURN'", "'RIGHT'",
		"'ROLLBACK'", "'RTRIM'", "'SAME'", "'SCHEMA'", "'SECOND'", "'SELECT'",
		"'SESSION'", "'SESSION_USER'", "'SET'", "'SIGNED'", "'SIN'", "'SINH'",
		"'SIZE'", "'SKIP'", "'SMALL'", "'SMALLINT'", "'SQRT'", "'START'", "'STDDEV_POP'",
		"'STDDEV_SAMP'", "'STRING'", "'SUM'", "'TAN'", "'TANH'", "'THEN'", "'TIME'",
		"'TIMESTAMP'", "'TRAILING'", "'TRIM'", "'TYPED'", "'UBIGINT'", "'UINT'",
		"'UINT8'", "'UINT16'", "'UINT32'", "'UINT64'", "'UINT128'", "'UINT256'",
		"'UNION'", "'UNSIGNED'", "'UPPER'", "'USE'", "'USMALLINT'", "'VALUE'",
		"'VARBINARY'", "'VARCHAR'", "'VARIABLE'", "'WHEN'", "'WHERE'", "'WITH'",
		"'XOR'", "'YEAR'", "'YIELD'", "'ZONED'", "'ZONED_DATETIME'", "'ZONED_TIME'",
		"'ABSTRACT'", "'AGGREGATE'", "'AGGREGATES'", "'ALTER'", "'CATALOG'",
		"'CLEAR'", "'CLONE'", "'CONSTRAINT'", "'CURRENT_ROLE'", "'CURRENT_USER'",
		"'DATA'", "'DIRECTORY'", "'DRYRUN'", "'EXACT'", "'EXISTING'", "'FUNCTION'",
		"'GQLSTATUS'", "'GRANT'", "'INSTANT'", "'INFINITY'", "'NUMBER'", "'NUMERIC'",
		"'ON'", "'OPEN'", "'PARTITION'", "'PROCEDURE'", "'PRODUCT'", "'PROJECT'",
		"'QUERY'", "'RECORDS'", "'REFERENCE'", "'RENAME'", "'REVOKE'", "'SUBSTRING'",
		"'SYSTEM_USER'", "'TEMPORAL'", "'UNIQUE'", "'UNIT'", "'VALUES'", "'ACYCLIC'",
		"'BINDING'", "'BINDINGS'", "'CONNECTING'", "'DESTINATION'", "'DIFFERENT'",
		"'DIRECTED'", "'EDGE'", "'EDGES'", "'ELEMENT'", "'ELEMENTS'", "'FIRST'",
		"'GRAPH'", "'GROUPS'", "'KEEP'", "'LABEL'", "'LABELED'", "'LABELS'",
		"'LAST'", "'NFC'", "'NFD'", "'NFKC'", "'NFKD'", "'NO'", "'NODE'", "'NORMALIZED'",
		"'ONLY'", "'ORDINALITY'", "'PROPERTY'", "'READ'", "'RELATIONSHIP'",
		"'RELATIONSHIPS'", "'REPEATABLE'", "'SHORTEST'", "'SIMPLE'", "'SOURCE'",
		"'TABLE'", "'TO'", "'TRAIL'", "'TRANSACTION'", "'TYPE'", "'UNDIRECTED'",
		"'VERTEX'", "'WALK'", "'WITHOUT'", "'WRITE'", "'ZONE'", "", "", "",
		"'|+|'", "']->'", "']~>'", "'||'", "'::'", "'$$'", "'..'", "'>='", "'<-'",
		"'<~'", "'<-['", "'<~['", "'<->'", "'<-/'", "'<~/'", "'<='", "'-['",
		"'-/'", "'<>'", "'->'", "']-'", "']~'", "'=>'", "'/-'", "'/->'", "'/~'",
		"'/~>'", "'~['", "'~>'", "'~/'", "'&'", "'*'", "':'", "','", "'@'",
		"'$'", "'\"'", "'='", "'!'", "'>'", "'`'", "'{'", "'['", "'('", "'<'",
		"'-'", "'%'", "'.'", "'+'", "'?'", "'''", "'\\'", "'}'", "']'", "')'",
		"'/'", "'~'", "'_'", "'|'",
	}
	staticData.SymbolicNames = []string{
		"", "CHECK", "PRIMARY", "KEY", "IMPLIES", "BOOLEAN_LITERAL", "SINGLE_QUOTED_CHARACTER_SEQUENCE",
		"DOUBLE_QUOTED_CHARACTER_SEQUENCE", "ACCENT_QUOTED_CHARACTER_SEQUENCE",
		"NO_ESCAPE", "BYTE_STRING_LITERAL", "UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX",
		"UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX", "UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX",
		"UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX", "UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX",
		"UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX",
		"UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX", "UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX",
		"UNSIGNED_DECIMAL_INTEGER", "UNSIGNED_HEXADECIMAL_INTEGER", "UNSIGNED_OCTAL_INTEGER",
		"UNSIGNED_BINARY_INTEGER", "ABS", "ACOS", "ALL", "ALL_DIFFERENT", "AND",
		"ANY", "ARRAY", "AS", "ASC", "ASCENDING", "ASIN", "AT", "ATAN", "AVG",
		"BIG", "BIGINT", "BINARY", "BOOL", "BOOLEAN", "BOTH", "BTRIM", "BY",
		"BYTE_LENGTH", "BYTES", "CALL", "CARDINALITY", "CASE", "CAST", "CEIL",
		"CEILING", "CHAR", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHARACTERISTICS",
		"CLOSE", "COALESCE", "COLLECT_LIST", "COMMIT", "COPY", "COS", "COSH",
		"COT", "COUNT", "CREATE", "CURRENT_DATE", "CURRENT_GRAPH", "CURRENT_PROPERTY_GRAPH",
		"CURRENT_SCHEMA", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATE", "DATETIME",
		"DAY", "DEC", "DECIMAL", "DEGREES", "DELETE", "DESC", "DESCENDING",
		"DETACH", "DISTINCT", "DOUBLE", "DROP", "DURATION", "DURATION_BETWEEN",
		"ELEMENT_ID", "ELSE", "END", "EXCEPT", "EXISTS", "EXP", "FILTER", "FINISH",
		"FLOAT", "FLOAT16", "FLOAT32", "FLOAT64", "FLOAT128", "FLOAT256", "FLOOR",
		"FOR", "FROM", "GROUP", "HAVING", "HOME_GRAPH", "HOME_PROPERTY_GRAPH",
		"HOME_SCHEMA", "HOUR", "IF", "IN", "INSERT", "INT", "INTEGER", "INT8",
		"INTEGER8", "INT16", "INTEGER16", "INT32", "INTEGER32", "INT64", "INTEGER64",
		"INT128", "INTEGER128", "INT256", "INTEGER256", "INTERSECT", "INTERVAL",
		"IS", "LEADING", "LEFT", "LET", "LIKE", "LIMIT", "LIST", "LN", "LOCAL",
		"LOCAL_DATETIME", "LOCAL_TIME", "LOCAL_TIMESTAMP", "LOG_KW", "LOG10",
		"LOWER", "LTRIM", "MATCH", "MAX", "MIN", "MINUTE", "MOD", "MONTH", "NEXT",
		"NODETACH", "NORMALIZE", "NOT", "NOTHING", "NULL_KW", "NULLS", "NULLIF",
		"OCTET_LENGTH", "OF", "OFFSET", "OPTIONAL", "OR", "ORDER", "OTHERWISE",
		"PARAMETER", "PARAMETERS", "PATH", "PATH_LENGTH", "PATHS", "PERCENTILE_CONT",
		"PERCENTILE_DISC", "POWER", "PRECISION", "PROPERTY_EXISTS", "RADIANS",
		"REAL", "RECORD", "REMOVE", "REPLACE", "RESET", "RETURN", "RIGHT", "ROLLBACK",
		"RTRIM", "SAME", "SCHEMA", "SECOND", "SELECT", "SESSION", "SESSION_USER",
		"SET", "SIGNED", "SIN", "SINH", "SIZE", "SKIP_RESERVED_WORD", "SMALL",
		"SMALLINT", "SQRT", "START", "STDDEV_POP", "STDDEV_SAMP", "STRING",
		"SUM", "TAN", "TANH", "THEN", "TIME", "TIMESTAMP", "TRAILING", "TRIM",
		"TYPED", "UBIGINT", "UINT", "UINT8", "UINT16", "UINT32", "UINT64", "UINT128",
		"UINT256", "UNION", "UNSIGNED", "UPPER", "USE", "USMALLINT", "VALUE",
		"VARBINARY", "VARCHAR", "VARIABLE", "WHEN", "WHERE", "WITH", "XOR",
		"YEAR", "YIELD", "ZONED", "ZONED_DATETIME", "ZONED_TIME", "ABSTRACT",
		"AGGREGATE", "AGGREGATES", "ALTER", "CATALOG", "CLEAR", "CLONE", "CONSTRAINT",
		"CURRENT_ROLE", "CURRENT_USER", "DATA", "DIRECTORY", "DRYRUN", "EXACT",
		"EXISTING", "FUNCTION", "GQLSTATUS", "GRANT", "INSTANT", "INFINITY_KW",
		"NUMBER", "NUMERIC", "ON", "OPEN", "PARTITION", "PROCEDURE", "PRODUCT",
		"PROJECT", "QUERY", "RECORDS", "REFERENCE", "RENAME", "REVOKE", "SUBSTRING",
		"SYSTEM_USER", "TEMPORAL", "UNIQUE", "UNIT", "VALUES", "ACYCLIC", "BINDING",
		"BINDINGS", "CONNECTING", "DESTINATION", "DIFFERENT", "DIRECTED", "EDGE",
		"EDGES", "ELEMENT", "ELEMENTS", "FIRST", "GRAPH", "GROUPS", "KEEP",
		"LABEL", "LABELED", "LABELS", "LAST", "NFC", "NFD", "NFKC", "NFKD",
		"NO", "NODE", "NORMALIZED", "ONLY", "ORDINALITY", "PROPERTY", "READ",
		"RELATIONSHIP", "RELATIONSHIPS", "REPEATABLE", "SHORTEST", "SIMPLE",
		"SOURCE", "TABLE", "TO", "TRAIL", "TRANSACTION", "TYPE", "UNDIRECTED",
		"VERTEX", "WALK", "WITHOUT", "WRITE", "ZONE", "REGULAR_IDENTIFIER",
		"SUBSTITUTED_PARAMETER_REFERENCE", "GENERAL_PARAMETER_REFERENCE", "MULTISET_ALTERNATION_OPERATOR",
		"BRACKET_RIGHT_ARROW", "BRACKET_TILDE_RIGHT_ARROW", "CONCATENATION_OPERATOR",
		"DOUBLE_COLON", "DOUBLE_DOLLAR_SIGN", "DOUBLE_PERIOD", "GREATER_THAN_OR_EQUALS_OPERATOR",
		"LEFT_ARROW", "LEFT_ARROW_TILDE", "LEFT_ARROW_BRACKET", "LEFT_ARROW_TILDE_BRACKET",
		"LEFT_MINUS_RIGHT", "LEFT_MINUS_SLASH", "LEFT_TILDE_SLASH", "LESS_THAN_OR_EQUALS_OPERATOR",
		"MINUS_LEFT_BRACKET", "MINUS_SLASH", "NOT_EQUALS_OPERATOR", "RIGHT_ARROW",
		"RIGHT_BRACKET_MINUS", "RIGHT_BRACKET_TILDE", "RIGHT_DOUBLE_ARROW",
		"SLASH_MINUS", "SLASH_MINUS_RIGHT", "SLASH_TILDE", "SLASH_TILDE_RIGHT",
		"TILDE_LEFT_BRACKET", "TILDE_RIGHT_ARROW", "TILDE_SLASH", "AMPERSAND",
		"ASTERISK", "COLON", "COMMA", "COMMERCIAL_AT", "DOLLAR_SIGN", "DOUBLE_QUOTE",
		"EQUALS_OPERATOR", "EXCLAMATION_MARK", "RIGHT_ANGLE_BRACKET", "GRAVE_ACCENT",
		"LEFT_BRACE", "LEFT_BRACKET", "LEFT_PAREN", "LEFT_ANGLE_BRACKET", "MINUS_SIGN",
		"PERCENT", "PERIOD", "PLUS_SIGN", "QUESTION_MARK", "QUOTE", "REVERSE_SOLIDUS",
		"RIGHT_BRACE", "RIGHT_BRACKET", "RIGHT_PAREN", "SOLIDUS", "TILDE", "UNDERSCORE",
		"VERTICAL_BAR", "SP", "WHITESPACE", "BRACKETED_COMMENT", "SIMPLE_COMMENT_SOLIDUS",
		"SIMPLE_COMMENT_MINUS",
	}
	staticData.RuleNames = []string{
		"gqlProgram", "programActivity", "sessionActivity", "transactionActivity",
		"endTransactionCommand", "sessionSetCommand", "sessionSetSchemaClause",
		"sessionSetGraphClause", "sessionSetTimeZoneClause", "setTimeZoneValue",
		"sessionSetParameterClause", "sessionSetGraphParameterClause", "sessionSetBindingTableParameterClause",
		"sessionSetValueParameterClause", "sessionSetParameterName", "sessionResetCommand",
		"sessionResetArguments", "sessionCloseCommand", "sessionParameterSpecification",
		"startTransactionCommand", "transactionCharacteristics", "transactionMode",
		"transactionAccessMode", "rollbackCommand", "commitCommand", "nestedProcedureSpecification",
		"procedureSpecification", "nestedDataModifyingProcedureSpecification",
		"nestedQuerySpecification", "procedureBody", "bindingVariableDefinitionBlock",
		"bindingVariableDefinition", "statementBlock", "statement", "nextStatement",
		"graphVariableDefinition", "optTypedGraphInitializer", "graphInitializer",
		"bindingTableVariableDefinition", "optTypedBindingTableInitializer",
		"bindingTableInitializer", "valueVariableDefinition", "optTypedValueInitializer",
		"valueInitializer", "graphExpression", "currentGraph", "bindingTableExpression",
		"nestedBindingTableQuerySpecification", "objectExpressionPrimary", "linearCatalogModifyingStatement",
		"simpleCatalogModifyingStatement", "primitiveCatalogModifyingStatement",
		"createSchemaStatement", "dropSchemaStatement", "createGraphStatement",
		"openGraphType", "ofGraphType", "graphTypeLikeGraph", "graphSource",
		"dropGraphStatement", "createGraphTypeStatement", "graphTypeSource",
		"copyOfGraphType", "dropGraphTypeStatement", "callCatalogModifyingProcedureStatement",
		"linearDataModifyingStatement", "focusedLinearDataModifyingStatement",
		"focusedLinearDataModifyingStatementBody", "focusedNestedDataModifyingProcedureSpecification",
		"ambientLinearDataModifyingStatement", "ambientLinearDataModifyingStatementBody",
		"simpleLinearDataAccessingStatement", "simpleDataAccessingStatement",
		"simpleDataModifyingStatement", "primitiveDataModifyingStatement", "insertStatement",
		"setStatement", "setItemList", "setItem", "setPropertyItem", "setAllPropertiesItem",
		"setLabelItem", "removeStatement", "removeItemList", "removeItem", "removePropertyItem",
		"removeLabelItem", "deleteStatement", "deleteItemList", "deleteItem",
		"callDataModifyingProcedureStatement", "compositeQueryStatement", "compositeQueryExpression",
		"queryConjunction", "setOperator", "compositeQueryPrimary", "linearQueryStatement",
		"focusedLinearQueryStatement", "focusedLinearQueryStatementPart", "focusedLinearQueryAndPrimitiveResultStatementPart",
		"focusedPrimitiveResultStatement", "focusedNestedQuerySpecification",
		"ambientLinearQueryStatement", "simpleLinearQueryStatement", "simpleQueryStatement",
		"primitiveQueryStatement", "matchStatement", "simpleMatchStatement",
		"optionalMatchStatement", "optionalOperand", "matchStatementBlock",
		"callQueryStatement", "filterStatement", "letStatement", "letVariableDefinitionList",
		"letVariableDefinition", "forStatement", "forItem", "forItemAlias",
		"forItemSource", "forOrdinalityOrOffset", "orderByAndPageStatement",
		"primitiveResultStatement", "returnStatement", "returnStatementBody",
		"returnItemList", "returnItem", "returnItemAlias", "selectStatement",
		"selectItemList", "selectItem", "selectItemAlias", "havingClause", "selectStatementBody",
		"selectGraphMatchList", "selectGraphMatch", "selectQuerySpecification",
		"callProcedureStatement", "procedureCall", "inlineProcedureCall", "variableScopeClause",
		"bindingVariableReferenceList", "namedProcedureCall", "procedureArgumentList",
		"procedureArgument", "atSchemaClause", "useGraphClause", "graphPatternBindingTable",
		"graphPatternYieldClause", "graphPatternYieldItemList", "graphPatternYieldItem",
		"graphPattern", "matchMode", "repeatableElementsMatchMode", "differentEdgesMatchMode",
		"elementBindingsOrElements", "edgeBindingsOrEdges", "pathPatternList",
		"pathPattern", "pathVariableDeclaration", "keepClause", "graphPatternWhereClause",
		"insertGraphPattern", "insertPathPatternList", "insertPathPattern",
		"insertNodePattern", "insertEdgePattern", "insertEdgePointingLeft",
		"insertEdgePointingRight", "insertEdgeUndirected", "insertElementPatternFiller",
		"labelAndPropertySetSpecification", "pathPatternPrefix", "pathModePrefix",
		"pathMode", "pathSearchPrefix", "allPathSearch", "pathOrPaths", "anyPathSearch",
		"numberOfPaths", "shortestPathSearch", "allShortestPathSearch", "anyShortestPathSearch",
		"countedShortestPathSearch", "countedShortestGroupSearch", "numberOfGroups",
		"pathPatternExpression", "pathTerm", "pathFactor", "pathPrimary", "elementPattern",
		"nodePattern", "elementPatternFiller", "elementVariableDeclaration",
		"isLabelExpression", "isOrColon", "elementPatternPredicate", "elementPatternWhereClause",
		"elementPropertySpecification", "propertyKeyValuePairList", "propertyKeyValuePair",
		"edgePattern", "fullEdgePattern", "fullEdgePointingLeft", "fullEdgeUndirected",
		"fullEdgePointingRight", "fullEdgeLeftOrUndirected", "fullEdgeUndirectedOrRight",
		"fullEdgeLeftOrRight", "fullEdgeAnyDirection", "abbreviatedEdgePattern",
		"parenthesizedPathPatternExpression", "subpathVariableDeclaration",
		"parenthesizedPathPatternWhereClause", "labelExpression", "pathVariableReference",
		"elementVariableReference", "graphPatternQuantifier", "fixedQuantifier",
		"generalQuantifier", "lowerBound", "upperBound", "simplifiedPathPatternExpression",
		"simplifiedDefaultingLeft", "simplifiedDefaultingUndirected", "simplifiedDefaultingRight",
		"simplifiedDefaultingLeftOrUndirected", "simplifiedDefaultingUndirectedOrRight",
		"simplifiedDefaultingLeftOrRight", "simplifiedDefaultingAnyDirection",
		"simplifiedContents", "simplifiedPathUnion", "simplifiedMultisetAlternation",
		"simplifiedTerm", "simplifiedFactorLow", "simplifiedFactorHigh", "simplifiedQuantified",
		"simplifiedQuestioned", "simplifiedTertiary", "simplifiedDirectionOverride",
		"simplifiedOverrideLeft", "simplifiedOverrideUndirected", "simplifiedOverrideRight",
		"simplifiedOverrideLeftOrUndirected", "simplifiedOverrideUndirectedOrRight",
		"simplifiedOverrideLeftOrRight", "simplifiedOverrideAnyDirection", "simplifiedSecondary",
		"simplifiedNegation", "simplifiedPrimary", "whereClause", "yieldClause",
		"yieldItemList", "yieldItem", "yieldItemName", "yieldItemAlias", "groupByClause",
		"groupingElementList", "groupingElement", "emptyGroupingSet", "orderByClause",
		"sortSpecificationList", "sortSpecification", "sortKey", "orderingSpecification",
		"nullOrdering", "limitClause", "offsetClause", "offsetSynonym", "schemaReference",
		"absoluteCatalogSchemaReference", "catalogSchemaParentAndName", "relativeCatalogSchemaReference",
		"predefinedSchemaReference", "absoluteDirectoryPath", "relativeDirectoryPath",
		"simpleDirectoryPath", "graphReference", "catalogGraphParentAndName",
		"homeGraph", "graphTypeReference", "catalogGraphTypeParentAndName",
		"bindingTableReference", "procedureReference", "catalogProcedureParentAndName",
		"catalogObjectParentReference", "referenceParameterSpecification", "nestedGraphTypeSpecification",
		"graphTypeSpecificationBody", "elementTypeList", "elementTypeSpecification",
		"compositePrimaryKey", "compositeUniqueConstraint", "fieldNameList",
		"nodeTypeSpecification", "nodeTypePattern", "nodeTypePhrase", "nodeTypePhraseFiller",
		"nodeTypeFiller", "localNodeTypeAlias", "nodeTypeImpliedContent", "nodeTypeKeyLabelSet",
		"nodeTypeLabelSet", "nodeTypePropertyTypes", "edgeTypeSpecification",
		"edgeTypePattern", "edgeTypePhrase", "edgeTypePhraseFiller", "edgeTypeFiller",
		"edgeTypeImpliedContent", "edgeTypeKeyLabelSet", "edgeTypeLabelSet",
		"edgeTypePropertyTypes", "edgeTypePatternDirected", "edgeTypePatternPointingRight",
		"edgeTypePatternPointingLeft", "edgeTypePatternUndirected", "arcTypePointingRight",
		"simpleArcTypePointingRight", "arcWithCardinalityPointingRight", "arcTypePointingLeft",
		"simpleArcTypePointingLeft", "arcWithCardinalityPointingLeft", "arcTypeUndirected",
		"simpleArcTypeUndirected", "arcWithCardinalityUndirected", "cardinality",
		"cardinalityFiller", "cardinalityLowerBound", "cardinalityUpperBound",
		"sourceNodeTypeReference", "destinationNodeTypeReference", "edgeKind",
		"endpointPairPhrase", "endpointPair", "endpointPairDirected", "endpointPairPointingRight",
		"endpointPairPointingLeft", "endpointPairUndirected", "connectorPointingRight",
		"connectorUndirected", "sourceNodeTypeAlias", "destinationNodeTypeAlias",
		"labelSetPhrase", "labelSetSpecification", "propertyTypesSpecification",
		"propertyTypeList", "propertyType", "primaryKey", "checkConstraint",
		"propertyValueType", "bindingTableType", "valueType", "typed", "predefinedType",
		"booleanType", "characterStringType", "byteStringType", "minLength",
		"maxLength", "fixedLength", "numericType", "exactNumericType", "binaryExactNumericType",
		"signedBinaryExactNumericType", "unsignedBinaryExactNumericType", "verboseBinaryExactNumericType",
		"decimalExactNumericType", "precision", "scale", "approximateNumericType",
		"temporalType", "temporalInstantType", "datetimeType", "localdatetimeType",
		"dateType", "timeType", "localtimeType", "temporalDurationType", "temporalDurationQualifier",
		"referenceValueType", "immaterialValueType", "nullType", "emptyType",
		"graphReferenceValueType", "closedGraphReferenceValueType", "openGraphReferenceValueType",
		"bindingTableReferenceValueType", "nodeReferenceValueType", "closedNodeReferenceValueType",
		"openNodeReferenceValueType", "edgeReferenceValueType", "closedEdgeReferenceValueType",
		"openEdgeReferenceValueType", "pathValueType", "listValueTypeName",
		"listValueTypeNameSynonym", "recordType", "fieldTypesSpecification",
		"fieldTypeList", "notNull", "fieldType", "searchCondition", "predicate",
		"compOp", "existsPredicate", "nullPredicate", "nullPredicatePart2",
		"valueTypePredicate", "valueTypePredicatePart2", "normalizedPredicatePart2",
		"directedPredicate", "directedPredicatePart2", "labeledPredicate", "labeledPredicatePart2",
		"isLabeledOrColon", "sourceDestinationPredicate", "nodeReference", "sourcePredicatePart2",
		"destinationPredicatePart2", "edgeReference", "all_differentPredicate",
		"samePredicate", "property_existsPredicate", "valueExpression", "valueFunction",
		"booleanValueExpression", "characterOrByteStringFunction", "subCharacterOrByteString",
		"trimSingleCharacterOrByteString", "foldCharacterString", "trimMultiCharacterCharacterString",
		"normalizeCharacterString", "nodeReferenceValueExpression", "edgeReferenceValueExpression",
		"aggregatingValueExpression", "valueExpressionPrimary", "parenthesizedValueExpression",
		"nonParenthesizedValueExpressionPrimary", "nonParenthesizedValueExpressionPrimarySpecialCase",
		"unsignedValueSpecification", "nonNegativeIntegerSpecification", "generalValueSpecification",
		"dynamicParameterSpecification", "letValueExpression", "valueQueryExpression",
		"caseExpression", "caseAbbreviation", "caseSpecification", "simpleCase",
		"searchedCase", "simpleWhenClause", "searchedWhenClause", "elseClause",
		"caseOperand", "whenOperandList", "whenOperand", "result", "resultExpression",
		"castSpecification", "castOperand", "castTarget", "aggregateFunction",
		"generalSetFunction", "binarySetFunction", "generalSetFunctionType",
		"setQuantifier", "binarySetFunctionType", "dependentValueExpression",
		"independentValueExpression", "element_idFunction", "bindingVariableReference",
		"pathValueExpression", "pathValueConstructor", "pathValueConstructorByEnumeration",
		"pathElementList", "pathElementListStart", "pathElementListStep", "listValueExpression",
		"listValueFunction", "trimListFunction", "elementsFunction", "listValueConstructor",
		"listValueConstructorByEnumeration", "listElementList", "listElement",
		"recordConstructor", "fieldsSpecification", "fieldList", "field", "truthValue",
		"numericValueExpression", "numericValueFunction", "lengthExpression",
		"cardinalityExpression", "cardinalityExpressionArgument", "charLengthExpression",
		"byteLengthExpression", "pathLengthExpression", "absoluteValueExpression",
		"modulusExpression", "numericValueExpressionDividend", "numericValueExpressionDivisor",
		"trigonometricFunction", "trigonometricFunctionName", "generalLogarithmFunction",
		"generalLogarithmBase", "generalLogarithmArgument", "commonLogarithm",
		"naturalLogarithm", "exponentialFunction", "powerFunction", "numericValueExpressionBase",
		"numericValueExpressionExponent", "squareRoot", "floorFunction", "ceilingFunction",
		"characterStringValueExpression", "byteStringValueExpression", "trimOperands",
		"trimCharacterOrByteStringSource", "trimSpecification", "trimCharacterOrByteString",
		"normalForm", "stringLength", "datetimeValueExpression", "datetimeValueFunction",
		"dateFunction", "timeFunction", "localtimeFunction", "datetimeFunction",
		"localdatetimeFunction", "dateFunctionParameters", "timeFunctionParameters",
		"datetimeFunctionParameters", "durationValueExpression", "datetimeSubtraction",
		"datetimeSubtractionParameters", "datetimeValueExpression1", "datetimeValueExpression2",
		"durationValueFunction", "durationFunction", "durationFunctionParameters",
		"objectName", "objectNameOrBindingVariable", "directoryName", "schemaName",
		"graphName", "delimitedGraphName", "graphTypeName", "nodeTypeName",
		"edgeTypeName", "bindingTableName", "delimitedBindingTableName", "procedureName",
		"labelName", "propertyName", "fieldName", "elementVariable", "pathVariable",
		"subpathVariable", "bindingVariable", "unsignedLiteral", "generalLiteral",
		"temporalLiteral", "dateLiteral", "timeLiteral", "datetimeLiteral",
		"listLiteral", "recordLiteral", "identifier", "regularIdentifier", "timeZoneString",
		"characterStringLiteral", "unsignedNumericLiteral", "exactNumericLiteral",
		"approximateNumericLiteral", "unsignedInteger", "unsignedDecimalInteger",
		"nullLiteral", "dateString", "timeString", "datetimeString", "durationLiteral",
		"durationString", "nodeSynonym", "edgesSynonym", "edgeSynonym", "nonReservedWords",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 393, 4718, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7,
		279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2,
		284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7,
		288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2,
		293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7,
		297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2,
		302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7,
		306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2,
		311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7,
		315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2,
		320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7,
		324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2,
		329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7,
		333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2,
		338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7,
		342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2,
		347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7,
		351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2,
		356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 2, 360, 7,
		360, 2, 361, 7, 361, 2, 362, 7, 362, 2, 363, 7, 363, 2, 364, 7, 364, 2,
		365, 7, 365, 2, 366, 7, 366, 2, 367, 7, 367, 2, 368, 7, 368, 2, 369, 7,
		369, 2, 370, 7, 370, 2, 371, 7, 371, 2, 372, 7, 372, 2, 373, 7, 373, 2,
		374, 7, 374, 2, 375, 7, 375, 2, 376, 7, 376, 2, 377, 7, 377, 2, 378, 7,
		378, 2, 379, 7, 379, 2, 380, 7, 380, 2, 381, 7, 381, 2, 382, 7, 382, 2,
		383, 7, 383, 2, 384, 7, 384, 2, 385, 7, 385, 2, 386, 7, 386, 2, 387, 7,
		387, 2, 388, 7, 388, 2, 389, 7, 389, 2, 390, 7, 390, 2, 391, 7, 391, 2,
		392, 7, 392, 2, 393, 7, 393, 2, 394, 7, 394, 2, 395, 7, 395, 2, 396, 7,
		396, 2, 397, 7, 397, 2, 398, 7, 398, 2, 399, 7, 399, 2, 400, 7, 400, 2,
		401, 7, 401, 2, 402, 7, 402, 2, 403, 7, 403, 2, 404, 7, 404, 2, 405, 7,
		405, 2, 406, 7, 406, 2, 407, 7, 407, 2, 408, 7, 408, 2, 409, 7, 409, 2,
		410, 7, 410, 2, 411, 7, 411, 2, 412, 7, 412, 2, 413, 7, 413, 2, 414, 7,
		414, 2, 415, 7, 415, 2, 416, 7, 416, 2, 417, 7, 417, 2, 418, 7, 418, 2,
		419, 7, 419, 2, 420, 7, 420, 2, 421, 7, 421, 2, 422, 7, 422, 2, 423, 7,
		423, 2, 424, 7, 424, 2, 425, 7, 425, 2, 426, 7, 426, 2, 427, 7, 427, 2,
		428, 7, 428, 2, 429, 7, 429, 2, 430, 7, 430, 2, 431, 7, 431, 2, 432, 7,
		432, 2, 433, 7, 433, 2, 434, 7, 434, 2, 435, 7, 435, 2, 436, 7, 436, 2,
		437, 7, 437, 2, 438, 7, 438, 2, 439, 7, 439, 2, 440, 7, 440, 2, 441, 7,
		441, 2, 442, 7, 442, 2, 443, 7, 443, 2, 444, 7, 444, 2, 445, 7, 445, 2,
		446, 7, 446, 2, 447, 7, 447, 2, 448, 7, 448, 2, 449, 7, 449, 2, 450, 7,
		450, 2, 451, 7, 451, 2, 452, 7, 452, 2, 453, 7, 453, 2, 454, 7, 454, 2,
		455, 7, 455, 2, 456, 7, 456, 2, 457, 7, 457, 2, 458, 7, 458, 2, 459, 7,
		459, 2, 460, 7, 460, 2, 461, 7, 461, 2, 462, 7, 462, 2, 463, 7, 463, 2,
		464, 7, 464, 2, 465, 7, 465, 2, 466, 7, 466, 2, 467, 7, 467, 2, 468, 7,
		468, 2, 469, 7, 469, 2, 470, 7, 470, 2, 471, 7, 471, 2, 472, 7, 472, 2,
		473, 7, 473, 2, 474, 7, 474, 2, 475, 7, 475, 2, 476, 7, 476, 2, 477, 7,
		477, 2, 478, 7, 478, 2, 479, 7, 479, 2, 480, 7, 480, 2, 481, 7, 481, 2,
		482, 7, 482, 2, 483, 7, 483, 2, 484, 7, 484, 2, 485, 7, 485, 2, 486, 7,
		486, 2, 487, 7, 487, 2, 488, 7, 488, 2, 489, 7, 489, 2, 490, 7, 490, 2,
		491, 7, 491, 2, 492, 7, 492, 2, 493, 7, 493, 2, 494, 7, 494, 2, 495, 7,
		495, 2, 496, 7, 496, 2, 497, 7, 497, 2, 498, 7, 498, 2, 499, 7, 499, 2,
		500, 7, 500, 2, 501, 7, 501, 2, 502, 7, 502, 2, 503, 7, 503, 2, 504, 7,
		504, 2, 505, 7, 505, 2, 506, 7, 506, 2, 507, 7, 507, 2, 508, 7, 508, 2,
		509, 7, 509, 2, 510, 7, 510, 2, 511, 7, 511, 2, 512, 7, 512, 2, 513, 7,
		513, 2, 514, 7, 514, 2, 515, 7, 515, 2, 516, 7, 516, 2, 517, 7, 517, 2,
		518, 7, 518, 2, 519, 7, 519, 2, 520, 7, 520, 2, 521, 7, 521, 2, 522, 7,
		522, 2, 523, 7, 523, 2, 524, 7, 524, 2, 525, 7, 525, 2, 526, 7, 526, 2,
		527, 7, 527, 2, 528, 7, 528, 2, 529, 7, 529, 2, 530, 7, 530, 2, 531, 7,
		531, 2, 532, 7, 532, 2, 533, 7, 533, 2, 534, 7, 534, 2, 535, 7, 535, 2,
		536, 7, 536, 2, 537, 7, 537, 2, 538, 7, 538, 2, 539, 7, 539, 2, 540, 7,
		540, 2, 541, 7, 541, 2, 542, 7, 542, 2, 543, 7, 543, 2, 544, 7, 544, 2,
		545, 7, 545, 2, 546, 7, 546, 2, 547, 7, 547, 2, 548, 7, 548, 2, 549, 7,
		549, 2, 550, 7, 550, 2, 551, 7, 551, 2, 552, 7, 552, 2, 553, 7, 553, 2,
		554, 7, 554, 2, 555, 7, 555, 2, 556, 7, 556, 2, 557, 7, 557, 2, 558, 7,
		558, 2, 559, 7, 559, 2, 560, 7, 560, 2, 561, 7, 561, 2, 562, 7, 562, 2,
		563, 7, 563, 2, 564, 7, 564, 2, 565, 7, 565, 2, 566, 7, 566, 2, 567, 7,
		567, 2, 568, 7, 568, 2, 569, 7, 569, 2, 570, 7, 570, 2, 571, 7, 571, 2,
		572, 7, 572, 2, 573, 7, 573, 2, 574, 7, 574, 2, 575, 7, 575, 2, 576, 7,
		576, 2, 577, 7, 577, 2, 578, 7, 578, 2, 579, 7, 579, 2, 580, 7, 580, 2,
		581, 7, 581, 2, 582, 7, 582, 2, 583, 7, 583, 2, 584, 7, 584, 2, 585, 7,
		585, 2, 586, 7, 586, 2, 587, 7, 587, 2, 588, 7, 588, 1, 0, 1, 0, 3, 0,
		1181, 8, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0, 1188, 8, 0, 1, 1, 1, 1,
		3, 1, 1192, 8, 1, 1, 2, 4, 2, 1195, 8, 2, 11, 2, 12, 2, 1196, 1, 2, 4,
		2, 1200, 8, 2, 11, 2, 12, 2, 1201, 1, 2, 5, 2, 1205, 8, 2, 10, 2, 12, 2,
		1208, 9, 2, 3, 2, 1210, 8, 2, 1, 3, 1, 3, 1, 3, 3, 3, 1215, 8, 3, 3, 3,
		1217, 8, 3, 1, 3, 1, 3, 3, 3, 1221, 8, 3, 1, 3, 3, 3, 1224, 8, 3, 1, 4,
		1, 4, 3, 4, 1228, 8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 1236,
		8, 5, 1, 6, 1, 6, 1, 6, 1, 7, 3, 7, 1242, 8, 7, 1, 7, 1, 7, 1, 7, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 3, 10, 1256, 8, 10,
		1, 11, 3, 11, 1259, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 12, 3, 12, 1266,
		8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 14, 1,
		14, 1, 14, 3, 14, 1279, 8, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 3, 15,
		1286, 8, 15, 1, 16, 3, 16, 1289, 8, 16, 1, 16, 1, 16, 1, 16, 3, 16, 1294,
		8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 1300, 8, 16, 1, 16, 3, 16, 1303,
		8, 16, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 3, 19, 1313,
		8, 19, 1, 20, 1, 20, 1, 20, 5, 20, 1318, 8, 20, 10, 20, 12, 20, 1321, 9,
		20, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 1329, 8, 22, 1, 23,
		1, 23, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 27, 1,
		27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 29, 3, 29, 1350, 8, 29,
		1, 29, 3, 29, 1353, 8, 29, 1, 29, 1, 29, 1, 30, 4, 30, 1358, 8, 30, 11,
		30, 12, 30, 1359, 1, 31, 1, 31, 1, 31, 3, 31, 1365, 8, 31, 1, 32, 1, 32,
		5, 32, 1369, 8, 32, 10, 32, 12, 32, 1372, 9, 32, 1, 33, 1, 33, 1, 33, 3,
		33, 1377, 8, 33, 1, 34, 1, 34, 3, 34, 1381, 8, 34, 1, 34, 1, 34, 1, 35,
		3, 35, 1386, 8, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 36, 3, 36, 1393, 8,
		36, 1, 36, 3, 36, 1396, 8, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 38,
		3, 38, 1404, 8, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 39, 3, 39, 1411, 8,
		39, 1, 39, 3, 39, 1414, 8, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 42, 3, 42, 1426, 8, 42, 1, 42, 3, 42, 1429, 8,
		42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44,
		1440, 8, 44, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 1448, 8,
		46, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1456, 8, 48, 1, 49,
		4, 49, 1459, 8, 49, 11, 49, 12, 49, 1460, 1, 50, 1, 50, 3, 50, 1465, 8,
		50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3, 51, 1473, 8, 51, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1480, 8, 52, 1, 52, 1, 52, 1, 53, 1,
		53, 1, 53, 1, 53, 3, 53, 1488, 8, 53, 1, 53, 1, 53, 1, 54, 1, 54, 3, 54,
		1494, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1500, 8, 54, 1, 54, 1,
		54, 1, 54, 3, 54, 1505, 8, 54, 1, 54, 3, 54, 1508, 8, 54, 1, 54, 1, 54,
		1, 54, 3, 54, 1513, 8, 54, 1, 54, 3, 54, 1516, 8, 54, 1, 55, 3, 55, 1519,
		8, 55, 1, 55, 1, 55, 3, 55, 1523, 8, 55, 1, 55, 3, 55, 1526, 8, 55, 1,
		56, 1, 56, 3, 56, 1530, 8, 56, 1, 56, 1, 56, 3, 56, 1534, 8, 56, 1, 56,
		3, 56, 1537, 8, 56, 1, 56, 3, 56, 1540, 8, 56, 1, 56, 3, 56, 1543, 8, 56,
		1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59, 3,
		59, 1555, 8, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1560, 8, 59, 1, 59, 1, 59,
		1, 60, 1, 60, 3, 60, 1566, 8, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3,
		60, 1573, 8, 60, 1, 60, 1, 60, 1, 60, 3, 60, 1578, 8, 60, 1, 60, 1, 60,
		3, 60, 1582, 8, 60, 1, 60, 1, 60, 1, 60, 1, 61, 3, 61, 1588, 8, 61, 1,
		61, 1, 61, 1, 61, 3, 61, 1593, 8, 61, 1, 61, 3, 61, 1596, 8, 61, 1, 62,
		1, 62, 1, 62, 1, 62, 1, 63, 1, 63, 3, 63, 1604, 8, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 3, 63, 1610, 8, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 65, 1, 65,
		3, 65, 1618, 8, 65, 1, 66, 1, 66, 3, 66, 1622, 8, 66, 1, 67, 1, 67, 1,
		67, 3, 67, 1627, 8, 67, 1, 68, 1, 68, 1, 68, 1, 69, 1, 69, 3, 69, 1634,
		8, 69, 1, 70, 1, 70, 3, 70, 1638, 8, 70, 1, 71, 4, 71, 1641, 8, 71, 11,
		71, 12, 71, 1642, 1, 72, 1, 72, 3, 72, 1647, 8, 72, 1, 73, 1, 73, 3, 73,
		1651, 8, 73, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 1657, 8, 74, 1, 75, 1,
		75, 1, 75, 1, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 5, 77, 1668, 8, 77,
		10, 77, 12, 77, 1671, 9, 77, 1, 78, 1, 78, 1, 78, 3, 78, 1676, 8, 78, 1,
		79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80,
		1688, 8, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1,
		82, 1, 83, 1, 83, 1, 83, 5, 83, 1702, 8, 83, 10, 83, 12, 83, 1705, 9, 83,
		1, 84, 1, 84, 3, 84, 1709, 8, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 86, 1,
		86, 1, 86, 1, 86, 1, 87, 3, 87, 1720, 8, 87, 1, 87, 1, 87, 1, 87, 1, 88,
		1, 88, 1, 88, 5, 88, 1728, 8, 88, 10, 88, 12, 88, 1731, 9, 88, 1, 89, 1,
		89, 1, 90, 1, 90, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92,
		1, 92, 5, 92, 1746, 8, 92, 10, 92, 12, 92, 1749, 9, 92, 1, 93, 1, 93, 3,
		93, 1753, 8, 93, 1, 94, 1, 94, 3, 94, 1757, 8, 94, 1, 94, 1, 94, 3, 94,
		1761, 8, 94, 1, 94, 1, 94, 3, 94, 1765, 8, 94, 3, 94, 1767, 8, 94, 1, 95,
		1, 95, 1, 96, 1, 96, 3, 96, 1773, 8, 96, 1, 97, 5, 97, 1776, 8, 97, 10,
		97, 12, 97, 1779, 9, 97, 1, 97, 1, 97, 1, 97, 1, 97, 3, 97, 1785, 8, 97,
		1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 100, 1, 100, 1, 100,
		1, 101, 1, 101, 1, 101, 1, 102, 3, 102, 1801, 8, 102, 1, 102, 1, 102, 3,
		102, 1805, 8, 102, 1, 103, 4, 103, 1808, 8, 103, 11, 103, 12, 103, 1809,
		1, 104, 1, 104, 3, 104, 1814, 8, 104, 1, 105, 1, 105, 1, 105, 1, 105, 1,
		105, 3, 105, 1821, 8, 105, 1, 106, 1, 106, 3, 106, 1825, 8, 106, 1, 107,
		1, 107, 1, 107, 1, 108, 1, 108, 1, 108, 1, 109, 1, 109, 1, 109, 1, 109,
		1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 1842, 8, 109, 1, 110, 4,
		110, 1845, 8, 110, 11, 110, 12, 110, 1846, 1, 111, 1, 111, 1, 112, 1, 112,
		1, 112, 3, 112, 1854, 8, 112, 1, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1,
		114, 5, 114, 1862, 8, 114, 10, 114, 12, 114, 1865, 9, 114, 1, 115, 1, 115,
		1, 115, 1, 115, 1, 115, 3, 115, 1872, 8, 115, 1, 116, 1, 116, 1, 116, 3,
		116, 1877, 8, 116, 1, 117, 1, 117, 1, 117, 1, 118, 1, 118, 1, 118, 1, 119,
		1, 119, 1, 120, 1, 120, 1, 120, 1, 120, 1, 121, 1, 121, 3, 121, 1893, 8,
		121, 1, 121, 3, 121, 1896, 8, 121, 1, 121, 1, 121, 3, 121, 1900, 8, 121,
		1, 121, 3, 121, 1903, 8, 121, 1, 122, 1, 122, 3, 122, 1907, 8, 122, 1,
		122, 3, 122, 1910, 8, 122, 1, 123, 1, 123, 1, 123, 1, 124, 3, 124, 1916,
		8, 124, 1, 124, 1, 124, 3, 124, 1920, 8, 124, 1, 124, 3, 124, 1923, 8,
		124, 1, 125, 1, 125, 1, 125, 5, 125, 1928, 8, 125, 10, 125, 12, 125, 1931,
		9, 125, 1, 126, 1, 126, 3, 126, 1935, 8, 126, 1, 127, 1, 127, 1, 127, 1,
		128, 1, 128, 3, 128, 1942, 8, 128, 1, 128, 1, 128, 3, 128, 1946, 8, 128,
		1, 128, 1, 128, 3, 128, 1950, 8, 128, 1, 128, 3, 128, 1953, 8, 128, 1,
		128, 3, 128, 1956, 8, 128, 1, 128, 3, 128, 1959, 8, 128, 1, 128, 3, 128,
		1962, 8, 128, 1, 128, 3, 128, 1965, 8, 128, 3, 128, 1967, 8, 128, 1, 129,
		1, 129, 1, 129, 5, 129, 1972, 8, 129, 10, 129, 12, 129, 1975, 9, 129, 1,
		130, 1, 130, 3, 130, 1979, 8, 130, 1, 131, 1, 131, 1, 131, 1, 132, 1, 132,
		1, 132, 1, 133, 1, 133, 1, 133, 3, 133, 1990, 8, 133, 1, 134, 1, 134, 1,
		134, 5, 134, 1995, 8, 134, 10, 134, 12, 134, 1998, 9, 134, 1, 135, 1, 135,
		1, 135, 1, 136, 1, 136, 1, 136, 1, 136, 3, 136, 2007, 8, 136, 1, 137, 3,
		137, 2010, 8, 137, 1, 137, 1, 137, 1, 137, 1, 138, 1, 138, 3, 138, 2017,
		8, 138, 1, 139, 3, 139, 2020, 8, 139, 1, 139, 1, 139, 1, 140, 1, 140, 3,
		140, 2026, 8, 140, 1, 140, 1, 140, 1, 141, 1, 141, 1, 141, 5, 141, 2033,
		8, 141, 10, 141, 12, 141, 2036, 9, 141, 1, 142, 1, 142, 1, 142, 3, 142,
		2041, 8, 142, 1, 142, 1, 142, 3, 142, 2045, 8, 142, 1, 143, 1, 143, 1,
		143, 5, 143, 2050, 8, 143, 10, 143, 12, 143, 2053, 9, 143, 1, 144, 1, 144,
		1, 145, 1, 145, 1, 145, 1, 146, 1, 146, 1, 146, 1, 147, 1, 147, 3, 147,
		2065, 8, 147, 1, 148, 1, 148, 1, 148, 1, 149, 1, 149, 1, 149, 5, 149, 2073,
		8, 149, 10, 149, 12, 149, 2076, 9, 149, 1, 150, 1, 150, 1, 151, 3, 151,
		2081, 8, 151, 1, 151, 1, 151, 3, 151, 2085, 8, 151, 1, 151, 3, 151, 2088,
		8, 151, 1, 152, 1, 152, 3, 152, 2092, 8, 152, 1, 153, 1, 153, 1, 153, 1,
		154, 1, 154, 1, 154, 1, 155, 1, 155, 3, 155, 2102, 8, 155, 1, 155, 3, 155,
		2105, 8, 155, 1, 156, 1, 156, 3, 156, 2109, 8, 156, 1, 156, 3, 156, 2112,
		8, 156, 1, 157, 1, 157, 1, 157, 5, 157, 2117, 8, 157, 10, 157, 12, 157,
		2120, 9, 157, 1, 158, 3, 158, 2123, 8, 158, 1, 158, 3, 158, 2126, 8, 158,
		1, 158, 1, 158, 1, 159, 1, 159, 1, 159, 1, 160, 1, 160, 1, 160, 1, 161,
		1, 161, 1, 161, 1, 162, 1, 162, 1, 163, 1, 163, 1, 163, 5, 163, 2144, 8,
		163, 10, 163, 12, 163, 2147, 9, 163, 1, 164, 1, 164, 1, 164, 1, 164, 5,
		164, 2153, 8, 164, 10, 164, 12, 164, 2156, 9, 164, 1, 165, 1, 165, 3, 165,
		2160, 8, 165, 1, 165, 1, 165, 1, 166, 1, 166, 1, 166, 3, 166, 2167, 8,
		166, 1, 167, 1, 167, 3, 167, 2171, 8, 167, 1, 167, 1, 167, 1, 168, 1, 168,
		3, 168, 2177, 8, 168, 1, 168, 1, 168, 1, 169, 1, 169, 3, 169, 2183, 8,
		169, 1, 169, 1, 169, 1, 170, 1, 170, 3, 170, 2189, 8, 170, 1, 170, 3, 170,
		2192, 8, 170, 1, 170, 3, 170, 2195, 8, 170, 1, 171, 1, 171, 1, 171, 3,
		171, 2200, 8, 171, 1, 171, 1, 171, 1, 171, 3, 171, 2205, 8, 171, 1, 171,
		3, 171, 2208, 8, 171, 1, 172, 1, 172, 3, 172, 2212, 8, 172, 1, 173, 1,
		173, 3, 173, 2216, 8, 173, 1, 174, 1, 174, 1, 175, 1, 175, 1, 175, 3, 175,
		2223, 8, 175, 1, 176, 1, 176, 3, 176, 2227, 8, 176, 1, 176, 3, 176, 2230,
		8, 176, 1, 177, 1, 177, 1, 178, 1, 178, 3, 178, 2236, 8, 178, 1, 178, 3,
		178, 2239, 8, 178, 1, 178, 3, 178, 2242, 8, 178, 1, 179, 1, 179, 1, 180,
		1, 180, 1, 180, 1, 180, 3, 180, 2250, 8, 180, 1, 181, 1, 181, 1, 181, 3,
		181, 2255, 8, 181, 1, 181, 3, 181, 2258, 8, 181, 1, 182, 1, 182, 1, 182,
		3, 182, 2263, 8, 182, 1, 182, 3, 182, 2266, 8, 182, 1, 183, 1, 183, 1,
		183, 3, 183, 2271, 8, 183, 1, 183, 3, 183, 2274, 8, 183, 1, 184, 1, 184,
		3, 184, 2278, 8, 184, 1, 184, 3, 184, 2281, 8, 184, 1, 184, 3, 184, 2284,
		8, 184, 1, 184, 1, 184, 1, 185, 1, 185, 1, 186, 1, 186, 1, 186, 1, 186,
		4, 186, 2294, 8, 186, 11, 186, 12, 186, 2295, 1, 186, 1, 186, 1, 186, 4,
		186, 2301, 8, 186, 11, 186, 12, 186, 2302, 3, 186, 2305, 8, 186, 1, 187,
		4, 187, 2308, 8, 187, 11, 187, 12, 187, 2309, 1, 188, 1, 188, 1, 188, 1,
		188, 1, 188, 1, 188, 1, 188, 3, 188, 2319, 8, 188, 1, 189, 1, 189, 1, 189,
		3, 189, 2324, 8, 189, 1, 190, 1, 190, 3, 190, 2328, 8, 190, 1, 191, 1,
		191, 1, 191, 1, 191, 1, 192, 3, 192, 2335, 8, 192, 1, 192, 3, 192, 2338,
		8, 192, 1, 192, 3, 192, 2341, 8, 192, 1, 193, 1, 193, 1, 194, 1, 194, 1,
		194, 1, 195, 1, 195, 1, 196, 1, 196, 3, 196, 2352, 8, 196, 1, 197, 1, 197,
		1, 197, 1, 198, 1, 198, 1, 198, 1, 198, 1, 199, 1, 199, 1, 199, 5, 199,
		2364, 8, 199, 10, 199, 12, 199, 2367, 9, 199, 1, 200, 1, 200, 1, 200, 1,
		200, 1, 201, 1, 201, 3, 201, 2375, 8, 201, 1, 202, 1, 202, 1, 202, 1, 202,
		1, 202, 1, 202, 1, 202, 3, 202, 2384, 8, 202, 1, 203, 1, 203, 1, 203, 1,
		203, 1, 204, 1, 204, 1, 204, 1, 204, 1, 205, 1, 205, 1, 205, 1, 205, 1,
		206, 1, 206, 1, 206, 1, 206, 1, 207, 1, 207, 1, 207, 1, 207, 1, 208, 1,
		208, 1, 208, 1, 208, 1, 209, 1, 209, 1, 209, 1, 209, 1, 210, 1, 210, 1,
		211, 1, 211, 3, 211, 2418, 8, 211, 1, 211, 3, 211, 2421, 8, 211, 1, 211,
		1, 211, 3, 211, 2425, 8, 211, 1, 211, 1, 211, 1, 212, 1, 212, 1, 212, 1,
		213, 1, 213, 1, 213, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1,
		214, 1, 214, 1, 214, 3, 214, 2444, 8, 214, 1, 214, 1, 214, 1, 214, 1, 214,
		1, 214, 1, 214, 5, 214, 2452, 8, 214, 10, 214, 12, 214, 2455, 9, 214, 1,
		215, 1, 215, 1, 216, 1, 216, 1, 217, 1, 217, 1, 217, 1, 217, 3, 217, 2465,
		8, 217, 1, 218, 1, 218, 1, 218, 1, 218, 1, 219, 1, 219, 3, 219, 2473, 8,
		219, 1, 219, 1, 219, 3, 219, 2477, 8, 219, 1, 219, 1, 219, 1, 220, 1, 220,
		1, 221, 1, 221, 1, 222, 1, 222, 1, 222, 1, 222, 1, 222, 1, 222, 1, 222,
		3, 222, 2492, 8, 222, 1, 223, 1, 223, 1, 223, 1, 223, 1, 224, 1, 224, 1,
		224, 1, 224, 1, 225, 1, 225, 1, 225, 1, 225, 1, 226, 1, 226, 1, 226, 1,
		226, 1, 227, 1, 227, 1, 227, 1, 227, 1, 228, 1, 228, 1, 228, 1, 228, 1,
		229, 1, 229, 1, 229, 1, 229, 1, 230, 1, 230, 1, 230, 3, 230, 2525, 8, 230,
		1, 231, 1, 231, 1, 231, 1, 231, 1, 231, 5, 231, 2532, 8, 231, 10, 231,
		12, 231, 2535, 9, 231, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232, 5, 232,
		2542, 8, 232, 10, 232, 12, 232, 2545, 9, 232, 1, 233, 1, 233, 1, 233, 1,
		233, 1, 233, 5, 233, 2552, 8, 233, 10, 233, 12, 233, 2555, 9, 233, 1, 234,
		1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 5, 234, 2563, 8, 234, 10, 234,
		12, 234, 2566, 9, 234, 1, 235, 1, 235, 1, 235, 3, 235, 2571, 8, 235, 1,
		236, 1, 236, 1, 236, 1, 237, 1, 237, 1, 237, 1, 238, 1, 238, 3, 238, 2581,
		8, 238, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239, 3, 239,
		2590, 8, 239, 1, 240, 1, 240, 1, 240, 1, 241, 1, 241, 1, 241, 1, 242, 1,
		242, 1, 242, 1, 243, 1, 243, 1, 243, 1, 244, 1, 244, 1, 244, 1, 244, 1,
		245, 1, 245, 1, 245, 1, 245, 1, 246, 1, 246, 1, 246, 1, 247, 1, 247, 3,
		247, 2617, 8, 247, 1, 248, 1, 248, 1, 248, 1, 249, 1, 249, 1, 249, 1, 249,
		1, 249, 3, 249, 2627, 8, 249, 1, 250, 1, 250, 1, 250, 1, 251, 1, 251, 1,
		251, 1, 252, 1, 252, 1, 252, 5, 252, 2638, 8, 252, 10, 252, 12, 252, 2641,
		9, 252, 1, 253, 1, 253, 3, 253, 2645, 8, 253, 1, 254, 1, 254, 1, 255, 1,
		255, 1, 255, 1, 256, 1, 256, 1, 256, 1, 256, 1, 257, 1, 257, 1, 257, 5,
		257, 2659, 8, 257, 10, 257, 12, 257, 2662, 9, 257, 1, 257, 3, 257, 2665,
		8, 257, 1, 258, 1, 258, 1, 259, 1, 259, 1, 259, 1, 260, 1, 260, 1, 260,
		1, 260, 1, 261, 1, 261, 1, 261, 5, 261, 2679, 8, 261, 10, 261, 12, 261,
		2682, 9, 261, 1, 262, 1, 262, 3, 262, 2686, 8, 262, 1, 262, 3, 262, 2689,
		8, 262, 1, 263, 1, 263, 1, 264, 1, 264, 1, 265, 1, 265, 1, 265, 1, 265,
		3, 265, 2699, 8, 265, 1, 266, 1, 266, 1, 266, 1, 267, 1, 267, 1, 267, 1,
		268, 1, 268, 1, 269, 1, 269, 1, 269, 3, 269, 2712, 8, 269, 1, 270, 1, 270,
		1, 270, 1, 270, 3, 270, 2718, 8, 270, 1, 271, 1, 271, 1, 271, 1, 272, 1,
		272, 1, 272, 1, 272, 3, 272, 2727, 8, 272, 1, 273, 1, 273, 1, 274, 1, 274,
		3, 274, 2733, 8, 274, 1, 275, 1, 275, 1, 275, 5, 275, 2738, 8, 275, 10,
		275, 12, 275, 2741, 9, 275, 1, 275, 1, 275, 3, 275, 2745, 8, 275, 1, 276,
		1, 276, 1, 276, 4, 276, 2750, 8, 276, 11, 276, 12, 276, 2751, 1, 277, 1,
		277, 1, 277, 1, 277, 1, 277, 1, 277, 3, 277, 2760, 8, 277, 1, 278, 3, 278,
		2763, 8, 278, 1, 278, 1, 278, 1, 279, 1, 279, 1, 280, 1, 280, 3, 280, 2771,
		8, 280, 1, 281, 3, 281, 2774, 8, 281, 1, 281, 1, 281, 1, 282, 1, 282, 1,
		282, 1, 282, 1, 282, 3, 282, 2783, 8, 282, 1, 283, 1, 283, 3, 283, 2787,
		8, 283, 1, 284, 3, 284, 2790, 8, 284, 1, 284, 1, 284, 1, 285, 1, 285, 3,
		285, 2796, 8, 285, 1, 285, 1, 285, 1, 285, 5, 285, 2801, 8, 285, 10, 285,
		12, 285, 2804, 9, 285, 1, 285, 1, 285, 1, 285, 4, 285, 2809, 8, 285, 11,
		285, 12, 285, 2810, 3, 285, 2813, 8, 285, 1, 286, 1, 286, 1, 287, 1, 287,
		1, 287, 1, 287, 1, 288, 1, 288, 1, 289, 1, 289, 1, 289, 5, 289, 2826, 8,
		289, 10, 289, 12, 289, 2829, 9, 289, 1, 290, 1, 290, 3, 290, 2833, 8, 290,
		1, 290, 1, 290, 3, 290, 2837, 8, 290, 1, 291, 1, 291, 1, 291, 1, 291, 1,
		291, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 293, 1, 293, 1, 293, 5,
		293, 2852, 8, 293, 10, 293, 12, 293, 2855, 9, 293, 1, 294, 1, 294, 3, 294,
		2859, 8, 294, 1, 295, 1, 295, 3, 295, 2863, 8, 295, 1, 295, 1, 295, 3,
		295, 2867, 8, 295, 1, 295, 1, 295, 3, 295, 2871, 8, 295, 1, 295, 3, 295,
		2874, 8, 295, 1, 295, 1, 295, 1, 296, 1, 296, 3, 296, 2880, 8, 296, 1,
		296, 1, 296, 1, 296, 3, 296, 2885, 8, 296, 1, 297, 1, 297, 3, 297, 2889,
		8, 297, 1, 297, 3, 297, 2892, 8, 297, 1, 298, 1, 298, 3, 298, 2896, 8,
		298, 1, 298, 3, 298, 2899, 8, 298, 1, 299, 1, 299, 1, 300, 1, 300, 1, 300,
		1, 300, 1, 300, 3, 300, 2908, 8, 300, 1, 301, 3, 301, 2911, 8, 301, 1,
		301, 1, 301, 1, 302, 1, 302, 1, 303, 1, 303, 1, 304, 1, 304, 3, 304, 2921,
		8, 304, 1, 305, 3, 305, 2924, 8, 305, 1, 305, 1, 305, 3, 305, 2928, 8,
		305, 1, 305, 1, 305, 3, 305, 2932, 8, 305, 1, 305, 1, 305, 3, 305, 2936,
		8, 305, 1, 306, 1, 306, 1, 306, 3, 306, 2941, 8, 306, 1, 306, 1, 306, 1,
		306, 1, 307, 1, 307, 3, 307, 2948, 8, 307, 1, 307, 3, 307, 2951, 8, 307,
		1, 308, 1, 308, 3, 308, 2955, 8, 308, 1, 308, 3, 308, 2958, 8, 308, 1,
		309, 1, 309, 1, 309, 1, 309, 1, 309, 3, 309, 2965, 8, 309, 1, 310, 3, 310,
		2968, 8, 310, 1, 310, 1, 310, 1, 311, 1, 311, 1, 312, 1, 312, 1, 313, 1,
		313, 3, 313, 2978, 8, 313, 1, 314, 1, 314, 1, 314, 1, 314, 1, 315, 1, 315,
		1, 315, 1, 315, 1, 316, 1, 316, 1, 316, 1, 316, 1, 317, 1, 317, 3, 317,
		2994, 8, 317, 1, 318, 1, 318, 1, 318, 1, 318, 1, 319, 1, 319, 1, 319, 1,
		319, 1, 319, 1, 319, 1, 319, 1, 319, 1, 320, 1, 320, 3, 320, 3010, 8, 320,
		1, 321, 1, 321, 1, 321, 1, 321, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322,
		1, 322, 1, 322, 1, 322, 1, 323, 1, 323, 3, 323, 3026, 8, 323, 1, 324, 1,
		324, 1, 324, 1, 324, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325, 1,
		325, 1, 325, 1, 326, 1, 326, 1, 326, 1, 326, 1, 327, 1, 327, 1, 327, 1,
		327, 1, 328, 1, 328, 1, 329, 1, 329, 1, 330, 1, 330, 1, 330, 1, 330, 1,
		330, 1, 330, 3, 330, 3058, 8, 330, 1, 330, 3, 330, 3061, 8, 330, 1, 331,
		1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 3, 331, 3069, 8, 331, 1, 331, 3,
		331, 3072, 8, 331, 1, 332, 1, 332, 1, 333, 1, 333, 1, 333, 1, 334, 1, 334,
		3, 334, 3081, 8, 334, 1, 335, 1, 335, 3, 335, 3085, 8, 335, 1, 336, 1,
		336, 1, 336, 1, 336, 1, 336, 1, 336, 1, 337, 1, 337, 1, 337, 1, 337, 1,
		337, 1, 337, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 339, 1,
		339, 1, 340, 1, 340, 1, 341, 1, 341, 1, 342, 1, 342, 1, 343, 1, 343, 1,
		343, 1, 343, 1, 343, 1, 343, 1, 343, 3, 343, 3120, 8, 343, 1, 344, 1, 344,
		1, 344, 5, 344, 3125, 8, 344, 10, 344, 12, 344, 3128, 9, 344, 1, 345, 1,
		345, 3, 345, 3132, 8, 345, 1, 345, 1, 345, 1, 346, 1, 346, 1, 346, 5, 346,
		3139, 8, 346, 10, 346, 12, 346, 3142, 9, 346, 1, 347, 1, 347, 3, 347, 3146,
		8, 347, 1, 347, 1, 347, 1, 348, 1, 348, 1, 348, 1, 349, 1, 349, 1, 349,
		1, 349, 1, 349, 1, 350, 1, 350, 1, 350, 1, 350, 5, 350, 3162, 8, 350, 10,
		350, 12, 350, 3165, 9, 350, 1, 351, 3, 351, 3168, 8, 351, 1, 351, 1, 351,
		1, 351, 1, 352, 1, 352, 1, 352, 1, 352, 1, 352, 1, 352, 1, 352, 1, 352,
		1, 352, 1, 352, 1, 352, 3, 352, 3184, 8, 352, 1, 352, 3, 352, 3187, 8,
		352, 1, 352, 1, 352, 1, 352, 1, 352, 1, 352, 3, 352, 3194, 8, 352, 1, 352,
		3, 352, 3197, 8, 352, 1, 352, 1, 352, 1, 352, 3, 352, 3202, 8, 352, 1,
		352, 3, 352, 3205, 8, 352, 1, 352, 3, 352, 3208, 8, 352, 1, 352, 1, 352,
		1, 352, 3, 352, 3213, 8, 352, 1, 352, 1, 352, 3, 352, 3217, 8, 352, 1,
		352, 1, 352, 1, 352, 1, 352, 5, 352, 3223, 8, 352, 10, 352, 12, 352, 3226,
		9, 352, 1, 352, 1, 352, 3, 352, 3230, 8, 352, 1, 352, 1, 352, 1, 352, 1,
		352, 1, 352, 1, 352, 1, 352, 1, 352, 1, 352, 3, 352, 3241, 8, 352, 1, 352,
		3, 352, 3244, 8, 352, 5, 352, 3246, 8, 352, 10, 352, 12, 352, 3249, 9,
		352, 1, 353, 1, 353, 1, 354, 1, 354, 1, 354, 1, 354, 1, 354, 1, 354, 1,
		354, 3, 354, 3260, 8, 354, 1, 355, 1, 355, 3, 355, 3264, 8, 355, 1, 356,
		1, 356, 1, 356, 1, 356, 1, 356, 3, 356, 3271, 8, 356, 1, 356, 1, 356, 1,
		356, 3, 356, 3276, 8, 356, 1, 356, 3, 356, 3279, 8, 356, 1, 356, 1, 356,
		1, 356, 1, 356, 1, 356, 3, 356, 3286, 8, 356, 1, 356, 3, 356, 3289, 8,
		356, 1, 356, 1, 356, 1, 356, 1, 356, 1, 356, 3, 356, 3296, 8, 356, 1, 356,
		3, 356, 3299, 8, 356, 3, 356, 3301, 8, 356, 1, 357, 1, 357, 1, 357, 1,
		357, 1, 357, 3, 357, 3308, 8, 357, 1, 357, 1, 357, 1, 357, 3, 357, 3313,
		8, 357, 1, 357, 3, 357, 3316, 8, 357, 1, 357, 1, 357, 1, 357, 1, 357, 1,
		357, 3, 357, 3323, 8, 357, 1, 357, 3, 357, 3326, 8, 357, 1, 357, 1, 357,
		1, 357, 1, 357, 1, 357, 3, 357, 3333, 8, 357, 1, 357, 3, 357, 3336, 8,
		357, 3, 357, 3338, 8, 357, 1, 358, 1, 358, 1, 359, 1, 359, 1, 360, 1, 360,
		1, 361, 1, 361, 3, 361, 3348, 8, 361, 1, 362, 1, 362, 3, 362, 3352, 8,
		362, 1, 363, 1, 363, 3, 363, 3356, 8, 363, 1, 364, 1, 364, 3, 364, 3360,
		8, 364, 1, 364, 1, 364, 3, 364, 3364, 8, 364, 1, 364, 1, 364, 3, 364, 3368,
		8, 364, 1, 364, 1, 364, 3, 364, 3372, 8, 364, 1, 364, 1, 364, 3, 364, 3376,
		8, 364, 1, 364, 1, 364, 3, 364, 3380, 8, 364, 1, 364, 1, 364, 3, 364, 3384,
		8, 364, 1, 364, 1, 364, 1, 364, 1, 364, 1, 364, 3, 364, 3391, 8, 364, 1,
		364, 3, 364, 3394, 8, 364, 1, 364, 1, 364, 3, 364, 3398, 8, 364, 1, 364,
		3, 364, 3401, 8, 364, 1, 364, 3, 364, 3404, 8, 364, 1, 365, 1, 365, 3,
		365, 3408, 8, 365, 1, 365, 1, 365, 3, 365, 3412, 8, 365, 1, 365, 1, 365,
		3, 365, 3416, 8, 365, 1, 365, 1, 365, 3, 365, 3420, 8, 365, 1, 365, 1,
		365, 3, 365, 3424, 8, 365, 1, 365, 1, 365, 3, 365, 3428, 8, 365, 1, 365,
		1, 365, 3, 365, 3432, 8, 365, 1, 365, 1, 365, 1, 365, 1, 365, 1, 365, 3,
		365, 3439, 8, 365, 1, 365, 3, 365, 3442, 8, 365, 1, 365, 1, 365, 3, 365,
		3446, 8, 365, 1, 365, 1, 365, 3, 365, 3450, 8, 365, 1, 366, 1, 366, 3,
		366, 3454, 8, 366, 1, 366, 1, 366, 3, 366, 3458, 8, 366, 1, 366, 1, 366,
		3, 366, 3462, 8, 366, 1, 366, 1, 366, 3, 366, 3466, 8, 366, 1, 366, 1,
		366, 3, 366, 3470, 8, 366, 1, 366, 1, 366, 3, 366, 3474, 8, 366, 1, 366,
		1, 366, 1, 366, 3, 366, 3479, 8, 366, 1, 366, 1, 366, 1, 366, 1, 366, 1,
		366, 3, 366, 3486, 8, 366, 1, 366, 3, 366, 3489, 8, 366, 1, 366, 1, 366,
		1, 366, 3, 366, 3494, 8, 366, 3, 366, 3496, 8, 366, 1, 367, 1, 367, 1,
		367, 1, 367, 1, 367, 3, 367, 3503, 8, 367, 1, 367, 1, 367, 3, 367, 3507,
		8, 367, 3, 367, 3509, 8, 367, 1, 368, 1, 368, 1, 369, 1, 369, 1, 370, 1,
		370, 3, 370, 3517, 8, 370, 1, 370, 1, 370, 3, 370, 3521, 8, 370, 1, 370,
		1, 370, 3, 370, 3525, 8, 370, 1, 370, 1, 370, 3, 370, 3529, 8, 370, 1,
		370, 1, 370, 3, 370, 3533, 8, 370, 1, 370, 1, 370, 1, 370, 1, 370, 1, 370,
		3, 370, 3540, 8, 370, 1, 370, 1, 370, 3, 370, 3544, 8, 370, 1, 370, 3,
		370, 3547, 8, 370, 1, 370, 1, 370, 3, 370, 3551, 8, 370, 1, 370, 1, 370,
		3, 370, 3555, 8, 370, 1, 370, 3, 370, 3558, 8, 370, 3, 370, 3560, 8, 370,
		1, 371, 1, 371, 3, 371, 3564, 8, 371, 1, 372, 1, 372, 1, 372, 1, 372, 1,
		372, 3, 372, 3571, 8, 372, 1, 373, 1, 373, 1, 373, 3, 373, 3576, 8, 373,
		1, 373, 1, 373, 1, 373, 1, 373, 1, 373, 3, 373, 3583, 8, 373, 3, 373, 3585,
		8, 373, 1, 374, 1, 374, 1, 374, 3, 374, 3590, 8, 374, 1, 374, 1, 374, 1,
		374, 1, 374, 3, 374, 3596, 8, 374, 1, 374, 3, 374, 3599, 8, 374, 3, 374,
		3601, 8, 374, 1, 375, 1, 375, 3, 375, 3605, 8, 375, 1, 376, 1, 376, 1,
		376, 3, 376, 3610, 8, 376, 1, 376, 1, 376, 1, 376, 1, 376, 1, 376, 3, 376,
		3617, 8, 376, 3, 376, 3619, 8, 376, 1, 377, 1, 377, 1, 377, 3, 377, 3624,
		8, 377, 1, 377, 1, 377, 1, 377, 1, 377, 1, 377, 3, 377, 3631, 8, 377, 3,
		377, 3633, 8, 377, 1, 378, 1, 378, 1, 378, 1, 378, 1, 378, 3, 378, 3640,
		8, 378, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 3, 379, 3648, 8,
		379, 1, 380, 1, 380, 1, 380, 1, 380, 3, 380, 3654, 8, 380, 1, 381, 1, 381,
		3, 381, 3658, 8, 381, 1, 382, 1, 382, 1, 383, 1, 383, 1, 383, 3, 383, 3665,
		8, 383, 1, 384, 1, 384, 3, 384, 3669, 8, 384, 1, 385, 3, 385, 3672, 8,
		385, 1, 385, 1, 385, 1, 385, 3, 385, 3677, 8, 385, 1, 386, 1, 386, 3, 386,
		3681, 8, 386, 1, 386, 1, 386, 3, 386, 3685, 8, 386, 1, 387, 1, 387, 3,
		387, 3689, 8, 387, 1, 388, 1, 388, 3, 388, 3693, 8, 388, 1, 389, 1, 389,
		3, 389, 3697, 8, 389, 1, 390, 3, 390, 3700, 8, 390, 1, 390, 1, 390, 3,
		390, 3704, 8, 390, 1, 391, 1, 391, 3, 391, 3708, 8, 391, 1, 392, 1, 392,
		3, 392, 3712, 8, 392, 1, 393, 3, 393, 3715, 8, 393, 1, 393, 1, 393, 3,
		393, 3719, 8, 393, 1, 394, 1, 394, 3, 394, 3723, 8, 394, 1, 395, 1, 395,
		1, 396, 1, 396, 1, 397, 3, 397, 3730, 8, 397, 1, 397, 1, 397, 3, 397, 3734,
		8, 397, 1, 397, 3, 397, 3737, 8, 397, 1, 397, 1, 397, 3, 397, 3741, 8,
		397, 3, 397, 3743, 8, 397, 1, 398, 1, 398, 3, 398, 3747, 8, 398, 1, 398,
		1, 398, 1, 399, 1, 399, 1, 399, 5, 399, 3754, 8, 399, 10, 399, 12, 399,
		3757, 9, 399, 1, 400, 1, 400, 1, 400, 1, 401, 1, 401, 3, 401, 3764, 8,
		401, 1, 401, 1, 401, 1, 402, 1, 402, 1, 403, 1, 403, 1, 403, 1, 403, 1,
		403, 1, 403, 1, 403, 1, 403, 1, 403, 3, 403, 3779, 8, 403, 1, 404, 1, 404,
		1, 405, 1, 405, 1, 405, 1, 405, 1, 405, 1, 405, 1, 405, 1, 405, 1, 405,
		1, 405, 1, 405, 1, 405, 1, 405, 1, 405, 1, 405, 1, 405, 1, 405, 1, 405,
		3, 405, 3801, 8, 405, 1, 406, 1, 406, 1, 406, 1, 407, 1, 407, 3, 407, 3808,
		8, 407, 1, 407, 1, 407, 1, 408, 1, 408, 1, 408, 1, 409, 1, 409, 3, 409,
		3817, 8, 409, 1, 409, 1, 409, 1, 409, 1, 410, 1, 410, 3, 410, 3824, 8,
		410, 1, 410, 3, 410, 3827, 8, 410, 1, 410, 1, 410, 1, 411, 1, 411, 1, 411,
		1, 412, 1, 412, 3, 412, 3836, 8, 412, 1, 412, 1, 412, 1, 413, 1, 413, 1,
		413, 1, 414, 1, 414, 1, 414, 1, 415, 1, 415, 3, 415, 3848, 8, 415, 1, 415,
		1, 415, 3, 415, 3852, 8, 415, 1, 416, 1, 416, 1, 416, 1, 416, 1, 416, 1,
		416, 3, 416, 3860, 8, 416, 1, 417, 1, 417, 1, 418, 1, 418, 3, 418, 3866,
		8, 418, 1, 418, 1, 418, 1, 418, 1, 418, 1, 419, 1, 419, 3, 419, 3874, 8,
		419, 1, 419, 1, 419, 1, 419, 1, 419, 1, 420, 1, 420, 1, 421, 1, 421, 1,
		421, 1, 421, 1, 421, 1, 421, 1, 421, 5, 421, 3889, 8, 421, 10, 421, 12,
		421, 3892, 9, 421, 1, 421, 1, 421, 1, 422, 1, 422, 1, 422, 1, 422, 1, 422,
		1, 422, 1, 422, 5, 422, 3903, 8, 422, 10, 422, 12, 422, 3906, 9, 422, 1,
		422, 1, 422, 1, 423, 1, 423, 1, 423, 1, 423, 1, 423, 1, 423, 1, 423, 1,
		424, 1, 424, 1, 424, 1, 424, 1, 424, 1, 424, 1, 424, 3, 424, 3924, 8, 424,
		1, 424, 1, 424, 1, 424, 3, 424, 3929, 8, 424, 1, 424, 1, 424, 1, 424, 1,
		424, 3, 424, 3935, 8, 424, 1, 424, 1, 424, 1, 424, 1, 424, 1, 424, 1, 424,
		1, 424, 1, 424, 1, 424, 1, 424, 1, 424, 1, 424, 1, 424, 1, 424, 1, 424,
		1, 424, 1, 424, 1, 424, 1, 424, 1, 424, 1, 424, 1, 424, 1, 424, 1, 424,
		3, 424, 3961, 8, 424, 1, 424, 5, 424, 3964, 8, 424, 10, 424, 12, 424, 3967,
		9, 424, 1, 425, 1, 425, 1, 425, 1, 425, 1, 425, 1, 425, 3, 425, 3975, 8,
		425, 1, 426, 1, 426, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427, 3, 427, 3984,
		8, 427, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 429,
		1, 429, 1, 429, 1, 429, 1, 429, 1, 430, 1, 430, 1, 430, 1, 430, 1, 430,
		1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 3, 431, 4008, 8, 431, 1, 431, 1,
		431, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 3, 432, 4017, 8, 432, 1, 432,
		1, 432, 1, 433, 1, 433, 1, 434, 1, 434, 1, 435, 1, 435, 1, 436, 1, 436,
		1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436,
		3, 436, 4038, 8, 436, 1, 436, 1, 436, 1, 436, 5, 436, 4043, 8, 436, 10,
		436, 12, 436, 4046, 9, 436, 1, 437, 1, 437, 1, 437, 1, 437, 1, 438, 1,
		438, 3, 438, 4054, 8, 438, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439,
		1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 3, 439, 4068, 8, 439, 1,
		440, 1, 440, 3, 440, 4072, 8, 440, 1, 441, 1, 441, 3, 441, 4076, 8, 441,
		1, 442, 1, 442, 3, 442, 4080, 8, 442, 1, 443, 1, 443, 1, 444, 1, 444, 1,
		444, 1, 444, 1, 444, 1, 444, 1, 445, 1, 445, 1, 445, 1, 446, 1, 446, 3,
		446, 4095, 8, 446, 1, 447, 1, 447, 1, 447, 1, 447, 1, 447, 1, 447, 1, 447,
		1, 447, 1, 447, 1, 447, 1, 447, 1, 447, 4, 447, 4109, 8, 447, 11, 447,
		12, 447, 4110, 1, 447, 1, 447, 3, 447, 4115, 8, 447, 1, 448, 1, 448, 3,
		448, 4119, 8, 448, 1, 449, 1, 449, 1, 449, 4, 449, 4124, 8, 449, 11, 449,
		12, 449, 4125, 1, 449, 3, 449, 4129, 8, 449, 1, 449, 1, 449, 1, 450, 1,
		450, 4, 450, 4135, 8, 450, 11, 450, 12, 450, 4136, 1, 450, 3, 450, 4140,
		8, 450, 1, 450, 1, 450, 1, 451, 1, 451, 1, 451, 1, 451, 1, 451, 1, 452,
		1, 452, 1, 452, 1, 452, 1, 452, 1, 453, 1, 453, 1, 453, 1, 454, 1, 454,
		3, 454, 4159, 8, 454, 1, 455, 1, 455, 1, 455, 5, 455, 4164, 8, 455, 10,
		455, 12, 455, 4167, 9, 455, 1, 456, 1, 456, 1, 456, 1, 456, 1, 456, 1,
		456, 1, 456, 1, 456, 1, 456, 1, 456, 1, 456, 3, 456, 4180, 8, 456, 1, 457,
		1, 457, 3, 457, 4184, 8, 457, 1, 458, 1, 458, 1, 459, 1, 459, 1, 459, 1,
		459, 1, 459, 1, 459, 1, 459, 1, 460, 1, 460, 3, 460, 4197, 8, 460, 1, 461,
		1, 461, 1, 462, 1, 462, 1, 462, 1, 462, 1, 462, 1, 462, 3, 462, 4207, 8,
		462, 1, 463, 1, 463, 1, 463, 3, 463, 4212, 8, 463, 1, 463, 1, 463, 1, 463,
		1, 464, 1, 464, 1, 464, 1, 464, 1, 464, 1, 464, 1, 464, 1, 465, 1, 465,
		1, 466, 1, 466, 1, 467, 1, 467, 1, 468, 3, 468, 4231, 8, 468, 1, 468, 1,
		468, 1, 469, 1, 469, 1, 470, 1, 470, 1, 470, 1, 470, 1, 470, 1, 471, 1,
		471, 1, 472, 1, 472, 1, 473, 1, 473, 1, 474, 1, 474, 1, 474, 1, 474, 1,
		474, 1, 475, 1, 475, 5, 475, 4255, 8, 475, 10, 475, 12, 475, 4258, 9, 475,
		1, 476, 1, 476, 1, 477, 1, 477, 1, 477, 1, 477, 1, 477, 1, 478, 1, 478,
		1, 479, 1, 479, 3, 479, 4271, 8, 479, 1, 480, 1, 480, 1, 480, 1, 480, 1,
		480, 1, 480, 1, 480, 1, 481, 1, 481, 1, 481, 1, 481, 1, 481, 1, 482, 1,
		482, 1, 483, 3, 483, 4288, 8, 483, 1, 483, 1, 483, 3, 483, 4292, 8, 483,
		1, 483, 1, 483, 1, 484, 1, 484, 1, 484, 5, 484, 4299, 8, 484, 10, 484,
		12, 484, 4302, 9, 484, 1, 485, 1, 485, 1, 486, 3, 486, 4307, 8, 486, 1,
		486, 1, 486, 1, 487, 1, 487, 3, 487, 4313, 8, 487, 1, 487, 1, 487, 1, 488,
		1, 488, 1, 488, 5, 488, 4320, 8, 488, 10, 488, 12, 488, 4323, 9, 488, 1,
		489, 1, 489, 1, 489, 1, 489, 1, 490, 1, 490, 1, 491, 1, 491, 1, 491, 1,
		491, 1, 491, 3, 491, 4336, 8, 491, 1, 491, 1, 491, 1, 491, 1, 491, 1, 491,
		1, 491, 5, 491, 4344, 8, 491, 10, 491, 12, 491, 4347, 9, 491, 1, 492, 1,
		492, 1, 492, 1, 492, 1, 492, 1, 492, 1, 492, 1, 492, 1, 492, 1, 492, 1,
		492, 1, 492, 1, 492, 3, 492, 4362, 8, 492, 1, 493, 1, 493, 1, 493, 3, 493,
		4367, 8, 493, 1, 494, 1, 494, 1, 494, 1, 494, 1, 494, 1, 494, 1, 494, 1,
		494, 1, 494, 1, 494, 3, 494, 4379, 8, 494, 1, 495, 1, 495, 1, 496, 1, 496,
		1, 496, 1, 496, 1, 496, 1, 497, 1, 497, 1, 497, 1, 497, 1, 497, 1, 498,
		1, 498, 1, 498, 1, 498, 1, 498, 1, 499, 1, 499, 1, 499, 1, 499, 1, 499,
		1, 500, 1, 500, 1, 500, 1, 500, 1, 500, 1, 500, 1, 500, 1, 501, 1, 501,
		1, 502, 1, 502, 1, 503, 1, 503, 1, 503, 1, 503, 1, 503, 1, 504, 1, 504,
		1, 505, 1, 505, 1, 505, 1, 505, 1, 505, 1, 505, 1, 505, 1, 506, 1, 506,
		1, 507, 1, 507, 1, 508, 1, 508, 1, 508, 1, 508, 1, 508, 1, 509, 1, 509,
		1, 509, 1, 509, 1, 509, 1, 510, 1, 510, 1, 510, 1, 510, 1, 510, 1, 511,
		1, 511, 1, 511, 1, 511, 1, 511, 1, 511, 1, 511, 1, 512, 1, 512, 1, 513,
		1, 513, 1, 514, 1, 514, 1, 514, 1, 514, 1, 514, 1, 515, 1, 515, 1, 515,
		1, 515, 1, 515, 1, 516, 1, 516, 1, 516, 1, 516, 1, 516, 1, 517, 1, 517,
		1, 518, 1, 518, 1, 519, 3, 519, 4478, 8, 519, 1, 519, 3, 519, 4481, 8,
		519, 1, 519, 3, 519, 4484, 8, 519, 1, 519, 1, 519, 1, 520, 1, 520, 1, 521,
		1, 521, 1, 522, 1, 522, 1, 523, 1, 523, 1, 524, 1, 524, 1, 525, 1, 525,
		1, 526, 1, 526, 1, 526, 1, 526, 1, 526, 3, 526, 4505, 8, 526, 1, 527, 1,
		527, 1, 527, 1, 527, 3, 527, 4511, 8, 527, 1, 527, 3, 527, 4514, 8, 527,
		1, 528, 1, 528, 1, 528, 1, 528, 3, 528, 4520, 8, 528, 1, 528, 3, 528, 4523,
		8, 528, 1, 529, 1, 529, 1, 529, 3, 529, 4528, 8, 529, 1, 529, 3, 529, 4531,
		8, 529, 1, 530, 1, 530, 1, 530, 1, 530, 3, 530, 4537, 8, 530, 1, 530, 3,
		530, 4540, 8, 530, 1, 531, 1, 531, 1, 531, 1, 531, 3, 531, 4546, 8, 531,
		1, 531, 3, 531, 4549, 8, 531, 1, 532, 1, 532, 3, 532, 4553, 8, 532, 1,
		533, 1, 533, 3, 533, 4557, 8, 533, 1, 534, 1, 534, 3, 534, 4561, 8, 534,
		1, 535, 1, 535, 1, 536, 1, 536, 1, 536, 1, 536, 1, 536, 3, 536, 4570, 8,
		536, 1, 537, 1, 537, 1, 537, 1, 537, 1, 538, 1, 538, 1, 539, 1, 539, 1,
		540, 1, 540, 3, 540, 4582, 8, 540, 1, 541, 1, 541, 1, 541, 1, 541, 1, 541,
		1, 542, 1, 542, 3, 542, 4591, 8, 542, 1, 543, 1, 543, 1, 544, 1, 544, 1,
		545, 1, 545, 1, 546, 1, 546, 1, 547, 1, 547, 3, 547, 4603, 8, 547, 1, 548,
		1, 548, 1, 549, 1, 549, 1, 550, 1, 550, 1, 551, 1, 551, 1, 552, 1, 552,
		3, 552, 4615, 8, 552, 1, 553, 1, 553, 1, 554, 1, 554, 1, 555, 1, 555, 1,
		556, 1, 556, 1, 557, 1, 557, 1, 558, 1, 558, 1, 559, 1, 559, 1, 560, 1,
		560, 1, 561, 1, 561, 1, 562, 1, 562, 3, 562, 4637, 8, 562, 1, 563, 1, 563,
		1, 563, 1, 563, 1, 563, 1, 563, 1, 563, 1, 563, 3, 563, 4647, 8, 563, 1,
		564, 1, 564, 1, 564, 3, 564, 4652, 8, 564, 1, 565, 1, 565, 1, 565, 1, 566,
		1, 566, 1, 566, 1, 567, 1, 567, 1, 567, 1, 568, 1, 568, 1, 569, 1, 569,
		1, 570, 1, 570, 1, 570, 3, 570, 4670, 8, 570, 1, 571, 1, 571, 3, 571, 4674,
		8, 571, 1, 572, 1, 572, 1, 573, 1, 573, 1, 574, 1, 574, 3, 574, 4682, 8,
		574, 1, 575, 1, 575, 1, 575, 1, 575, 1, 575, 3, 575, 4689, 8, 575, 1, 576,
		1, 576, 1, 577, 1, 577, 1, 578, 1, 578, 1, 579, 1, 579, 1, 580, 1, 580,
		1, 581, 1, 581, 1, 582, 1, 582, 1, 583, 1, 583, 1, 583, 1, 584, 1, 584,
		1, 585, 1, 585, 1, 586, 1, 586, 1, 587, 1, 587, 1, 588, 1, 588, 1, 588,
		0, 8, 184, 428, 466, 468, 704, 848, 872, 982, 589, 0, 2, 4, 6, 8, 10, 12,
		14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48,
		50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84,
		86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,
		118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146,
		148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176,
		178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206,
		208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236,
		238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266,
		268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296,
		298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326,
		328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356,
		358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386,
		388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416,
		418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446,
		448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476,
		478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 502, 504, 506,
		508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536,
		538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, 564, 566,
		568, 570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 590, 592, 594, 596,
		598, 600, 602, 604, 606, 608, 610, 612, 614, 616, 618, 620, 622, 624, 626,
		628, 630, 632, 634, 636, 638, 640, 642, 644, 646, 648, 650, 652, 654, 656,
		658, 660, 662, 664, 666, 668, 670, 672, 674, 676, 678, 680, 682, 684, 686,
		688, 690, 692, 694, 696, 698, 700, 702, 704, 706, 708, 710, 712, 714, 716,
		718, 720, 722, 724, 726, 728, 730, 732, 734, 736, 738, 740, 742, 744, 746,
		748, 750, 752, 754, 756, 758, 760, 762, 764, 766, 768, 770, 772, 774, 776,
		778, 780, 782, 784, 786, 788, 790, 792, 794, 796, 798, 800, 802, 804, 806,
		808, 810, 812, 814, 816, 818, 820, 822, 824, 826, 828, 830, 832, 834, 836,
		838, 840, 842, 844, 846, 848, 850, 852, 854, 856, 858, 860, 862, 864, 866,
		868, 870, 872, 874, 876, 878, 880, 882, 884, 886, 888, 890, 892, 894, 896,
		898, 900, 902, 904, 906, 908, 910, 912, 914, 916, 918, 920, 922, 924, 926,
		928, 930, 932, 934, 936, 938, 940, 942, 944, 946, 948, 950, 952, 954, 956,
		958, 960, 962, 964, 966, 968, 970, 972, 974, 976, 978, 980, 982, 984, 986,
		988, 990, 992, 994, 996, 998, 1000, 1002, 1004, 1006, 1008, 1010, 1012,
		1014, 1016, 1018, 1020, 1022, 1024, 1026, 1028, 1030, 1032, 1034, 1036,
		1038, 1040, 1042, 1044, 1046, 1048, 1050, 1052, 1054, 1056, 1058, 1060,
		1062, 1064, 1066, 1068, 1070, 1072, 1074, 1076, 1078, 1080, 1082, 1084,
		1086, 1088, 1090, 1092, 1094, 1096, 1098, 1100, 1102, 1104, 1106, 1108,
		1110, 1112, 1114, 1116, 1118, 1120, 1122, 1124, 1126, 1128, 1130, 1132,
		1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150, 1152, 1154, 1156,
		1158, 1160, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 0, 46, 2, 0,
		56, 56, 168, 168, 1, 0, 68, 69, 2, 0, 82, 82, 153, 153, 2, 0, 162, 162,
		307, 307, 4, 0, 280, 280, 314, 314, 318, 318, 323, 323, 2, 0, 169, 169,
		171, 171, 2, 0, 105, 105, 293, 293, 2, 0, 130, 130, 362, 362, 6, 0, 338,
		339, 342, 342, 349, 349, 358, 358, 375, 375, 386, 386, 2, 0, 31, 32, 80,
		81, 2, 0, 162, 162, 198, 198, 3, 0, 70, 70, 109, 109, 377, 377, 1, 0, 107,
		108, 2, 0, 19, 19, 361, 361, 2, 0, 286, 286, 321, 321, 2, 0, 317, 317,
		349, 349, 2, 0, 317, 317, 386, 386, 2, 0, 214, 214, 334, 334, 1, 0, 40,
		41, 1, 0, 76, 77, 2, 0, 29, 29, 136, 136, 6, 0, 337, 337, 345, 345, 348,
		348, 367, 367, 369, 369, 374, 374, 2, 0, 375, 375, 378, 378, 2, 0, 361,
		361, 385, 385, 2, 0, 164, 164, 235, 235, 2, 0, 132, 132, 184, 184, 2, 0,
		144, 144, 225, 225, 3, 0, 43, 43, 145, 145, 186, 186, 6, 0, 36, 36, 59,
		59, 65, 65, 147, 148, 203, 204, 206, 206, 2, 0, 25, 25, 83, 83, 1, 0, 172,
		173, 1, 0, 54, 55, 2, 0, 45, 45, 160, 160, 8, 0, 24, 24, 33, 33, 35, 35,
		62, 64, 78, 78, 177, 177, 195, 196, 207, 208, 1, 0, 51, 52, 3, 0, 42, 42,
		131, 131, 212, 212, 1, 0, 299, 302, 1, 0, 7, 8, 2, 0, 74, 74, 211, 211,
		1, 0, 6, 7, 3, 0, 12, 13, 16, 16, 18, 18, 1, 0, 19, 22, 2, 0, 304, 304,
		322, 322, 2, 0, 288, 288, 311, 311, 2, 0, 287, 287, 310, 310, 1, 0, 280,
		326, 4835, 0, 1187, 1, 0, 0, 0, 2, 1191, 1, 0, 0, 0, 4, 1209, 1, 0, 0,
		0, 6, 1223, 1, 0, 0, 0, 8, 1227, 1, 0, 0, 0, 10, 1229, 1, 0, 0, 0, 12,
		1237, 1, 0, 0, 0, 14, 1241, 1, 0, 0, 0, 16, 1246, 1, 0, 0, 0, 18, 1250,
		1, 0, 0, 0, 20, 1255, 1, 0, 0, 0, 22, 1258, 1, 0, 0, 0, 24, 1265, 1, 0,
		0, 0, 26, 1271, 1, 0, 0, 0, 28, 1278, 1, 0, 0, 0, 30, 1282, 1, 0, 0, 0,
		32, 1302, 1, 0, 0, 0, 34, 1304, 1, 0, 0, 0, 36, 1307, 1, 0, 0, 0, 38, 1309,
		1, 0, 0, 0, 40, 1314, 1, 0, 0, 0, 42, 1322, 1, 0, 0, 0, 44, 1328, 1, 0,
		0, 0, 46, 1330, 1, 0, 0, 0, 48, 1332, 1, 0, 0, 0, 50, 1334, 1, 0, 0, 0,
		52, 1338, 1, 0, 0, 0, 54, 1340, 1, 0, 0, 0, 56, 1344, 1, 0, 0, 0, 58, 1349,
		1, 0, 0, 0, 60, 1357, 1, 0, 0, 0, 62, 1364, 1, 0, 0, 0, 64, 1366, 1, 0,
		0, 0, 66, 1376, 1, 0, 0, 0, 68, 1378, 1, 0, 0, 0, 70, 1385, 1, 0, 0, 0,
		72, 1395, 1, 0, 0, 0, 74, 1399, 1, 0, 0, 0, 76, 1403, 1, 0, 0, 0, 78, 1413,
		1, 0, 0, 0, 80, 1417, 1, 0, 0, 0, 82, 1420, 1, 0, 0, 0, 84, 1428, 1, 0,
		0, 0, 86, 1432, 1, 0, 0, 0, 88, 1439, 1, 0, 0, 0, 90, 1441, 1, 0, 0, 0,
		92, 1447, 1, 0, 0, 0, 94, 1449, 1, 0, 0, 0, 96, 1455, 1, 0, 0, 0, 98, 1458,
		1, 0, 0, 0, 100, 1464, 1, 0, 0, 0, 102, 1472, 1, 0, 0, 0, 104, 1474, 1,
		0, 0, 0, 106, 1483, 1, 0, 0, 0, 108, 1491, 1, 0, 0, 0, 110, 1518, 1, 0,
		0, 0, 112, 1542, 1, 0, 0, 0, 114, 1544, 1, 0, 0, 0, 116, 1547, 1, 0, 0,
		0, 118, 1552, 1, 0, 0, 0, 120, 1563, 1, 0, 0, 0, 122, 1595, 1, 0, 0, 0,
		124, 1597, 1, 0, 0, 0, 126, 1601, 1, 0, 0, 0, 128, 1613, 1, 0, 0, 0, 130,
		1617, 1, 0, 0, 0, 132, 1621, 1, 0, 0, 0, 134, 1623, 1, 0, 0, 0, 136, 1628,
		1, 0, 0, 0, 138, 1633, 1, 0, 0, 0, 140, 1635, 1, 0, 0, 0, 142, 1640, 1,
		0, 0, 0, 144, 1646, 1, 0, 0, 0, 146, 1650, 1, 0, 0, 0, 148, 1656, 1, 0,
		0, 0, 150, 1658, 1, 0, 0, 0, 152, 1661, 1, 0, 0, 0, 154, 1664, 1, 0, 0,
		0, 156, 1675, 1, 0, 0, 0, 158, 1677, 1, 0, 0, 0, 160, 1683, 1, 0, 0, 0,
		162, 1691, 1, 0, 0, 0, 164, 1695, 1, 0, 0, 0, 166, 1698, 1, 0, 0, 0, 168,
		1708, 1, 0, 0, 0, 170, 1710, 1, 0, 0, 0, 172, 1714, 1, 0, 0, 0, 174, 1719,
		1, 0, 0, 0, 176, 1724, 1, 0, 0, 0, 178, 1732, 1, 0, 0, 0, 180, 1734, 1,
		0, 0, 0, 182, 1736, 1, 0, 0, 0, 184, 1738, 1, 0, 0, 0, 186, 1752, 1, 0,
		0, 0, 188, 1766, 1, 0, 0, 0, 190, 1768, 1, 0, 0, 0, 192, 1772, 1, 0, 0,
		0, 194, 1784, 1, 0, 0, 0, 196, 1786, 1, 0, 0, 0, 198, 1789, 1, 0, 0, 0,
		200, 1793, 1, 0, 0, 0, 202, 1796, 1, 0, 0, 0, 204, 1804, 1, 0, 0, 0, 206,
		1807, 1, 0, 0, 0, 208, 1813, 1, 0, 0, 0, 210, 1820, 1, 0, 0, 0, 212, 1824,
		1, 0, 0, 0, 214, 1826, 1, 0, 0, 0, 216, 1829, 1, 0, 0, 0, 218, 1841, 1,
		0, 0, 0, 220, 1844, 1, 0, 0, 0, 222, 1848, 1, 0, 0, 0, 224, 1850, 1, 0,
		0, 0, 226, 1855, 1, 0, 0, 0, 228, 1858, 1, 0, 0, 0, 230, 1871, 1, 0, 0,
		0, 232, 1873, 1, 0, 0, 0, 234, 1878, 1, 0, 0, 0, 236, 1881, 1, 0, 0, 0,
		238, 1884, 1, 0, 0, 0, 240, 1886, 1, 0, 0, 0, 242, 1902, 1, 0, 0, 0, 244,
		1909, 1, 0, 0, 0, 246, 1911, 1, 0, 0, 0, 248, 1915, 1, 0, 0, 0, 250, 1924,
		1, 0, 0, 0, 252, 1932, 1, 0, 0, 0, 254, 1936, 1, 0, 0, 0, 256, 1939, 1,
		0, 0, 0, 258, 1968, 1, 0, 0, 0, 260, 1976, 1, 0, 0, 0, 262, 1980, 1, 0,
		0, 0, 264, 1983, 1, 0, 0, 0, 266, 1986, 1, 0, 0, 0, 268, 1991, 1, 0, 0,
		0, 270, 1999, 1, 0, 0, 0, 272, 2006, 1, 0, 0, 0, 274, 2009, 1, 0, 0, 0,
		276, 2016, 1, 0, 0, 0, 278, 2019, 1, 0, 0, 0, 280, 2023, 1, 0, 0, 0, 282,
		2029, 1, 0, 0, 0, 284, 2037, 1, 0, 0, 0, 286, 2046, 1, 0, 0, 0, 288, 2054,
		1, 0, 0, 0, 290, 2056, 1, 0, 0, 0, 292, 2059, 1, 0, 0, 0, 294, 2062, 1,
		0, 0, 0, 296, 2066, 1, 0, 0, 0, 298, 2069, 1, 0, 0, 0, 300, 2077, 1, 0,
		0, 0, 302, 2080, 1, 0, 0, 0, 304, 2091, 1, 0, 0, 0, 306, 2093, 1, 0, 0,
		0, 308, 2096, 1, 0, 0, 0, 310, 2104, 1, 0, 0, 0, 312, 2111, 1, 0, 0, 0,
		314, 2113, 1, 0, 0, 0, 316, 2122, 1, 0, 0, 0, 318, 2129, 1, 0, 0, 0, 320,
		2132, 1, 0, 0, 0, 322, 2135, 1, 0, 0, 0, 324, 2138, 1, 0, 0, 0, 326, 2140,
		1, 0, 0, 0, 328, 2148, 1, 0, 0, 0, 330, 2157, 1, 0, 0, 0, 332, 2166, 1,
		0, 0, 0, 334, 2168, 1, 0, 0, 0, 336, 2174, 1, 0, 0, 0, 338, 2180, 1, 0,
		0, 0, 340, 2194, 1, 0, 0, 0, 342, 2207, 1, 0, 0, 0, 344, 2211, 1, 0, 0,
		0, 346, 2213, 1, 0, 0, 0, 348, 2217, 1, 0, 0, 0, 350, 2222, 1, 0, 0, 0,
		352, 2224, 1, 0, 0, 0, 354, 2231, 1, 0, 0, 0, 356, 2233, 1, 0, 0, 0, 358,
		2243, 1, 0, 0, 0, 360, 2249, 1, 0, 0, 0, 362, 2251, 1, 0, 0, 0, 364, 2259,
		1, 0, 0, 0, 366, 2267, 1, 0, 0, 0, 368, 2275, 1, 0, 0, 0, 370, 2287, 1,
		0, 0, 0, 372, 2304, 1, 0, 0, 0, 374, 2307, 1, 0, 0, 0, 376, 2318, 1, 0,
		0, 0, 378, 2323, 1, 0, 0, 0, 380, 2327, 1, 0, 0, 0, 382, 2329, 1, 0, 0,
		0, 384, 2334, 1, 0, 0, 0, 386, 2342, 1, 0, 0, 0, 388, 2344, 1, 0, 0, 0,
		390, 2347, 1, 0, 0, 0, 392, 2351, 1, 0, 0, 0, 394, 2353, 1, 0, 0, 0, 396,
		2356, 1, 0, 0, 0, 398, 2360, 1, 0, 0, 0, 400, 2368, 1, 0, 0, 0, 402, 2374,
		1, 0, 0, 0, 404, 2383, 1, 0, 0, 0, 406, 2385, 1, 0, 0, 0, 408, 2389, 1,
		0, 0, 0, 410, 2393, 1, 0, 0, 0, 412, 2397, 1, 0, 0, 0, 414, 2401, 1, 0,
		0, 0, 416, 2405, 1, 0, 0, 0, 418, 2409, 1, 0, 0, 0, 420, 2413, 1, 0, 0,
		0, 422, 2415, 1, 0, 0, 0, 424, 2428, 1, 0, 0, 0, 426, 2431, 1, 0, 0, 0,
		428, 2443, 1, 0, 0, 0, 430, 2456, 1, 0, 0, 0, 432, 2458, 1, 0, 0, 0, 434,
		2464, 1, 0, 0, 0, 436, 2466, 1, 0, 0, 0, 438, 2470, 1, 0, 0, 0, 440, 2480,
		1, 0, 0, 0, 442, 2482, 1, 0, 0, 0, 444, 2491, 1, 0, 0, 0, 446, 2493, 1,
		0, 0, 0, 448, 2497, 1, 0, 0, 0, 450, 2501, 1, 0, 0, 0, 452, 2505, 1, 0,
		0, 0, 454, 2509, 1, 0, 0, 0, 456, 2513, 1, 0, 0, 0, 458, 2517, 1, 0, 0,
		0, 460, 2524, 1, 0, 0, 0, 462, 2526, 1, 0, 0, 0, 464, 2536, 1, 0, 0, 0,
		466, 2546, 1, 0, 0, 0, 468, 2556, 1, 0, 0, 0, 470, 2570, 1, 0, 0, 0, 472,
		2572, 1, 0, 0, 0, 474, 2575, 1, 0, 0, 0, 476, 2580, 1, 0, 0, 0, 478, 2589,
		1, 0, 0, 0, 480, 2591, 1, 0, 0, 0, 482, 2594, 1, 0, 0, 0, 484, 2597, 1,
		0, 0, 0, 486, 2600, 1, 0, 0, 0, 488, 2603, 1, 0, 0, 0, 490, 2607, 1, 0,
		0, 0, 492, 2611, 1, 0, 0, 0, 494, 2616, 1, 0, 0, 0, 496, 2618, 1, 0, 0,
		0, 498, 2626, 1, 0, 0, 0, 500, 2628, 1, 0, 0, 0, 502, 2631, 1, 0, 0, 0,
		504, 2634, 1, 0, 0, 0, 506, 2642, 1, 0, 0, 0, 508, 2646, 1, 0, 0, 0, 510,
		2648, 1, 0, 0, 0, 512, 2651, 1, 0, 0, 0, 514, 2664, 1, 0, 0, 0, 516, 2666,
		1, 0, 0, 0, 518, 2668, 1, 0, 0, 0, 520, 2671, 1, 0, 0, 0, 522, 2675, 1,
		0, 0, 0, 524, 2683, 1, 0, 0, 0, 526, 2690, 1, 0, 0, 0, 528, 2692, 1, 0,
		0, 0, 530, 2698, 1, 0, 0, 0, 532, 2700, 1, 0, 0, 0, 534, 2703, 1, 0, 0,
		0, 536, 2706, 1, 0, 0, 0, 538, 2711, 1, 0, 0, 0, 540, 2717, 1, 0, 0, 0,
		542, 2719, 1, 0, 0, 0, 544, 2726, 1, 0, 0, 0, 546, 2728, 1, 0, 0, 0, 548,
		2730, 1, 0, 0, 0, 550, 2734, 1, 0, 0, 0, 552, 2749, 1, 0, 0, 0, 554, 2759,
		1, 0, 0, 0, 556, 2762, 1, 0, 0, 0, 558, 2766, 1, 0, 0, 0, 560, 2770, 1,
		0, 0, 0, 562, 2773, 1, 0, 0, 0, 564, 2782, 1, 0, 0, 0, 566, 2786, 1, 0,
		0, 0, 568, 2789, 1, 0, 0, 0, 570, 2812, 1, 0, 0, 0, 572, 2814, 1, 0, 0,
		0, 574, 2816, 1, 0, 0, 0, 576, 2820, 1, 0, 0, 0, 578, 2822, 1, 0, 0, 0,
		580, 2832, 1, 0, 0, 0, 582, 2838, 1, 0, 0, 0, 584, 2843, 1, 0, 0, 0, 586,
		2848, 1, 0, 0, 0, 588, 2858, 1, 0, 0, 0, 590, 2866, 1, 0, 0, 0, 592, 2877,
		1, 0, 0, 0, 594, 2891, 1, 0, 0, 0, 596, 2898, 1, 0, 0, 0, 598, 2900, 1,
		0, 0, 0, 600, 2907, 1, 0, 0, 0, 602, 2910, 1, 0, 0, 0, 604, 2914, 1, 0,
		0, 0, 606, 2916, 1, 0, 0, 0, 608, 2920, 1, 0, 0, 0, 610, 2931, 1, 0, 0,
		0, 612, 2937, 1, 0, 0, 0, 614, 2950, 1, 0, 0, 0, 616, 2957, 1, 0, 0, 0,
		618, 2964, 1, 0, 0, 0, 620, 2967, 1, 0, 0, 0, 622, 2971, 1, 0, 0, 0, 624,
		2973, 1, 0, 0, 0, 626, 2977, 1, 0, 0, 0, 628, 2979, 1, 0, 0, 0, 630, 2983,
		1, 0, 0, 0, 632, 2987, 1, 0, 0, 0, 634, 2993, 1, 0, 0, 0, 636, 2995, 1,
		0, 0, 0, 638, 2999, 1, 0, 0, 0, 640, 3009, 1, 0, 0, 0, 642, 3011, 1, 0,
		0, 0, 644, 3015, 1, 0, 0, 0, 646, 3025, 1, 0, 0, 0, 648, 3027, 1, 0, 0,
		0, 650, 3031, 1, 0, 0, 0, 652, 3039, 1, 0, 0, 0, 654, 3043, 1, 0, 0, 0,
		656, 3047, 1, 0, 0, 0, 658, 3049, 1, 0, 0, 0, 660, 3060, 1, 0, 0, 0, 662,
		3071, 1, 0, 0, 0, 664, 3073, 1, 0, 0, 0, 666, 3075, 1, 0, 0, 0, 668, 3080,
		1, 0, 0, 0, 670, 3084, 1, 0, 0, 0, 672, 3086, 1, 0, 0, 0, 674, 3092, 1,
		0, 0, 0, 676, 3098, 1, 0, 0, 0, 678, 3104, 1, 0, 0, 0, 680, 3106, 1, 0,
		0, 0, 682, 3108, 1, 0, 0, 0, 684, 3110, 1, 0, 0, 0, 686, 3119, 1, 0, 0,
		0, 688, 3121, 1, 0, 0, 0, 690, 3129, 1, 0, 0, 0, 692, 3135, 1, 0, 0, 0,
		694, 3143, 1, 0, 0, 0, 696, 3149, 1, 0, 0, 0, 698, 3152, 1, 0, 0, 0, 700,
		3157, 1, 0, 0, 0, 702, 3167, 1, 0, 0, 0, 704, 3229, 1, 0, 0, 0, 706, 3250,
		1, 0, 0, 0, 708, 3259, 1, 0, 0, 0, 710, 3261, 1, 0, 0, 0, 712, 3300, 1,
		0, 0, 0, 714, 3337, 1, 0, 0, 0, 716, 3339, 1, 0, 0, 0, 718, 3341, 1, 0,
		0, 0, 720, 3343, 1, 0, 0, 0, 722, 3347, 1, 0, 0, 0, 724, 3351, 1, 0, 0,
		0, 726, 3355, 1, 0, 0, 0, 728, 3403, 1, 0, 0, 0, 730, 3449, 1, 0, 0, 0,
		732, 3495, 1, 0, 0, 0, 734, 3497, 1, 0, 0, 0, 736, 3510, 1, 0, 0, 0, 738,
		3512, 1, 0, 0, 0, 740, 3559, 1, 0, 0, 0, 742, 3563, 1, 0, 0, 0, 744, 3570,
		1, 0, 0, 0, 746, 3584, 1, 0, 0, 0, 748, 3600, 1, 0, 0, 0, 750, 3602, 1,
		0, 0, 0, 752, 3618, 1, 0, 0, 0, 754, 3632, 1, 0, 0, 0, 756, 3634, 1, 0,
		0, 0, 758, 3647, 1, 0, 0, 0, 760, 3653, 1, 0, 0, 0, 762, 3657, 1, 0, 0,
		0, 764, 3659, 1, 0, 0, 0, 766, 3664, 1, 0, 0, 0, 768, 3668, 1, 0, 0, 0,
		770, 3671, 1, 0, 0, 0, 772, 3678, 1, 0, 0, 0, 774, 3686, 1, 0, 0, 0, 776,
		3692, 1, 0, 0, 0, 778, 3694, 1, 0, 0, 0, 780, 3699, 1, 0, 0, 0, 782, 3707,
		1, 0, 0, 0, 784, 3709, 1, 0, 0, 0, 786, 3714, 1, 0, 0, 0, 788, 3720, 1,
		0, 0, 0, 790, 3724, 1, 0, 0, 0, 792, 3726, 1, 0, 0, 0, 794, 3742, 1, 0,
		0, 0, 796, 3744, 1, 0, 0, 0, 798, 3750, 1, 0, 0, 0, 800, 3758, 1, 0, 0,
		0, 802, 3761, 1, 0, 0, 0, 804, 3767, 1, 0, 0, 0, 806, 3778, 1, 0, 0, 0,
		808, 3780, 1, 0, 0, 0, 810, 3782, 1, 0, 0, 0, 812, 3802, 1, 0, 0, 0, 814,
		3805, 1, 0, 0, 0, 816, 3811, 1, 0, 0, 0, 818, 3814, 1, 0, 0, 0, 820, 3821,
		1, 0, 0, 0, 822, 3830, 1, 0, 0, 0, 824, 3833, 1, 0, 0, 0, 826, 3839, 1,
		0, 0, 0, 828, 3842, 1, 0, 0, 0, 830, 3851, 1, 0, 0, 0, 832, 3859, 1, 0,
		0, 0, 834, 3861, 1, 0, 0, 0, 836, 3863, 1, 0, 0, 0, 838, 3871, 1, 0, 0,
		0, 840, 3879, 1, 0, 0, 0, 842, 3881, 1, 0, 0, 0, 844, 3895, 1, 0, 0, 0,
		846, 3909, 1, 0, 0, 0, 848, 3934, 1, 0, 0, 0, 850, 3974, 1, 0, 0, 0, 852,
		3976, 1, 0, 0, 0, 854, 3983, 1, 0, 0, 0, 856, 3985, 1, 0, 0, 0, 858, 3992,
		1, 0, 0, 0, 860, 3997, 1, 0, 0, 0, 862, 4002, 1, 0, 0, 0, 864, 4011, 1,
		0, 0, 0, 866, 4020, 1, 0, 0, 0, 868, 4022, 1, 0, 0, 0, 870, 4024, 1, 0,
		0, 0, 872, 4037, 1, 0, 0, 0, 874, 4047, 1, 0, 0, 0, 876, 4053, 1, 0, 0,
		0, 878, 4067, 1, 0, 0, 0, 880, 4071, 1, 0, 0, 0, 882, 4075, 1, 0, 0, 0,
		884, 4079, 1, 0, 0, 0, 886, 4081, 1, 0, 0, 0, 888, 4083, 1, 0, 0, 0, 890,
		4089, 1, 0, 0, 0, 892, 4094, 1, 0, 0, 0, 894, 4114, 1, 0, 0, 0, 896, 4118,
		1, 0, 0, 0, 898, 4120, 1, 0, 0, 0, 900, 4132, 1, 0, 0, 0, 902, 4143, 1,
		0, 0, 0, 904, 4148, 1, 0, 0, 0, 906, 4153, 1, 0, 0, 0, 908, 4158, 1, 0,
		0, 0, 910, 4160, 1, 0, 0, 0, 912, 4179, 1, 0, 0, 0, 914, 4183, 1, 0, 0,
		0, 916, 4185, 1, 0, 0, 0, 918, 4187, 1, 0, 0, 0, 920, 4196, 1, 0, 0, 0,
		922, 4198, 1, 0, 0, 0, 924, 4206, 1, 0, 0, 0, 926, 4208, 1, 0, 0, 0, 928,
		4216, 1, 0, 0, 0, 930, 4223, 1, 0, 0, 0, 932, 4225, 1, 0, 0, 0, 934, 4227,
		1, 0, 0, 0, 936, 4230, 1, 0, 0, 0, 938, 4234, 1, 0, 0, 0, 940, 4236, 1,
		0, 0, 0, 942, 4241, 1, 0, 0, 0, 944, 4243, 1, 0, 0, 0, 946, 4245, 1, 0,
		0, 0, 948, 4247, 1, 0, 0, 0, 950, 4252, 1, 0, 0, 0, 952, 4259, 1, 0, 0,
		0, 954, 4261, 1, 0, 0, 0, 956, 4266, 1, 0, 0, 0, 958, 4270, 1, 0, 0, 0,
		960, 4272, 1, 0, 0, 0, 962, 4279, 1, 0, 0, 0, 964, 4284, 1, 0, 0, 0, 966,
		4287, 1, 0, 0, 0, 968, 4295, 1, 0, 0, 0, 970, 4303, 1, 0, 0, 0, 972, 4306,
		1, 0, 0, 0, 974, 4310, 1, 0, 0, 0, 976, 4316, 1, 0, 0, 0, 978, 4324, 1,
		0, 0, 0, 980, 4328, 1, 0, 0, 0, 982, 4335, 1, 0, 0, 0, 984, 4361, 1, 0,
		0, 0, 986, 4366, 1, 0, 0, 0, 988, 4378, 1, 0, 0, 0, 990, 4380, 1, 0, 0,
		0, 992, 4382, 1, 0, 0, 0, 994, 4387, 1, 0, 0, 0, 996, 4392, 1, 0, 0, 0,
		998, 4397, 1, 0, 0, 0, 1000, 4402, 1, 0, 0, 0, 1002, 4409, 1, 0, 0, 0,
		1004, 4411, 1, 0, 0, 0, 1006, 4413, 1, 0, 0, 0, 1008, 4418, 1, 0, 0, 0,
		1010, 4420, 1, 0, 0, 0, 1012, 4427, 1, 0, 0, 0, 1014, 4429, 1, 0, 0, 0,
		1016, 4431, 1, 0, 0, 0, 1018, 4436, 1, 0, 0, 0, 1020, 4441, 1, 0, 0, 0,
		1022, 4446, 1, 0, 0, 0, 1024, 4453, 1, 0, 0, 0, 1026, 4455, 1, 0, 0, 0,
		1028, 4457, 1, 0, 0, 0, 1030, 4462, 1, 0, 0, 0, 1032, 4467, 1, 0, 0, 0,
		1034, 4472, 1, 0, 0, 0, 1036, 4474, 1, 0, 0, 0, 1038, 4483, 1, 0, 0, 0,
		1040, 4487, 1, 0, 0, 0, 1042, 4489, 1, 0, 0, 0, 1044, 4491, 1, 0, 0, 0,
		1046, 4493, 1, 0, 0, 0, 1048, 4495, 1, 0, 0, 0, 1050, 4497, 1, 0, 0, 0,
		1052, 4504, 1, 0, 0, 0, 1054, 4513, 1, 0, 0, 0, 1056, 4522, 1, 0, 0, 0,
		1058, 4524, 1, 0, 0, 0, 1060, 4539, 1, 0, 0, 0, 1062, 4548, 1, 0, 0, 0,
		1064, 4552, 1, 0, 0, 0, 1066, 4556, 1, 0, 0, 0, 1068, 4560, 1, 0, 0, 0,
		1070, 4562, 1, 0, 0, 0, 1072, 4564, 1, 0, 0, 0, 1074, 4571, 1, 0, 0, 0,
		1076, 4575, 1, 0, 0, 0, 1078, 4577, 1, 0, 0, 0, 1080, 4581, 1, 0, 0, 0,
		1082, 4583, 1, 0, 0, 0, 1084, 4590, 1, 0, 0, 0, 1086, 4592, 1, 0, 0, 0,
		1088, 4594, 1, 0, 0, 0, 1090, 4596, 1, 0, 0, 0, 1092, 4598, 1, 0, 0, 0,
		1094, 4602, 1, 0, 0, 0, 1096, 4604, 1, 0, 0, 0, 1098, 4606, 1, 0, 0, 0,
		1100, 4608, 1, 0, 0, 0, 1102, 4610, 1, 0, 0, 0, 1104, 4614, 1, 0, 0, 0,
		1106, 4616, 1, 0, 0, 0, 1108, 4618, 1, 0, 0, 0, 1110, 4620, 1, 0, 0, 0,
		1112, 4622, 1, 0, 0, 0, 1114, 4624, 1, 0, 0, 0, 1116, 4626, 1, 0, 0, 0,
		1118, 4628, 1, 0, 0, 0, 1120, 4630, 1, 0, 0, 0, 1122, 4632, 1, 0, 0, 0,
		1124, 4636, 1, 0, 0, 0, 1126, 4646, 1, 0, 0, 0, 1128, 4651, 1, 0, 0, 0,
		1130, 4653, 1, 0, 0, 0, 1132, 4656, 1, 0, 0, 0, 1134, 4659, 1, 0, 0, 0,
		1136, 4662, 1, 0, 0, 0, 1138, 4664, 1, 0, 0, 0, 1140, 4669, 1, 0, 0, 0,
		1142, 4673, 1, 0, 0, 0, 1144, 4675, 1, 0, 0, 0, 1146, 4677, 1, 0, 0, 0,
		1148, 4681, 1, 0, 0, 0, 1150, 4688, 1, 0, 0, 0, 1152, 4690, 1, 0, 0, 0,
		1154, 4692, 1, 0, 0, 0, 1156, 4694, 1, 0, 0, 0, 1158, 4696, 1, 0, 0, 0,
		1160, 4698, 1, 0, 0, 0, 1162, 4700, 1, 0, 0, 0, 1164, 4702, 1, 0, 0, 0,
		1166, 4704, 1, 0, 0, 0, 1168, 4707, 1, 0, 0, 0, 1170, 4709, 1, 0, 0, 0,
		1172, 4711, 1, 0, 0, 0, 1174, 4713, 1, 0, 0, 0, 1176, 4715, 1, 0, 0, 0,
		1178, 1180, 3, 2, 1, 0, 1179, 1181, 3, 34, 17, 0, 1180, 1179, 1, 0, 0,
		0, 1180, 1181, 1, 0, 0, 0, 1181, 1182, 1, 0, 0, 0, 1182, 1183, 5, 0, 0,
		1, 1183, 1188, 1, 0, 0, 0, 1184, 1185, 3, 34, 17, 0, 1185, 1186, 5, 0,
		0, 1, 1186, 1188, 1, 0, 0, 0, 1187, 1178, 1, 0, 0, 0, 1187, 1184, 1, 0,
		0, 0, 1188, 1, 1, 0, 0, 0, 1189, 1192, 3, 4, 2, 0, 1190, 1192, 3, 6, 3,
		0, 1191, 1189, 1, 0, 0, 0, 1191, 1190, 1, 0, 0, 0, 1192, 3, 1, 0, 0, 0,
		1193, 1195, 3, 30, 15, 0, 1194, 1193, 1, 0, 0, 0, 1195, 1196, 1, 0, 0,
		0, 1196, 1194, 1, 0, 0, 0, 1196, 1197, 1, 0, 0, 0, 1197, 1210, 1, 0, 0,
		0, 1198, 1200, 3, 10, 5, 0, 1199, 1198, 1, 0, 0, 0, 1200, 1201, 1, 0, 0,
		0, 1201, 1199, 1, 0, 0, 0, 1201, 1202, 1, 0, 0, 0, 1202, 1206, 1, 0, 0,
		0, 1203, 1205, 3, 30, 15, 0, 1204, 1203, 1, 0, 0, 0, 1205, 1208, 1, 0,
		0, 0, 1206, 1204, 1, 0, 0, 0, 1206, 1207, 1, 0, 0, 0, 1207, 1210, 1, 0,
		0, 0, 1208, 1206, 1, 0, 0, 0, 1209, 1194, 1, 0, 0, 0, 1209, 1199, 1, 0,
		0, 0, 1210, 5, 1, 0, 0, 0, 1211, 1216, 3, 38, 19, 0, 1212, 1214, 3, 52,
		26, 0, 1213, 1215, 3, 8, 4, 0, 1214, 1213, 1, 0, 0, 0, 1214, 1215, 1, 0,
		0, 0, 1215, 1217, 1, 0, 0, 0, 1216, 1212, 1, 0, 0, 0, 1216, 1217, 1, 0,
		0, 0, 1217, 1224, 1, 0, 0, 0, 1218, 1220, 3, 52, 26, 0, 1219, 1221, 3,
		8, 4, 0, 1220, 1219, 1, 0, 0, 0, 1220, 1221, 1, 0, 0, 0, 1221, 1224, 1,
		0, 0, 0, 1222, 1224, 3, 8, 4, 0, 1223, 1211, 1, 0, 0, 0, 1223, 1218, 1,
		0, 0, 0, 1223, 1222, 1, 0, 0, 0, 1224, 7, 1, 0, 0, 0, 1225, 1228, 3, 46,
		23, 0, 1226, 1228, 3, 48, 24, 0, 1227, 1225, 1, 0, 0, 0, 1227, 1226, 1,
		0, 0, 0, 1228, 9, 1, 0, 0, 0, 1229, 1230, 5, 191, 0, 0, 1230, 1235, 5,
		193, 0, 0, 1231, 1236, 3, 12, 6, 0, 1232, 1236, 3, 14, 7, 0, 1233, 1236,
		3, 16, 8, 0, 1234, 1236, 3, 20, 10, 0, 1235, 1231, 1, 0, 0, 0, 1235, 1232,
		1, 0, 0, 0, 1235, 1233, 1, 0, 0, 0, 1235, 1234, 1, 0, 0, 0, 1236, 11, 1,
		0, 0, 0, 1237, 1238, 5, 188, 0, 0, 1238, 1239, 3, 538, 269, 0, 1239, 13,
		1, 0, 0, 0, 1240, 1242, 5, 308, 0, 0, 1241, 1240, 1, 0, 0, 0, 1241, 1242,
		1, 0, 0, 0, 1242, 1243, 1, 0, 0, 0, 1243, 1244, 5, 292, 0, 0, 1244, 1245,
		3, 88, 44, 0, 1245, 15, 1, 0, 0, 0, 1246, 1247, 5, 210, 0, 0, 1247, 1248,
		5, 326, 0, 0, 1248, 1249, 3, 18, 9, 0, 1249, 17, 1, 0, 0, 0, 1250, 1251,
		3, 1144, 572, 0, 1251, 19, 1, 0, 0, 0, 1252, 1256, 3, 22, 11, 0, 1253,
		1256, 3, 24, 12, 0, 1254, 1256, 3, 26, 13, 0, 1255, 1252, 1, 0, 0, 0, 1255,
		1253, 1, 0, 0, 0, 1255, 1254, 1, 0, 0, 0, 1256, 21, 1, 0, 0, 0, 1257, 1259,
		5, 308, 0, 0, 1258, 1257, 1, 0, 0, 0, 1258, 1259, 1, 0, 0, 0, 1259, 1260,
		1, 0, 0, 0, 1260, 1261, 5, 292, 0, 0, 1261, 1262, 3, 28, 14, 0, 1262, 1263,
		3, 72, 36, 0, 1263, 23, 1, 0, 0, 0, 1264, 1266, 5, 281, 0, 0, 1265, 1264,
		1, 0, 0, 0, 1265, 1266, 1, 0, 0, 0, 1266, 1267, 1, 0, 0, 0, 1267, 1268,
		5, 316, 0, 0, 1268, 1269, 3, 28, 14, 0, 1269, 1270, 3, 78, 39, 0, 1270,
		25, 1, 0, 0, 0, 1271, 1272, 5, 228, 0, 0, 1272, 1273, 3, 28, 14, 0, 1273,
		1274, 3, 84, 42, 0, 1274, 27, 1, 0, 0, 0, 1275, 1276, 5, 111, 0, 0, 1276,
		1277, 5, 155, 0, 0, 1277, 1279, 5, 92, 0, 0, 1278, 1275, 1, 0, 0, 0, 1278,
		1279, 1, 0, 0, 0, 1279, 1280, 1, 0, 0, 0, 1280, 1281, 3, 36, 18, 0, 1281,
		29, 1, 0, 0, 0, 1282, 1283, 5, 191, 0, 0, 1283, 1285, 5, 182, 0, 0, 1284,
		1286, 3, 32, 16, 0, 1285, 1284, 1, 0, 0, 0, 1285, 1286, 1, 0, 0, 0, 1286,
		31, 1, 0, 0, 0, 1287, 1289, 5, 25, 0, 0, 1288, 1287, 1, 0, 0, 0, 1288,
		1289, 1, 0, 0, 0, 1289, 1290, 1, 0, 0, 0, 1290, 1303, 7, 0, 0, 0, 1291,
		1303, 5, 188, 0, 0, 1292, 1294, 5, 308, 0, 0, 1293, 1292, 1, 0, 0, 0, 1293,
		1294, 1, 0, 0, 0, 1294, 1295, 1, 0, 0, 0, 1295, 1303, 5, 292, 0, 0, 1296,
		1297, 5, 210, 0, 0, 1297, 1303, 5, 326, 0, 0, 1298, 1300, 5, 167, 0, 0,
		1299, 1298, 1, 0, 0, 0, 1299, 1300, 1, 0, 0, 0, 1300, 1301, 1, 0, 0, 0,
		1301, 1303, 3, 36, 18, 0, 1302, 1288, 1, 0, 0, 0, 1302, 1291, 1, 0, 0,
		0, 1302, 1293, 1, 0, 0, 0, 1302, 1296, 1, 0, 0, 0, 1302, 1299, 1, 0, 0,
		0, 1303, 33, 1, 0, 0, 0, 1304, 1305, 5, 191, 0, 0, 1305, 1306, 5, 57, 0,
		0, 1306, 35, 1, 0, 0, 0, 1307, 1308, 5, 329, 0, 0, 1308, 37, 1, 0, 0, 0,
		1309, 1310, 5, 202, 0, 0, 1310, 1312, 5, 319, 0, 0, 1311, 1313, 3, 40,
		20, 0, 1312, 1311, 1, 0, 0, 0, 1312, 1313, 1, 0, 0, 0, 1313, 39, 1, 0,
		0, 0, 1314, 1319, 3, 42, 21, 0, 1315, 1316, 5, 363, 0, 0, 1316, 1318, 3,
		42, 21, 0, 1317, 1315, 1, 0, 0, 0, 1318, 1321, 1, 0, 0, 0, 1319, 1317,
		1, 0, 0, 0, 1319, 1320, 1, 0, 0, 0, 1320, 41, 1, 0, 0, 0, 1321, 1319, 1,
		0, 0, 0, 1322, 1323, 3, 44, 22, 0, 1323, 43, 1, 0, 0, 0, 1324, 1325, 5,
		309, 0, 0, 1325, 1329, 5, 306, 0, 0, 1326, 1327, 5, 309, 0, 0, 1327, 1329,
		5, 325, 0, 0, 1328, 1324, 1, 0, 0, 0, 1328, 1326, 1, 0, 0, 0, 1329, 45,
		1, 0, 0, 0, 1330, 1331, 5, 185, 0, 0, 1331, 47, 1, 0, 0, 0, 1332, 1333,
		5, 60, 0, 0, 1333, 49, 1, 0, 0, 0, 1334, 1335, 5, 371, 0, 0, 1335, 1336,
		3, 52, 26, 0, 1336, 1337, 5, 382, 0, 0, 1337, 51, 1, 0, 0, 0, 1338, 1339,
		3, 58, 29, 0, 1339, 53, 1, 0, 0, 0, 1340, 1341, 5, 371, 0, 0, 1341, 1342,
		3, 58, 29, 0, 1342, 1343, 5, 382, 0, 0, 1343, 55, 1, 0, 0, 0, 1344, 1345,
		5, 371, 0, 0, 1345, 1346, 3, 58, 29, 0, 1346, 1347, 5, 382, 0, 0, 1347,
		57, 1, 0, 0, 0, 1348, 1350, 3, 290, 145, 0, 1349, 1348, 1, 0, 0, 0, 1349,
		1350, 1, 0, 0, 0, 1350, 1352, 1, 0, 0, 0, 1351, 1353, 3, 60, 30, 0, 1352,
		1351, 1, 0, 0, 0, 1352, 1353, 1, 0, 0, 0, 1353, 1354, 1, 0, 0, 0, 1354,
		1355, 3, 64, 32, 0, 1355, 59, 1, 0, 0, 0, 1356, 1358, 3, 62, 31, 0, 1357,
		1356, 1, 0, 0, 0, 1358, 1359, 1, 0, 0, 0, 1359, 1357, 1, 0, 0, 0, 1359,
		1360, 1, 0, 0, 0, 1360, 61, 1, 0, 0, 0, 1361, 1365, 3, 70, 35, 0, 1362,
		1365, 3, 76, 38, 0, 1363, 1365, 3, 82, 41, 0, 1364, 1361, 1, 0, 0, 0, 1364,
		1362, 1, 0, 0, 0, 1364, 1363, 1, 0, 0, 0, 1365, 63, 1, 0, 0, 0, 1366, 1370,
		3, 66, 33, 0, 1367, 1369, 3, 68, 34, 0, 1368, 1367, 1, 0, 0, 0, 1369, 1372,
		1, 0, 0, 0, 1370, 1368, 1, 0, 0, 0, 1370, 1371, 1, 0, 0, 0, 1371, 65, 1,
		0, 0, 0, 1372, 1370, 1, 0, 0, 0, 1373, 1377, 3, 98, 49, 0, 1374, 1377,
		3, 130, 65, 0, 1375, 1377, 3, 182, 91, 0, 1376, 1373, 1, 0, 0, 0, 1376,
		1374, 1, 0, 0, 0, 1376, 1375, 1, 0, 0, 0, 1377, 67, 1, 0, 0, 0, 1378, 1380,
		5, 152, 0, 0, 1379, 1381, 3, 502, 251, 0, 1380, 1379, 1, 0, 0, 0, 1380,
		1381, 1, 0, 0, 0, 1381, 1382, 1, 0, 0, 0, 1382, 1383, 3, 66, 33, 0, 1383,
		69, 1, 0, 0, 0, 1384, 1386, 5, 308, 0, 0, 1385, 1384, 1, 0, 0, 0, 1385,
		1386, 1, 0, 0, 0, 1386, 1387, 1, 0, 0, 0, 1387, 1388, 5, 292, 0, 0, 1388,
		1389, 3, 1122, 561, 0, 1389, 1390, 3, 72, 36, 0, 1390, 71, 1, 0, 0, 0,
		1391, 1393, 3, 706, 353, 0, 1392, 1391, 1, 0, 0, 0, 1392, 1393, 1, 0, 0,
		0, 1393, 1394, 1, 0, 0, 0, 1394, 1396, 3, 768, 384, 0, 1395, 1392, 1, 0,
		0, 0, 1395, 1396, 1, 0, 0, 0, 1396, 1397, 1, 0, 0, 0, 1397, 1398, 3, 74,
		37, 0, 1398, 73, 1, 0, 0, 0, 1399, 1400, 5, 367, 0, 0, 1400, 1401, 3, 88,
		44, 0, 1401, 75, 1, 0, 0, 0, 1402, 1404, 5, 281, 0, 0, 1403, 1402, 1, 0,
		0, 0, 1403, 1404, 1, 0, 0, 0, 1404, 1405, 1, 0, 0, 0, 1405, 1406, 5, 316,
		0, 0, 1406, 1407, 3, 1122, 561, 0, 1407, 1408, 3, 78, 39, 0, 1408, 77,
		1, 0, 0, 0, 1409, 1411, 3, 706, 353, 0, 1410, 1409, 1, 0, 0, 0, 1410, 1411,
		1, 0, 0, 0, 1411, 1412, 1, 0, 0, 0, 1412, 1414, 3, 774, 387, 0, 1413, 1410,
		1, 0, 0, 0, 1413, 1414, 1, 0, 0, 0, 1414, 1415, 1, 0, 0, 0, 1415, 1416,
		3, 80, 40, 0, 1416, 79, 1, 0, 0, 0, 1417, 1418, 5, 367, 0, 0, 1418, 1419,
		3, 92, 46, 0, 1419, 81, 1, 0, 0, 0, 1420, 1421, 5, 228, 0, 0, 1421, 1422,
		3, 1122, 561, 0, 1422, 1423, 3, 84, 42, 0, 1423, 83, 1, 0, 0, 0, 1424,
		1426, 3, 706, 353, 0, 1425, 1424, 1, 0, 0, 0, 1425, 1426, 1, 0, 0, 0, 1426,
		1427, 1, 0, 0, 0, 1427, 1429, 3, 704, 352, 0, 1428, 1425, 1, 0, 0, 0, 1428,
		1429, 1, 0, 0, 0, 1429, 1430, 1, 0, 0, 0, 1430, 1431, 3, 86, 43, 0, 1431,
		85, 1, 0, 0, 0, 1432, 1433, 5, 367, 0, 0, 1433, 1434, 3, 848, 424, 0, 1434,
		87, 1, 0, 0, 0, 1435, 1440, 3, 554, 277, 0, 1436, 1440, 3, 96, 48, 0, 1437,
		1440, 3, 1088, 544, 0, 1438, 1440, 3, 90, 45, 0, 1439, 1435, 1, 0, 0, 0,
		1439, 1436, 1, 0, 0, 0, 1439, 1437, 1, 0, 0, 0, 1439, 1438, 1, 0, 0, 0,
		1440, 89, 1, 0, 0, 0, 1441, 1442, 7, 1, 0, 0, 1442, 91, 1, 0, 0, 0, 1443,
		1448, 3, 94, 47, 0, 1444, 1448, 3, 564, 282, 0, 1445, 1448, 3, 96, 48,
		0, 1446, 1448, 3, 1088, 544, 0, 1447, 1443, 1, 0, 0, 0, 1447, 1444, 1,
		0, 0, 0, 1447, 1445, 1, 0, 0, 0, 1447, 1446, 1, 0, 0, 0, 1448, 93, 1, 0,
		0, 0, 1449, 1450, 3, 56, 28, 0, 1450, 95, 1, 0, 0, 0, 1451, 1452, 5, 231,
		0, 0, 1452, 1456, 3, 872, 436, 0, 1453, 1456, 3, 874, 437, 0, 1454, 1456,
		3, 878, 439, 0, 1455, 1451, 1, 0, 0, 0, 1455, 1453, 1, 0, 0, 0, 1455, 1454,
		1, 0, 0, 0, 1456, 97, 1, 0, 0, 0, 1457, 1459, 3, 100, 50, 0, 1458, 1457,
		1, 0, 0, 0, 1459, 1460, 1, 0, 0, 0, 1460, 1458, 1, 0, 0, 0, 1460, 1461,
		1, 0, 0, 0, 1461, 99, 1, 0, 0, 0, 1462, 1465, 3, 102, 51, 0, 1463, 1465,
		3, 128, 64, 0, 1464, 1462, 1, 0, 0, 0, 1464, 1463, 1, 0, 0, 0, 1465, 101,
		1, 0, 0, 0, 1466, 1473, 3, 104, 52, 0, 1467, 1473, 3, 106, 53, 0, 1468,
		1473, 3, 108, 54, 0, 1469, 1473, 3, 118, 59, 0, 1470, 1473, 3, 120, 60,
		0, 1471, 1473, 3, 126, 63, 0, 1472, 1466, 1, 0, 0, 0, 1472, 1467, 1, 0,
		0, 0, 1472, 1468, 1, 0, 0, 0, 1472, 1469, 1, 0, 0, 0, 1472, 1470, 1, 0,
		0, 0, 1472, 1471, 1, 0, 0, 0, 1473, 103, 1, 0, 0, 0, 1474, 1475, 5, 66,
		0, 0, 1475, 1479, 5, 188, 0, 0, 1476, 1477, 5, 111, 0, 0, 1477, 1478, 5,
		155, 0, 0, 1478, 1480, 5, 92, 0, 0, 1479, 1476, 1, 0, 0, 0, 1479, 1480,
		1, 0, 0, 0, 1480, 1481, 1, 0, 0, 0, 1481, 1482, 3, 542, 271, 0, 1482, 105,
		1, 0, 0, 0, 1483, 1484, 5, 85, 0, 0, 1484, 1487, 5, 188, 0, 0, 1485, 1486,
		5, 111, 0, 0, 1486, 1488, 5, 92, 0, 0, 1487, 1485, 1, 0, 0, 0, 1487, 1488,
		1, 0, 0, 0, 1488, 1489, 1, 0, 0, 0, 1489, 1490, 3, 542, 271, 0, 1490, 107,
		1, 0, 0, 0, 1491, 1507, 5, 66, 0, 0, 1492, 1494, 5, 308, 0, 0, 1493, 1492,
		1, 0, 0, 0, 1493, 1494, 1, 0, 0, 0, 1494, 1495, 1, 0, 0, 0, 1495, 1499,
		5, 292, 0, 0, 1496, 1497, 5, 111, 0, 0, 1497, 1498, 5, 155, 0, 0, 1498,
		1500, 5, 92, 0, 0, 1499, 1496, 1, 0, 0, 0, 1499, 1500, 1, 0, 0, 0, 1500,
		1508, 1, 0, 0, 0, 1501, 1502, 5, 164, 0, 0, 1502, 1504, 5, 181, 0, 0, 1503,
		1505, 5, 308, 0, 0, 1504, 1503, 1, 0, 0, 0, 1504, 1505, 1, 0, 0, 0, 1505,
		1506, 1, 0, 0, 0, 1506, 1508, 5, 292, 0, 0, 1507, 1493, 1, 0, 0, 0, 1507,
		1501, 1, 0, 0, 0, 1508, 1509, 1, 0, 0, 0, 1509, 1512, 3, 556, 278, 0, 1510,
		1513, 3, 110, 55, 0, 1511, 1513, 3, 112, 56, 0, 1512, 1510, 1, 0, 0, 0,
		1512, 1511, 1, 0, 0, 0, 1513, 1515, 1, 0, 0, 0, 1514, 1516, 3, 116, 58,
		0, 1515, 1514, 1, 0, 0, 0, 1515, 1516, 1, 0, 0, 0, 1516, 109, 1, 0, 0,
		0, 1517, 1519, 3, 706, 353, 0, 1518, 1517, 1, 0, 0, 0, 1518, 1519, 1, 0,
		0, 0, 1519, 1520, 1, 0, 0, 0, 1520, 1525, 5, 28, 0, 0, 1521, 1523, 5, 308,
		0, 0, 1522, 1521, 1, 0, 0, 0, 1522, 1523, 1, 0, 0, 0, 1523, 1524, 1, 0,
		0, 0, 1524, 1526, 5, 292, 0, 0, 1525, 1522, 1, 0, 0, 0, 1525, 1526, 1,
		0, 0, 0, 1526, 111, 1, 0, 0, 0, 1527, 1543, 3, 114, 57, 0, 1528, 1530,
		3, 706, 353, 0, 1529, 1528, 1, 0, 0, 0, 1529, 1530, 1, 0, 0, 0, 1530, 1531,
		1, 0, 0, 0, 1531, 1543, 3, 560, 280, 0, 1532, 1534, 3, 706, 353, 0, 1533,
		1532, 1, 0, 0, 0, 1533, 1534, 1, 0, 0, 0, 1534, 1539, 1, 0, 0, 0, 1535,
		1537, 5, 308, 0, 0, 1536, 1535, 1, 0, 0, 0, 1536, 1537, 1, 0, 0, 0, 1537,
		1538, 1, 0, 0, 0, 1538, 1540, 5, 292, 0, 0, 1539, 1536, 1, 0, 0, 0, 1539,
		1540, 1, 0, 0, 0, 1540, 1541, 1, 0, 0, 0, 1541, 1543, 3, 574, 287, 0, 1542,
		1527, 1, 0, 0, 0, 1542, 1529, 1, 0, 0, 0, 1542, 1533, 1, 0, 0, 0, 1543,
		113, 1, 0, 0, 0, 1544, 1545, 5, 134, 0, 0, 1545, 1546, 3, 88, 44, 0, 1546,
		115, 1, 0, 0, 0, 1547, 1548, 5, 30, 0, 0, 1548, 1549, 5, 61, 0, 0, 1549,
		1550, 5, 161, 0, 0, 1550, 1551, 3, 88, 44, 0, 1551, 117, 1, 0, 0, 0, 1552,
		1554, 5, 85, 0, 0, 1553, 1555, 5, 308, 0, 0, 1554, 1553, 1, 0, 0, 0, 1554,
		1555, 1, 0, 0, 0, 1555, 1556, 1, 0, 0, 0, 1556, 1559, 5, 292, 0, 0, 1557,
		1558, 5, 111, 0, 0, 1558, 1560, 5, 92, 0, 0, 1559, 1557, 1, 0, 0, 0, 1559,
		1560, 1, 0, 0, 0, 1560, 1561, 1, 0, 0, 0, 1561, 1562, 3, 556, 278, 0, 1562,
		119, 1, 0, 0, 0, 1563, 1581, 5, 66, 0, 0, 1564, 1566, 5, 308, 0, 0, 1565,
		1564, 1, 0, 0, 0, 1565, 1566, 1, 0, 0, 0, 1566, 1567, 1, 0, 0, 0, 1567,
		1568, 5, 292, 0, 0, 1568, 1572, 5, 320, 0, 0, 1569, 1570, 5, 111, 0, 0,
		1570, 1571, 5, 155, 0, 0, 1571, 1573, 5, 92, 0, 0, 1572, 1569, 1, 0, 0,
		0, 1572, 1573, 1, 0, 0, 0, 1573, 1582, 1, 0, 0, 0, 1574, 1575, 5, 164,
		0, 0, 1575, 1577, 5, 181, 0, 0, 1576, 1578, 5, 308, 0, 0, 1577, 1576, 1,
		0, 0, 0, 1577, 1578, 1, 0, 0, 0, 1578, 1579, 1, 0, 0, 0, 1579, 1580, 5,
		292, 0, 0, 1580, 1582, 5, 320, 0, 0, 1581, 1565, 1, 0, 0, 0, 1581, 1574,
		1, 0, 0, 0, 1582, 1583, 1, 0, 0, 0, 1583, 1584, 3, 562, 281, 0, 1584, 1585,
		3, 122, 61, 0, 1585, 121, 1, 0, 0, 0, 1586, 1588, 5, 30, 0, 0, 1587, 1586,
		1, 0, 0, 0, 1587, 1588, 1, 0, 0, 0, 1588, 1589, 1, 0, 0, 0, 1589, 1596,
		3, 124, 62, 0, 1590, 1596, 3, 114, 57, 0, 1591, 1593, 5, 30, 0, 0, 1592,
		1591, 1, 0, 0, 0, 1592, 1593, 1, 0, 0, 0, 1593, 1594, 1, 0, 0, 0, 1594,
		1596, 3, 574, 287, 0, 1595, 1587, 1, 0, 0, 0, 1595, 1590, 1, 0, 0, 0, 1595,
		1592, 1, 0, 0, 0, 1596, 123, 1, 0, 0, 0, 1597, 1598, 5, 61, 0, 0, 1598,
		1599, 5, 161, 0, 0, 1599, 1600, 3, 560, 280, 0, 1600, 125, 1, 0, 0, 0,
		1601, 1603, 5, 85, 0, 0, 1602, 1604, 5, 308, 0, 0, 1603, 1602, 1, 0, 0,
		0, 1603, 1604, 1, 0, 0, 0, 1604, 1605, 1, 0, 0, 0, 1605, 1606, 5, 292,
		0, 0, 1606, 1609, 5, 320, 0, 0, 1607, 1608, 5, 111, 0, 0, 1608, 1610, 5,
		92, 0, 0, 1609, 1607, 1, 0, 0, 0, 1609, 1610, 1, 0, 0, 0, 1610, 1611, 1,
		0, 0, 0, 1611, 1612, 3, 562, 281, 0, 1612, 127, 1, 0, 0, 0, 1613, 1614,
		3, 274, 137, 0, 1614, 129, 1, 0, 0, 0, 1615, 1618, 3, 132, 66, 0, 1616,
		1618, 3, 138, 69, 0, 1617, 1615, 1, 0, 0, 0, 1617, 1616, 1, 0, 0, 0, 1618,
		131, 1, 0, 0, 0, 1619, 1622, 3, 134, 67, 0, 1620, 1622, 3, 136, 68, 0,
		1621, 1619, 1, 0, 0, 0, 1621, 1620, 1, 0, 0, 0, 1622, 133, 1, 0, 0, 0,
		1623, 1624, 3, 292, 146, 0, 1624, 1626, 3, 142, 71, 0, 1625, 1627, 3, 244,
		122, 0, 1626, 1625, 1, 0, 0, 0, 1626, 1627, 1, 0, 0, 0, 1627, 135, 1, 0,
		0, 0, 1628, 1629, 3, 292, 146, 0, 1629, 1630, 3, 54, 27, 0, 1630, 137,
		1, 0, 0, 0, 1631, 1634, 3, 140, 70, 0, 1632, 1634, 3, 54, 27, 0, 1633,
		1631, 1, 0, 0, 0, 1633, 1632, 1, 0, 0, 0, 1634, 139, 1, 0, 0, 0, 1635,
		1637, 3, 142, 71, 0, 1636, 1638, 3, 244, 122, 0, 1637, 1636, 1, 0, 0, 0,
		1637, 1638, 1, 0, 0, 0, 1638, 141, 1, 0, 0, 0, 1639, 1641, 3, 144, 72,
		0, 1640, 1639, 1, 0, 0, 0, 1641, 1642, 1, 0, 0, 0, 1642, 1640, 1, 0, 0,
		0, 1642, 1643, 1, 0, 0, 0, 1643, 143, 1, 0, 0, 0, 1644, 1647, 3, 208, 104,
		0, 1645, 1647, 3, 146, 73, 0, 1646, 1644, 1, 0, 0, 0, 1646, 1645, 1, 0,
		0, 0, 1647, 145, 1, 0, 0, 0, 1648, 1651, 3, 148, 74, 0, 1649, 1651, 3,
		180, 90, 0, 1650, 1648, 1, 0, 0, 0, 1650, 1649, 1, 0, 0, 0, 1651, 147,
		1, 0, 0, 0, 1652, 1657, 3, 150, 75, 0, 1653, 1657, 3, 152, 76, 0, 1654,
		1657, 3, 164, 82, 0, 1655, 1657, 3, 174, 87, 0, 1656, 1652, 1, 0, 0, 0,
		1656, 1653, 1, 0, 0, 0, 1656, 1654, 1, 0, 0, 0, 1656, 1655, 1, 0, 0, 0,
		1657, 149, 1, 0, 0, 0, 1658, 1659, 5, 113, 0, 0, 1659, 1660, 3, 324, 162,
		0, 1660, 151, 1, 0, 0, 0, 1661, 1662, 5, 193, 0, 0, 1662, 1663, 3, 154,
		77, 0, 1663, 153, 1, 0, 0, 0, 1664, 1669, 3, 156, 78, 0, 1665, 1666, 5,
		363, 0, 0, 1666, 1668, 3, 156, 78, 0, 1667, 1665, 1, 0, 0, 0, 1668, 1671,
		1, 0, 0, 0, 1669, 1667, 1, 0, 0, 0, 1669, 1670, 1, 0, 0, 0, 1670, 155,
		1, 0, 0, 0, 1671, 1669, 1, 0, 0, 0, 1672, 1676, 3, 158, 79, 0, 1673, 1676,
		3, 160, 80, 0, 1674, 1676, 3, 162, 81, 0, 1675, 1672, 1, 0, 0, 0, 1675,
		1673, 1, 0, 0, 0, 1675, 1674, 1, 0, 0, 0, 1676, 157, 1, 0, 0, 0, 1677,
		1678, 3, 942, 471, 0, 1678, 1679, 5, 377, 0, 0, 1679, 1680, 3, 1112, 556,
		0, 1680, 1681, 5, 367, 0, 0, 1681, 1682, 3, 848, 424, 0, 1682, 159, 1,
		0, 0, 0, 1683, 1684, 3, 942, 471, 0, 1684, 1685, 5, 367, 0, 0, 1685, 1687,
		5, 371, 0, 0, 1686, 1688, 3, 398, 199, 0, 1687, 1686, 1, 0, 0, 0, 1687,
		1688, 1, 0, 0, 0, 1688, 1689, 1, 0, 0, 0, 1689, 1690, 5, 382, 0, 0, 1690,
		161, 1, 0, 0, 0, 1691, 1692, 3, 942, 471, 0, 1692, 1693, 3, 390, 195, 0,
		1693, 1694, 3, 1110, 555, 0, 1694, 163, 1, 0, 0, 0, 1695, 1696, 5, 180,
		0, 0, 1696, 1697, 3, 166, 83, 0, 1697, 165, 1, 0, 0, 0, 1698, 1703, 3,
		168, 84, 0, 1699, 1700, 5, 363, 0, 0, 1700, 1702, 3, 168, 84, 0, 1701,
		1699, 1, 0, 0, 0, 1702, 1705, 1, 0, 0, 0, 1703, 1701, 1, 0, 0, 0, 1703,
		1704, 1, 0, 0, 0, 1704, 167, 1, 0, 0, 0, 1705, 1703, 1, 0, 0, 0, 1706,
		1709, 3, 170, 85, 0, 1707, 1709, 3, 172, 86, 0, 1708, 1706, 1, 0, 0, 0,
		1708, 1707, 1, 0, 0, 0, 1709, 169, 1, 0, 0, 0, 1710, 1711, 3, 942, 471,
		0, 1711, 1712, 5, 377, 0, 0, 1712, 1713, 3, 1112, 556, 0, 1713, 171, 1,
		0, 0, 0, 1714, 1715, 3, 942, 471, 0, 1715, 1716, 3, 390, 195, 0, 1716,
		1717, 3, 1110, 555, 0, 1717, 173, 1, 0, 0, 0, 1718, 1720, 7, 2, 0, 0, 1719,
		1718, 1, 0, 0, 0, 1719, 1720, 1, 0, 0, 0, 1720, 1721, 1, 0, 0, 0, 1721,
		1722, 5, 79, 0, 0, 1722, 1723, 3, 176, 88, 0, 1723, 175, 1, 0, 0, 0, 1724,
		1729, 3, 178, 89, 0, 1725, 1726, 5, 363, 0, 0, 1726, 1728, 3, 178, 89,
		0, 1727, 1725, 1, 0, 0, 0, 1728, 1731, 1, 0, 0, 0, 1729, 1727, 1, 0, 0,
		0, 1729, 1730, 1, 0, 0, 0, 1730, 177, 1, 0, 0, 0, 1731, 1729, 1, 0, 0,
		0, 1732, 1733, 3, 848, 424, 0, 1733, 179, 1, 0, 0, 0, 1734, 1735, 3, 274,
		137, 0, 1735, 181, 1, 0, 0, 0, 1736, 1737, 3, 184, 92, 0, 1737, 183, 1,
		0, 0, 0, 1738, 1739, 6, 92, -1, 0, 1739, 1740, 3, 190, 95, 0, 1740, 1747,
		1, 0, 0, 0, 1741, 1742, 10, 2, 0, 0, 1742, 1743, 3, 186, 93, 0, 1743, 1744,
		3, 190, 95, 0, 1744, 1746, 1, 0, 0, 0, 1745, 1741, 1, 0, 0, 0, 1746, 1749,
		1, 0, 0, 0, 1747, 1745, 1, 0, 0, 0, 1747, 1748, 1, 0, 0, 0, 1748, 185,
		1, 0, 0, 0, 1749, 1747, 1, 0, 0, 0, 1750, 1753, 3, 188, 94, 0, 1751, 1753,
		5, 166, 0, 0, 1752, 1750, 1, 0, 0, 0, 1752, 1751, 1, 0, 0, 0, 1753, 187,
		1, 0, 0, 0, 1754, 1756, 5, 223, 0, 0, 1755, 1757, 3, 932, 466, 0, 1756,
		1755, 1, 0, 0, 0, 1756, 1757, 1, 0, 0, 0, 1757, 1767, 1, 0, 0, 0, 1758,
		1760, 5, 91, 0, 0, 1759, 1761, 3, 932, 466, 0, 1760, 1759, 1, 0, 0, 0,
		1760, 1761, 1, 0, 0, 0, 1761, 1767, 1, 0, 0, 0, 1762, 1764, 5, 128, 0,
		0, 1763, 1765, 3, 932, 466, 0, 1764, 1763, 1, 0, 0, 0, 1764, 1765, 1, 0,
		0, 0, 1765, 1767, 1, 0, 0, 0, 1766, 1754, 1, 0, 0, 0, 1766, 1758, 1, 0,
		0, 0, 1766, 1762, 1, 0, 0, 0, 1767, 189, 1, 0, 0, 0, 1768, 1769, 3, 192,
		96, 0, 1769, 191, 1, 0, 0, 0, 1770, 1773, 3, 194, 97, 0, 1771, 1773, 3,
		204, 102, 0, 1772, 1770, 1, 0, 0, 0, 1772, 1771, 1, 0, 0, 0, 1773, 193,
		1, 0, 0, 0, 1774, 1776, 3, 196, 98, 0, 1775, 1774, 1, 0, 0, 0, 1776, 1779,
		1, 0, 0, 0, 1777, 1775, 1, 0, 0, 0, 1777, 1778, 1, 0, 0, 0, 1778, 1780,
		1, 0, 0, 0, 1779, 1777, 1, 0, 0, 0, 1780, 1785, 3, 198, 99, 0, 1781, 1785,
		3, 200, 100, 0, 1782, 1785, 3, 202, 101, 0, 1783, 1785, 3, 256, 128, 0,
		1784, 1777, 1, 0, 0, 0, 1784, 1781, 1, 0, 0, 0, 1784, 1782, 1, 0, 0, 0,
		1784, 1783, 1, 0, 0, 0, 1785, 195, 1, 0, 0, 0, 1786, 1787, 3, 292, 146,
		0, 1787, 1788, 3, 206, 103, 0, 1788, 197, 1, 0, 0, 0, 1789, 1790, 3, 292,
		146, 0, 1790, 1791, 3, 206, 103, 0, 1791, 1792, 3, 244, 122, 0, 1792, 199,
		1, 0, 0, 0, 1793, 1794, 3, 292, 146, 0, 1794, 1795, 3, 244, 122, 0, 1795,
		201, 1, 0, 0, 0, 1796, 1797, 3, 292, 146, 0, 1797, 1798, 3, 56, 28, 0,
		1798, 203, 1, 0, 0, 0, 1799, 1801, 3, 206, 103, 0, 1800, 1799, 1, 0, 0,
		0, 1800, 1801, 1, 0, 0, 0, 1801, 1802, 1, 0, 0, 0, 1802, 1805, 3, 244,
		122, 0, 1803, 1805, 3, 56, 28, 0, 1804, 1800, 1, 0, 0, 0, 1804, 1803, 1,
		0, 0, 0, 1805, 205, 1, 0, 0, 0, 1806, 1808, 3, 208, 104, 0, 1807, 1806,
		1, 0, 0, 0, 1808, 1809, 1, 0, 0, 0, 1809, 1807, 1, 0, 0, 0, 1809, 1810,
		1, 0, 0, 0, 1810, 207, 1, 0, 0, 0, 1811, 1814, 3, 210, 105, 0, 1812, 1814,
		3, 222, 111, 0, 1813, 1811, 1, 0, 0, 0, 1813, 1812, 1, 0, 0, 0, 1814, 209,
		1, 0, 0, 0, 1815, 1821, 3, 212, 106, 0, 1816, 1821, 3, 226, 113, 0, 1817,
		1821, 3, 232, 116, 0, 1818, 1821, 3, 224, 112, 0, 1819, 1821, 3, 242, 121,
		0, 1820, 1815, 1, 0, 0, 0, 1820, 1816, 1, 0, 0, 0, 1820, 1817, 1, 0, 0,
		0, 1820, 1818, 1, 0, 0, 0, 1820, 1819, 1, 0, 0, 0, 1821, 211, 1, 0, 0,
		0, 1822, 1825, 3, 214, 107, 0, 1823, 1825, 3, 216, 108, 0, 1824, 1822,
		1, 0, 0, 0, 1824, 1823, 1, 0, 0, 0, 1825, 213, 1, 0, 0, 0, 1826, 1827,
		5, 146, 0, 0, 1827, 1828, 3, 294, 147, 0, 1828, 215, 1, 0, 0, 0, 1829,
		1830, 5, 163, 0, 0, 1830, 1831, 3, 218, 109, 0, 1831, 217, 1, 0, 0, 0,
		1832, 1842, 3, 214, 107, 0, 1833, 1834, 5, 371, 0, 0, 1834, 1835, 3, 220,
		110, 0, 1835, 1836, 5, 382, 0, 0, 1836, 1842, 1, 0, 0, 0, 1837, 1838, 5,
		373, 0, 0, 1838, 1839, 3, 220, 110, 0, 1839, 1840, 5, 384, 0, 0, 1840,
		1842, 1, 0, 0, 0, 1841, 1832, 1, 0, 0, 0, 1841, 1833, 1, 0, 0, 0, 1841,
		1837, 1, 0, 0, 0, 1842, 219, 1, 0, 0, 0, 1843, 1845, 3, 212, 106, 0, 1844,
		1843, 1, 0, 0, 0, 1845, 1846, 1, 0, 0, 0, 1846, 1844, 1, 0, 0, 0, 1846,
		1847, 1, 0, 0, 0, 1847, 221, 1, 0, 0, 0, 1848, 1849, 3, 274, 137, 0, 1849,
		223, 1, 0, 0, 0, 1850, 1853, 5, 94, 0, 0, 1851, 1854, 3, 500, 250, 0, 1852,
		1854, 3, 804, 402, 0, 1853, 1851, 1, 0, 0, 0, 1853, 1852, 1, 0, 0, 0, 1854,
		225, 1, 0, 0, 0, 1855, 1856, 5, 133, 0, 0, 1856, 1857, 3, 228, 114, 0,
		1857, 227, 1, 0, 0, 0, 1858, 1863, 3, 230, 115, 0, 1859, 1860, 5, 363,
		0, 0, 1860, 1862, 3, 230, 115, 0, 1861, 1859, 1, 0, 0, 0, 1862, 1865, 1,
		0, 0, 0, 1863, 1861, 1, 0, 0, 0, 1863, 1864, 1, 0, 0, 0, 1864, 229, 1,
		0, 0, 0, 1865, 1863, 1, 0, 0, 0, 1866, 1872, 3, 82, 41, 0, 1867, 1868,
		3, 1122, 561, 0, 1868, 1869, 5, 367, 0, 0, 1869, 1870, 3, 848, 424, 0,
		1870, 1872, 1, 0, 0, 0, 1871, 1866, 1, 0, 0, 0, 1871, 1867, 1, 0, 0, 0,
		1872, 231, 1, 0, 0, 0, 1873, 1874, 5, 103, 0, 0, 1874, 1876, 3, 234, 117,
		0, 1875, 1877, 3, 240, 120, 0, 1876, 1875, 1, 0, 0, 0, 1876, 1877, 1, 0,
		0, 0, 1877, 233, 1, 0, 0, 0, 1878, 1879, 3, 236, 118, 0, 1879, 1880, 3,
		238, 119, 0, 1880, 235, 1, 0, 0, 0, 1881, 1882, 3, 1122, 561, 0, 1882,
		1883, 5, 112, 0, 0, 1883, 237, 1, 0, 0, 0, 1884, 1885, 3, 848, 424, 0,
		1885, 239, 1, 0, 0, 0, 1886, 1887, 5, 234, 0, 0, 1887, 1888, 7, 3, 0, 0,
		1888, 1889, 3, 1122, 561, 0, 1889, 241, 1, 0, 0, 0, 1890, 1892, 3, 520,
		260, 0, 1891, 1893, 3, 534, 267, 0, 1892, 1891, 1, 0, 0, 0, 1892, 1893,
		1, 0, 0, 0, 1893, 1895, 1, 0, 0, 0, 1894, 1896, 3, 532, 266, 0, 1895, 1894,
		1, 0, 0, 0, 1895, 1896, 1, 0, 0, 0, 1896, 1903, 1, 0, 0, 0, 1897, 1899,
		3, 534, 267, 0, 1898, 1900, 3, 532, 266, 0, 1899, 1898, 1, 0, 0, 0, 1899,
		1900, 1, 0, 0, 0, 1900, 1903, 1, 0, 0, 0, 1901, 1903, 3, 532, 266, 0, 1902,
		1890, 1, 0, 0, 0, 1902, 1897, 1, 0, 0, 0, 1902, 1901, 1, 0, 0, 0, 1903,
		243, 1, 0, 0, 0, 1904, 1906, 3, 246, 123, 0, 1905, 1907, 3, 242, 121, 0,
		1906, 1905, 1, 0, 0, 0, 1906, 1907, 1, 0, 0, 0, 1907, 1910, 1, 0, 0, 0,
		1908, 1910, 5, 95, 0, 0, 1909, 1904, 1, 0, 0, 0, 1909, 1908, 1, 0, 0, 0,
		1910, 245, 1, 0, 0, 0, 1911, 1912, 5, 183, 0, 0, 1912, 1913, 3, 248, 124,
		0, 1913, 247, 1, 0, 0, 0, 1914, 1916, 3, 932, 466, 0, 1915, 1914, 1, 0,
		0, 0, 1915, 1916, 1, 0, 0, 0, 1916, 1919, 1, 0, 0, 0, 1917, 1920, 5, 361,
		0, 0, 1918, 1920, 3, 250, 125, 0, 1919, 1917, 1, 0, 0, 0, 1919, 1918, 1,
		0, 0, 0, 1920, 1922, 1, 0, 0, 0, 1921, 1923, 3, 512, 256, 0, 1922, 1921,
		1, 0, 0, 0, 1922, 1923, 1, 0, 0, 0, 1923, 249, 1, 0, 0, 0, 1924, 1929,
		3, 252, 126, 0, 1925, 1926, 5, 363, 0, 0, 1926, 1928, 3, 252, 126, 0, 1927,
		1925, 1, 0, 0, 0, 1928, 1931, 1, 0, 0, 0, 1929, 1927, 1, 0, 0, 0, 1929,
		1930, 1, 0, 0, 0, 1930, 251, 1, 0, 0, 0, 1931, 1929, 1, 0, 0, 0, 1932,
		1934, 3, 870, 435, 0, 1933, 1935, 3, 254, 127, 0, 1934, 1933, 1, 0, 0,
		0, 1934, 1935, 1, 0, 0, 0, 1935, 253, 1, 0, 0, 0, 1936, 1937, 5, 30, 0,
		0, 1937, 1938, 3, 1140, 570, 0, 1938, 255, 1, 0, 0, 0, 1939, 1941, 5, 190,
		0, 0, 1940, 1942, 3, 932, 466, 0, 1941, 1940, 1, 0, 0, 0, 1941, 1942, 1,
		0, 0, 0, 1942, 1945, 1, 0, 0, 0, 1943, 1946, 5, 361, 0, 0, 1944, 1946,
		3, 258, 129, 0, 1945, 1943, 1, 0, 0, 0, 1945, 1944, 1, 0, 0, 0, 1946, 1966,
		1, 0, 0, 0, 1947, 1949, 3, 266, 133, 0, 1948, 1950, 3, 500, 250, 0, 1949,
		1948, 1, 0, 0, 0, 1949, 1950, 1, 0, 0, 0, 1950, 1952, 1, 0, 0, 0, 1951,
		1953, 3, 512, 256, 0, 1952, 1951, 1, 0, 0, 0, 1952, 1953, 1, 0, 0, 0, 1953,
		1955, 1, 0, 0, 0, 1954, 1956, 3, 264, 132, 0, 1955, 1954, 1, 0, 0, 0, 1955,
		1956, 1, 0, 0, 0, 1956, 1958, 1, 0, 0, 0, 1957, 1959, 3, 520, 260, 0, 1958,
		1957, 1, 0, 0, 0, 1958, 1959, 1, 0, 0, 0, 1959, 1961, 1, 0, 0, 0, 1960,
		1962, 3, 534, 267, 0, 1961, 1960, 1, 0, 0, 0, 1961, 1962, 1, 0, 0, 0, 1962,
		1964, 1, 0, 0, 0, 1963, 1965, 3, 532, 266, 0, 1964, 1963, 1, 0, 0, 0, 1964,
		1965, 1, 0, 0, 0, 1965, 1967, 1, 0, 0, 0, 1966, 1947, 1, 0, 0, 0, 1966,
		1967, 1, 0, 0, 0, 1967, 257, 1, 0, 0, 0, 1968, 1973, 3, 260, 130, 0, 1969,
		1970, 5, 363, 0, 0, 1970, 1972, 3, 260, 130, 0, 1971, 1969, 1, 0, 0, 0,
		1972, 1975, 1, 0, 0, 0, 1973, 1971, 1, 0, 0, 0, 1973, 1974, 1, 0, 0, 0,
		1974, 259, 1, 0, 0, 0, 1975, 1973, 1, 0, 0, 0, 1976, 1978, 3, 870, 435,
		0, 1977, 1979, 3, 262, 131, 0, 1978, 1977, 1, 0, 0, 0, 1978, 1979, 1, 0,
		0, 0, 1979, 261, 1, 0, 0, 0, 1980, 1981, 5, 30, 0, 0, 1981, 1982, 3, 1140,
		570, 0, 1982, 263, 1, 0, 0, 0, 1983, 1984, 5, 106, 0, 0, 1984, 1985, 3,
		804, 402, 0, 1985, 265, 1, 0, 0, 0, 1986, 1989, 5, 104, 0, 0, 1987, 1990,
		3, 268, 134, 0, 1988, 1990, 3, 272, 136, 0, 1989, 1987, 1, 0, 0, 0, 1989,
		1988, 1, 0, 0, 0, 1990, 267, 1, 0, 0, 0, 1991, 1996, 3, 270, 135, 0, 1992,
		1993, 5, 363, 0, 0, 1993, 1995, 3, 270, 135, 0, 1994, 1992, 1, 0, 0, 0,
		1995, 1998, 1, 0, 0, 0, 1996, 1994, 1, 0, 0, 0, 1996, 1997, 1, 0, 0, 0,
		1997, 269, 1, 0, 0, 0, 1998, 1996, 1, 0, 0, 0, 1999, 2000, 3, 88, 44, 0,
		2000, 2001, 3, 212, 106, 0, 2001, 271, 1, 0, 0, 0, 2002, 2007, 3, 56, 28,
		0, 2003, 2004, 3, 88, 44, 0, 2004, 2005, 3, 56, 28, 0, 2005, 2007, 1, 0,
		0, 0, 2006, 2002, 1, 0, 0, 0, 2006, 2003, 1, 0, 0, 0, 2007, 273, 1, 0,
		0, 0, 2008, 2010, 5, 163, 0, 0, 2009, 2008, 1, 0, 0, 0, 2009, 2010, 1,
		0, 0, 0, 2010, 2011, 1, 0, 0, 0, 2011, 2012, 5, 47, 0, 0, 2012, 2013, 3,
		276, 138, 0, 2013, 275, 1, 0, 0, 0, 2014, 2017, 3, 278, 139, 0, 2015, 2017,
		3, 284, 142, 0, 2016, 2014, 1, 0, 0, 0, 2016, 2015, 1, 0, 0, 0, 2017, 277,
		1, 0, 0, 0, 2018, 2020, 3, 280, 140, 0, 2019, 2018, 1, 0, 0, 0, 2019, 2020,
		1, 0, 0, 0, 2020, 2021, 1, 0, 0, 0, 2021, 2022, 3, 50, 25, 0, 2022, 279,
		1, 0, 0, 0, 2023, 2025, 5, 373, 0, 0, 2024, 2026, 3, 282, 141, 0, 2025,
		2024, 1, 0, 0, 0, 2025, 2026, 1, 0, 0, 0, 2026, 2027, 1, 0, 0, 0, 2027,
		2028, 5, 384, 0, 0, 2028, 281, 1, 0, 0, 0, 2029, 2034, 3, 942, 471, 0,
		2030, 2031, 5, 363, 0, 0, 2031, 2033, 3, 942, 471, 0, 2032, 2030, 1, 0,
		0, 0, 2033, 2036, 1, 0, 0, 0, 2034, 2032, 1, 0, 0, 0, 2034, 2035, 1, 0,
		0, 0, 2035, 283, 1, 0, 0, 0, 2036, 2034, 1, 0, 0, 0, 2037, 2038, 3, 566,
		283, 0, 2038, 2040, 5, 373, 0, 0, 2039, 2041, 3, 286, 143, 0, 2040, 2039,
		1, 0, 0, 0, 2040, 2041, 1, 0, 0, 0, 2041, 2042, 1, 0, 0, 0, 2042, 2044,
		5, 384, 0, 0, 2043, 2045, 3, 502, 251, 0, 2044, 2043, 1, 0, 0, 0, 2044,
		2045, 1, 0, 0, 0, 2045, 285, 1, 0, 0, 0, 2046, 2051, 3, 288, 144, 0, 2047,
		2048, 5, 363, 0, 0, 2048, 2050, 3, 288, 144, 0, 2049, 2047, 1, 0, 0, 0,
		2050, 2053, 1, 0, 0, 0, 2051, 2049, 1, 0, 0, 0, 2051, 2052, 1, 0, 0, 0,
		2052, 287, 1, 0, 0, 0, 2053, 2051, 1, 0, 0, 0, 2054, 2055, 3, 848, 424,
		0, 2055, 289, 1, 0, 0, 0, 2056, 2057, 5, 34, 0, 0, 2057, 2058, 3, 538,
		269, 0, 2058, 291, 1, 0, 0, 0, 2059, 2060, 5, 226, 0, 0, 2060, 2061, 3,
		88, 44, 0, 2061, 293, 1, 0, 0, 0, 2062, 2064, 3, 302, 151, 0, 2063, 2065,
		3, 296, 148, 0, 2064, 2063, 1, 0, 0, 0, 2064, 2065, 1, 0, 0, 0, 2065, 295,
		1, 0, 0, 0, 2066, 2067, 5, 237, 0, 0, 2067, 2068, 3, 298, 149, 0, 2068,
		297, 1, 0, 0, 0, 2069, 2074, 3, 300, 150, 0, 2070, 2071, 5, 363, 0, 0,
		2071, 2073, 3, 300, 150, 0, 2072, 2070, 1, 0, 0, 0, 2073, 2076, 1, 0, 0,
		0, 2074, 2072, 1, 0, 0, 0, 2074, 2075, 1, 0, 0, 0, 2075, 299, 1, 0, 0,
		0, 2076, 2074, 1, 0, 0, 0, 2077, 2078, 3, 942, 471, 0, 2078, 301, 1, 0,
		0, 0, 2079, 2081, 3, 304, 152, 0, 2080, 2079, 1, 0, 0, 0, 2080, 2081, 1,
		0, 0, 0, 2081, 2082, 1, 0, 0, 0, 2082, 2084, 3, 314, 157, 0, 2083, 2085,
		3, 320, 160, 0, 2084, 2083, 1, 0, 0, 0, 2084, 2085, 1, 0, 0, 0, 2085, 2087,
		1, 0, 0, 0, 2086, 2088, 3, 322, 161, 0, 2087, 2086, 1, 0, 0, 0, 2087, 2088,
		1, 0, 0, 0, 2088, 303, 1, 0, 0, 0, 2089, 2092, 3, 306, 153, 0, 2090, 2092,
		3, 308, 154, 0, 2091, 2089, 1, 0, 0, 0, 2091, 2090, 1, 0, 0, 0, 2092, 305,
		1, 0, 0, 0, 2093, 2094, 5, 312, 0, 0, 2094, 2095, 3, 310, 155, 0, 2095,
		307, 1, 0, 0, 0, 2096, 2097, 5, 285, 0, 0, 2097, 2098, 3, 312, 156, 0,
		2098, 309, 1, 0, 0, 0, 2099, 2101, 5, 289, 0, 0, 2100, 2102, 5, 282, 0,
		0, 2101, 2100, 1, 0, 0, 0, 2101, 2102, 1, 0, 0, 0, 2102, 2105, 1, 0, 0,
		0, 2103, 2105, 5, 290, 0, 0, 2104, 2099, 1, 0, 0, 0, 2104, 2103, 1, 0,
		0, 0, 2105, 311, 1, 0, 0, 0, 2106, 2108, 3, 1174, 587, 0, 2107, 2109, 5,
		282, 0, 0, 2108, 2107, 1, 0, 0, 0, 2108, 2109, 1, 0, 0, 0, 2109, 2112,
		1, 0, 0, 0, 2110, 2112, 3, 1172, 586, 0, 2111, 2106, 1, 0, 0, 0, 2111,
		2110, 1, 0, 0, 0, 2112, 313, 1, 0, 0, 0, 2113, 2118, 3, 316, 158, 0, 2114,
		2115, 5, 363, 0, 0, 2115, 2117, 3, 316, 158, 0, 2116, 2114, 1, 0, 0, 0,
		2117, 2120, 1, 0, 0, 0, 2118, 2116, 1, 0, 0, 0, 2118, 2119, 1, 0, 0, 0,
		2119, 315, 1, 0, 0, 0, 2120, 2118, 1, 0, 0, 0, 2121, 2123, 3, 318, 159,
		0, 2122, 2121, 1, 0, 0, 0, 2122, 2123, 1, 0, 0, 0, 2123, 2125, 1, 0, 0,
		0, 2124, 2126, 3, 344, 172, 0, 2125, 2124, 1, 0, 0, 0, 2125, 2126, 1, 0,
		0, 0, 2126, 2127, 1, 0, 0, 0, 2127, 2128, 3, 372, 186, 0, 2128, 317, 1,
		0, 0, 0, 2129, 2130, 3, 1118, 559, 0, 2130, 2131, 5, 367, 0, 0, 2131, 319,
		1, 0, 0, 0, 2132, 2133, 5, 294, 0, 0, 2133, 2134, 3, 344, 172, 0, 2134,
		321, 1, 0, 0, 0, 2135, 2136, 5, 233, 0, 0, 2136, 2137, 3, 804, 402, 0,
		2137, 323, 1, 0, 0, 0, 2138, 2139, 3, 326, 163, 0, 2139, 325, 1, 0, 0,
		0, 2140, 2145, 3, 328, 164, 0, 2141, 2142, 5, 363, 0, 0, 2142, 2144, 3,
		328, 164, 0, 2143, 2141, 1, 0, 0, 0, 2144, 2147, 1, 0, 0, 0, 2145, 2143,
		1, 0, 0, 0, 2145, 2146, 1, 0, 0, 0, 2146, 327, 1, 0, 0, 0, 2147, 2145,
		1, 0, 0, 0, 2148, 2154, 3, 330, 165, 0, 2149, 2150, 3, 332, 166, 0, 2150,
		2151, 3, 330, 165, 0, 2151, 2153, 1, 0, 0, 0, 2152, 2149, 1, 0, 0, 0, 2153,
		2156, 1, 0, 0, 0, 2154, 2152, 1, 0, 0, 0, 2154, 2155, 1, 0, 0, 0, 2155,
		329, 1, 0, 0, 0, 2156, 2154, 1, 0, 0, 0, 2157, 2159, 5, 373, 0, 0, 2158,
		2160, 3, 340, 170, 0, 2159, 2158, 1, 0, 0, 0, 2159, 2160, 1, 0, 0, 0, 2160,
		2161, 1, 0, 0, 0, 2161, 2162, 5, 384, 0, 0, 2162, 331, 1, 0, 0, 0, 2163,
		2167, 3, 334, 167, 0, 2164, 2167, 3, 336, 168, 0, 2165, 2167, 3, 338, 169,
		0, 2166, 2163, 1, 0, 0, 0, 2166, 2164, 1, 0, 0, 0, 2166, 2165, 1, 0, 0,
		0, 2167, 333, 1, 0, 0, 0, 2168, 2170, 5, 340, 0, 0, 2169, 2171, 3, 340,
		170, 0, 2170, 2169, 1, 0, 0, 0, 2170, 2171, 1, 0, 0, 0, 2171, 2172, 1,
		0, 0, 0, 2172, 2173, 5, 350, 0, 0, 2173, 335, 1, 0, 0, 0, 2174, 2176, 5,
		346, 0, 0, 2175, 2177, 3, 340, 170, 0, 2176, 2175, 1, 0, 0, 0, 2176, 2177,
		1, 0, 0, 0, 2177, 2178, 1, 0, 0, 0, 2178, 2179, 5, 331, 0, 0, 2179, 337,
		1, 0, 0, 0, 2180, 2182, 5, 357, 0, 0, 2181, 2183, 3, 340, 170, 0, 2182,
		2181, 1, 0, 0, 0, 2182, 2183, 1, 0, 0, 0, 2183, 2184, 1, 0, 0, 0, 2184,
		2185, 5, 351, 0, 0, 2185, 339, 1, 0, 0, 0, 2186, 2188, 3, 386, 193, 0,
		2187, 2189, 3, 342, 171, 0, 2188, 2187, 1, 0, 0, 0, 2188, 2189, 1, 0, 0,
		0, 2189, 2195, 1, 0, 0, 0, 2190, 2192, 3, 386, 193, 0, 2191, 2190, 1, 0,
		0, 0, 2191, 2192, 1, 0, 0, 0, 2192, 2193, 1, 0, 0, 0, 2193, 2195, 3, 342,
		171, 0, 2194, 2186, 1, 0, 0, 0, 2194, 2191, 1, 0, 0, 0, 2195, 341, 1, 0,
		0, 0, 2196, 2197, 3, 390, 195, 0, 2197, 2199, 3, 688, 344, 0, 2198, 2200,
		3, 396, 198, 0, 2199, 2198, 1, 0, 0, 0, 2199, 2200, 1, 0, 0, 0, 2200, 2208,
		1, 0, 0, 0, 2201, 2202, 3, 390, 195, 0, 2202, 2203, 3, 688, 344, 0, 2203,
		2205, 1, 0, 0, 0, 2204, 2201, 1, 0, 0, 0, 2204, 2205, 1, 0, 0, 0, 2205,
		2206, 1, 0, 0, 0, 2206, 2208, 3, 396, 198, 0, 2207, 2196, 1, 0, 0, 0, 2207,
		2204, 1, 0, 0, 0, 2208, 343, 1, 0, 0, 0, 2209, 2212, 3, 346, 173, 0, 2210,
		2212, 3, 350, 175, 0, 2211, 2209, 1, 0, 0, 0, 2211, 2210, 1, 0, 0, 0, 2212,
		345, 1, 0, 0, 0, 2213, 2215, 3, 348, 174, 0, 2214, 2216, 3, 354, 177, 0,
		2215, 2214, 1, 0, 0, 0, 2215, 2216, 1, 0, 0, 0, 2216, 347, 1, 0, 0, 0,
		2217, 2218, 7, 4, 0, 0, 2218, 349, 1, 0, 0, 0, 2219, 2223, 3, 352, 176,
		0, 2220, 2223, 3, 356, 178, 0, 2221, 2223, 3, 360, 180, 0, 2222, 2219,
		1, 0, 0, 0, 2222, 2220, 1, 0, 0, 0, 2222, 2221, 1, 0, 0, 0, 2223, 351,
		1, 0, 0, 0, 2224, 2226, 5, 25, 0, 0, 2225, 2227, 3, 348, 174, 0, 2226,
		2225, 1, 0, 0, 0, 2226, 2227, 1, 0, 0, 0, 2227, 2229, 1, 0, 0, 0, 2228,
		2230, 3, 354, 177, 0, 2229, 2228, 1, 0, 0, 0, 2229, 2230, 1, 0, 0, 0, 2230,
		353, 1, 0, 0, 0, 2231, 2232, 7, 5, 0, 0, 2232, 355, 1, 0, 0, 0, 2233, 2235,
		5, 28, 0, 0, 2234, 2236, 3, 358, 179, 0, 2235, 2234, 1, 0, 0, 0, 2235,
		2236, 1, 0, 0, 0, 2236, 2238, 1, 0, 0, 0, 2237, 2239, 3, 348, 174, 0, 2238,
		2237, 1, 0, 0, 0, 2238, 2239, 1, 0, 0, 0, 2239, 2241, 1, 0, 0, 0, 2240,
		2242, 3, 354, 177, 0, 2241, 2240, 1, 0, 0, 0, 2241, 2242, 1, 0, 0, 0, 2242,
		357, 1, 0, 0, 0, 2243, 2244, 3, 882, 441, 0, 2244, 359, 1, 0, 0, 0, 2245,
		2250, 3, 362, 181, 0, 2246, 2250, 3, 364, 182, 0, 2247, 2250, 3, 366, 183,
		0, 2248, 2250, 3, 368, 184, 0, 2249, 2245, 1, 0, 0, 0, 2249, 2246, 1, 0,
		0, 0, 2249, 2247, 1, 0, 0, 0, 2249, 2248, 1, 0, 0, 0, 2250, 361, 1, 0,
		0, 0, 2251, 2252, 5, 25, 0, 0, 2252, 2254, 5, 313, 0, 0, 2253, 2255, 3,
		348, 174, 0, 2254, 2253, 1, 0, 0, 0, 2254, 2255, 1, 0, 0, 0, 2255, 2257,
		1, 0, 0, 0, 2256, 2258, 3, 354, 177, 0, 2257, 2256, 1, 0, 0, 0, 2257, 2258,
		1, 0, 0, 0, 2258, 363, 1, 0, 0, 0, 2259, 2260, 5, 28, 0, 0, 2260, 2262,
		5, 313, 0, 0, 2261, 2263, 3, 348, 174, 0, 2262, 2261, 1, 0, 0, 0, 2262,
		2263, 1, 0, 0, 0, 2263, 2265, 1, 0, 0, 0, 2264, 2266, 3, 354, 177, 0, 2265,
		2264, 1, 0, 0, 0, 2265, 2266, 1, 0, 0, 0, 2266, 365, 1, 0, 0, 0, 2267,
		2268, 5, 313, 0, 0, 2268, 2270, 3, 358, 179, 0, 2269, 2271, 3, 348, 174,
		0, 2270, 2269, 1, 0, 0, 0, 2270, 2271, 1, 0, 0, 0, 2271, 2273, 1, 0, 0,
		0, 2272, 2274, 3, 354, 177, 0, 2273, 2272, 1, 0, 0, 0, 2273, 2274, 1, 0,
		0, 0, 2274, 367, 1, 0, 0, 0, 2275, 2277, 5, 313, 0, 0, 2276, 2278, 3, 370,
		185, 0, 2277, 2276, 1, 0, 0, 0, 2277, 2278, 1, 0, 0, 0, 2278, 2280, 1,
		0, 0, 0, 2279, 2281, 3, 348, 174, 0, 2280, 2279, 1, 0, 0, 0, 2280, 2281,
		1, 0, 0, 0, 2281, 2283, 1, 0, 0, 0, 2282, 2284, 3, 354, 177, 0, 2283, 2282,
		1, 0, 0, 0, 2283, 2284, 1, 0, 0, 0, 2284, 2285, 1, 0, 0, 0, 2285, 2286,
		7, 6, 0, 0, 2286, 369, 1, 0, 0, 0, 2287, 2288, 3, 882, 441, 0, 2288, 371,
		1, 0, 0, 0, 2289, 2305, 3, 374, 187, 0, 2290, 2293, 3, 374, 187, 0, 2291,
		2292, 5, 330, 0, 0, 2292, 2294, 3, 374, 187, 0, 2293, 2291, 1, 0, 0, 0,
		2294, 2295, 1, 0, 0, 0, 2295, 2293, 1, 0, 0, 0, 2295, 2296, 1, 0, 0, 0,
		2296, 2305, 1, 0, 0, 0, 2297, 2300, 3, 374, 187, 0, 2298, 2299, 5, 388,
		0, 0, 2299, 2301, 3, 374, 187, 0, 2300, 2298, 1, 0, 0, 0, 2301, 2302, 1,
		0, 0, 0, 2302, 2300, 1, 0, 0, 0, 2302, 2303, 1, 0, 0, 0, 2303, 2305, 1,
		0, 0, 0, 2304, 2289, 1, 0, 0, 0, 2304, 2290, 1, 0, 0, 0, 2304, 2297, 1,
		0, 0, 0, 2305, 373, 1, 0, 0, 0, 2306, 2308, 3, 376, 188, 0, 2307, 2306,
		1, 0, 0, 0, 2308, 2309, 1, 0, 0, 0, 2309, 2307, 1, 0, 0, 0, 2309, 2310,
		1, 0, 0, 0, 2310, 375, 1, 0, 0, 0, 2311, 2319, 3, 378, 189, 0, 2312, 2313,
		3, 378, 189, 0, 2313, 2314, 3, 434, 217, 0, 2314, 2319, 1, 0, 0, 0, 2315,
		2316, 3, 378, 189, 0, 2316, 2317, 5, 379, 0, 0, 2317, 2319, 1, 0, 0, 0,
		2318, 2311, 1, 0, 0, 0, 2318, 2312, 1, 0, 0, 0, 2318, 2315, 1, 0, 0, 0,
		2319, 377, 1, 0, 0, 0, 2320, 2324, 3, 380, 190, 0, 2321, 2324, 3, 422,
		211, 0, 2322, 2324, 3, 444, 222, 0, 2323, 2320, 1, 0, 0, 0, 2323, 2321,
		1, 0, 0, 0, 2323, 2322, 1, 0, 0, 0, 2324, 379, 1, 0, 0, 0, 2325, 2328,
		3, 382, 191, 0, 2326, 2328, 3, 402, 201, 0, 2327, 2325, 1, 0, 0, 0, 2327,
		2326, 1, 0, 0, 0, 2328, 381, 1, 0, 0, 0, 2329, 2330, 5, 373, 0, 0, 2330,
		2331, 3, 384, 192, 0, 2331, 2332, 5, 384, 0, 0, 2332, 383, 1, 0, 0, 0,
		2333, 2335, 3, 386, 193, 0, 2334, 2333, 1, 0, 0, 0, 2334, 2335, 1, 0, 0,
		0, 2335, 2337, 1, 0, 0, 0, 2336, 2338, 3, 388, 194, 0, 2337, 2336, 1, 0,
		0, 0, 2337, 2338, 1, 0, 0, 0, 2338, 2340, 1, 0, 0, 0, 2339, 2341, 3, 392,
		196, 0, 2340, 2339, 1, 0, 0, 0, 2340, 2341, 1, 0, 0, 0, 2341, 385, 1, 0,
		0, 0, 2342, 2343, 3, 1116, 558, 0, 2343, 387, 1, 0, 0, 0, 2344, 2345, 3,
		390, 195, 0, 2345, 2346, 3, 428, 214, 0, 2346, 389, 1, 0, 0, 0, 2347, 2348,
		7, 7, 0, 0, 2348, 391, 1, 0, 0, 0, 2349, 2352, 3, 394, 197, 0, 2350, 2352,
		3, 396, 198, 0, 2351, 2349, 1, 0, 0, 0, 2351, 2350, 1, 0, 0, 0, 2352, 393,
		1, 0, 0, 0, 2353, 2354, 5, 233, 0, 0, 2354, 2355, 3, 804, 402, 0, 2355,
		395, 1, 0, 0, 0, 2356, 2357, 5, 371, 0, 0, 2357, 2358, 3, 398, 199, 0,
		2358, 2359, 5, 382, 0, 0, 2359, 397, 1, 0, 0, 0, 2360, 2365, 3, 400, 200,
		0, 2361, 2362, 5, 363, 0, 0, 2362, 2364, 3, 400, 200, 0, 2363, 2361, 1,
		0, 0, 0, 2364, 2367, 1, 0, 0, 0, 2365, 2363, 1, 0, 0, 0, 2365, 2366, 1,
		0, 0, 0, 2366, 399, 1, 0, 0, 0, 2367, 2365, 1, 0, 0, 0, 2368, 2369, 3,
		1112, 556, 0, 2369, 2370, 5, 362, 0, 0, 2370, 2371, 3, 848, 424, 0, 2371,
		401, 1, 0, 0, 0, 2372, 2375, 3, 404, 202, 0, 2373, 2375, 3, 420, 210, 0,
		2374, 2372, 1, 0, 0, 0, 2374, 2373, 1, 0, 0, 0, 2375, 403, 1, 0, 0, 0,
		2376, 2384, 3, 406, 203, 0, 2377, 2384, 3, 408, 204, 0, 2378, 2384, 3,
		410, 205, 0, 2379, 2384, 3, 412, 206, 0, 2380, 2384, 3, 414, 207, 0, 2381,
		2384, 3, 416, 208, 0, 2382, 2384, 3, 418, 209, 0, 2383, 2376, 1, 0, 0,
		0, 2383, 2377, 1, 0, 0, 0, 2383, 2378, 1, 0, 0, 0, 2383, 2379, 1, 0, 0,
		0, 2383, 2380, 1, 0, 0, 0, 2383, 2381, 1, 0, 0, 0, 2383, 2382, 1, 0, 0,
		0, 2384, 405, 1, 0, 0, 0, 2385, 2386, 5, 340, 0, 0, 2386, 2387, 3, 384,
		192, 0, 2387, 2388, 5, 350, 0, 0, 2388, 407, 1, 0, 0, 0, 2389, 2390, 5,
		357, 0, 0, 2390, 2391, 3, 384, 192, 0, 2391, 2392, 5, 351, 0, 0, 2392,
		409, 1, 0, 0, 0, 2393, 2394, 5, 346, 0, 0, 2394, 2395, 3, 384, 192, 0,
		2395, 2396, 5, 331, 0, 0, 2396, 411, 1, 0, 0, 0, 2397, 2398, 5, 341, 0,
		0, 2398, 2399, 3, 384, 192, 0, 2399, 2400, 5, 351, 0, 0, 2400, 413, 1,
		0, 0, 0, 2401, 2402, 5, 357, 0, 0, 2402, 2403, 3, 384, 192, 0, 2403, 2404,
		5, 332, 0, 0, 2404, 415, 1, 0, 0, 0, 2405, 2406, 5, 340, 0, 0, 2406, 2407,
		3, 384, 192, 0, 2407, 2408, 5, 331, 0, 0, 2408, 417, 1, 0, 0, 0, 2409,
		2410, 5, 346, 0, 0, 2410, 2411, 3, 384, 192, 0, 2411, 2412, 5, 350, 0,
		0, 2412, 419, 1, 0, 0, 0, 2413, 2414, 7, 8, 0, 0, 2414, 421, 1, 0, 0, 0,
		2415, 2417, 5, 373, 0, 0, 2416, 2418, 3, 424, 212, 0, 2417, 2416, 1, 0,
		0, 0, 2417, 2418, 1, 0, 0, 0, 2418, 2420, 1, 0, 0, 0, 2419, 2421, 3, 346,
		173, 0, 2420, 2419, 1, 0, 0, 0, 2420, 2421, 1, 0, 0, 0, 2421, 2422, 1,
		0, 0, 0, 2422, 2424, 3, 372, 186, 0, 2423, 2425, 3, 426, 213, 0, 2424,
		2423, 1, 0, 0, 0, 2424, 2425, 1, 0, 0, 0, 2425, 2426, 1, 0, 0, 0, 2426,
		2427, 5, 384, 0, 0, 2427, 423, 1, 0, 0, 0, 2428, 2429, 3, 1120, 560, 0,
		2429, 2430, 5, 367, 0, 0, 2430, 425, 1, 0, 0, 0, 2431, 2432, 5, 233, 0,
		0, 2432, 2433, 3, 804, 402, 0, 2433, 427, 1, 0, 0, 0, 2434, 2435, 6, 214,
		-1, 0, 2435, 2436, 5, 368, 0, 0, 2436, 2444, 3, 428, 214, 6, 2437, 2444,
		3, 1110, 555, 0, 2438, 2444, 5, 376, 0, 0, 2439, 2440, 5, 373, 0, 0, 2440,
		2441, 3, 428, 214, 0, 2441, 2442, 5, 384, 0, 0, 2442, 2444, 1, 0, 0, 0,
		2443, 2434, 1, 0, 0, 0, 2443, 2437, 1, 0, 0, 0, 2443, 2438, 1, 0, 0, 0,
		2443, 2439, 1, 0, 0, 0, 2444, 2453, 1, 0, 0, 0, 2445, 2446, 10, 5, 0, 0,
		2446, 2447, 5, 360, 0, 0, 2447, 2452, 3, 428, 214, 6, 2448, 2449, 10, 4,
		0, 0, 2449, 2450, 5, 388, 0, 0, 2450, 2452, 3, 428, 214, 5, 2451, 2445,
		1, 0, 0, 0, 2451, 2448, 1, 0, 0, 0, 2452, 2455, 1, 0, 0, 0, 2453, 2451,
		1, 0, 0, 0, 2453, 2454, 1, 0, 0, 0, 2454, 429, 1, 0, 0, 0, 2455, 2453,
		1, 0, 0, 0, 2456, 2457, 3, 942, 471, 0, 2457, 431, 1, 0, 0, 0, 2458, 2459,
		3, 942, 471, 0, 2459, 433, 1, 0, 0, 0, 2460, 2465, 5, 361, 0, 0, 2461,
		2465, 5, 378, 0, 0, 2462, 2465, 3, 436, 218, 0, 2463, 2465, 3, 438, 219,
		0, 2464, 2460, 1, 0, 0, 0, 2464, 2461, 1, 0, 0, 0, 2464, 2462, 1, 0, 0,
		0, 2464, 2463, 1, 0, 0, 0, 2465, 435, 1, 0, 0, 0, 2466, 2467, 5, 371, 0,
		0, 2467, 2468, 3, 1154, 577, 0, 2468, 2469, 5, 382, 0, 0, 2469, 437, 1,
		0, 0, 0, 2470, 2472, 5, 371, 0, 0, 2471, 2473, 3, 440, 220, 0, 2472, 2471,
		1, 0, 0, 0, 2472, 2473, 1, 0, 0, 0, 2473, 2474, 1, 0, 0, 0, 2474, 2476,
		5, 363, 0, 0, 2475, 2477, 3, 442, 221, 0, 2476, 2475, 1, 0, 0, 0, 2476,
		2477, 1, 0, 0, 0, 2477, 2478, 1, 0, 0, 0, 2478, 2479, 5, 382, 0, 0, 2479,
		439, 1, 0, 0, 0, 2480, 2481, 3, 1154, 577, 0, 2481, 441, 1, 0, 0, 0, 2482,
		2483, 3, 1154, 577, 0, 2483, 443, 1, 0, 0, 0, 2484, 2492, 3, 446, 223,
		0, 2485, 2492, 3, 448, 224, 0, 2486, 2492, 3, 450, 225, 0, 2487, 2492,
		3, 452, 226, 0, 2488, 2492, 3, 454, 227, 0, 2489, 2492, 3, 456, 228, 0,
		2490, 2492, 3, 458, 229, 0, 2491, 2484, 1, 0, 0, 0, 2491, 2485, 1, 0, 0,
		0, 2491, 2486, 1, 0, 0, 0, 2491, 2487, 1, 0, 0, 0, 2491, 2488, 1, 0, 0,
		0, 2491, 2489, 1, 0, 0, 0, 2491, 2490, 1, 0, 0, 0, 2492, 445, 1, 0, 0,
		0, 2493, 2494, 5, 343, 0, 0, 2494, 2495, 3, 460, 230, 0, 2495, 2496, 5,
		353, 0, 0, 2496, 447, 1, 0, 0, 0, 2497, 2498, 5, 359, 0, 0, 2498, 2499,
		3, 460, 230, 0, 2499, 2500, 5, 355, 0, 0, 2500, 449, 1, 0, 0, 0, 2501,
		2502, 5, 347, 0, 0, 2502, 2503, 3, 460, 230, 0, 2503, 2504, 5, 354, 0,
		0, 2504, 451, 1, 0, 0, 0, 2505, 2506, 5, 344, 0, 0, 2506, 2507, 3, 460,
		230, 0, 2507, 2508, 5, 355, 0, 0, 2508, 453, 1, 0, 0, 0, 2509, 2510, 5,
		359, 0, 0, 2510, 2511, 3, 460, 230, 0, 2511, 2512, 5, 356, 0, 0, 2512,
		455, 1, 0, 0, 0, 2513, 2514, 5, 343, 0, 0, 2514, 2515, 3, 460, 230, 0,
		2515, 2516, 5, 354, 0, 0, 2516, 457, 1, 0, 0, 0, 2517, 2518, 5, 347, 0,
		0, 2518, 2519, 3, 460, 230, 0, 2519, 2520, 5, 353, 0, 0, 2520, 459, 1,
		0, 0, 0, 2521, 2525, 3, 466, 233, 0, 2522, 2525, 3, 462, 231, 0, 2523,
		2525, 3, 464, 232, 0, 2524, 2521, 1, 0, 0, 0, 2524, 2522, 1, 0, 0, 0, 2524,
		2523, 1, 0, 0, 0, 2525, 461, 1, 0, 0, 0, 2526, 2527, 3, 466, 233, 0, 2527,
		2528, 5, 388, 0, 0, 2528, 2533, 3, 466, 233, 0, 2529, 2530, 5, 388, 0,
		0, 2530, 2532, 3, 466, 233, 0, 2531, 2529, 1, 0, 0, 0, 2532, 2535, 1, 0,
		0, 0, 2533, 2531, 1, 0, 0, 0, 2533, 2534, 1, 0, 0, 0, 2534, 463, 1, 0,
		0, 0, 2535, 2533, 1, 0, 0, 0, 2536, 2537, 3, 466, 233, 0, 2537, 2538, 5,
		330, 0, 0, 2538, 2543, 3, 466, 233, 0, 2539, 2540, 5, 330, 0, 0, 2540,
		2542, 3, 466, 233, 0, 2541, 2539, 1, 0, 0, 0, 2542, 2545, 1, 0, 0, 0, 2543,
		2541, 1, 0, 0, 0, 2543, 2544, 1, 0, 0, 0, 2544, 465, 1, 0, 0, 0, 2545,
		2543, 1, 0, 0, 0, 2546, 2547, 6, 233, -1, 0, 2547, 2548, 3, 468, 234, 0,
		2548, 2553, 1, 0, 0, 0, 2549, 2550, 10, 1, 0, 0, 2550, 2552, 3, 468, 234,
		0, 2551, 2549, 1, 0, 0, 0, 2552, 2555, 1, 0, 0, 0, 2553, 2551, 1, 0, 0,
		0, 2553, 2554, 1, 0, 0, 0, 2554, 467, 1, 0, 0, 0, 2555, 2553, 1, 0, 0,
		0, 2556, 2557, 6, 234, -1, 0, 2557, 2558, 3, 470, 235, 0, 2558, 2564, 1,
		0, 0, 0, 2559, 2560, 10, 1, 0, 0, 2560, 2561, 5, 360, 0, 0, 2561, 2563,
		3, 470, 235, 0, 2562, 2559, 1, 0, 0, 0, 2563, 2566, 1, 0, 0, 0, 2564, 2562,
		1, 0, 0, 0, 2564, 2565, 1, 0, 0, 0, 2565, 469, 1, 0, 0, 0, 2566, 2564,
		1, 0, 0, 0, 2567, 2571, 3, 476, 238, 0, 2568, 2571, 3, 472, 236, 0, 2569,
		2571, 3, 474, 237, 0, 2570, 2567, 1, 0, 0, 0, 2570, 2568, 1, 0, 0, 0, 2570,
		2569, 1, 0, 0, 0, 2571, 471, 1, 0, 0, 0, 2572, 2573, 3, 476, 238, 0, 2573,
		2574, 3, 434, 217, 0, 2574, 473, 1, 0, 0, 0, 2575, 2576, 3, 476, 238, 0,
		2576, 2577, 5, 379, 0, 0, 2577, 475, 1, 0, 0, 0, 2578, 2581, 3, 478, 239,
		0, 2579, 2581, 3, 494, 247, 0, 2580, 2578, 1, 0, 0, 0, 2580, 2579, 1, 0,
		0, 0, 2581, 477, 1, 0, 0, 0, 2582, 2590, 3, 480, 240, 0, 2583, 2590, 3,
		482, 241, 0, 2584, 2590, 3, 484, 242, 0, 2585, 2590, 3, 486, 243, 0, 2586,
		2590, 3, 488, 244, 0, 2587, 2590, 3, 490, 245, 0, 2588, 2590, 3, 492, 246,
		0, 2589, 2582, 1, 0, 0, 0, 2589, 2583, 1, 0, 0, 0, 2589, 2584, 1, 0, 0,
		0, 2589, 2585, 1, 0, 0, 0, 2589, 2586, 1, 0, 0, 0, 2589, 2587, 1, 0, 0,
		0, 2589, 2588, 1, 0, 0, 0, 2590, 479, 1, 0, 0, 0, 2591, 2592, 5, 374, 0,
		0, 2592, 2593, 3, 494, 247, 0, 2593, 481, 1, 0, 0, 0, 2594, 2595, 5, 386,
		0, 0, 2595, 2596, 3, 494, 247, 0, 2596, 483, 1, 0, 0, 0, 2597, 2598, 3,
		494, 247, 0, 2598, 2599, 5, 369, 0, 0, 2599, 485, 1, 0, 0, 0, 2600, 2601,
		5, 339, 0, 0, 2601, 2602, 3, 494, 247, 0, 2602, 487, 1, 0, 0, 0, 2603,
		2604, 5, 386, 0, 0, 2604, 2605, 3, 494, 247, 0, 2605, 2606, 5, 369, 0,
		0, 2606, 489, 1, 0, 0, 0, 2607, 2608, 5, 374, 0, 0, 2608, 2609, 3, 494,
		247, 0, 2609, 2610, 5, 369, 0, 0, 2610, 491, 1, 0, 0, 0, 2611, 2612, 5,
		375, 0, 0, 2612, 2613, 3, 494, 247, 0, 2613, 493, 1, 0, 0, 0, 2614, 2617,
		3, 498, 249, 0, 2615, 2617, 3, 496, 248, 0, 2616, 2614, 1, 0, 0, 0, 2616,
		2615, 1, 0, 0, 0, 2617, 495, 1, 0, 0, 0, 2618, 2619, 5, 368, 0, 0, 2619,
		2620, 3, 498, 249, 0, 2620, 497, 1, 0, 0, 0, 2621, 2627, 3, 1110, 555,
		0, 2622, 2623, 5, 373, 0, 0, 2623, 2624, 3, 460, 230, 0, 2624, 2625, 5,
		384, 0, 0, 2625, 2627, 1, 0, 0, 0, 2626, 2621, 1, 0, 0, 0, 2626, 2622,
		1, 0, 0, 0, 2627, 499, 1, 0, 0, 0, 2628, 2629, 5, 233, 0, 0, 2629, 2630,
		3, 804, 402, 0, 2630, 501, 1, 0, 0, 0, 2631, 2632, 5, 237, 0, 0, 2632,
		2633, 3, 504, 252, 0, 2633, 503, 1, 0, 0, 0, 2634, 2639, 3, 506, 253, 0,
		2635, 2636, 5, 363, 0, 0, 2636, 2638, 3, 506, 253, 0, 2637, 2635, 1, 0,
		0, 0, 2638, 2641, 1, 0, 0, 0, 2639, 2637, 1, 0, 0, 0, 2639, 2640, 1, 0,
		0, 0, 2640, 505, 1, 0, 0, 0, 2641, 2639, 1, 0, 0, 0, 2642, 2644, 3, 508,
		254, 0, 2643, 2645, 3, 510, 255, 0, 2644, 2643, 1, 0, 0, 0, 2644, 2645,
		1, 0, 0, 0, 2645, 507, 1, 0, 0, 0, 2646, 2647, 3, 1114, 557, 0, 2647, 509,
		1, 0, 0, 0, 2648, 2649, 5, 30, 0, 0, 2649, 2650, 3, 1122, 561, 0, 2650,
		511, 1, 0, 0, 0, 2651, 2652, 5, 105, 0, 0, 2652, 2653, 5, 44, 0, 0, 2653,
		2654, 3, 514, 257, 0, 2654, 513, 1, 0, 0, 0, 2655, 2660, 3, 516, 258, 0,
		2656, 2657, 5, 363, 0, 0, 2657, 2659, 3, 516, 258, 0, 2658, 2656, 1, 0,
		0, 0, 2659, 2662, 1, 0, 0, 0, 2660, 2658, 1, 0, 0, 0, 2660, 2661, 1, 0,
		0, 0, 2661, 2665, 1, 0, 0, 0, 2662, 2660, 1, 0, 0, 0, 2663, 2665, 3, 518,
		259, 0, 2664, 2655, 1, 0, 0, 0, 2664, 2663, 1, 0, 0, 0, 2665, 515, 1, 0,
		0, 0, 2666, 2667, 3, 942, 471, 0, 2667, 517, 1, 0, 0, 0, 2668, 2669, 5,
		373, 0, 0, 2669, 2670, 5, 384, 0, 0, 2670, 519, 1, 0, 0, 0, 2671, 2672,
		5, 165, 0, 0, 2672, 2673, 5, 44, 0, 0, 2673, 2674, 3, 522, 261, 0, 2674,
		521, 1, 0, 0, 0, 2675, 2680, 3, 524, 262, 0, 2676, 2677, 5, 363, 0, 0,
		2677, 2679, 3, 524, 262, 0, 2678, 2676, 1, 0, 0, 0, 2679, 2682, 1, 0, 0,
		0, 2680, 2678, 1, 0, 0, 0, 2680, 2681, 1, 0, 0, 0, 2681, 523, 1, 0, 0,
		0, 2682, 2680, 1, 0, 0, 0, 2683, 2685, 3, 526, 263, 0, 2684, 2686, 3, 528,
		264, 0, 2685, 2684, 1, 0, 0, 0, 2685, 2686, 1, 0, 0, 0, 2686, 2688, 1,
		0, 0, 0, 2687, 2689, 3, 530, 265, 0, 2688, 2687, 1, 0, 0, 0, 2688, 2689,
		1, 0, 0, 0, 2689, 525, 1, 0, 0, 0, 2690, 2691, 3, 870, 435, 0, 2691, 527,
		1, 0, 0, 0, 2692, 2693, 7, 9, 0, 0, 2693, 529, 1, 0, 0, 0, 2694, 2695,
		5, 158, 0, 0, 2695, 2699, 5, 291, 0, 0, 2696, 2697, 5, 158, 0, 0, 2697,
		2699, 5, 298, 0, 0, 2698, 2694, 1, 0, 0, 0, 2698, 2696, 1, 0, 0, 0, 2699,
		531, 1, 0, 0, 0, 2700, 2701, 5, 135, 0, 0, 2701, 2702, 3, 882, 441, 0,
		2702, 533, 1, 0, 0, 0, 2703, 2704, 3, 536, 268, 0, 2704, 2705, 3, 882,
		441, 0, 2705, 535, 1, 0, 0, 0, 2706, 2707, 7, 10, 0, 0, 2707, 537, 1, 0,
		0, 0, 2708, 2712, 3, 540, 270, 0, 2709, 2712, 3, 544, 272, 0, 2710, 2712,
		3, 572, 286, 0, 2711, 2708, 1, 0, 0, 0, 2711, 2709, 1, 0, 0, 0, 2711, 2710,
		1, 0, 0, 0, 2712, 539, 1, 0, 0, 0, 2713, 2718, 5, 385, 0, 0, 2714, 2715,
		3, 548, 274, 0, 2715, 2716, 3, 1092, 546, 0, 2716, 2718, 1, 0, 0, 0, 2717,
		2713, 1, 0, 0, 0, 2717, 2714, 1, 0, 0, 0, 2718, 541, 1, 0, 0, 0, 2719,
		2720, 3, 548, 274, 0, 2720, 2721, 3, 1092, 546, 0, 2721, 543, 1, 0, 0,
		0, 2722, 2727, 3, 546, 273, 0, 2723, 2724, 3, 550, 275, 0, 2724, 2725,
		3, 1092, 546, 0, 2725, 2727, 1, 0, 0, 0, 2726, 2722, 1, 0, 0, 0, 2726,
		2723, 1, 0, 0, 0, 2727, 545, 1, 0, 0, 0, 2728, 2729, 7, 11, 0, 0, 2729,
		547, 1, 0, 0, 0, 2730, 2732, 5, 385, 0, 0, 2731, 2733, 3, 552, 276, 0,
		2732, 2731, 1, 0, 0, 0, 2732, 2733, 1, 0, 0, 0, 2733, 549, 1, 0, 0, 0,
		2734, 2739, 5, 336, 0, 0, 2735, 2736, 5, 385, 0, 0, 2736, 2738, 5, 336,
		0, 0, 2737, 2735, 1, 0, 0, 0, 2738, 2741, 1, 0, 0, 0, 2739, 2737, 1, 0,
		0, 0, 2739, 2740, 1, 0, 0, 0, 2740, 2742, 1, 0, 0, 0, 2741, 2739, 1, 0,
		0, 0, 2742, 2744, 5, 385, 0, 0, 2743, 2745, 3, 552, 276, 0, 2744, 2743,
		1, 0, 0, 0, 2744, 2745, 1, 0, 0, 0, 2745, 551, 1, 0, 0, 0, 2746, 2747,
		3, 1090, 545, 0, 2747, 2748, 5, 385, 0, 0, 2748, 2750, 1, 0, 0, 0, 2749,
		2746, 1, 0, 0, 0, 2750, 2751, 1, 0, 0, 0, 2751, 2749, 1, 0, 0, 0, 2751,
		2752, 1, 0, 0, 0, 2752, 553, 1, 0, 0, 0, 2753, 2754, 3, 570, 285, 0, 2754,
		2755, 3, 1094, 547, 0, 2755, 2760, 1, 0, 0, 0, 2756, 2760, 3, 1096, 548,
		0, 2757, 2760, 3, 558, 279, 0, 2758, 2760, 3, 572, 286, 0, 2759, 2753,
		1, 0, 0, 0, 2759, 2756, 1, 0, 0, 0, 2759, 2757, 1, 0, 0, 0, 2759, 2758,
		1, 0, 0, 0, 2760, 555, 1, 0, 0, 0, 2761, 2763, 3, 570, 285, 0, 2762, 2761,
		1, 0, 0, 0, 2762, 2763, 1, 0, 0, 0, 2763, 2764, 1, 0, 0, 0, 2764, 2765,
		3, 1094, 547, 0, 2765, 557, 1, 0, 0, 0, 2766, 2767, 7, 12, 0, 0, 2767,
		559, 1, 0, 0, 0, 2768, 2771, 3, 562, 281, 0, 2769, 2771, 3, 572, 286, 0,
		2770, 2768, 1, 0, 0, 0, 2770, 2769, 1, 0, 0, 0, 2771, 561, 1, 0, 0, 0,
		2772, 2774, 3, 570, 285, 0, 2773, 2772, 1, 0, 0, 0, 2773, 2774, 1, 0, 0,
		0, 2774, 2775, 1, 0, 0, 0, 2775, 2776, 3, 1098, 549, 0, 2776, 563, 1, 0,
		0, 0, 2777, 2778, 3, 570, 285, 0, 2778, 2779, 3, 1104, 552, 0, 2779, 2783,
		1, 0, 0, 0, 2780, 2783, 3, 1106, 553, 0, 2781, 2783, 3, 572, 286, 0, 2782,
		2777, 1, 0, 0, 0, 2782, 2780, 1, 0, 0, 0, 2782, 2781, 1, 0, 0, 0, 2783,
		565, 1, 0, 0, 0, 2784, 2787, 3, 568, 284, 0, 2785, 2787, 3, 572, 286, 0,
		2786, 2784, 1, 0, 0, 0, 2786, 2785, 1, 0, 0, 0, 2787, 567, 1, 0, 0, 0,
		2788, 2790, 3, 570, 285, 0, 2789, 2788, 1, 0, 0, 0, 2789, 2790, 1, 0, 0,
		0, 2790, 2791, 1, 0, 0, 0, 2791, 2792, 3, 1108, 554, 0, 2792, 569, 1, 0,
		0, 0, 2793, 2795, 3, 538, 269, 0, 2794, 2796, 5, 385, 0, 0, 2795, 2794,
		1, 0, 0, 0, 2795, 2796, 1, 0, 0, 0, 2796, 2802, 1, 0, 0, 0, 2797, 2798,
		3, 1086, 543, 0, 2798, 2799, 5, 377, 0, 0, 2799, 2801, 1, 0, 0, 0, 2800,
		2797, 1, 0, 0, 0, 2801, 2804, 1, 0, 0, 0, 2802, 2800, 1, 0, 0, 0, 2802,
		2803, 1, 0, 0, 0, 2803, 2813, 1, 0, 0, 0, 2804, 2802, 1, 0, 0, 0, 2805,
		2806, 3, 1086, 543, 0, 2806, 2807, 5, 377, 0, 0, 2807, 2809, 1, 0, 0, 0,
		2808, 2805, 1, 0, 0, 0, 2809, 2810, 1, 0, 0, 0, 2810, 2808, 1, 0, 0, 0,
		2810, 2811, 1, 0, 0, 0, 2811, 2813, 1, 0, 0, 0, 2812, 2793, 1, 0, 0, 0,
		2812, 2808, 1, 0, 0, 0, 2813, 571, 1, 0, 0, 0, 2814, 2815, 5, 328, 0, 0,
		2815, 573, 1, 0, 0, 0, 2816, 2817, 5, 371, 0, 0, 2817, 2818, 3, 576, 288,
		0, 2818, 2819, 5, 382, 0, 0, 2819, 575, 1, 0, 0, 0, 2820, 2821, 3, 578,
		289, 0, 2821, 577, 1, 0, 0, 0, 2822, 2827, 3, 580, 290, 0, 2823, 2824,
		5, 363, 0, 0, 2824, 2826, 3, 580, 290, 0, 2825, 2823, 1, 0, 0, 0, 2826,
		2829, 1, 0, 0, 0, 2827, 2825, 1, 0, 0, 0, 2827, 2828, 1, 0, 0, 0, 2828,
		579, 1, 0, 0, 0, 2829, 2827, 1, 0, 0, 0, 2830, 2833, 3, 588, 294, 0, 2831,
		2833, 3, 608, 304, 0, 2832, 2830, 1, 0, 0, 0, 2832, 2831, 1, 0, 0, 0, 2833,
		2836, 1, 0, 0, 0, 2834, 2837, 3, 582, 291, 0, 2835, 2837, 3, 584, 292,
		0, 2836, 2834, 1, 0, 0, 0, 2836, 2835, 1, 0, 0, 0, 2836, 2837, 1, 0, 0,
		0, 2837, 581, 1, 0, 0, 0, 2838, 2839, 3, 696, 348, 0, 2839, 2840, 5, 373,
		0, 0, 2840, 2841, 3, 586, 293, 0, 2841, 2842, 5, 384, 0, 0, 2842, 583,
		1, 0, 0, 0, 2843, 2844, 5, 277, 0, 0, 2844, 2845, 5, 373, 0, 0, 2845, 2846,
		3, 586, 293, 0, 2846, 2847, 5, 384, 0, 0, 2847, 585, 1, 0, 0, 0, 2848,
		2853, 3, 1114, 557, 0, 2849, 2850, 5, 363, 0, 0, 2850, 2852, 3, 1114, 557,
		0, 2851, 2849, 1, 0, 0, 0, 2852, 2855, 1, 0, 0, 0, 2853, 2851, 1, 0, 0,
		0, 2853, 2854, 1, 0, 0, 0, 2854, 587, 1, 0, 0, 0, 2855, 2853, 1, 0, 0,
		0, 2856, 2859, 3, 590, 295, 0, 2857, 2859, 3, 592, 296, 0, 2858, 2856,
		1, 0, 0, 0, 2858, 2857, 1, 0, 0, 0, 2859, 589, 1, 0, 0, 0, 2860, 2862,
		3, 1170, 585, 0, 2861, 2863, 5, 320, 0, 0, 2862, 2861, 1, 0, 0, 0, 2862,
		2863, 1, 0, 0, 0, 2863, 2864, 1, 0, 0, 0, 2864, 2865, 3, 1100, 550, 0,
		2865, 2867, 1, 0, 0, 0, 2866, 2860, 1, 0, 0, 0, 2866, 2867, 1, 0, 0, 0,
		2867, 2868, 1, 0, 0, 0, 2868, 2870, 5, 373, 0, 0, 2869, 2871, 3, 598, 299,
		0, 2870, 2869, 1, 0, 0, 0, 2870, 2871, 1, 0, 0, 0, 2871, 2873, 1, 0, 0,
		0, 2872, 2874, 3, 596, 298, 0, 2873, 2872, 1, 0, 0, 0, 2873, 2874, 1, 0,
		0, 0, 2874, 2875, 1, 0, 0, 0, 2875, 2876, 5, 384, 0, 0, 2876, 591, 1, 0,
		0, 0, 2877, 2879, 3, 1170, 585, 0, 2878, 2880, 5, 320, 0, 0, 2879, 2878,
		1, 0, 0, 0, 2879, 2880, 1, 0, 0, 0, 2880, 2881, 1, 0, 0, 0, 2881, 2884,
		3, 594, 297, 0, 2882, 2883, 5, 30, 0, 0, 2883, 2885, 3, 598, 299, 0, 2884,
		2882, 1, 0, 0, 0, 2884, 2885, 1, 0, 0, 0, 2885, 593, 1, 0, 0, 0, 2886,
		2888, 3, 1100, 550, 0, 2887, 2889, 3, 596, 298, 0, 2888, 2887, 1, 0, 0,
		0, 2888, 2889, 1, 0, 0, 0, 2889, 2892, 1, 0, 0, 0, 2890, 2892, 3, 596,
		298, 0, 2891, 2886, 1, 0, 0, 0, 2891, 2890, 1, 0, 0, 0, 2892, 595, 1, 0,
		0, 0, 2893, 2895, 3, 602, 301, 0, 2894, 2896, 3, 600, 300, 0, 2895, 2894,
		1, 0, 0, 0, 2895, 2896, 1, 0, 0, 0, 2896, 2899, 1, 0, 0, 0, 2897, 2899,
		3, 600, 300, 0, 2898, 2893, 1, 0, 0, 0, 2898, 2897, 1, 0, 0, 0, 2899, 597,
		1, 0, 0, 0, 2900, 2901, 3, 1142, 571, 0, 2901, 599, 1, 0, 0, 0, 2902, 2908,
		3, 604, 302, 0, 2903, 2908, 3, 606, 303, 0, 2904, 2905, 3, 604, 302, 0,
		2905, 2906, 3, 606, 303, 0, 2906, 2908, 1, 0, 0, 0, 2907, 2902, 1, 0, 0,
		0, 2907, 2903, 1, 0, 0, 0, 2907, 2904, 1, 0, 0, 0, 2908, 601, 1, 0, 0,
		0, 2909, 2911, 3, 686, 343, 0, 2910, 2909, 1, 0, 0, 0, 2910, 2911, 1, 0,
		0, 0, 2911, 2912, 1, 0, 0, 0, 2912, 2913, 5, 4, 0, 0, 2913, 603, 1, 0,
		0, 0, 2914, 2915, 3, 686, 343, 0, 2915, 605, 1, 0, 0, 0, 2916, 2917, 3,
		690, 345, 0, 2917, 607, 1, 0, 0, 0, 2918, 2921, 3, 610, 305, 0, 2919, 2921,
		3, 612, 306, 0, 2920, 2918, 1, 0, 0, 0, 2920, 2919, 1, 0, 0, 0, 2921, 609,
		1, 0, 0, 0, 2922, 2924, 3, 664, 332, 0, 2923, 2922, 1, 0, 0, 0, 2923, 2924,
		1, 0, 0, 0, 2924, 2925, 1, 0, 0, 0, 2925, 2927, 3, 1174, 587, 0, 2926,
		2928, 5, 320, 0, 0, 2927, 2926, 1, 0, 0, 0, 2927, 2928, 1, 0, 0, 0, 2928,
		2929, 1, 0, 0, 0, 2929, 2930, 3, 1102, 551, 0, 2930, 2932, 1, 0, 0, 0,
		2931, 2923, 1, 0, 0, 0, 2931, 2932, 1, 0, 0, 0, 2932, 2935, 1, 0, 0, 0,
		2933, 2936, 3, 626, 313, 0, 2934, 2936, 3, 632, 316, 0, 2935, 2933, 1,
		0, 0, 0, 2935, 2934, 1, 0, 0, 0, 2936, 611, 1, 0, 0, 0, 2937, 2938, 3,
		664, 332, 0, 2938, 2940, 3, 1174, 587, 0, 2939, 2941, 5, 320, 0, 0, 2940,
		2939, 1, 0, 0, 0, 2940, 2941, 1, 0, 0, 0, 2941, 2942, 1, 0, 0, 0, 2942,
		2943, 3, 614, 307, 0, 2943, 2944, 3, 666, 333, 0, 2944, 613, 1, 0, 0, 0,
		2945, 2947, 3, 1102, 551, 0, 2946, 2948, 3, 616, 308, 0, 2947, 2946, 1,
		0, 0, 0, 2947, 2948, 1, 0, 0, 0, 2948, 2951, 1, 0, 0, 0, 2949, 2951, 3,
		616, 308, 0, 2950, 2945, 1, 0, 0, 0, 2950, 2949, 1, 0, 0, 0, 2951, 615,
		1, 0, 0, 0, 2952, 2954, 3, 620, 310, 0, 2953, 2955, 3, 618, 309, 0, 2954,
		2953, 1, 0, 0, 0, 2954, 2955, 1, 0, 0, 0, 2955, 2958, 1, 0, 0, 0, 2956,
		2958, 3, 618, 309, 0, 2957, 2952, 1, 0, 0, 0, 2957, 2956, 1, 0, 0, 0, 2958,
		617, 1, 0, 0, 0, 2959, 2965, 3, 622, 311, 0, 2960, 2965, 3, 624, 312, 0,
		2961, 2962, 3, 622, 311, 0, 2962, 2963, 3, 624, 312, 0, 2963, 2965, 1,
		0, 0, 0, 2964, 2959, 1, 0, 0, 0, 2964, 2960, 1, 0, 0, 0, 2964, 2961, 1,
		0, 0, 0, 2965, 619, 1, 0, 0, 0, 2966, 2968, 3, 686, 343, 0, 2967, 2966,
		1, 0, 0, 0, 2967, 2968, 1, 0, 0, 0, 2968, 2969, 1, 0, 0, 0, 2969, 2970,
		5, 4, 0, 0, 2970, 621, 1, 0, 0, 0, 2971, 2972, 3, 686, 343, 0, 2972, 623,
		1, 0, 0, 0, 2973, 2974, 3, 690, 345, 0, 2974, 625, 1, 0, 0, 0, 2975, 2978,
		3, 628, 314, 0, 2976, 2978, 3, 630, 315, 0, 2977, 2975, 1, 0, 0, 0, 2977,
		2976, 1, 0, 0, 0, 2978, 627, 1, 0, 0, 0, 2979, 2980, 3, 660, 330, 0, 2980,
		2981, 3, 634, 317, 0, 2981, 2982, 3, 662, 331, 0, 2982, 629, 1, 0, 0, 0,
		2983, 2984, 3, 662, 331, 0, 2984, 2985, 3, 640, 320, 0, 2985, 2986, 3,
		660, 330, 0, 2986, 631, 1, 0, 0, 0, 2987, 2988, 3, 660, 330, 0, 2988, 2989,
		3, 646, 323, 0, 2989, 2990, 3, 662, 331, 0, 2990, 633, 1, 0, 0, 0, 2991,
		2994, 3, 636, 318, 0, 2992, 2994, 3, 638, 319, 0, 2993, 2991, 1, 0, 0,
		0, 2993, 2992, 1, 0, 0, 0, 2994, 635, 1, 0, 0, 0, 2995, 2996, 5, 346, 0,
		0, 2996, 2997, 3, 616, 308, 0, 2997, 2998, 5, 331, 0, 0, 2998, 637, 1,
		0, 0, 0, 2999, 3000, 5, 375, 0, 0, 3000, 3001, 3, 652, 326, 0, 3001, 3002,
		5, 346, 0, 0, 3002, 3003, 3, 616, 308, 0, 3003, 3004, 5, 350, 0, 0, 3004,
		3005, 3, 652, 326, 0, 3005, 3006, 5, 349, 0, 0, 3006, 639, 1, 0, 0, 0,
		3007, 3010, 3, 642, 321, 0, 3008, 3010, 3, 644, 322, 0, 3009, 3007, 1,
		0, 0, 0, 3009, 3008, 1, 0, 0, 0, 3010, 641, 1, 0, 0, 0, 3011, 3012, 5,
		340, 0, 0, 3012, 3013, 3, 616, 308, 0, 3013, 3014, 5, 350, 0, 0, 3014,
		643, 1, 0, 0, 0, 3015, 3016, 5, 338, 0, 0, 3016, 3017, 3, 652, 326, 0,
		3017, 3018, 5, 346, 0, 0, 3018, 3019, 3, 616, 308, 0, 3019, 3020, 5, 350,
		0, 0, 3020, 3021, 3, 652, 326, 0, 3021, 3022, 5, 375, 0, 0, 3022, 645,
		1, 0, 0, 0, 3023, 3026, 3, 648, 324, 0, 3024, 3026, 3, 650, 325, 0, 3025,
		3023, 1, 0, 0, 0, 3025, 3024, 1, 0, 0, 0, 3026, 647, 1, 0, 0, 0, 3027,
		3028, 5, 357, 0, 0, 3028, 3029, 3, 616, 308, 0, 3029, 3030, 5, 351, 0,
		0, 3030, 649, 1, 0, 0, 0, 3031, 3032, 5, 386, 0, 0, 3032, 3033, 3, 652,
		326, 0, 3033, 3034, 5, 357, 0, 0, 3034, 3035, 3, 616, 308, 0, 3035, 3036,
		5, 351, 0, 0, 3036, 3037, 3, 652, 326, 0, 3037, 3038, 5, 386, 0, 0, 3038,
		651, 1, 0, 0, 0, 3039, 3040, 5, 373, 0, 0, 3040, 3041, 3, 654, 327, 0,
		3041, 3042, 5, 384, 0, 0, 3042, 653, 1, 0, 0, 0, 3043, 3044, 3, 656, 328,
		0, 3044, 3045, 5, 363, 0, 0, 3045, 3046, 3, 658, 329, 0, 3046, 655, 1,
		0, 0, 0, 3047, 3048, 5, 19, 0, 0, 3048, 657, 1, 0, 0, 0, 3049, 3050, 7,
		13, 0, 0, 3050, 659, 1, 0, 0, 0, 3051, 3052, 5, 373, 0, 0, 3052, 3053,
		3, 682, 341, 0, 3053, 3054, 5, 384, 0, 0, 3054, 3061, 1, 0, 0, 0, 3055,
		3057, 5, 373, 0, 0, 3056, 3058, 3, 596, 298, 0, 3057, 3056, 1, 0, 0, 0,
		3057, 3058, 1, 0, 0, 0, 3058, 3059, 1, 0, 0, 0, 3059, 3061, 5, 384, 0,
		0, 3060, 3051, 1, 0, 0, 0, 3060, 3055, 1, 0, 0, 0, 3061, 661, 1, 0, 0,
		0, 3062, 3063, 5, 373, 0, 0, 3063, 3064, 3, 684, 342, 0, 3064, 3065, 5,
		384, 0, 0, 3065, 3072, 1, 0, 0, 0, 3066, 3068, 5, 373, 0, 0, 3067, 3069,
		3, 596, 298, 0, 3068, 3067, 1, 0, 0, 0, 3068, 3069, 1, 0, 0, 0, 3069, 3070,
		1, 0, 0, 0, 3070, 3072, 5, 384, 0, 0, 3071, 3062, 1, 0, 0, 0, 3071, 3066,
		1, 0, 0, 0, 3072, 663, 1, 0, 0, 0, 3073, 3074, 7, 14, 0, 0, 3074, 665,
		1, 0, 0, 0, 3075, 3076, 5, 283, 0, 0, 3076, 3077, 3, 668, 334, 0, 3077,
		667, 1, 0, 0, 0, 3078, 3081, 3, 670, 335, 0, 3079, 3081, 3, 676, 338, 0,
		3080, 3078, 1, 0, 0, 0, 3080, 3079, 1, 0, 0, 0, 3081, 669, 1, 0, 0, 0,
		3082, 3085, 3, 672, 336, 0, 3083, 3085, 3, 674, 337, 0, 3084, 3082, 1,
		0, 0, 0, 3084, 3083, 1, 0, 0, 0, 3085, 671, 1, 0, 0, 0, 3086, 3087, 5,
		373, 0, 0, 3087, 3088, 3, 682, 341, 0, 3088, 3089, 3, 678, 339, 0, 3089,
		3090, 3, 684, 342, 0, 3090, 3091, 5, 384, 0, 0, 3091, 673, 1, 0, 0, 0,
		3092, 3093, 5, 373, 0, 0, 3093, 3094, 3, 684, 342, 0, 3094, 3095, 5, 338,
		0, 0, 3095, 3096, 3, 682, 341, 0, 3096, 3097, 5, 384, 0, 0, 3097, 675,
		1, 0, 0, 0, 3098, 3099, 5, 373, 0, 0, 3099, 3100, 3, 682, 341, 0, 3100,
		3101, 3, 680, 340, 0, 3101, 3102, 3, 684, 342, 0, 3102, 3103, 5, 384, 0,
		0, 3103, 677, 1, 0, 0, 0, 3104, 3105, 7, 15, 0, 0, 3105, 679, 1, 0, 0,
		0, 3106, 3107, 7, 16, 0, 0, 3107, 681, 1, 0, 0, 0, 3108, 3109, 3, 1142,
		571, 0, 3109, 683, 1, 0, 0, 0, 3110, 3111, 3, 1142, 571, 0, 3111, 685,
		1, 0, 0, 0, 3112, 3113, 5, 295, 0, 0, 3113, 3120, 3, 1110, 555, 0, 3114,
		3115, 5, 297, 0, 0, 3115, 3120, 3, 688, 344, 0, 3116, 3117, 3, 390, 195,
		0, 3117, 3118, 3, 688, 344, 0, 3118, 3120, 1, 0, 0, 0, 3119, 3112, 1, 0,
		0, 0, 3119, 3114, 1, 0, 0, 0, 3119, 3116, 1, 0, 0, 0, 3120, 687, 1, 0,
		0, 0, 3121, 3126, 3, 1110, 555, 0, 3122, 3123, 5, 360, 0, 0, 3123, 3125,
		3, 1110, 555, 0, 3124, 3122, 1, 0, 0, 0, 3125, 3128, 1, 0, 0, 0, 3126,
		3124, 1, 0, 0, 0, 3126, 3127, 1, 0, 0, 0, 3127, 689, 1, 0, 0, 0, 3128,
		3126, 1, 0, 0, 0, 3129, 3131, 5, 371, 0, 0, 3130, 3132, 3, 692, 346, 0,
		3131, 3130, 1, 0, 0, 0, 3131, 3132, 1, 0, 0, 0, 3132, 3133, 1, 0, 0, 0,
		3133, 3134, 5, 382, 0, 0, 3134, 691, 1, 0, 0, 0, 3135, 3140, 3, 694, 347,
		0, 3136, 3137, 5, 363, 0, 0, 3137, 3139, 3, 694, 347, 0, 3138, 3136, 1,
		0, 0, 0, 3139, 3142, 1, 0, 0, 0, 3140, 3138, 1, 0, 0, 0, 3140, 3141, 1,
		0, 0, 0, 3141, 693, 1, 0, 0, 0, 3142, 3140, 1, 0, 0, 0, 3143, 3145, 3,
		1112, 556, 0, 3144, 3146, 3, 706, 353, 0, 3145, 3144, 1, 0, 0, 0, 3145,
		3146, 1, 0, 0, 0, 3146, 3147, 1, 0, 0, 0, 3147, 3148, 3, 700, 350, 0, 3148,
		695, 1, 0, 0, 0, 3149, 3150, 5, 2, 0, 0, 3150, 3151, 5, 3, 0, 0, 3151,
		697, 1, 0, 0, 0, 3152, 3153, 5, 1, 0, 0, 3153, 3154, 5, 373, 0, 0, 3154,
		3155, 3, 804, 402, 0, 3155, 3156, 5, 384, 0, 0, 3156, 699, 1, 0, 0, 0,
		3157, 3163, 3, 704, 352, 0, 3158, 3162, 5, 277, 0, 0, 3159, 3162, 3, 696,
		348, 0, 3160, 3162, 3, 698, 349, 0, 3161, 3158, 1, 0, 0, 0, 3161, 3159,
		1, 0, 0, 0, 3161, 3160, 1, 0, 0, 0, 3162, 3165, 1, 0, 0, 0, 3163, 3161,
		1, 0, 0, 0, 3163, 3164, 1, 0, 0, 0, 3164, 701, 1, 0, 0, 0, 3165, 3163,
		1, 0, 0, 0, 3166, 3168, 5, 281, 0, 0, 3167, 3166, 1, 0, 0, 0, 3167, 3168,
		1, 0, 0, 0, 3168, 3169, 1, 0, 0, 0, 3169, 3170, 5, 316, 0, 0, 3170, 3171,
		3, 796, 398, 0, 3171, 703, 1, 0, 0, 0, 3172, 3173, 6, 352, -1, 0, 3173,
		3230, 3, 708, 354, 0, 3174, 3230, 3, 788, 394, 0, 3175, 3176, 3, 790, 395,
		0, 3176, 3177, 5, 374, 0, 0, 3177, 3178, 3, 704, 352, 0, 3178, 3183, 5,
		369, 0, 0, 3179, 3180, 5, 372, 0, 0, 3180, 3181, 3, 718, 359, 0, 3181,
		3182, 5, 383, 0, 0, 3182, 3184, 1, 0, 0, 0, 3183, 3179, 1, 0, 0, 0, 3183,
		3184, 1, 0, 0, 0, 3184, 3186, 1, 0, 0, 0, 3185, 3187, 3, 800, 400, 0, 3186,
		3185, 1, 0, 0, 0, 3186, 3187, 1, 0, 0, 0, 3187, 3230, 1, 0, 0, 0, 3188,
		3193, 3, 790, 395, 0, 3189, 3190, 5, 372, 0, 0, 3190, 3191, 3, 718, 359,
		0, 3191, 3192, 5, 383, 0, 0, 3192, 3194, 1, 0, 0, 0, 3193, 3189, 1, 0,
		0, 0, 3193, 3194, 1, 0, 0, 0, 3194, 3196, 1, 0, 0, 0, 3195, 3197, 3, 800,
		400, 0, 3196, 3195, 1, 0, 0, 0, 3196, 3197, 1, 0, 0, 0, 3197, 3230, 1,
		0, 0, 0, 3198, 3230, 3, 794, 397, 0, 3199, 3201, 5, 28, 0, 0, 3200, 3202,
		5, 228, 0, 0, 3201, 3200, 1, 0, 0, 0, 3201, 3202, 1, 0, 0, 0, 3202, 3204,
		1, 0, 0, 0, 3203, 3205, 3, 800, 400, 0, 3204, 3203, 1, 0, 0, 0, 3204, 3205,
		1, 0, 0, 0, 3205, 3230, 1, 0, 0, 0, 3206, 3208, 5, 28, 0, 0, 3207, 3206,
		1, 0, 0, 0, 3207, 3208, 1, 0, 0, 0, 3208, 3209, 1, 0, 0, 0, 3209, 3210,
		5, 308, 0, 0, 3210, 3212, 5, 228, 0, 0, 3211, 3213, 3, 800, 400, 0, 3212,
		3211, 1, 0, 0, 0, 3212, 3213, 1, 0, 0, 0, 3213, 3230, 1, 0, 0, 0, 3214,
		3216, 5, 28, 0, 0, 3215, 3217, 5, 228, 0, 0, 3216, 3215, 1, 0, 0, 0, 3216,
		3217, 1, 0, 0, 0, 3217, 3218, 1, 0, 0, 0, 3218, 3219, 5, 374, 0, 0, 3219,
		3224, 3, 704, 352, 0, 3220, 3221, 5, 388, 0, 0, 3221, 3223, 3, 704, 352,
		0, 3222, 3220, 1, 0, 0, 0, 3223, 3226, 1, 0, 0, 0, 3224, 3222, 1, 0, 0,
		0, 3224, 3225, 1, 0, 0, 0, 3225, 3227, 1, 0, 0, 0, 3226, 3224, 1, 0, 0,
		0, 3227, 3228, 5, 369, 0, 0, 3228, 3230, 1, 0, 0, 0, 3229, 3172, 1, 0,
		0, 0, 3229, 3174, 1, 0, 0, 0, 3229, 3175, 1, 0, 0, 0, 3229, 3188, 1, 0,
		0, 0, 3229, 3198, 1, 0, 0, 0, 3229, 3199, 1, 0, 0, 0, 3229, 3207, 1, 0,
		0, 0, 3229, 3214, 1, 0, 0, 0, 3230, 3247, 1, 0, 0, 0, 3231, 3232, 10, 1,
		0, 0, 3232, 3233, 5, 388, 0, 0, 3233, 3246, 3, 704, 352, 2, 3234, 3235,
		10, 7, 0, 0, 3235, 3240, 3, 790, 395, 0, 3236, 3237, 5, 372, 0, 0, 3237,
		3238, 3, 718, 359, 0, 3238, 3239, 5, 383, 0, 0, 3239, 3241, 1, 0, 0, 0,
		3240, 3236, 1, 0, 0, 0, 3240, 3241, 1, 0, 0, 0, 3241, 3243, 1, 0, 0, 0,
		3242, 3244, 3, 800, 400, 0, 3243, 3242, 1, 0, 0, 0, 3243, 3244, 1, 0, 0,
		0, 3244, 3246, 1, 0, 0, 0, 3245, 3231, 1, 0, 0, 0, 3245, 3234, 1, 0, 0,
		0, 3246, 3249, 1, 0, 0, 0, 3247, 3245, 1, 0, 0, 0, 3247, 3248, 1, 0, 0,
		0, 3248, 705, 1, 0, 0, 0, 3249, 3247, 1, 0, 0, 0, 3250, 3251, 7, 17, 0,
		0, 3251, 707, 1, 0, 0, 0, 3252, 3260, 3, 710, 355, 0, 3253, 3260, 3, 712,
		356, 0, 3254, 3260, 3, 714, 357, 0, 3255, 3260, 3, 722, 361, 0, 3256, 3260,
		3, 742, 371, 0, 3257, 3260, 3, 760, 380, 0, 3258, 3260, 3, 762, 381, 0,
		3259, 3252, 1, 0, 0, 0, 3259, 3253, 1, 0, 0, 0, 3259, 3254, 1, 0, 0, 0,
		3259, 3255, 1, 0, 0, 0, 3259, 3256, 1, 0, 0, 0, 3259, 3257, 1, 0, 0, 0,
		3259, 3258, 1, 0, 0, 0, 3260, 709, 1, 0, 0, 0, 3261, 3263, 7, 18, 0, 0,
		3262, 3264, 3, 800, 400, 0, 3263, 3262, 1, 0, 0, 0, 3263, 3264, 1, 0, 0,
		0, 3264, 711, 1, 0, 0, 0, 3265, 3275, 5, 205, 0, 0, 3266, 3270, 5, 373,
		0, 0, 3267, 3268, 3, 716, 358, 0, 3268, 3269, 5, 363, 0, 0, 3269, 3271,
		1, 0, 0, 0, 3270, 3267, 1, 0, 0, 0, 3270, 3271, 1, 0, 0, 0, 3271, 3272,
		1, 0, 0, 0, 3272, 3273, 3, 718, 359, 0, 3273, 3274, 5, 384, 0, 0, 3274,
		3276, 1, 0, 0, 0, 3275, 3266, 1, 0, 0, 0, 3275, 3276, 1, 0, 0, 0, 3276,
		3278, 1, 0, 0, 0, 3277, 3279, 3, 800, 400, 0, 3278, 3277, 1, 0, 0, 0, 3278,
		3279, 1, 0, 0, 0, 3279, 3301, 1, 0, 0, 0, 3280, 3285, 5, 53, 0, 0, 3281,
		3282, 5, 373, 0, 0, 3282, 3283, 3, 720, 360, 0, 3283, 3284, 5, 384, 0,
		0, 3284, 3286, 1, 0, 0, 0, 3285, 3281, 1, 0, 0, 0, 3285, 3286, 1, 0, 0,
		0, 3286, 3288, 1, 0, 0, 0, 3287, 3289, 3, 800, 400, 0, 3288, 3287, 1, 0,
		0, 0, 3288, 3289, 1, 0, 0, 0, 3289, 3301, 1, 0, 0, 0, 3290, 3295, 5, 230,
		0, 0, 3291, 3292, 5, 373, 0, 0, 3292, 3293, 3, 718, 359, 0, 3293, 3294,
		5, 384, 0, 0, 3294, 3296, 1, 0, 0, 0, 3295, 3291, 1, 0, 0, 0, 3295, 3296,
		1, 0, 0, 0, 3296, 3298, 1, 0, 0, 0, 3297, 3299, 3, 800, 400, 0, 3298, 3297,
		1, 0, 0, 0, 3298, 3299, 1, 0, 0, 0, 3299, 3301, 1, 0, 0, 0, 3300, 3265,
		1, 0, 0, 0, 3300, 3280, 1, 0, 0, 0, 3300, 3290, 1, 0, 0, 0, 3301, 713,
		1, 0, 0, 0, 3302, 3312, 5, 46, 0, 0, 3303, 3307, 5, 373, 0, 0, 3304, 3305,
		3, 716, 358, 0, 3305, 3306, 5, 363, 0, 0, 3306, 3308, 1, 0, 0, 0, 3307,
		3304, 1, 0, 0, 0, 3307, 3308, 1, 0, 0, 0, 3308, 3309, 1, 0, 0, 0, 3309,
		3310, 3, 718, 359, 0, 3310, 3311, 5, 384, 0, 0, 3311, 3313, 1, 0, 0, 0,
		3312, 3303, 1, 0, 0, 0, 3312, 3313, 1, 0, 0, 0, 3313, 3315, 1, 0, 0, 0,
		3314, 3316, 3, 800, 400, 0, 3315, 3314, 1, 0, 0, 0, 3315, 3316, 1, 0, 0,
		0, 3316, 3338, 1, 0, 0, 0, 3317, 3322, 5, 39, 0, 0, 3318, 3319, 5, 373,
		0, 0, 3319, 3320, 3, 720, 360, 0, 3320, 3321, 5, 384, 0, 0, 3321, 3323,
		1, 0, 0, 0, 3322, 3318, 1, 0, 0, 0, 3322, 3323, 1, 0, 0, 0, 3323, 3325,
		1, 0, 0, 0, 3324, 3326, 3, 800, 400, 0, 3325, 3324, 1, 0, 0, 0, 3325, 3326,
		1, 0, 0, 0, 3326, 3338, 1, 0, 0, 0, 3327, 3332, 5, 229, 0, 0, 3328, 3329,
		5, 373, 0, 0, 3329, 3330, 3, 718, 359, 0, 3330, 3331, 5, 384, 0, 0, 3331,
		3333, 1, 0, 0, 0, 3332, 3328, 1, 0, 0, 0, 3332, 3333, 1, 0, 0, 0, 3333,
		3335, 1, 0, 0, 0, 3334, 3336, 3, 800, 400, 0, 3335, 3334, 1, 0, 0, 0, 3335,
		3336, 1, 0, 0, 0, 3336, 3338, 1, 0, 0, 0, 3337, 3302, 1, 0, 0, 0, 3337,
		3317, 1, 0, 0, 0, 3337, 3327, 1, 0, 0, 0, 3338, 715, 1, 0, 0, 0, 3339,
		3340, 3, 1154, 577, 0, 3340, 717, 1, 0, 0, 0, 3341, 3342, 3, 1154, 577,
		0, 3342, 719, 1, 0, 0, 0, 3343, 3344, 3, 1154, 577, 0, 3344, 721, 1, 0,
		0, 0, 3345, 3348, 3, 724, 362, 0, 3346, 3348, 3, 740, 370, 0, 3347, 3345,
		1, 0, 0, 0, 3347, 3346, 1, 0, 0, 0, 3348, 723, 1, 0, 0, 0, 3349, 3352,
		3, 726, 363, 0, 3350, 3352, 3, 734, 367, 0, 3351, 3349, 1, 0, 0, 0, 3351,
		3350, 1, 0, 0, 0, 3352, 725, 1, 0, 0, 0, 3353, 3356, 3, 728, 364, 0, 3354,
		3356, 3, 730, 365, 0, 3355, 3353, 1, 0, 0, 0, 3355, 3354, 1, 0, 0, 0, 3356,
		727, 1, 0, 0, 0, 3357, 3359, 5, 116, 0, 0, 3358, 3360, 3, 800, 400, 0,
		3359, 3358, 1, 0, 0, 0, 3359, 3360, 1, 0, 0, 0, 3360, 3404, 1, 0, 0, 0,
		3361, 3363, 5, 118, 0, 0, 3362, 3364, 3, 800, 400, 0, 3363, 3362, 1, 0,
		0, 0, 3363, 3364, 1, 0, 0, 0, 3364, 3404, 1, 0, 0, 0, 3365, 3367, 5, 120,
		0, 0, 3366, 3368, 3, 800, 400, 0, 3367, 3366, 1, 0, 0, 0, 3367, 3368, 1,
		0, 0, 0, 3368, 3404, 1, 0, 0, 0, 3369, 3371, 5, 122, 0, 0, 3370, 3372,
		3, 800, 400, 0, 3371, 3370, 1, 0, 0, 0, 3371, 3372, 1, 0, 0, 0, 3372, 3404,
		1, 0, 0, 0, 3373, 3375, 5, 124, 0, 0, 3374, 3376, 3, 800, 400, 0, 3375,
		3374, 1, 0, 0, 0, 3375, 3376, 1, 0, 0, 0, 3376, 3404, 1, 0, 0, 0, 3377,
		3379, 5, 126, 0, 0, 3378, 3380, 3, 800, 400, 0, 3379, 3378, 1, 0, 0, 0,
		3379, 3380, 1, 0, 0, 0, 3380, 3404, 1, 0, 0, 0, 3381, 3383, 5, 200, 0,
		0, 3382, 3384, 3, 800, 400, 0, 3383, 3382, 1, 0, 0, 0, 3383, 3384, 1, 0,
		0, 0, 3384, 3404, 1, 0, 0, 0, 3385, 3390, 5, 114, 0, 0, 3386, 3387, 5,
		373, 0, 0, 3387, 3388, 3, 736, 368, 0, 3388, 3389, 5, 384, 0, 0, 3389,
		3391, 1, 0, 0, 0, 3390, 3386, 1, 0, 0, 0, 3390, 3391, 1, 0, 0, 0, 3391,
		3393, 1, 0, 0, 0, 3392, 3394, 3, 800, 400, 0, 3393, 3392, 1, 0, 0, 0, 3393,
		3394, 1, 0, 0, 0, 3394, 3404, 1, 0, 0, 0, 3395, 3397, 5, 38, 0, 0, 3396,
		3398, 3, 800, 400, 0, 3397, 3396, 1, 0, 0, 0, 3397, 3398, 1, 0, 0, 0, 3398,
		3404, 1, 0, 0, 0, 3399, 3401, 5, 194, 0, 0, 3400, 3399, 1, 0, 0, 0, 3400,
		3401, 1, 0, 0, 0, 3401, 3402, 1, 0, 0, 0, 3402, 3404, 3, 732, 366, 0, 3403,
		3357, 1, 0, 0, 0, 3403, 3361, 1, 0, 0, 0, 3403, 3365, 1, 0, 0, 0, 3403,
		3369, 1, 0, 0, 0, 3403, 3373, 1, 0, 0, 0, 3403, 3377, 1, 0, 0, 0, 3403,
		3381, 1, 0, 0, 0, 3403, 3385, 1, 0, 0, 0, 3403, 3395, 1, 0, 0, 0, 3403,
		3400, 1, 0, 0, 0, 3404, 729, 1, 0, 0, 0, 3405, 3407, 5, 217, 0, 0, 3406,
		3408, 3, 800, 400, 0, 3407, 3406, 1, 0, 0, 0, 3407, 3408, 1, 0, 0, 0, 3408,
		3450, 1, 0, 0, 0, 3409, 3411, 5, 218, 0, 0, 3410, 3412, 3, 800, 400, 0,
		3411, 3410, 1, 0, 0, 0, 3411, 3412, 1, 0, 0, 0, 3412, 3450, 1, 0, 0, 0,
		3413, 3415, 5, 219, 0, 0, 3414, 3416, 3, 800, 400, 0, 3415, 3414, 1, 0,
		0, 0, 3415, 3416, 1, 0, 0, 0, 3416, 3450, 1, 0, 0, 0, 3417, 3419, 5, 220,
		0, 0, 3418, 3420, 3, 800, 400, 0, 3419, 3418, 1, 0, 0, 0, 3419, 3420, 1,
		0, 0, 0, 3420, 3450, 1, 0, 0, 0, 3421, 3423, 5, 221, 0, 0, 3422, 3424,
		3, 800, 400, 0, 3423, 3422, 1, 0, 0, 0, 3423, 3424, 1, 0, 0, 0, 3424, 3450,
		1, 0, 0, 0, 3425, 3427, 5, 222, 0, 0, 3426, 3428, 3, 800, 400, 0, 3427,
		3426, 1, 0, 0, 0, 3427, 3428, 1, 0, 0, 0, 3428, 3450, 1, 0, 0, 0, 3429,
		3431, 5, 227, 0, 0, 3430, 3432, 3, 800, 400, 0, 3431, 3430, 1, 0, 0, 0,
		3431, 3432, 1, 0, 0, 0, 3432, 3450, 1, 0, 0, 0, 3433, 3438, 5, 216, 0,
		0, 3434, 3435, 5, 373, 0, 0, 3435, 3436, 3, 736, 368, 0, 3436, 3437, 5,
		384, 0, 0, 3437, 3439, 1, 0, 0, 0, 3438, 3434, 1, 0, 0, 0, 3438, 3439,
		1, 0, 0, 0, 3439, 3441, 1, 0, 0, 0, 3440, 3442, 3, 800, 400, 0, 3441, 3440,
		1, 0, 0, 0, 3441, 3442, 1, 0, 0, 0, 3442, 3450, 1, 0, 0, 0, 3443, 3445,
		5, 215, 0, 0, 3444, 3446, 3, 800, 400, 0, 3445, 3444, 1, 0, 0, 0, 3445,
		3446, 1, 0, 0, 0, 3446, 3450, 1, 0, 0, 0, 3447, 3448, 5, 224, 0, 0, 3448,
		3450, 3, 732, 366, 0, 3449, 3405, 1, 0, 0, 0, 3449, 3409, 1, 0, 0, 0, 3449,
		3413, 1, 0, 0, 0, 3449, 3417, 1, 0, 0, 0, 3449, 3421, 1, 0, 0, 0, 3449,
		3425, 1, 0, 0, 0, 3449, 3429, 1, 0, 0, 0, 3449, 3433, 1, 0, 0, 0, 3449,
		3443, 1, 0, 0, 0, 3449, 3447, 1, 0, 0, 0, 3450, 731, 1, 0, 0, 0, 3451,
		3453, 5, 117, 0, 0, 3452, 3454, 3, 800, 400, 0, 3453, 3452, 1, 0, 0, 0,
		3453, 3454, 1, 0, 0, 0, 3454, 3496, 1, 0, 0, 0, 3455, 3457, 5, 119, 0,
		0, 3456, 3458, 3, 800, 400, 0, 3457, 3456, 1, 0, 0, 0, 3457, 3458, 1, 0,
		0, 0, 3458, 3496, 1, 0, 0, 0, 3459, 3461, 5, 121, 0, 0, 3460, 3462, 3,
		800, 400, 0, 3461, 3460, 1, 0, 0, 0, 3461, 3462, 1, 0, 0, 0, 3462, 3496,
		1, 0, 0, 0, 3463, 3465, 5, 123, 0, 0, 3464, 3466, 3, 800, 400, 0, 3465,
		3464, 1, 0, 0, 0, 3465, 3466, 1, 0, 0, 0, 3466, 3496, 1, 0, 0, 0, 3467,
		3469, 5, 125, 0, 0, 3468, 3470, 3, 800, 400, 0, 3469, 3468, 1, 0, 0, 0,
		3469, 3470, 1, 0, 0, 0, 3470, 3496, 1, 0, 0, 0, 3471, 3473, 5, 127, 0,
		0, 3472, 3474, 3, 800, 400, 0, 3473, 3472, 1, 0, 0, 0, 3473, 3474, 1, 0,
		0, 0, 3474, 3496, 1, 0, 0, 0, 3475, 3476, 5, 199, 0, 0, 3476, 3478, 5,
		115, 0, 0, 3477, 3479, 3, 800, 400, 0, 3478, 3477, 1, 0, 0, 0, 3478, 3479,
		1, 0, 0, 0, 3479, 3496, 1, 0, 0, 0, 3480, 3485, 5, 115, 0, 0, 3481, 3482,
		5, 373, 0, 0, 3482, 3483, 3, 736, 368, 0, 3483, 3484, 5, 384, 0, 0, 3484,
		3486, 1, 0, 0, 0, 3485, 3481, 1, 0, 0, 0, 3485, 3486, 1, 0, 0, 0, 3486,
		3488, 1, 0, 0, 0, 3487, 3489, 3, 800, 400, 0, 3488, 3487, 1, 0, 0, 0, 3488,
		3489, 1, 0, 0, 0, 3489, 3496, 1, 0, 0, 0, 3490, 3491, 5, 37, 0, 0, 3491,
		3493, 5, 115, 0, 0, 3492, 3494, 3, 800, 400, 0, 3493, 3492, 1, 0, 0, 0,
		3493, 3494, 1, 0, 0, 0, 3494, 3496, 1, 0, 0, 0, 3495, 3451, 1, 0, 0, 0,
		3495, 3455, 1, 0, 0, 0, 3495, 3459, 1, 0, 0, 0, 3495, 3463, 1, 0, 0, 0,
		3495, 3467, 1, 0, 0, 0, 3495, 3471, 1, 0, 0, 0, 3495, 3475, 1, 0, 0, 0,
		3495, 3480, 1, 0, 0, 0, 3495, 3490, 1, 0, 0, 0, 3496, 733, 1, 0, 0, 0,
		3497, 3508, 7, 19, 0, 0, 3498, 3499, 5, 373, 0, 0, 3499, 3502, 3, 736,
		368, 0, 3500, 3501, 5, 363, 0, 0, 3501, 3503, 3, 738, 369, 0, 3502, 3500,
		1, 0, 0, 0, 3502, 3503, 1, 0, 0, 0, 3503, 3504, 1, 0, 0, 0, 3504, 3506,
		5, 384, 0, 0, 3505, 3507, 3, 800, 400, 0, 3506, 3505, 1, 0, 0, 0, 3506,
		3507, 1, 0, 0, 0, 3507, 3509, 1, 0, 0, 0, 3508, 3498, 1, 0, 0, 0, 3508,
		3509, 1, 0, 0, 0, 3509, 735, 1, 0, 0, 0, 3510, 3511, 3, 1156, 578, 0, 3511,
		737, 1, 0, 0, 0, 3512, 3513, 3, 1156, 578, 0, 3513, 739, 1, 0, 0, 0, 3514,
		3516, 5, 97, 0, 0, 3515, 3517, 3, 800, 400, 0, 3516, 3515, 1, 0, 0, 0,
		3516, 3517, 1, 0, 0, 0, 3517, 3560, 1, 0, 0, 0, 3518, 3520, 5, 98, 0, 0,
		3519, 3521, 3, 800, 400, 0, 3520, 3519, 1, 0, 0, 0, 3520, 3521, 1, 0, 0,
		0, 3521, 3560, 1, 0, 0, 0, 3522, 3524, 5, 99, 0, 0, 3523, 3525, 3, 800,
		400, 0, 3524, 3523, 1, 0, 0, 0, 3524, 3525, 1, 0, 0, 0, 3525, 3560, 1,
		0, 0, 0, 3526, 3528, 5, 100, 0, 0, 3527, 3529, 3, 800, 400, 0, 3528, 3527,
		1, 0, 0, 0, 3528, 3529, 1, 0, 0, 0, 3529, 3560, 1, 0, 0, 0, 3530, 3532,
		5, 101, 0, 0, 3531, 3533, 3, 800, 400, 0, 3532, 3531, 1, 0, 0, 0, 3532,
		3533, 1, 0, 0, 0, 3533, 3560, 1, 0, 0, 0, 3534, 3543, 5, 96, 0, 0, 3535,
		3536, 5, 373, 0, 0, 3536, 3539, 3, 736, 368, 0, 3537, 3538, 5, 363, 0,
		0, 3538, 3540, 3, 738, 369, 0, 3539, 3537, 1, 0, 0, 0, 3539, 3540, 1, 0,
		0, 0, 3540, 3541, 1, 0, 0, 0, 3541, 3542, 5, 384, 0, 0, 3542, 3544, 1,
		0, 0, 0, 3543, 3535, 1, 0, 0, 0, 3543, 3544, 1, 0, 0, 0, 3544, 3546, 1,
		0, 0, 0, 3545, 3547, 3, 800, 400, 0, 3546, 3545, 1, 0, 0, 0, 3546, 3547,
		1, 0, 0, 0, 3547, 3560, 1, 0, 0, 0, 3548, 3550, 5, 178, 0, 0, 3549, 3551,
		3, 800, 400, 0, 3550, 3549, 1, 0, 0, 0, 3550, 3551, 1, 0, 0, 0, 3551, 3560,
		1, 0, 0, 0, 3552, 3554, 5, 84, 0, 0, 3553, 3555, 5, 175, 0, 0, 3554, 3553,
		1, 0, 0, 0, 3554, 3555, 1, 0, 0, 0, 3555, 3557, 1, 0, 0, 0, 3556, 3558,
		3, 800, 400, 0, 3557, 3556, 1, 0, 0, 0, 3557, 3558, 1, 0, 0, 0, 3558, 3560,
		1, 0, 0, 0, 3559, 3514, 1, 0, 0, 0, 3559, 3518, 1, 0, 0, 0, 3559, 3522,
		1, 0, 0, 0, 3559, 3526, 1, 0, 0, 0, 3559, 3530, 1, 0, 0, 0, 3559, 3534,
		1, 0, 0, 0, 3559, 3548, 1, 0, 0, 0, 3559, 3552, 1, 0, 0, 0, 3560, 741,
		1, 0, 0, 0, 3561, 3564, 3, 744, 372, 0, 3562, 3564, 3, 756, 378, 0, 3563,
		3561, 1, 0, 0, 0, 3563, 3562, 1, 0, 0, 0, 3564, 743, 1, 0, 0, 0, 3565,
		3571, 3, 746, 373, 0, 3566, 3571, 3, 748, 374, 0, 3567, 3571, 3, 750, 375,
		0, 3568, 3571, 3, 752, 376, 0, 3569, 3571, 3, 754, 377, 0, 3570, 3565,
		1, 0, 0, 0, 3570, 3566, 1, 0, 0, 0, 3570, 3567, 1, 0, 0, 0, 3570, 3568,
		1, 0, 0, 0, 3570, 3569, 1, 0, 0, 0, 3571, 745, 1, 0, 0, 0, 3572, 3573,
		5, 238, 0, 0, 3573, 3575, 5, 74, 0, 0, 3574, 3576, 3, 800, 400, 0, 3575,
		3574, 1, 0, 0, 0, 3575, 3576, 1, 0, 0, 0, 3576, 3585, 1, 0, 0, 0, 3577,
		3578, 5, 211, 0, 0, 3578, 3579, 5, 234, 0, 0, 3579, 3580, 5, 210, 0, 0,
		3580, 3582, 5, 326, 0, 0, 3581, 3583, 3, 800, 400, 0, 3582, 3581, 1, 0,
		0, 0, 3582, 3583, 1, 0, 0, 0, 3583, 3585, 1, 0, 0, 0, 3584, 3572, 1, 0,
		0, 0, 3584, 3577, 1, 0, 0, 0, 3585, 747, 1, 0, 0, 0, 3586, 3587, 5, 138,
		0, 0, 3587, 3589, 5, 74, 0, 0, 3588, 3590, 3, 800, 400, 0, 3589, 3588,
		1, 0, 0, 0, 3589, 3590, 1, 0, 0, 0, 3590, 3601, 1, 0, 0, 0, 3591, 3595,
		5, 211, 0, 0, 3592, 3593, 5, 324, 0, 0, 3593, 3594, 5, 210, 0, 0, 3594,
		3596, 5, 326, 0, 0, 3595, 3592, 1, 0, 0, 0, 3595, 3596, 1, 0, 0, 0, 3596,
		3598, 1, 0, 0, 0, 3597, 3599, 3, 800, 400, 0, 3598, 3597, 1, 0, 0, 0, 3598,
		3599, 1, 0, 0, 0, 3599, 3601, 1, 0, 0, 0, 3600, 3586, 1, 0, 0, 0, 3600,
		3591, 1, 0, 0, 0, 3601, 749, 1, 0, 0, 0, 3602, 3604, 5, 73, 0, 0, 3603,
		3605, 3, 800, 400, 0, 3604, 3603, 1, 0, 0, 0, 3604, 3605, 1, 0, 0, 0, 3605,
		751, 1, 0, 0, 0, 3606, 3607, 5, 238, 0, 0, 3607, 3609, 5, 210, 0, 0, 3608,
		3610, 3, 800, 400, 0, 3609, 3608, 1, 0, 0, 0, 3609, 3610, 1, 0, 0, 0, 3610,
		3619, 1, 0, 0, 0, 3611, 3612, 5, 210, 0, 0, 3612, 3613, 5, 234, 0, 0, 3613,
		3614, 5, 210, 0, 0, 3614, 3616, 5, 326, 0, 0, 3615, 3617, 3, 800, 400,
		0, 3616, 3615, 1, 0, 0, 0, 3616, 3617, 1, 0, 0, 0, 3617, 3619, 1, 0, 0,
		0, 3618, 3606, 1, 0, 0, 0, 3618, 3611, 1, 0, 0, 0, 3619, 753, 1, 0, 0,
		0, 3620, 3621, 5, 138, 0, 0, 3621, 3623, 5, 210, 0, 0, 3622, 3624, 3, 800,
		400, 0, 3623, 3622, 1, 0, 0, 0, 3623, 3624, 1, 0, 0, 0, 3624, 3633, 1,
		0, 0, 0, 3625, 3626, 5, 210, 0, 0, 3626, 3627, 5, 324, 0, 0, 3627, 3628,
		5, 210, 0, 0, 3628, 3630, 5, 326, 0, 0, 3629, 3631, 3, 800, 400, 0, 3630,
		3629, 1, 0, 0, 0, 3630, 3631, 1, 0, 0, 0, 3631, 3633, 1, 0, 0, 0, 3632,
		3620, 1, 0, 0, 0, 3632, 3625, 1, 0, 0, 0, 3633, 755, 1, 0, 0, 0, 3634,
		3635, 5, 86, 0, 0, 3635, 3636, 5, 373, 0, 0, 3636, 3637, 3, 758, 379, 0,
		3637, 3639, 5, 384, 0, 0, 3638, 3640, 3, 800, 400, 0, 3639, 3638, 1, 0,
		0, 0, 3639, 3640, 1, 0, 0, 0, 3640, 757, 1, 0, 0, 0, 3641, 3642, 5, 236,
		0, 0, 3642, 3643, 5, 317, 0, 0, 3643, 3648, 5, 151, 0, 0, 3644, 3645, 5,
		75, 0, 0, 3645, 3646, 5, 317, 0, 0, 3646, 3648, 5, 189, 0, 0, 3647, 3641,
		1, 0, 0, 0, 3647, 3644, 1, 0, 0, 0, 3648, 759, 1, 0, 0, 0, 3649, 3654,
		3, 768, 384, 0, 3650, 3654, 3, 774, 387, 0, 3651, 3654, 3, 776, 388, 0,
		3652, 3654, 3, 782, 391, 0, 3653, 3649, 1, 0, 0, 0, 3653, 3650, 1, 0, 0,
		0, 3653, 3651, 1, 0, 0, 0, 3653, 3652, 1, 0, 0, 0, 3654, 761, 1, 0, 0,
		0, 3655, 3658, 3, 764, 382, 0, 3656, 3658, 3, 766, 383, 0, 3657, 3655,
		1, 0, 0, 0, 3657, 3656, 1, 0, 0, 0, 3658, 763, 1, 0, 0, 0, 3659, 3660,
		5, 157, 0, 0, 3660, 765, 1, 0, 0, 0, 3661, 3662, 5, 157, 0, 0, 3662, 3665,
		3, 800, 400, 0, 3663, 3665, 5, 156, 0, 0, 3664, 3661, 1, 0, 0, 0, 3664,
		3663, 1, 0, 0, 0, 3665, 767, 1, 0, 0, 0, 3666, 3669, 3, 772, 386, 0, 3667,
		3669, 3, 770, 385, 0, 3668, 3666, 1, 0, 0, 0, 3668, 3667, 1, 0, 0, 0, 3669,
		769, 1, 0, 0, 0, 3670, 3672, 5, 308, 0, 0, 3671, 3670, 1, 0, 0, 0, 3671,
		3672, 1, 0, 0, 0, 3672, 3673, 1, 0, 0, 0, 3673, 3674, 5, 292, 0, 0, 3674,
		3676, 3, 574, 287, 0, 3675, 3677, 3, 800, 400, 0, 3676, 3675, 1, 0, 0,
		0, 3676, 3677, 1, 0, 0, 0, 3677, 771, 1, 0, 0, 0, 3678, 3680, 5, 28, 0,
		0, 3679, 3681, 5, 308, 0, 0, 3680, 3679, 1, 0, 0, 0, 3680, 3681, 1, 0,
		0, 0, 3681, 3682, 1, 0, 0, 0, 3682, 3684, 5, 292, 0, 0, 3683, 3685, 3,
		800, 400, 0, 3684, 3683, 1, 0, 0, 0, 3684, 3685, 1, 0, 0, 0, 3685, 773,
		1, 0, 0, 0, 3686, 3688, 3, 702, 351, 0, 3687, 3689, 3, 800, 400, 0, 3688,
		3687, 1, 0, 0, 0, 3688, 3689, 1, 0, 0, 0, 3689, 775, 1, 0, 0, 0, 3690,
		3693, 3, 780, 390, 0, 3691, 3693, 3, 778, 389, 0, 3692, 3690, 1, 0, 0,
		0, 3692, 3691, 1, 0, 0, 0, 3693, 777, 1, 0, 0, 0, 3694, 3696, 3, 588, 294,
		0, 3695, 3697, 3, 800, 400, 0, 3696, 3695, 1, 0, 0, 0, 3696, 3697, 1, 0,
		0, 0, 3697, 779, 1, 0, 0, 0, 3698, 3700, 5, 28, 0, 0, 3699, 3698, 1, 0,
		0, 0, 3699, 3700, 1, 0, 0, 0, 3700, 3701, 1, 0, 0, 0, 3701, 3703, 3, 1170,
		585, 0, 3702, 3704, 3, 800, 400, 0, 3703, 3702, 1, 0, 0, 0, 3703, 3704,
		1, 0, 0, 0, 3704, 781, 1, 0, 0, 0, 3705, 3708, 3, 786, 393, 0, 3706, 3708,
		3, 784, 392, 0, 3707, 3705, 1, 0, 0, 0, 3707, 3706, 1, 0, 0, 0, 3708, 783,
		1, 0, 0, 0, 3709, 3711, 3, 608, 304, 0, 3710, 3712, 3, 800, 400, 0, 3711,
		3710, 1, 0, 0, 0, 3711, 3712, 1, 0, 0, 0, 3712, 785, 1, 0, 0, 0, 3713,
		3715, 5, 28, 0, 0, 3714, 3713, 1, 0, 0, 0, 3714, 3715, 1, 0, 0, 0, 3715,
		3716, 1, 0, 0, 0, 3716, 3718, 3, 1174, 587, 0, 3717, 3719, 3, 800, 400,
		0, 3718, 3717, 1, 0, 0, 0, 3718, 3719, 1, 0, 0, 0, 3719, 787, 1, 0, 0,
		0, 3720, 3722, 5, 169, 0, 0, 3721, 3723, 3, 800, 400, 0, 3722, 3721, 1,
		0, 0, 0, 3722, 3723, 1, 0, 0, 0, 3723, 789, 1, 0, 0, 0, 3724, 3725, 3,
		792, 396, 0, 3725, 791, 1, 0, 0, 0, 3726, 3727, 7, 20, 0, 0, 3727, 793,
		1, 0, 0, 0, 3728, 3730, 5, 28, 0, 0, 3729, 3728, 1, 0, 0, 0, 3729, 3730,
		1, 0, 0, 0, 3730, 3731, 1, 0, 0, 0, 3731, 3733, 5, 179, 0, 0, 3732, 3734,
		3, 800, 400, 0, 3733, 3732, 1, 0, 0, 0, 3733, 3734, 1, 0, 0, 0, 3734, 3743,
		1, 0, 0, 0, 3735, 3737, 5, 179, 0, 0, 3736, 3735, 1, 0, 0, 0, 3736, 3737,
		1, 0, 0, 0, 3737, 3738, 1, 0, 0, 0, 3738, 3740, 3, 796, 398, 0, 3739, 3741,
		3, 800, 400, 0, 3740, 3739, 1, 0, 0, 0, 3740, 3741, 1, 0, 0, 0, 3741, 3743,
		1, 0, 0, 0, 3742, 3729, 1, 0, 0, 0, 3742, 3736, 1, 0, 0, 0, 3743, 795,
		1, 0, 0, 0, 3744, 3746, 5, 371, 0, 0, 3745, 3747, 3, 798, 399, 0, 3746,
		3745, 1, 0, 0, 0, 3746, 3747, 1, 0, 0, 0, 3747, 3748, 1, 0, 0, 0, 3748,
		3749, 5, 382, 0, 0, 3749, 797, 1, 0, 0, 0, 3750, 3755, 3, 802, 401, 0,
		3751, 3752, 5, 363, 0, 0, 3752, 3754, 3, 802, 401, 0, 3753, 3751, 1, 0,
		0, 0, 3754, 3757, 1, 0, 0, 0, 3755, 3753, 1, 0, 0, 0, 3755, 3756, 1, 0,
		0, 0, 3756, 799, 1, 0, 0, 0, 3757, 3755, 1, 0, 0, 0, 3758, 3759, 5, 155,
		0, 0, 3759, 3760, 5, 157, 0, 0, 3760, 801, 1, 0, 0, 0, 3761, 3763, 3, 1114,
		557, 0, 3762, 3764, 3, 706, 353, 0, 3763, 3762, 1, 0, 0, 0, 3763, 3764,
		1, 0, 0, 0, 3764, 3765, 1, 0, 0, 0, 3765, 3766, 3, 704, 352, 0, 3766, 803,
		1, 0, 0, 0, 3767, 3768, 3, 852, 426, 0, 3768, 805, 1, 0, 0, 0, 3769, 3779,
		3, 810, 405, 0, 3770, 3779, 3, 812, 406, 0, 3771, 3779, 3, 816, 408, 0,
		3772, 3779, 3, 822, 411, 0, 3773, 3779, 3, 826, 413, 0, 3774, 3779, 3,
		832, 416, 0, 3775, 3779, 3, 842, 421, 0, 3776, 3779, 3, 844, 422, 0, 3777,
		3779, 3, 846, 423, 0, 3778, 3769, 1, 0, 0, 0, 3778, 3770, 1, 0, 0, 0, 3778,
		3771, 1, 0, 0, 0, 3778, 3772, 1, 0, 0, 0, 3778, 3773, 1, 0, 0, 0, 3778,
		3774, 1, 0, 0, 0, 3778, 3775, 1, 0, 0, 0, 3778, 3776, 1, 0, 0, 0, 3778,
		3777, 1, 0, 0, 0, 3779, 807, 1, 0, 0, 0, 3780, 3781, 7, 21, 0, 0, 3781,
		809, 1, 0, 0, 0, 3782, 3800, 5, 92, 0, 0, 3783, 3784, 5, 371, 0, 0, 3784,
		3785, 3, 302, 151, 0, 3785, 3786, 5, 382, 0, 0, 3786, 3801, 1, 0, 0, 0,
		3787, 3788, 5, 373, 0, 0, 3788, 3789, 3, 302, 151, 0, 3789, 3790, 5, 384,
		0, 0, 3790, 3801, 1, 0, 0, 0, 3791, 3792, 5, 371, 0, 0, 3792, 3793, 3,
		220, 110, 0, 3793, 3794, 5, 382, 0, 0, 3794, 3801, 1, 0, 0, 0, 3795, 3796,
		5, 373, 0, 0, 3796, 3797, 3, 220, 110, 0, 3797, 3798, 5, 384, 0, 0, 3798,
		3801, 1, 0, 0, 0, 3799, 3801, 3, 56, 28, 0, 3800, 3783, 1, 0, 0, 0, 3800,
		3787, 1, 0, 0, 0, 3800, 3791, 1, 0, 0, 0, 3800, 3795, 1, 0, 0, 0, 3800,
		3799, 1, 0, 0, 0, 3801, 811, 1, 0, 0, 0, 3802, 3803, 3, 872, 436, 0, 3803,
		3804, 3, 814, 407, 0, 3804, 813, 1, 0, 0, 0, 3805, 3807, 5, 130, 0, 0,
		3806, 3808, 5, 155, 0, 0, 3807, 3806, 1, 0, 0, 0, 3807, 3808, 1, 0, 0,
		0, 3808, 3809, 1, 0, 0, 0, 3809, 3810, 5, 157, 0, 0, 3810, 815, 1, 0, 0,
		0, 3811, 3812, 3, 872, 436, 0, 3812, 3813, 3, 818, 409, 0, 3813, 817, 1,
		0, 0, 0, 3814, 3816, 5, 130, 0, 0, 3815, 3817, 5, 155, 0, 0, 3816, 3815,
		1, 0, 0, 0, 3816, 3817, 1, 0, 0, 0, 3817, 3818, 1, 0, 0, 0, 3818, 3819,
		3, 706, 353, 0, 3819, 3820, 3, 704, 352, 0, 3820, 819, 1, 0, 0, 0, 3821,
		3823, 5, 130, 0, 0, 3822, 3824, 5, 155, 0, 0, 3823, 3822, 1, 0, 0, 0, 3823,
		3824, 1, 0, 0, 0, 3824, 3826, 1, 0, 0, 0, 3825, 3827, 3, 1046, 523, 0,
		3826, 3825, 1, 0, 0, 0, 3826, 3827, 1, 0, 0, 0, 3827, 3828, 1, 0, 0, 0,
		3828, 3829, 5, 305, 0, 0, 3829, 821, 1, 0, 0, 0, 3830, 3831, 3, 432, 216,
		0, 3831, 3832, 3, 824, 412, 0, 3832, 823, 1, 0, 0, 0, 3833, 3835, 5, 130,
		0, 0, 3834, 3836, 5, 155, 0, 0, 3835, 3834, 1, 0, 0, 0, 3835, 3836, 1,
		0, 0, 0, 3836, 3837, 1, 0, 0, 0, 3837, 3838, 5, 286, 0, 0, 3838, 825, 1,
		0, 0, 0, 3839, 3840, 3, 432, 216, 0, 3840, 3841, 3, 828, 414, 0, 3841,
		827, 1, 0, 0, 0, 3842, 3843, 3, 830, 415, 0, 3843, 3844, 3, 428, 214, 0,
		3844, 829, 1, 0, 0, 0, 3845, 3847, 5, 130, 0, 0, 3846, 3848, 5, 155, 0,
		0, 3847, 3846, 1, 0, 0, 0, 3847, 3848, 1, 0, 0, 0, 3848, 3849, 1, 0, 0,
		0, 3849, 3852, 5, 296, 0, 0, 3850, 3852, 5, 362, 0, 0, 3851, 3845, 1, 0,
		0, 0, 3851, 3850, 1, 0, 0, 0, 3852, 831, 1, 0, 0, 0, 3853, 3854, 3, 834,
		417, 0, 3854, 3855, 3, 836, 418, 0, 3855, 3860, 1, 0, 0, 0, 3856, 3857,
		3, 834, 417, 0, 3857, 3858, 3, 838, 419, 0, 3858, 3860, 1, 0, 0, 0, 3859,
		3853, 1, 0, 0, 0, 3859, 3856, 1, 0, 0, 0, 3860, 833, 1, 0, 0, 0, 3861,
		3862, 3, 432, 216, 0, 3862, 835, 1, 0, 0, 0, 3863, 3865, 5, 130, 0, 0,
		3864, 3866, 5, 155, 0, 0, 3865, 3864, 1, 0, 0, 0, 3865, 3866, 1, 0, 0,
		0, 3866, 3867, 1, 0, 0, 0, 3867, 3868, 5, 315, 0, 0, 3868, 3869, 5, 161,
		0, 0, 3869, 3870, 3, 840, 420, 0, 3870, 837, 1, 0, 0, 0, 3871, 3873, 5,
		130, 0, 0, 3872, 3874, 5, 155, 0, 0, 3873, 3872, 1, 0, 0, 0, 3873, 3874,
		1, 0, 0, 0, 3874, 3875, 1, 0, 0, 0, 3875, 3876, 5, 284, 0, 0, 3876, 3877,
		5, 161, 0, 0, 3877, 3878, 3, 840, 420, 0, 3878, 839, 1, 0, 0, 0, 3879,
		3880, 3, 432, 216, 0, 3880, 841, 1, 0, 0, 0, 3881, 3882, 5, 26, 0, 0, 3882,
		3883, 5, 373, 0, 0, 3883, 3884, 3, 432, 216, 0, 3884, 3885, 5, 363, 0,
		0, 3885, 3890, 3, 432, 216, 0, 3886, 3887, 5, 363, 0, 0, 3887, 3889, 3,
		432, 216, 0, 3888, 3886, 1, 0, 0, 0, 3889, 3892, 1, 0, 0, 0, 3890, 3888,
		1, 0, 0, 0, 3890, 3891, 1, 0, 0, 0, 3891, 3893, 1, 0, 0, 0, 3892, 3890,
		1, 0, 0, 0, 3893, 3894, 5, 384, 0, 0, 3894, 843, 1, 0, 0, 0, 3895, 3896,
		5, 187, 0, 0, 3896, 3897, 5, 373, 0, 0, 3897, 3898, 3, 432, 216, 0, 3898,
		3899, 5, 363, 0, 0, 3899, 3904, 3, 432, 216, 0, 3900, 3901, 5, 363, 0,
		0, 3901, 3903, 3, 432, 216, 0, 3902, 3900, 1, 0, 0, 0, 3903, 3906, 1, 0,
		0, 0, 3904, 3902, 1, 0, 0, 0, 3904, 3905, 1, 0, 0, 0, 3905, 3907, 1, 0,
		0, 0, 3906, 3904, 1, 0, 0, 0, 3907, 3908, 5, 384, 0, 0, 3908, 845, 1, 0,
		0, 0, 3909, 3910, 5, 176, 0, 0, 3910, 3911, 5, 373, 0, 0, 3911, 3912, 3,
		432, 216, 0, 3912, 3913, 5, 363, 0, 0, 3913, 3914, 3, 1112, 556, 0, 3914,
		3915, 5, 384, 0, 0, 3915, 847, 1, 0, 0, 0, 3916, 3917, 6, 424, -1, 0, 3917,
		3918, 7, 22, 0, 0, 3918, 3935, 3, 848, 424, 15, 3919, 3935, 3, 806, 403,
		0, 3920, 3921, 5, 155, 0, 0, 3921, 3935, 3, 848, 424, 8, 3922, 3924, 5,
		308, 0, 0, 3923, 3922, 1, 0, 0, 0, 3923, 3924, 1, 0, 0, 0, 3924, 3925,
		1, 0, 0, 0, 3925, 3926, 5, 292, 0, 0, 3926, 3935, 3, 88, 44, 0, 3927, 3929,
		5, 281, 0, 0, 3928, 3927, 1, 0, 0, 0, 3928, 3929, 1, 0, 0, 0, 3929, 3930,
		1, 0, 0, 0, 3930, 3931, 5, 316, 0, 0, 3931, 3935, 3, 92, 46, 0, 3932, 3935,
		3, 850, 425, 0, 3933, 3935, 3, 872, 436, 0, 3934, 3916, 1, 0, 0, 0, 3934,
		3919, 1, 0, 0, 0, 3934, 3920, 1, 0, 0, 0, 3934, 3923, 1, 0, 0, 0, 3934,
		3928, 1, 0, 0, 0, 3934, 3932, 1, 0, 0, 0, 3934, 3933, 1, 0, 0, 0, 3935,
		3965, 1, 0, 0, 0, 3936, 3937, 10, 14, 0, 0, 3937, 3938, 7, 23, 0, 0, 3938,
		3964, 3, 848, 424, 15, 3939, 3940, 10, 13, 0, 0, 3940, 3941, 7, 22, 0,
		0, 3941, 3964, 3, 848, 424, 14, 3942, 3943, 10, 12, 0, 0, 3943, 3944, 5,
		333, 0, 0, 3944, 3964, 3, 848, 424, 13, 3945, 3946, 10, 11, 0, 0, 3946,
		3947, 3, 808, 404, 0, 3947, 3948, 3, 848, 424, 12, 3948, 3964, 1, 0, 0,
		0, 3949, 3950, 10, 6, 0, 0, 3950, 3951, 5, 27, 0, 0, 3951, 3964, 3, 848,
		424, 7, 3952, 3953, 10, 5, 0, 0, 3953, 3954, 7, 24, 0, 0, 3954, 3964, 3,
		848, 424, 6, 3955, 3956, 10, 9, 0, 0, 3956, 3964, 3, 820, 410, 0, 3957,
		3958, 10, 7, 0, 0, 3958, 3960, 5, 130, 0, 0, 3959, 3961, 5, 155, 0, 0,
		3960, 3959, 1, 0, 0, 0, 3960, 3961, 1, 0, 0, 0, 3961, 3962, 1, 0, 0, 0,
		3962, 3964, 3, 980, 490, 0, 3963, 3936, 1, 0, 0, 0, 3963, 3939, 1, 0, 0,
		0, 3963, 3942, 1, 0, 0, 0, 3963, 3945, 1, 0, 0, 0, 3963, 3949, 1, 0, 0,
		0, 3963, 3952, 1, 0, 0, 0, 3963, 3955, 1, 0, 0, 0, 3963, 3957, 1, 0, 0,
		0, 3964, 3967, 1, 0, 0, 0, 3965, 3963, 1, 0, 0, 0, 3965, 3966, 1, 0, 0,
		0, 3966, 849, 1, 0, 0, 0, 3967, 3965, 1, 0, 0, 0, 3968, 3975, 3, 984, 492,
		0, 3969, 3975, 3, 1072, 536, 0, 3970, 3975, 3, 1052, 526, 0, 3971, 3975,
		3, 1080, 540, 0, 3972, 3975, 3, 854, 427, 0, 3973, 3975, 3, 958, 479, 0,
		3974, 3968, 1, 0, 0, 0, 3974, 3969, 1, 0, 0, 0, 3974, 3970, 1, 0, 0, 0,
		3974, 3971, 1, 0, 0, 0, 3974, 3972, 1, 0, 0, 0, 3974, 3973, 1, 0, 0, 0,
		3975, 851, 1, 0, 0, 0, 3976, 3977, 3, 848, 424, 0, 3977, 853, 1, 0, 0,
		0, 3978, 3984, 3, 856, 428, 0, 3979, 3984, 3, 858, 429, 0, 3980, 3984,
		3, 860, 430, 0, 3981, 3984, 3, 862, 431, 0, 3982, 3984, 3, 864, 432, 0,
		3983, 3978, 1, 0, 0, 0, 3983, 3979, 1, 0, 0, 0, 3983, 3980, 1, 0, 0, 0,
		3983, 3981, 1, 0, 0, 0, 3983, 3982, 1, 0, 0, 0, 3984, 855, 1, 0, 0, 0,
		3985, 3986, 7, 25, 0, 0, 3986, 3987, 5, 373, 0, 0, 3987, 3988, 3, 848,
		424, 0, 3988, 3989, 5, 363, 0, 0, 3989, 3990, 3, 1048, 524, 0, 3990, 3991,
		5, 384, 0, 0, 3991, 857, 1, 0, 0, 0, 3992, 3993, 5, 213, 0, 0, 3993, 3994,
		5, 373, 0, 0, 3994, 3995, 3, 1038, 519, 0, 3995, 3996, 5, 384, 0, 0, 3996,
		859, 1, 0, 0, 0, 3997, 3998, 7, 26, 0, 0, 3998, 3999, 5, 373, 0, 0, 3999,
		4000, 3, 848, 424, 0, 4000, 4001, 5, 384, 0, 0, 4001, 861, 1, 0, 0, 0,
		4002, 4003, 7, 27, 0, 0, 4003, 4004, 5, 373, 0, 0, 4004, 4007, 3, 848,
		424, 0, 4005, 4006, 5, 363, 0, 0, 4006, 4008, 3, 848, 424, 0, 4007, 4005,
		1, 0, 0, 0, 4007, 4008, 1, 0, 0, 0, 4008, 4009, 1, 0, 0, 0, 4009, 4010,
		5, 384, 0, 0, 4010, 863, 1, 0, 0, 0, 4011, 4012, 5, 154, 0, 0, 4012, 4013,
		5, 373, 0, 0, 4013, 4016, 3, 848, 424, 0, 4014, 4015, 5, 363, 0, 0, 4015,
		4017, 3, 1046, 523, 0, 4016, 4014, 1, 0, 0, 0, 4016, 4017, 1, 0, 0, 0,
		4017, 4018, 1, 0, 0, 0, 4018, 4019, 5, 384, 0, 0, 4019, 865, 1, 0, 0, 0,
		4020, 4021, 3, 872, 436, 0, 4021, 867, 1, 0, 0, 0, 4022, 4023, 3, 872,
		436, 0, 4023, 869, 1, 0, 0, 0, 4024, 4025, 3, 848, 424, 0, 4025, 871, 1,
		0, 0, 0, 4026, 4027, 6, 436, -1, 0, 4027, 4038, 3, 874, 437, 0, 4028, 4038,
		3, 924, 462, 0, 4029, 4038, 3, 880, 440, 0, 4030, 4038, 3, 946, 473, 0,
		4031, 4038, 3, 890, 445, 0, 4032, 4038, 3, 892, 446, 0, 4033, 4038, 3,
		918, 459, 0, 4034, 4038, 3, 940, 470, 0, 4035, 4038, 3, 888, 444, 0, 4036,
		4038, 3, 942, 471, 0, 4037, 4026, 1, 0, 0, 0, 4037, 4028, 1, 0, 0, 0, 4037,
		4029, 1, 0, 0, 0, 4037, 4030, 1, 0, 0, 0, 4037, 4031, 1, 0, 0, 0, 4037,
		4032, 1, 0, 0, 0, 4037, 4033, 1, 0, 0, 0, 4037, 4034, 1, 0, 0, 0, 4037,
		4035, 1, 0, 0, 0, 4037, 4036, 1, 0, 0, 0, 4038, 4044, 1, 0, 0, 0, 4039,
		4040, 10, 7, 0, 0, 4040, 4041, 5, 377, 0, 0, 4041, 4043, 3, 1112, 556,
		0, 4042, 4039, 1, 0, 0, 0, 4043, 4046, 1, 0, 0, 0, 4044, 4042, 1, 0, 0,
		0, 4044, 4045, 1, 0, 0, 0, 4045, 873, 1, 0, 0, 0, 4046, 4044, 1, 0, 0,
		0, 4047, 4048, 5, 373, 0, 0, 4048, 4049, 3, 848, 424, 0, 4049, 4050, 5,
		384, 0, 0, 4050, 875, 1, 0, 0, 0, 4051, 4054, 3, 878, 439, 0, 4052, 4054,
		3, 942, 471, 0, 4053, 4051, 1, 0, 0, 0, 4053, 4052, 1, 0, 0, 0, 4054, 877,
		1, 0, 0, 0, 4055, 4068, 3, 924, 462, 0, 4056, 4068, 3, 880, 440, 0, 4057,
		4068, 3, 946, 473, 0, 4058, 4059, 3, 872, 436, 0, 4059, 4060, 5, 377, 0,
		0, 4060, 4061, 3, 1112, 556, 0, 4061, 4068, 1, 0, 0, 0, 4062, 4068, 3,
		890, 445, 0, 4063, 4068, 3, 892, 446, 0, 4064, 4068, 3, 918, 459, 0, 4065,
		4068, 3, 940, 470, 0, 4066, 4068, 3, 888, 444, 0, 4067, 4055, 1, 0, 0,
		0, 4067, 4056, 1, 0, 0, 0, 4067, 4057, 1, 0, 0, 0, 4067, 4058, 1, 0, 0,
		0, 4067, 4062, 1, 0, 0, 0, 4067, 4063, 1, 0, 0, 0, 4067, 4064, 1, 0, 0,
		0, 4067, 4065, 1, 0, 0, 0, 4067, 4066, 1, 0, 0, 0, 4068, 879, 1, 0, 0,
		0, 4069, 4072, 3, 1124, 562, 0, 4070, 4072, 3, 884, 442, 0, 4071, 4069,
		1, 0, 0, 0, 4071, 4070, 1, 0, 0, 0, 4072, 881, 1, 0, 0, 0, 4073, 4076,
		3, 1154, 577, 0, 4074, 4076, 3, 886, 443, 0, 4075, 4073, 1, 0, 0, 0, 4075,
		4074, 1, 0, 0, 0, 4076, 883, 1, 0, 0, 0, 4077, 4080, 3, 886, 443, 0, 4078,
		4080, 5, 192, 0, 0, 4079, 4077, 1, 0, 0, 0, 4079, 4078, 1, 0, 0, 0, 4080,
		885, 1, 0, 0, 0, 4081, 4082, 5, 329, 0, 0, 4082, 887, 1, 0, 0, 0, 4083,
		4084, 5, 133, 0, 0, 4084, 4085, 3, 228, 114, 0, 4085, 4086, 5, 112, 0,
		0, 4086, 4087, 3, 848, 424, 0, 4087, 4088, 5, 90, 0, 0, 4088, 889, 1, 0,
		0, 0, 4089, 4090, 5, 228, 0, 0, 4090, 4091, 3, 56, 28, 0, 4091, 891, 1,
		0, 0, 0, 4092, 4095, 3, 894, 447, 0, 4093, 4095, 3, 896, 448, 0, 4094,
		4092, 1, 0, 0, 0, 4094, 4093, 1, 0, 0, 0, 4095, 893, 1, 0, 0, 0, 4096,
		4097, 5, 159, 0, 0, 4097, 4098, 5, 373, 0, 0, 4098, 4099, 3, 848, 424,
		0, 4099, 4100, 5, 363, 0, 0, 4100, 4101, 3, 848, 424, 0, 4101, 4102, 5,
		384, 0, 0, 4102, 4115, 1, 0, 0, 0, 4103, 4104, 5, 58, 0, 0, 4104, 4105,
		5, 373, 0, 0, 4105, 4108, 3, 848, 424, 0, 4106, 4107, 5, 363, 0, 0, 4107,
		4109, 3, 848, 424, 0, 4108, 4106, 1, 0, 0, 0, 4109, 4110, 1, 0, 0, 0, 4110,
		4108, 1, 0, 0, 0, 4110, 4111, 1, 0, 0, 0, 4111, 4112, 1, 0, 0, 0, 4112,
		4113, 5, 384, 0, 0, 4113, 4115, 1, 0, 0, 0, 4114, 4096, 1, 0, 0, 0, 4114,
		4103, 1, 0, 0, 0, 4115, 895, 1, 0, 0, 0, 4116, 4119, 3, 898, 449, 0, 4117,
		4119, 3, 900, 450, 0, 4118, 4116, 1, 0, 0, 0, 4118, 4117, 1, 0, 0, 0, 4119,
		897, 1, 0, 0, 0, 4120, 4121, 5, 49, 0, 0, 4121, 4123, 3, 908, 454, 0, 4122,
		4124, 3, 902, 451, 0, 4123, 4122, 1, 0, 0, 0, 4124, 4125, 1, 0, 0, 0, 4125,
		4123, 1, 0, 0, 0, 4125, 4126, 1, 0, 0, 0, 4126, 4128, 1, 0, 0, 0, 4127,
		4129, 3, 906, 453, 0, 4128, 4127, 1, 0, 0, 0, 4128, 4129, 1, 0, 0, 0, 4129,
		4130, 1, 0, 0, 0, 4130, 4131, 5, 90, 0, 0, 4131, 899, 1, 0, 0, 0, 4132,
		4134, 5, 49, 0, 0, 4133, 4135, 3, 904, 452, 0, 4134, 4133, 1, 0, 0, 0,
		4135, 4136, 1, 0, 0, 0, 4136, 4134, 1, 0, 0, 0, 4136, 4137, 1, 0, 0, 0,
		4137, 4139, 1, 0, 0, 0, 4138, 4140, 3, 906, 453, 0, 4139, 4138, 1, 0, 0,
		0, 4139, 4140, 1, 0, 0, 0, 4140, 4141, 1, 0, 0, 0, 4141, 4142, 5, 90, 0,
		0, 4142, 901, 1, 0, 0, 0, 4143, 4144, 5, 232, 0, 0, 4144, 4145, 3, 910,
		455, 0, 4145, 4146, 5, 209, 0, 0, 4146, 4147, 3, 914, 457, 0, 4147, 903,
		1, 0, 0, 0, 4148, 4149, 5, 232, 0, 0, 4149, 4150, 3, 804, 402, 0, 4150,
		4151, 5, 209, 0, 0, 4151, 4152, 3, 914, 457, 0, 4152, 905, 1, 0, 0, 0,
		4153, 4154, 5, 89, 0, 0, 4154, 4155, 3, 914, 457, 0, 4155, 907, 1, 0, 0,
		0, 4156, 4159, 3, 876, 438, 0, 4157, 4159, 3, 432, 216, 0, 4158, 4156,
		1, 0, 0, 0, 4158, 4157, 1, 0, 0, 0, 4159, 909, 1, 0, 0, 0, 4160, 4165,
		3, 912, 456, 0, 4161, 4162, 5, 363, 0, 0, 4162, 4164, 3, 912, 456, 0, 4163,
		4161, 1, 0, 0, 0, 4164, 4167, 1, 0, 0, 0, 4165, 4163, 1, 0, 0, 0, 4165,
		4166, 1, 0, 0, 0, 4166, 911, 1, 0, 0, 0, 4167, 4165, 1, 0, 0, 0, 4168,
		4180, 3, 876, 438, 0, 4169, 4170, 3, 808, 404, 0, 4170, 4171, 3, 848, 424,
		0, 4171, 4180, 1, 0, 0, 0, 4172, 4180, 3, 814, 407, 0, 4173, 4180, 3, 818,
		409, 0, 4174, 4180, 3, 820, 410, 0, 4175, 4180, 3, 824, 412, 0, 4176, 4180,
		3, 828, 414, 0, 4177, 4180, 3, 836, 418, 0, 4178, 4180, 3, 838, 419, 0,
		4179, 4168, 1, 0, 0, 0, 4179, 4169, 1, 0, 0, 0, 4179, 4172, 1, 0, 0, 0,
		4179, 4173, 1, 0, 0, 0, 4179, 4174, 1, 0, 0, 0, 4179, 4175, 1, 0, 0, 0,
		4179, 4176, 1, 0, 0, 0, 4179, 4177, 1, 0, 0, 0, 4179, 4178, 1, 0, 0, 0,
		4180, 913, 1, 0, 0, 0, 4181, 4184, 3, 916, 458, 0, 4182, 4184, 3, 1158,
		579, 0, 4183, 4181, 1, 0, 0, 0, 4183, 4182, 1, 0, 0, 0, 4184, 915, 1, 0,
		0, 0, 4185, 4186, 3, 848, 424, 0, 4186, 917, 1, 0, 0, 0, 4187, 4188, 5,
		50, 0, 0, 4188, 4189, 5, 373, 0, 0, 4189, 4190, 3, 920, 460, 0, 4190, 4191,
		5, 30, 0, 0, 4191, 4192, 3, 922, 461, 0, 4192, 4193, 5, 384, 0, 0, 4193,
		919, 1, 0, 0, 0, 4194, 4197, 3, 848, 424, 0, 4195, 4197, 3, 1158, 579,
		0, 4196, 4194, 1, 0, 0, 0, 4196, 4195, 1, 0, 0, 0, 4197, 921, 1, 0, 0,
		0, 4198, 4199, 3, 704, 352, 0, 4199, 923, 1, 0, 0, 0, 4200, 4201, 5, 65,
		0, 0, 4201, 4202, 5, 373, 0, 0, 4202, 4203, 5, 361, 0, 0, 4203, 4207, 5,
		384, 0, 0, 4204, 4207, 3, 926, 463, 0, 4205, 4207, 3, 928, 464, 0, 4206,
		4200, 1, 0, 0, 0, 4206, 4204, 1, 0, 0, 0, 4206, 4205, 1, 0, 0, 0, 4207,
		925, 1, 0, 0, 0, 4208, 4209, 3, 930, 465, 0, 4209, 4211, 5, 373, 0, 0,
		4210, 4212, 3, 932, 466, 0, 4211, 4210, 1, 0, 0, 0, 4211, 4212, 1, 0, 0,
		0, 4212, 4213, 1, 0, 0, 0, 4213, 4214, 3, 848, 424, 0, 4214, 4215, 5, 384,
		0, 0, 4215, 927, 1, 0, 0, 0, 4216, 4217, 3, 934, 467, 0, 4217, 4218, 5,
		373, 0, 0, 4218, 4219, 3, 936, 468, 0, 4219, 4220, 5, 363, 0, 0, 4220,
		4221, 3, 938, 469, 0, 4221, 4222, 5, 384, 0, 0, 4222, 929, 1, 0, 0, 0,
		4223, 4224, 7, 28, 0, 0, 4224, 931, 1, 0, 0, 0, 4225, 4226, 7, 29, 0, 0,
		4226, 933, 1, 0, 0, 0, 4227, 4228, 7, 30, 0, 0, 4228, 935, 1, 0, 0, 0,
		4229, 4231, 3, 932, 466, 0, 4230, 4229, 1, 0, 0, 0, 4230, 4231, 1, 0, 0,
		0, 4231, 4232, 1, 0, 0, 0, 4232, 4233, 3, 982, 491, 0, 4233, 937, 1, 0,
		0, 0, 4234, 4235, 3, 982, 491, 0, 4235, 939, 1, 0, 0, 0, 4236, 4237, 5,
		88, 0, 0, 4237, 4238, 5, 373, 0, 0, 4238, 4239, 3, 432, 216, 0, 4239, 4240,
		5, 384, 0, 0, 4240, 941, 1, 0, 0, 0, 4241, 4242, 3, 1122, 561, 0, 4242,
		943, 1, 0, 0, 0, 4243, 4244, 3, 848, 424, 0, 4244, 945, 1, 0, 0, 0, 4245,
		4246, 3, 948, 474, 0, 4246, 947, 1, 0, 0, 0, 4247, 4248, 5, 169, 0, 0,
		4248, 4249, 5, 372, 0, 0, 4249, 4250, 3, 950, 475, 0, 4250, 4251, 5, 383,
		0, 0, 4251, 949, 1, 0, 0, 0, 4252, 4256, 3, 952, 476, 0, 4253, 4255, 3,
		954, 477, 0, 4254, 4253, 1, 0, 0, 0, 4255, 4258, 1, 0, 0, 0, 4256, 4254,
		1, 0, 0, 0, 4256, 4257, 1, 0, 0, 0, 4257, 951, 1, 0, 0, 0, 4258, 4256,
		1, 0, 0, 0, 4259, 4260, 3, 866, 433, 0, 4260, 953, 1, 0, 0, 0, 4261, 4262,
		5, 363, 0, 0, 4262, 4263, 3, 868, 434, 0, 4263, 4264, 5, 363, 0, 0, 4264,
		4265, 3, 866, 433, 0, 4265, 955, 1, 0, 0, 0, 4266, 4267, 3, 848, 424, 0,
		4267, 957, 1, 0, 0, 0, 4268, 4271, 3, 960, 480, 0, 4269, 4271, 3, 962,
		481, 0, 4270, 4268, 1, 0, 0, 0, 4270, 4269, 1, 0, 0, 0, 4271, 959, 1, 0,
		0, 0, 4272, 4273, 5, 213, 0, 0, 4273, 4274, 5, 373, 0, 0, 4274, 4275, 3,
		956, 478, 0, 4275, 4276, 5, 363, 0, 0, 4276, 4277, 3, 982, 491, 0, 4277,
		4278, 5, 384, 0, 0, 4278, 961, 1, 0, 0, 0, 4279, 4280, 5, 290, 0, 0, 4280,
		4281, 5, 373, 0, 0, 4281, 4282, 3, 944, 472, 0, 4282, 4283, 5, 384, 0,
		0, 4283, 963, 1, 0, 0, 0, 4284, 4285, 3, 966, 483, 0, 4285, 965, 1, 0,
		0, 0, 4286, 4288, 3, 790, 395, 0, 4287, 4286, 1, 0, 0, 0, 4287, 4288, 1,
		0, 0, 0, 4288, 4289, 1, 0, 0, 0, 4289, 4291, 5, 372, 0, 0, 4290, 4292,
		3, 968, 484, 0, 4291, 4290, 1, 0, 0, 0, 4291, 4292, 1, 0, 0, 0, 4292, 4293,
		1, 0, 0, 0, 4293, 4294, 5, 383, 0, 0, 4294, 967, 1, 0, 0, 0, 4295, 4300,
		3, 970, 485, 0, 4296, 4297, 5, 363, 0, 0, 4297, 4299, 3, 970, 485, 0, 4298,
		4296, 1, 0, 0, 0, 4299, 4302, 1, 0, 0, 0, 4300, 4298, 1, 0, 0, 0, 4300,
		4301, 1, 0, 0, 0, 4301, 969, 1, 0, 0, 0, 4302, 4300, 1, 0, 0, 0, 4303,
		4304, 3, 848, 424, 0, 4304, 971, 1, 0, 0, 0, 4305, 4307, 5, 179, 0, 0,
		4306, 4305, 1, 0, 0, 0, 4306, 4307, 1, 0, 0, 0, 4307, 4308, 1, 0, 0, 0,
		4308, 4309, 3, 974, 487, 0, 4309, 973, 1, 0, 0, 0, 4310, 4312, 5, 371,
		0, 0, 4311, 4313, 3, 976, 488, 0, 4312, 4311, 1, 0, 0, 0, 4312, 4313, 1,
		0, 0, 0, 4313, 4314, 1, 0, 0, 0, 4314, 4315, 5, 382, 0, 0, 4315, 975, 1,
		0, 0, 0, 4316, 4321, 3, 978, 489, 0, 4317, 4318, 5, 363, 0, 0, 4318, 4320,
		3, 978, 489, 0, 4319, 4317, 1, 0, 0, 0, 4320, 4323, 1, 0, 0, 0, 4321, 4319,
		1, 0, 0, 0, 4321, 4322, 1, 0, 0, 0, 4322, 977, 1, 0, 0, 0, 4323, 4321,
		1, 0, 0, 0, 4324, 4325, 3, 1114, 557, 0, 4325, 4326, 5, 362, 0, 0, 4326,
		4327, 3, 848, 424, 0, 4327, 979, 1, 0, 0, 0, 4328, 4329, 5, 5, 0, 0, 4329,
		981, 1, 0, 0, 0, 4330, 4331, 6, 491, -1, 0, 4331, 4332, 7, 22, 0, 0, 4332,
		4336, 3, 982, 491, 5, 4333, 4336, 3, 872, 436, 0, 4334, 4336, 3, 984, 492,
		0, 4335, 4330, 1, 0, 0, 0, 4335, 4333, 1, 0, 0, 0, 4335, 4334, 1, 0, 0,
		0, 4336, 4345, 1, 0, 0, 0, 4337, 4338, 10, 4, 0, 0, 4338, 4339, 7, 23,
		0, 0, 4339, 4344, 3, 982, 491, 5, 4340, 4341, 10, 3, 0, 0, 4341, 4342,
		7, 22, 0, 0, 4342, 4344, 3, 982, 491, 4, 4343, 4337, 1, 0, 0, 0, 4343,
		4340, 1, 0, 0, 0, 4344, 4347, 1, 0, 0, 0, 4345, 4343, 1, 0, 0, 0, 4345,
		4346, 1, 0, 0, 0, 4346, 983, 1, 0, 0, 0, 4347, 4345, 1, 0, 0, 0, 4348,
		4362, 3, 986, 493, 0, 4349, 4362, 3, 988, 494, 0, 4350, 4362, 3, 998, 499,
		0, 4351, 4362, 3, 1000, 500, 0, 4352, 4362, 3, 1006, 503, 0, 4353, 4362,
		3, 1010, 505, 0, 4354, 4362, 3, 1016, 508, 0, 4355, 4362, 3, 1018, 509,
		0, 4356, 4362, 3, 1020, 510, 0, 4357, 4362, 3, 1022, 511, 0, 4358, 4362,
		3, 1028, 514, 0, 4359, 4362, 3, 1030, 515, 0, 4360, 4362, 3, 1032, 516,
		0, 4361, 4348, 1, 0, 0, 0, 4361, 4349, 1, 0, 0, 0, 4361, 4350, 1, 0, 0,
		0, 4361, 4351, 1, 0, 0, 0, 4361, 4352, 1, 0, 0, 0, 4361, 4353, 1, 0, 0,
		0, 4361, 4354, 1, 0, 0, 0, 4361, 4355, 1, 0, 0, 0, 4361, 4356, 1, 0, 0,
		0, 4361, 4357, 1, 0, 0, 0, 4361, 4358, 1, 0, 0, 0, 4361, 4359, 1, 0, 0,
		0, 4361, 4360, 1, 0, 0, 0, 4362, 985, 1, 0, 0, 0, 4363, 4367, 3, 992, 496,
		0, 4364, 4367, 3, 994, 497, 0, 4365, 4367, 3, 996, 498, 0, 4366, 4363,
		1, 0, 0, 0, 4366, 4364, 1, 0, 0, 0, 4366, 4365, 1, 0, 0, 0, 4367, 987,
		1, 0, 0, 0, 4368, 4369, 5, 48, 0, 0, 4369, 4370, 5, 373, 0, 0, 4370, 4371,
		3, 990, 495, 0, 4371, 4372, 5, 384, 0, 0, 4372, 4379, 1, 0, 0, 0, 4373,
		4374, 5, 197, 0, 0, 4374, 4375, 5, 373, 0, 0, 4375, 4376, 3, 956, 478,
		0, 4376, 4377, 5, 384, 0, 0, 4377, 4379, 1, 0, 0, 0, 4378, 4368, 1, 0,
		0, 0, 4378, 4373, 1, 0, 0, 0, 4379, 989, 1, 0, 0, 0, 4380, 4381, 3, 848,
		424, 0, 4381, 991, 1, 0, 0, 0, 4382, 4383, 7, 31, 0, 0, 4383, 4384, 5,
		373, 0, 0, 4384, 4385, 3, 1034, 517, 0, 4385, 4386, 5, 384, 0, 0, 4386,
		993, 1, 0, 0, 0, 4387, 4388, 7, 32, 0, 0, 4388, 4389, 5, 373, 0, 0, 4389,
		4390, 3, 1036, 518, 0, 4390, 4391, 5, 384, 0, 0, 4391, 995, 1, 0, 0, 0,
		4392, 4393, 5, 170, 0, 0, 4393, 4394, 5, 373, 0, 0, 4394, 4395, 3, 944,
		472, 0, 4395, 4396, 5, 384, 0, 0, 4396, 997, 1, 0, 0, 0, 4397, 4398, 5,
		23, 0, 0, 4398, 4399, 5, 373, 0, 0, 4399, 4400, 3, 848, 424, 0, 4400, 4401,
		5, 384, 0, 0, 4401, 999, 1, 0, 0, 0, 4402, 4403, 5, 150, 0, 0, 4403, 4404,
		5, 373, 0, 0, 4404, 4405, 3, 1002, 501, 0, 4405, 4406, 5, 363, 0, 0, 4406,
		4407, 3, 1004, 502, 0, 4407, 4408, 5, 384, 0, 0, 4408, 1001, 1, 0, 0, 0,
		4409, 4410, 3, 982, 491, 0, 4410, 1003, 1, 0, 0, 0, 4411, 4412, 3, 982,
		491, 0, 4412, 1005, 1, 0, 0, 0, 4413, 4414, 3, 1008, 504, 0, 4414, 4415,
		5, 373, 0, 0, 4415, 4416, 3, 982, 491, 0, 4416, 4417, 5, 384, 0, 0, 4417,
		1007, 1, 0, 0, 0, 4418, 4419, 7, 33, 0, 0, 4419, 1009, 1, 0, 0, 0, 4420,
		4421, 5, 142, 0, 0, 4421, 4422, 5, 373, 0, 0, 4422, 4423, 3, 1012, 506,
		0, 4423, 4424, 5, 363, 0, 0, 4424, 4425, 3, 1014, 507, 0, 4425, 4426, 5,
		384, 0, 0, 4426, 1011, 1, 0, 0, 0, 4427, 4428, 3, 982, 491, 0, 4428, 1013,
		1, 0, 0, 0, 4429, 4430, 3, 982, 491, 0, 4430, 1015, 1, 0, 0, 0, 4431, 4432,
		5, 143, 0, 0, 4432, 4433, 5, 373, 0, 0, 4433, 4434, 3, 982, 491, 0, 4434,
		4435, 5, 384, 0, 0, 4435, 1017, 1, 0, 0, 0, 4436, 4437, 5, 137, 0, 0, 4437,
		4438, 5, 373, 0, 0, 4438, 4439, 3, 982, 491, 0, 4439, 4440, 5, 384, 0,
		0, 4440, 1019, 1, 0, 0, 0, 4441, 4442, 5, 93, 0, 0, 4442, 4443, 5, 373,
		0, 0, 4443, 4444, 3, 982, 491, 0, 4444, 4445, 5, 384, 0, 0, 4445, 1021,
		1, 0, 0, 0, 4446, 4447, 5, 174, 0, 0, 4447, 4448, 5, 373, 0, 0, 4448, 4449,
		3, 1024, 512, 0, 4449, 4450, 5, 363, 0, 0, 4450, 4451, 3, 1026, 513, 0,
		4451, 4452, 5, 384, 0, 0, 4452, 1023, 1, 0, 0, 0, 4453, 4454, 3, 982, 491,
		0, 4454, 1025, 1, 0, 0, 0, 4455, 4456, 3, 982, 491, 0, 4456, 1027, 1, 0,
		0, 0, 4457, 4458, 5, 201, 0, 0, 4458, 4459, 5, 373, 0, 0, 4459, 4460, 3,
		982, 491, 0, 4460, 4461, 5, 384, 0, 0, 4461, 1029, 1, 0, 0, 0, 4462, 4463,
		5, 102, 0, 0, 4463, 4464, 5, 373, 0, 0, 4464, 4465, 3, 982, 491, 0, 4465,
		4466, 5, 384, 0, 0, 4466, 1031, 1, 0, 0, 0, 4467, 4468, 7, 34, 0, 0, 4468,
		4469, 5, 373, 0, 0, 4469, 4470, 3, 982, 491, 0, 4470, 4471, 5, 384, 0,
		0, 4471, 1033, 1, 0, 0, 0, 4472, 4473, 3, 848, 424, 0, 4473, 1035, 1, 0,
		0, 0, 4474, 4475, 3, 848, 424, 0, 4475, 1037, 1, 0, 0, 0, 4476, 4478, 3,
		1042, 521, 0, 4477, 4476, 1, 0, 0, 0, 4477, 4478, 1, 0, 0, 0, 4478, 4480,
		1, 0, 0, 0, 4479, 4481, 3, 1044, 522, 0, 4480, 4479, 1, 0, 0, 0, 4480,
		4481, 1, 0, 0, 0, 4481, 4482, 1, 0, 0, 0, 4482, 4484, 5, 104, 0, 0, 4483,
		4477, 1, 0, 0, 0, 4483, 4484, 1, 0, 0, 0, 4484, 4485, 1, 0, 0, 0, 4485,
		4486, 3, 1040, 520, 0, 4486, 1039, 1, 0, 0, 0, 4487, 4488, 3, 848, 424,
		0, 4488, 1041, 1, 0, 0, 0, 4489, 4490, 7, 35, 0, 0, 4490, 1043, 1, 0, 0,
		0, 4491, 4492, 3, 848, 424, 0, 4492, 1045, 1, 0, 0, 0, 4493, 4494, 7, 36,
		0, 0, 4494, 1047, 1, 0, 0, 0, 4495, 4496, 3, 982, 491, 0, 4496, 1049, 1,
		0, 0, 0, 4497, 4498, 3, 848, 424, 0, 4498, 1051, 1, 0, 0, 0, 4499, 4505,
		3, 1054, 527, 0, 4500, 4505, 3, 1056, 528, 0, 4501, 4505, 3, 1060, 530,
		0, 4502, 4505, 3, 1058, 529, 0, 4503, 4505, 3, 1062, 531, 0, 4504, 4499,
		1, 0, 0, 0, 4504, 4500, 1, 0, 0, 0, 4504, 4501, 1, 0, 0, 0, 4504, 4502,
		1, 0, 0, 0, 4504, 4503, 1, 0, 0, 0, 4505, 1053, 1, 0, 0, 0, 4506, 4514,
		5, 67, 0, 0, 4507, 4508, 5, 73, 0, 0, 4508, 4510, 5, 373, 0, 0, 4509, 4511,
		3, 1064, 532, 0, 4510, 4509, 1, 0, 0, 0, 4510, 4511, 1, 0, 0, 0, 4511,
		4512, 1, 0, 0, 0, 4512, 4514, 5, 384, 0, 0, 4513, 4506, 1, 0, 0, 0, 4513,
		4507, 1, 0, 0, 0, 4514, 1055, 1, 0, 0, 0, 4515, 4523, 5, 71, 0, 0, 4516,
		4517, 5, 240, 0, 0, 4517, 4519, 5, 373, 0, 0, 4518, 4520, 3, 1066, 533,
		0, 4519, 4518, 1, 0, 0, 0, 4519, 4520, 1, 0, 0, 0, 4520, 4521, 1, 0, 0,
		0, 4521, 4523, 5, 384, 0, 0, 4522, 4515, 1, 0, 0, 0, 4522, 4516, 1, 0,
		0, 0, 4523, 1057, 1, 0, 0, 0, 4524, 4530, 5, 140, 0, 0, 4525, 4527, 5,
		373, 0, 0, 4526, 4528, 3, 1066, 533, 0, 4527, 4526, 1, 0, 0, 0, 4527, 4528,
		1, 0, 0, 0, 4528, 4529, 1, 0, 0, 0, 4529, 4531, 5, 384, 0, 0, 4530, 4525,
		1, 0, 0, 0, 4530, 4531, 1, 0, 0, 0, 4531, 1059, 1, 0, 0, 0, 4532, 4540,
		5, 72, 0, 0, 4533, 4534, 5, 239, 0, 0, 4534, 4536, 5, 373, 0, 0, 4535,
		4537, 3, 1068, 534, 0, 4536, 4535, 1, 0, 0, 0, 4536, 4537, 1, 0, 0, 0,
		4537, 4538, 1, 0, 0, 0, 4538, 4540, 5, 384, 0, 0, 4539, 4532, 1, 0, 0,
		0, 4539, 4533, 1, 0, 0, 0, 4540, 1061, 1, 0, 0, 0, 4541, 4549, 5, 141,
		0, 0, 4542, 4543, 5, 139, 0, 0, 4543, 4545, 5, 373, 0, 0, 4544, 4546, 3,
		1068, 534, 0, 4545, 4544, 1, 0, 0, 0, 4545, 4546, 1, 0, 0, 0, 4546, 4547,
		1, 0, 0, 0, 4547, 4549, 5, 384, 0, 0, 4548, 4541, 1, 0, 0, 0, 4548, 4542,
		1, 0, 0, 0, 4549, 1063, 1, 0, 0, 0, 4550, 4553, 3, 1160, 580, 0, 4551,
		4553, 3, 972, 486, 0, 4552, 4550, 1, 0, 0, 0, 4552, 4551, 1, 0, 0, 0, 4553,
		1065, 1, 0, 0, 0, 4554, 4557, 3, 1162, 581, 0, 4555, 4557, 3, 972, 486,
		0, 4556, 4554, 1, 0, 0, 0, 4556, 4555, 1, 0, 0, 0, 4557, 1067, 1, 0, 0,
		0, 4558, 4561, 3, 1164, 582, 0, 4559, 4561, 3, 972, 486, 0, 4560, 4558,
		1, 0, 0, 0, 4560, 4559, 1, 0, 0, 0, 4561, 1069, 1, 0, 0, 0, 4562, 4563,
		3, 848, 424, 0, 4563, 1071, 1, 0, 0, 0, 4564, 4565, 5, 87, 0, 0, 4565,
		4566, 5, 373, 0, 0, 4566, 4567, 3, 1074, 537, 0, 4567, 4569, 5, 384, 0,
		0, 4568, 4570, 3, 758, 379, 0, 4569, 4568, 1, 0, 0, 0, 4569, 4570, 1, 0,
		0, 0, 4570, 1073, 1, 0, 0, 0, 4571, 4572, 3, 1076, 538, 0, 4572, 4573,
		5, 363, 0, 0, 4573, 4574, 3, 1078, 539, 0, 4574, 1075, 1, 0, 0, 0, 4575,
		4576, 3, 1050, 525, 0, 4576, 1077, 1, 0, 0, 0, 4577, 4578, 3, 1050, 525,
		0, 4578, 1079, 1, 0, 0, 0, 4579, 4582, 3, 1082, 541, 0, 4580, 4582, 3,
		998, 499, 0, 4581, 4579, 1, 0, 0, 0, 4581, 4580, 1, 0, 0, 0, 4582, 1081,
		1, 0, 0, 0, 4583, 4584, 5, 86, 0, 0, 4584, 4585, 5, 373, 0, 0, 4585, 4586,
		3, 1084, 542, 0, 4586, 4587, 5, 384, 0, 0, 4587, 1083, 1, 0, 0, 0, 4588,
		4591, 3, 1168, 584, 0, 4589, 4591, 3, 972, 486, 0, 4590, 4588, 1, 0, 0,
		0, 4590, 4589, 1, 0, 0, 0, 4591, 1085, 1, 0, 0, 0, 4592, 4593, 3, 1140,
		570, 0, 4593, 1087, 1, 0, 0, 0, 4594, 4595, 3, 1142, 571, 0, 4595, 1089,
		1, 0, 0, 0, 4596, 4597, 3, 1140, 570, 0, 4597, 1091, 1, 0, 0, 0, 4598,
		4599, 3, 1140, 570, 0, 4599, 1093, 1, 0, 0, 0, 4600, 4603, 3, 1142, 571,
		0, 4601, 4603, 3, 1096, 548, 0, 4602, 4600, 1, 0, 0, 0, 4602, 4601, 1,
		0, 0, 0, 4603, 1095, 1, 0, 0, 0, 4604, 4605, 7, 37, 0, 0, 4605, 1097, 1,
		0, 0, 0, 4606, 4607, 3, 1140, 570, 0, 4607, 1099, 1, 0, 0, 0, 4608, 4609,
		3, 1140, 570, 0, 4609, 1101, 1, 0, 0, 0, 4610, 4611, 3, 1140, 570, 0, 4611,
		1103, 1, 0, 0, 0, 4612, 4615, 3, 1142, 571, 0, 4613, 4615, 3, 1106, 553,
		0, 4614, 4612, 1, 0, 0, 0, 4614, 4613, 1, 0, 0, 0, 4615, 1105, 1, 0, 0,
		0, 4616, 4617, 7, 37, 0, 0, 4617, 1107, 1, 0, 0, 0, 4618, 4619, 3, 1140,
		570, 0, 4619, 1109, 1, 0, 0, 0, 4620, 4621, 3, 1140, 570, 0, 4621, 1111,
		1, 0, 0, 0, 4622, 4623, 3, 1140, 570, 0, 4623, 1113, 1, 0, 0, 0, 4624,
		4625, 3, 1140, 570, 0, 4625, 1115, 1, 0, 0, 0, 4626, 4627, 3, 1122, 561,
		0, 4627, 1117, 1, 0, 0, 0, 4628, 4629, 3, 1122, 561, 0, 4629, 1119, 1,
		0, 0, 0, 4630, 4631, 3, 1142, 571, 0, 4631, 1121, 1, 0, 0, 0, 4632, 4633,
		3, 1142, 571, 0, 4633, 1123, 1, 0, 0, 0, 4634, 4637, 3, 1148, 574, 0, 4635,
		4637, 3, 1126, 563, 0, 4636, 4634, 1, 0, 0, 0, 4636, 4635, 1, 0, 0, 0,
		4637, 1125, 1, 0, 0, 0, 4638, 4647, 5, 5, 0, 0, 4639, 4647, 3, 1146, 573,
		0, 4640, 4647, 5, 10, 0, 0, 4641, 4647, 3, 1128, 564, 0, 4642, 4647, 3,
		1166, 583, 0, 4643, 4647, 3, 1158, 579, 0, 4644, 4647, 3, 1136, 568, 0,
		4645, 4647, 3, 1138, 569, 0, 4646, 4638, 1, 0, 0, 0, 4646, 4639, 1, 0,
		0, 0, 4646, 4640, 1, 0, 0, 0, 4646, 4641, 1, 0, 0, 0, 4646, 4642, 1, 0,
		0, 0, 4646, 4643, 1, 0, 0, 0, 4646, 4644, 1, 0, 0, 0, 4646, 4645, 1, 0,
		0, 0, 4647, 1127, 1, 0, 0, 0, 4648, 4652, 3, 1130, 565, 0, 4649, 4652,
		3, 1132, 566, 0, 4650, 4652, 3, 1134, 567, 0, 4651, 4648, 1, 0, 0, 0, 4651,
		4649, 1, 0, 0, 0, 4651, 4650, 1, 0, 0, 0, 4652, 1129, 1, 0, 0, 0, 4653,
		4654, 5, 73, 0, 0, 4654, 4655, 3, 1160, 580, 0, 4655, 1131, 1, 0, 0, 0,
		4656, 4657, 5, 210, 0, 0, 4657, 4658, 3, 1162, 581, 0, 4658, 1133, 1, 0,
		0, 0, 4659, 4660, 7, 38, 0, 0, 4660, 4661, 3, 1164, 582, 0, 4661, 1135,
		1, 0, 0, 0, 4662, 4663, 3, 966, 483, 0, 4663, 1137, 1, 0, 0, 0, 4664, 4665,
		3, 972, 486, 0, 4665, 1139, 1, 0, 0, 0, 4666, 4670, 3, 1142, 571, 0, 4667,
		4670, 5, 7, 0, 0, 4668, 4670, 5, 8, 0, 0, 4669, 4666, 1, 0, 0, 0, 4669,
		4667, 1, 0, 0, 0, 4669, 4668, 1, 0, 0, 0, 4670, 1141, 1, 0, 0, 0, 4671,
		4674, 5, 327, 0, 0, 4672, 4674, 3, 1176, 588, 0, 4673, 4671, 1, 0, 0, 0,
		4673, 4672, 1, 0, 0, 0, 4674, 1143, 1, 0, 0, 0, 4675, 4676, 3, 1146, 573,
		0, 4676, 1145, 1, 0, 0, 0, 4677, 4678, 7, 39, 0, 0, 4678, 1147, 1, 0, 0,
		0, 4679, 4682, 3, 1150, 575, 0, 4680, 4682, 3, 1152, 576, 0, 4681, 4679,
		1, 0, 0, 0, 4681, 4680, 1, 0, 0, 0, 4682, 1149, 1, 0, 0, 0, 4683, 4689,
		5, 11, 0, 0, 4684, 4689, 5, 14, 0, 0, 4685, 4689, 5, 15, 0, 0, 4686, 4689,
		5, 17, 0, 0, 4687, 4689, 3, 1154, 577, 0, 4688, 4683, 1, 0, 0, 0, 4688,
		4684, 1, 0, 0, 0, 4688, 4685, 1, 0, 0, 0, 4688, 4686, 1, 0, 0, 0, 4688,
		4687, 1, 0, 0, 0, 4689, 1151, 1, 0, 0, 0, 4690, 4691, 7, 40, 0, 0, 4691,
		1153, 1, 0, 0, 0, 4692, 4693, 7, 41, 0, 0, 4693, 1155, 1, 0, 0, 0, 4694,
		4695, 5, 19, 0, 0, 4695, 1157, 1, 0, 0, 0, 4696, 4697, 5, 157, 0, 0, 4697,
		1159, 1, 0, 0, 0, 4698, 4699, 3, 1146, 573, 0, 4699, 1161, 1, 0, 0, 0,
		4700, 4701, 3, 1146, 573, 0, 4701, 1163, 1, 0, 0, 0, 4702, 4703, 3, 1146,
		573, 0, 4703, 1165, 1, 0, 0, 0, 4704, 4705, 5, 86, 0, 0, 4705, 4706, 3,
		1168, 584, 0, 4706, 1167, 1, 0, 0, 0, 4707, 4708, 3, 1146, 573, 0, 4708,
		1169, 1, 0, 0, 0, 4709, 4710, 7, 42, 0, 0, 4710, 1171, 1, 0, 0, 0, 4711,
		4712, 7, 43, 0, 0, 4712, 1173, 1, 0, 0, 0, 4713, 4714, 7, 44, 0, 0, 4714,
		1175, 1, 0, 0, 0, 4715, 4716, 7, 45, 0, 0, 4716, 1177, 1, 0, 0, 0, 514,
		1180, 1187, 1191, 1196, 1201, 1206, 1209, 1214, 1216, 1220, 1223, 1227,
		1235, 1241, 1255, 1258, 1265, 1278, 1285, 1288, 1293, 1299, 1302, 1312,
		1319, 1328, 1349, 1352, 1359, 1364, 1370, 1376, 1380, 1385, 1392, 1395,
		1403, 1410, 1413, 1425, 1428, 1439, 1447, 1455, 1460, 1464, 1472, 1479,
		1487, 1493, 1499, 1504, 1507, 1512, 1515, 1518, 1522, 1525, 1529, 1533,
		1536, 1539, 1542, 1554, 1559, 1565, 1572, 1577, 1581, 1587, 1592, 1595,
		1603, 1609, 1617, 1621, 1626, 1633, 1637, 1642, 1646, 1650, 1656, 1669,
		1675, 1687, 1703, 1708, 1719, 1729, 1747, 1752, 1756, 1760, 1764, 1766,
		1772, 1777, 1784, 1800, 1804, 1809, 1813, 1820, 1824, 1841, 1846, 1853,
		1863, 1871, 1876, 1892, 1895, 1899, 1902, 1906, 1909, 1915, 1919, 1922,
		1929, 1934, 1941, 1945, 1949, 1952, 1955, 1958, 1961, 1964, 1966, 1973,
		1978, 1989, 1996, 2006, 2009, 2016, 2019, 2025, 2034, 2040, 2044, 2051,
		2064, 2074, 2080, 2084, 2087, 2091, 2101, 2104, 2108, 2111, 2118, 2122,
		2125, 2145, 2154, 2159, 2166, 2170, 2176, 2182, 2188, 2191, 2194, 2199,
		2204, 2207, 2211, 2215, 2222, 2226, 2229, 2235, 2238, 2241, 2249, 2254,
		2257, 2262, 2265, 2270, 2273, 2277, 2280, 2283, 2295, 2302, 2304, 2309,
		2318, 2323, 2327, 2334, 2337, 2340, 2351, 2365, 2374, 2383, 2417, 2420,
		2424, 2443, 2451, 2453, 2464, 2472, 2476, 2491, 2524, 2533, 2543, 2553,
		2564, 2570, 2580, 2589, 2616, 2626, 2639, 2644, 2660, 2664, 2680, 2685,
		2688, 2698, 2711, 2717, 2726, 2732, 2739, 2744, 2751, 2759, 2762, 2770,
		2773, 2782, 2786, 2789, 2795, 2802, 2810, 2812, 2827, 2832, 2836, 2853,
		2858, 2862, 2866, 2870, 2873, 2879, 2884, 2888, 2891, 2895, 2898, 2907,
		2910, 2920, 2923, 2927, 2931, 2935, 2940, 2947, 2950, 2954, 2957, 2964,
		2967, 2977, 2993, 3009, 3025, 3057, 3060, 3068, 3071, 3080, 3084, 3119,
		3126, 3131, 3140, 3145, 3161, 3163, 3167, 3183, 3186, 3193, 3196, 3201,
		3204, 3207, 3212, 3216, 3224, 3229, 3240, 3243, 3245, 3247, 3259, 3263,
		3270, 3275, 3278, 3285, 3288, 3295, 3298, 3300, 3307, 3312, 3315, 3322,
		3325, 3332, 3335, 3337, 3347, 3351, 3355, 3359, 3363, 3367, 3371, 3375,
		3379, 3383, 3390, 3393, 3397, 3400, 3403, 3407, 3411, 3415, 3419, 3423,
		3427, 3431, 3438, 3441, 3445, 3449, 3453, 3457, 3461, 3465, 3469, 3473,
		3478, 3485, 3488, 3493, 3495, 3502, 3506, 3508, 3516, 3520, 3524, 3528,
		3532, 3539, 3543, 3546, 3550, 3554, 3557, 3559, 3563, 3570, 3575, 3582,
		3584, 3589, 3595, 3598, 3600, 3604, 3609, 3616, 3618, 3623, 3630, 3632,
		3639, 3647, 3653, 3657, 3664, 3668, 3671, 3676, 3680, 3684, 3688, 3692,
		3696, 3699, 3703, 3707, 3711, 3714, 3718, 3722, 3729, 3733, 3736, 3740,
		3742, 3746, 3755, 3763, 3778, 3800, 3807, 3816, 3823, 3826, 3835, 3847,
		3851, 3859, 3865, 3873, 3890, 3904, 3923, 3928, 3934, 3960, 3963, 3965,
		3974, 3983, 4007, 4016, 4037, 4044, 4053, 4067, 4071, 4075, 4079, 4094,
		4110, 4114, 4118, 4125, 4128, 4136, 4139, 4158, 4165, 4179, 4183, 4196,
		4206, 4211, 4230, 4256, 4270, 4287, 4291, 4300, 4306, 4312, 4321, 4335,
		4343, 4345, 4361, 4366, 4378, 4477, 4480, 4483, 4504, 4510, 4513, 4519,
		4522, 4527, 4530, 4536, 4539, 4545, 4548, 4552, 4556, 4560, 4569, 4581,
		4590, 4602, 4614, 4636, 4646, 4651, 4669, 4673, 4681, 4688,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// GQLParserInit initializes any static state used to implement GQLParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewGQLParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func GQLParserInit() {
	staticData := &GQLParserStaticData
	staticData.once.Do(gqlParserInit)
}

// NewGQLParser produces a new parser instance for the optional input antlr.TokenStream.
func NewGQLParser(input antlr.TokenStream) *GQLParser {
	GQLParserInit()
	this := new(GQLParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &GQLParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "GQL.g4"

	return this
}

// GQLParser tokens.
const (
	GQLParserEOF                                                                    = antlr.TokenEOF
	GQLParserCHECK                                                                  = 1
	GQLParserPRIMARY                                                                = 2
	GQLParserKEY                                                                    = 3
	GQLParserIMPLIES                                                                = 4
	GQLParserBOOLEAN_LITERAL                                                        = 5
	GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE                                       = 6
	GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE                                       = 7
	GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE                                       = 8
	GQLParserNO_ESCAPE                                                              = 9
	GQLParserBYTE_STRING_LITERAL                                                    = 10
	GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX       = 11
	GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX                 = 12
	GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX = 13
	GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX           = 14
	GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX                     = 15
	GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX     = 16
	GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX                      = 17
	GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX                = 18
	GQLParserUNSIGNED_DECIMAL_INTEGER                                               = 19
	GQLParserUNSIGNED_HEXADECIMAL_INTEGER                                           = 20
	GQLParserUNSIGNED_OCTAL_INTEGER                                                 = 21
	GQLParserUNSIGNED_BINARY_INTEGER                                                = 22
	GQLParserABS                                                                    = 23
	GQLParserACOS                                                                   = 24
	GQLParserALL                                                                    = 25
	GQLParserALL_DIFFERENT                                                          = 26
	GQLParserAND                                                                    = 27
	GQLParserANY                                                                    = 28
	GQLParserARRAY                                                                  = 29
	GQLParserAS                                                                     = 30
	GQLParserASC                                                                    = 31
	GQLParserASCENDING                                                              = 32
	GQLParserASIN                                                                   = 33
	GQLParserAT                                                                     = 34
	GQLParserATAN                                                                   = 35
	GQLParserAVG                                                                    = 36
	GQLParserBIG                                                                    = 37
	GQLParserBIGINT                                                                 = 38
	GQLParserBINARY                                                                 = 39
	GQLParserBOOL                                                                   = 40
	GQLParserBOOLEAN                                                                = 41
	GQLParserBOTH                                                                   = 42
	GQLParserBTRIM                                                                  = 43
	GQLParserBY                                                                     = 44
	GQLParserBYTE_LENGTH                                                            = 45
	GQLParserBYTES                                                                  = 46
	GQLParserCALL                                                                   = 47
	GQLParserCARDINALITY                                                            = 48
	GQLParserCASE                                                                   = 49
	GQLParserCAST                                                                   = 50
	GQLParserCEIL                                                                   = 51
	GQLParserCEILING                                                                = 52
	GQLParserCHAR                                                                   = 53
	GQLParserCHAR_LENGTH                                                            = 54
	GQLParserCHARACTER_LENGTH                                                       = 55
	GQLParserCHARACTERISTICS                                                        = 56
	GQLParserCLOSE                                                                  = 57
	GQLParserCOALESCE                                                               = 58
	GQLParserCOLLECT_LIST                                                           = 59
	GQLParserCOMMIT                                                                 = 60
	GQLParserCOPY                                                                   = 61
	GQLParserCOS                                                                    = 62
	GQLParserCOSH                                                                   = 63
	GQLParserCOT                                                                    = 64
	GQLParserCOUNT                                                                  = 65
	GQLParserCREATE                                                                 = 66
	GQLParserCURRENT_DATE                                                           = 67
	GQLParserCURRENT_GRAPH                                                          = 68
	GQLParserCURRENT_PROPERTY_GRAPH                                                 = 69
	GQLParserCURRENT_SCHEMA                                                         = 70
	GQLParserCURRENT_TIME                                                           = 71
	GQLParserCURRENT_TIMESTAMP                                                      = 72
	GQLParserDATE                                                                   = 73
	GQLParserDATETIME                                                               = 74
	GQLParserDAY                                                                    = 75
	GQLParserDEC                                                                    = 76
	GQLParserDECIMAL                                                                = 77
	GQLParserDEGREES                                                                = 78
	GQLParserDELETE                                                                 = 79
	GQLParserDESC                                                                   = 80
	GQLParserDESCENDING                                                             = 81
	GQLParserDETACH                                                                 = 82
	GQLParserDISTINCT                                                               = 83
	GQLParserDOUBLE                                                                 = 84
	GQLParserDROP                                                                   = 85
	GQLParserDURATION                                                               = 86
	GQLParserDURATION_BETWEEN                                                       = 87
	GQLParserELEMENT_ID                                                             = 88
	GQLParserELSE                                                                   = 89
	GQLParserEND                                                                    = 90
	GQLParserEXCEPT                                                                 = 91
	GQLParserEXISTS                                                                 = 92
	GQLParserEXP                                                                    = 93
	GQLParserFILTER                                                                 = 94
	GQLParserFINISH                                                                 = 95
	GQLParserFLOAT                                                                  = 96
	GQLParserFLOAT16                                                                = 97
	GQLParserFLOAT32                                                                = 98
	GQLParserFLOAT64                                                                = 99
	GQLParserFLOAT128                                                               = 100
	GQLParserFLOAT256                                                               = 101
	GQLParserFLOOR                                                                  = 102
	GQLParserFOR                                                                    = 103
	GQLParserFROM                                                                   = 104
	GQLParserGROUP                                                                  = 105
	GQLParserHAVING                                                                 = 106
	GQLParserHOME_GRAPH                                                             = 107
	GQLParserHOME_PROPERTY_GRAPH                                                    = 108
	GQLParserHOME_SCHEMA                                                            = 109
	GQLParserHOUR                                                                   = 110
	GQLParserIF                                                                     = 111
	GQLParserIN                                                                     = 112
	GQLParserINSERT                                                                 = 113
	GQLParserINT                                                                    = 114
	GQLParserINTEGER                                                                = 115
	GQLParserINT8                                                                   = 116
	GQLParserINTEGER8                                                               = 117
	GQLParserINT16                                                                  = 118
	GQLParserINTEGER16                                                              = 119
	GQLParserINT32                                                                  = 120
	GQLParserINTEGER32                                                              = 121
	GQLParserINT64                                                                  = 122
	GQLParserINTEGER64                                                              = 123
	GQLParserINT128                                                                 = 124
	GQLParserINTEGER128                                                             = 125
	GQLParserINT256                                                                 = 126
	GQLParserINTEGER256                                                             = 127
	GQLParserINTERSECT                                                              = 128
	GQLParserINTERVAL                                                               = 129
	GQLParserIS                                                                     = 130
	GQLParserLEADING                                                                = 131
	GQLParserLEFT                                                                   = 132
	GQLParserLET                                                                    = 133
	GQLParserLIKE                                                                   = 134
	GQLParserLIMIT                                                                  = 135
	GQLParserLIST                                                                   = 136
	GQLParserLN                                                                     = 137
	GQLParserLOCAL                                                                  = 138
	GQLParserLOCAL_DATETIME                                                         = 139
	GQLParserLOCAL_TIME                                                             = 140
	GQLParserLOCAL_TIMESTAMP                                                        = 141
	GQLParserLOG_KW                                                                 = 142
	GQLParserLOG10                                                                  = 143
	GQLParserLOWER                                                                  = 144
	GQLParserLTRIM                                                                  = 145
	GQLParserMATCH                                                                  = 146
	GQLParserMAX                                                                    = 147
	GQLParserMIN                                                                    = 148
	GQLParserMINUTE                                                                 = 149
	GQLParserMOD                                                                    = 150
	GQLParserMONTH                                                                  = 151
	GQLParserNEXT                                                                   = 152
	GQLParserNODETACH                                                               = 153
	GQLParserNORMALIZE                                                              = 154
	GQLParserNOT                                                                    = 155
	GQLParserNOTHING                                                                = 156
	GQLParserNULL_KW                                                                = 157
	GQLParserNULLS                                                                  = 158
	GQLParserNULLIF                                                                 = 159
	GQLParserOCTET_LENGTH                                                           = 160
	GQLParserOF                                                                     = 161
	GQLParserOFFSET                                                                 = 162
	GQLParserOPTIONAL                                                               = 163
	GQLParserOR                                                                     = 164
	GQLParserORDER                                                                  = 165
	GQLParserOTHERWISE                                                              = 166
	GQLParserPARAMETER                                                              = 167
	GQLParserPARAMETERS                                                             = 168
	GQLParserPATH                                                                   = 169
	GQLParserPATH_LENGTH                                                            = 170
	GQLParserPATHS                                                                  = 171
	GQLParserPERCENTILE_CONT                                                        = 172
	GQLParserPERCENTILE_DISC                                                        = 173
	GQLParserPOWER                                                                  = 174
	GQLParserPRECISION                                                              = 175
	GQLParserPROPERTY_EXISTS                                                        = 176
	GQLParserRADIANS                                                                = 177
	GQLParserREAL                                                                   = 178
	GQLParserRECORD                                                                 = 179
	GQLParserREMOVE                                                                 = 180
	GQLParserREPLACE                                                                = 181
	GQLParserRESET                                                                  = 182
	GQLParserRETURN                                                                 = 183
	GQLParserRIGHT                                                                  = 184
	GQLParserROLLBACK                                                               = 185
	GQLParserRTRIM                                                                  = 186
	GQLParserSAME                                                                   = 187
	GQLParserSCHEMA                                                                 = 188
	GQLParserSECOND                                                                 = 189
	GQLParserSELECT                                                                 = 190
	GQLParserSESSION                                                                = 191
	GQLParserSESSION_USER                                                           = 192
	GQLParserSET                                                                    = 193
	GQLParserSIGNED                                                                 = 194
	GQLParserSIN                                                                    = 195
	GQLParserSINH                                                                   = 196
	GQLParserSIZE                                                                   = 197
	GQLParserSKIP_RESERVED_WORD                                                     = 198
	GQLParserSMALL                                                                  = 199
	GQLParserSMALLINT                                                               = 200
	GQLParserSQRT                                                                   = 201
	GQLParserSTART                                                                  = 202
	GQLParserSTDDEV_POP                                                             = 203
	GQLParserSTDDEV_SAMP                                                            = 204
	GQLParserSTRING                                                                 = 205
	GQLParserSUM                                                                    = 206
	GQLParserTAN                                                                    = 207
	GQLParserTANH                                                                   = 208
	GQLParserTHEN                                                                   = 209
	GQLParserTIME                                                                   = 210
	GQLParserTIMESTAMP                                                              = 211
	GQLParserTRAILING                                                               = 212
	GQLParserTRIM                                                                   = 213
	GQLParserTYPED                                                                  = 214
	GQLParserUBIGINT                                                                = 215
	GQLParserUINT                                                                   = 216
	GQLParserUINT8                                                                  = 217
	GQLParserUINT16                                                                 = 218
	GQLParserUINT32                                                                 = 219
	GQLParserUINT64                                                                 = 220
	GQLParserUINT128                                                                = 221
	GQLParserUINT256                                                                = 222
	GQLParserUNION                                                                  = 223
	GQLParserUNSIGNED                                                               = 224
	GQLParserUPPER                                                                  = 225
	GQLParserUSE                                                                    = 226
	GQLParserUSMALLINT                                                              = 227
	GQLParserVALUE                                                                  = 228
	GQLParserVARBINARY                                                              = 229
	GQLParserVARCHAR                                                                = 230
	GQLParserVARIABLE                                                               = 231
	GQLParserWHEN                                                                   = 232
	GQLParserWHERE                                                                  = 233
	GQLParserWITH                                                                   = 234
	GQLParserXOR                                                                    = 235
	GQLParserYEAR                                                                   = 236
	GQLParserYIELD                                                                  = 237
	GQLParserZONED                                                                  = 238
	GQLParserZONED_DATETIME                                                         = 239
	GQLParserZONED_TIME                                                             = 240
	GQLParserABSTRACT                                                               = 241
	GQLParserAGGREGATE                                                              = 242
	GQLParserAGGREGATES                                                             = 243
	GQLParserALTER                                                                  = 244
	GQLParserCATALOG                                                                = 245
	GQLParserCLEAR                                                                  = 246
	GQLParserCLONE                                                                  = 247
	GQLParserCONSTRAINT                                                             = 248
	GQLParserCURRENT_ROLE                                                           = 249
	GQLParserCURRENT_USER                                                           = 250
	GQLParserDATA                                                                   = 251
	GQLParserDIRECTORY                                                              = 252
	GQLParserDRYRUN                                                                 = 253
	GQLParserEXACT                                                                  = 254
	GQLParserEXISTING                                                               = 255
	GQLParserFUNCTION                                                               = 256
	GQLParserGQLSTATUS                                                              = 257
	GQLParserGRANT                                                                  = 258
	GQLParserINSTANT                                                                = 259
	GQLParserINFINITY_KW                                                            = 260
	GQLParserNUMBER                                                                 = 261
	GQLParserNUMERIC                                                                = 262
	GQLParserON                                                                     = 263
	GQLParserOPEN                                                                   = 264
	GQLParserPARTITION                                                              = 265
	GQLParserPROCEDURE                                                              = 266
	GQLParserPRODUCT                                                                = 267
	GQLParserPROJECT                                                                = 268
	GQLParserQUERY                                                                  = 269
	GQLParserRECORDS                                                                = 270
	GQLParserREFERENCE                                                              = 271
	GQLParserRENAME                                                                 = 272
	GQLParserREVOKE                                                                 = 273
	GQLParserSUBSTRING                                                              = 274
	GQLParserSYSTEM_USER                                                            = 275
	GQLParserTEMPORAL                                                               = 276
	GQLParserUNIQUE                                                                 = 277
	GQLParserUNIT                                                                   = 278
	GQLParserVALUES                                                                 = 279
	GQLParserACYCLIC                                                                = 280
	GQLParserBINDING                                                                = 281
	GQLParserBINDINGS                                                               = 282
	GQLParserCONNECTING                                                             = 283
	GQLParserDESTINATION                                                            = 284
	GQLParserDIFFERENT                                                              = 285
	GQLParserDIRECTED                                                               = 286
	GQLParserEDGE                                                                   = 287
	GQLParserEDGES                                                                  = 288
	GQLParserELEMENT                                                                = 289
	GQLParserELEMENTS                                                               = 290
	GQLParserFIRST                                                                  = 291
	GQLParserGRAPH                                                                  = 292
	GQLParserGROUPS                                                                 = 293
	GQLParserKEEP                                                                   = 294
	GQLParserLABEL                                                                  = 295
	GQLParserLABELED                                                                = 296
	GQLParserLABELS                                                                 = 297
	GQLParserLAST                                                                   = 298
	GQLParserNFC                                                                    = 299
	GQLParserNFD                                                                    = 300
	GQLParserNFKC                                                                   = 301
	GQLParserNFKD                                                                   = 302
	GQLParserNO                                                                     = 303
	GQLParserNODE                                                                   = 304
	GQLParserNORMALIZED                                                             = 305
	GQLParserONLY                                                                   = 306
	GQLParserORDINALITY                                                             = 307
	GQLParserPROPERTY                                                               = 308
	GQLParserREAD                                                                   = 309
	GQLParserRELATIONSHIP                                                           = 310
	GQLParserRELATIONSHIPS                                                          = 311
	GQLParserREPEATABLE                                                             = 312
	GQLParserSHORTEST                                                               = 313
	GQLParserSIMPLE                                                                 = 314
	GQLParserSOURCE                                                                 = 315
	GQLParserTABLE                                                                  = 316
	GQLParserTO                                                                     = 317
	GQLParserTRAIL                                                                  = 318
	GQLParserTRANSACTION                                                            = 319
	GQLParserTYPE                                                                   = 320
	GQLParserUNDIRECTED                                                             = 321
	GQLParserVERTEX                                                                 = 322
	GQLParserWALK                                                                   = 323
	GQLParserWITHOUT                                                                = 324
	GQLParserWRITE                                                                  = 325
	GQLParserZONE                                                                   = 326
	GQLParserREGULAR_IDENTIFIER                                                     = 327
	GQLParserSUBSTITUTED_PARAMETER_REFERENCE                                        = 328
	GQLParserGENERAL_PARAMETER_REFERENCE                                            = 329
	GQLParserMULTISET_ALTERNATION_OPERATOR                                          = 330
	GQLParserBRACKET_RIGHT_ARROW                                                    = 331
	GQLParserBRACKET_TILDE_RIGHT_ARROW                                              = 332
	GQLParserCONCATENATION_OPERATOR                                                 = 333
	GQLParserDOUBLE_COLON                                                           = 334
	GQLParserDOUBLE_DOLLAR_SIGN                                                     = 335
	GQLParserDOUBLE_PERIOD                                                          = 336
	GQLParserGREATER_THAN_OR_EQUALS_OPERATOR                                        = 337
	GQLParserLEFT_ARROW                                                             = 338
	GQLParserLEFT_ARROW_TILDE                                                       = 339
	GQLParserLEFT_ARROW_BRACKET                                                     = 340
	GQLParserLEFT_ARROW_TILDE_BRACKET                                               = 341
	GQLParserLEFT_MINUS_RIGHT                                                       = 342
	GQLParserLEFT_MINUS_SLASH                                                       = 343
	GQLParserLEFT_TILDE_SLASH                                                       = 344
	GQLParserLESS_THAN_OR_EQUALS_OPERATOR                                           = 345
	GQLParserMINUS_LEFT_BRACKET                                                     = 346
	GQLParserMINUS_SLASH                                                            = 347
	GQLParserNOT_EQUALS_OPERATOR                                                    = 348
	GQLParserRIGHT_ARROW                                                            = 349
	GQLParserRIGHT_BRACKET_MINUS                                                    = 350
	GQLParserRIGHT_BRACKET_TILDE                                                    = 351
	GQLParserRIGHT_DOUBLE_ARROW                                                     = 352
	GQLParserSLASH_MINUS                                                            = 353
	GQLParserSLASH_MINUS_RIGHT                                                      = 354
	GQLParserSLASH_TILDE                                                            = 355
	GQLParserSLASH_TILDE_RIGHT                                                      = 356
	GQLParserTILDE_LEFT_BRACKET                                                     = 357
	GQLParserTILDE_RIGHT_ARROW                                                      = 358
	GQLParserTILDE_SLASH                                                            = 359
	GQLParserAMPERSAND                                                              = 360
	GQLParserASTERISK                                                               = 361
	GQLParserCOLON                                                                  = 362
	GQLParserCOMMA                                                                  = 363
	GQLParserCOMMERCIAL_AT                                                          = 364
	GQLParserDOLLAR_SIGN                                                            = 365
	GQLParserDOUBLE_QUOTE                                                           = 366
	GQLParserEQUALS_OPERATOR                                                        = 367
	GQLParserEXCLAMATION_MARK                                                       = 368
	GQLParserRIGHT_ANGLE_BRACKET                                                    = 369
	GQLParserGRAVE_ACCENT                                                           = 370
	GQLParserLEFT_BRACE                                                             = 371
	GQLParserLEFT_BRACKET                                                           = 372
	GQLParserLEFT_PAREN                                                             = 373
	GQLParserLEFT_ANGLE_BRACKET                                                     = 374
	GQLParserMINUS_SIGN                                                             = 375
	GQLParserPERCENT                                                                = 376
	GQLParserPERIOD                                                                 = 377
	GQLParserPLUS_SIGN                                                              = 378
	GQLParserQUESTION_MARK                                                          = 379
	GQLParserQUOTE                                                                  = 380
	GQLParserREVERSE_SOLIDUS                                                        = 381
	GQLParserRIGHT_BRACE                                                            = 382
	GQLParserRIGHT_BRACKET                                                          = 383
	GQLParserRIGHT_PAREN                                                            = 384
	GQLParserSOLIDUS                                                                = 385
	GQLParserTILDE                                                                  = 386
	GQLParserUNDERSCORE                                                             = 387
	GQLParserVERTICAL_BAR                                                           = 388
	GQLParserSP                                                                     = 389
	GQLParserWHITESPACE                                                             = 390
	GQLParserBRACKETED_COMMENT                                                      = 391
	GQLParserSIMPLE_COMMENT_SOLIDUS                                                 = 392
	GQLParserSIMPLE_COMMENT_MINUS                                                   = 393
)

// GQLParser rules.
const (
	GQLParserRULE_gqlProgram                                        = 0
	GQLParserRULE_programActivity                                   = 1
	GQLParserRULE_sessionActivity                                   = 2
	GQLParserRULE_transactionActivity                               = 3
	GQLParserRULE_endTransactionCommand                             = 4
	GQLParserRULE_sessionSetCommand                                 = 5
	GQLParserRULE_sessionSetSchemaClause                            = 6
	GQLParserRULE_sessionSetGraphClause                             = 7
	GQLParserRULE_sessionSetTimeZoneClause                          = 8
	GQLParserRULE_setTimeZoneValue                                  = 9
	GQLParserRULE_sessionSetParameterClause                         = 10
	GQLParserRULE_sessionSetGraphParameterClause                    = 11
	GQLParserRULE_sessionSetBindingTableParameterClause             = 12
	GQLParserRULE_sessionSetValueParameterClause                    = 13
	GQLParserRULE_sessionSetParameterName                           = 14
	GQLParserRULE_sessionResetCommand                               = 15
	GQLParserRULE_sessionResetArguments                             = 16
	GQLParserRULE_sessionCloseCommand                               = 17
	GQLParserRULE_sessionParameterSpecification                     = 18
	GQLParserRULE_startTransactionCommand                           = 19
	GQLParserRULE_transactionCharacteristics                        = 20
	GQLParserRULE_transactionMode                                   = 21
	GQLParserRULE_transactionAccessMode                             = 22
	GQLParserRULE_rollbackCommand                                   = 23
	GQLParserRULE_commitCommand                                     = 24
	GQLParserRULE_nestedProcedureSpecification                      = 25
	GQLParserRULE_procedureSpecification                            = 26
	GQLParserRULE_nestedDataModifyingProcedureSpecification         = 27
	GQLParserRULE_nestedQuerySpecification                          = 28
	GQLParserRULE_procedureBody                                     = 29
	GQLParserRULE_bindingVariableDefinitionBlock                    = 30
	GQLParserRULE_bindingVariableDefinition                         = 31
	GQLParserRULE_statementBlock                                    = 32
	GQLParserRULE_statement                                         = 33
	GQLParserRULE_nextStatement                                     = 34
	GQLParserRULE_graphVariableDefinition                           = 35
	GQLParserRULE_optTypedGraphInitializer                          = 36
	GQLParserRULE_graphInitializer                                  = 37
	GQLParserRULE_bindingTableVariableDefinition                    = 38
	GQLParserRULE_optTypedBindingTableInitializer                   = 39
	GQLParserRULE_bindingTableInitializer                           = 40
	GQLParserRULE_valueVariableDefinition                           = 41
	GQLParserRULE_optTypedValueInitializer                          = 42
	GQLParserRULE_valueInitializer                                  = 43
	GQLParserRULE_graphExpression                                   = 44
	GQLParserRULE_currentGraph                                      = 45
	GQLParserRULE_bindingTableExpression                            = 46
	GQLParserRULE_nestedBindingTableQuerySpecification              = 47
	GQLParserRULE_objectExpressionPrimary                           = 48
	GQLParserRULE_linearCatalogModifyingStatement                   = 49
	GQLParserRULE_simpleCatalogModifyingStatement                   = 50
	GQLParserRULE_primitiveCatalogModifyingStatement                = 51
	GQLParserRULE_createSchemaStatement                             = 52
	GQLParserRULE_dropSchemaStatement                               = 53
	GQLParserRULE_createGraphStatement                              = 54
	GQLParserRULE_openGraphType                                     = 55
	GQLParserRULE_ofGraphType                                       = 56
	GQLParserRULE_graphTypeLikeGraph                                = 57
	GQLParserRULE_graphSource                                       = 58
	GQLParserRULE_dropGraphStatement                                = 59
	GQLParserRULE_createGraphTypeStatement                          = 60
	GQLParserRULE_graphTypeSource                                   = 61
	GQLParserRULE_copyOfGraphType                                   = 62
	GQLParserRULE_dropGraphTypeStatement                            = 63
	GQLParserRULE_callCatalogModifyingProcedureStatement            = 64
	GQLParserRULE_linearDataModifyingStatement                      = 65
	GQLParserRULE_focusedLinearDataModifyingStatement               = 66
	GQLParserRULE_focusedLinearDataModifyingStatementBody           = 67
	GQLParserRULE_focusedNestedDataModifyingProcedureSpecification  = 68
	GQLParserRULE_ambientLinearDataModifyingStatement               = 69
	GQLParserRULE_ambientLinearDataModifyingStatementBody           = 70
	GQLParserRULE_simpleLinearDataAccessingStatement                = 71
	GQLParserRULE_simpleDataAccessingStatement                      = 72
	GQLParserRULE_simpleDataModifyingStatement                      = 73
	GQLParserRULE_primitiveDataModifyingStatement                   = 74
	GQLParserRULE_insertStatement                                   = 75
	GQLParserRULE_setStatement                                      = 76
	GQLParserRULE_setItemList                                       = 77
	GQLParserRULE_setItem                                           = 78
	GQLParserRULE_setPropertyItem                                   = 79
	GQLParserRULE_setAllPropertiesItem                              = 80
	GQLParserRULE_setLabelItem                                      = 81
	GQLParserRULE_removeStatement                                   = 82
	GQLParserRULE_removeItemList                                    = 83
	GQLParserRULE_removeItem                                        = 84
	GQLParserRULE_removePropertyItem                                = 85
	GQLParserRULE_removeLabelItem                                   = 86
	GQLParserRULE_deleteStatement                                   = 87
	GQLParserRULE_deleteItemList                                    = 88
	GQLParserRULE_deleteItem                                        = 89
	GQLParserRULE_callDataModifyingProcedureStatement               = 90
	GQLParserRULE_compositeQueryStatement                           = 91
	GQLParserRULE_compositeQueryExpression                          = 92
	GQLParserRULE_queryConjunction                                  = 93
	GQLParserRULE_setOperator                                       = 94
	GQLParserRULE_compositeQueryPrimary                             = 95
	GQLParserRULE_linearQueryStatement                              = 96
	GQLParserRULE_focusedLinearQueryStatement                       = 97
	GQLParserRULE_focusedLinearQueryStatementPart                   = 98
	GQLParserRULE_focusedLinearQueryAndPrimitiveResultStatementPart = 99
	GQLParserRULE_focusedPrimitiveResultStatement                   = 100
	GQLParserRULE_focusedNestedQuerySpecification                   = 101
	GQLParserRULE_ambientLinearQueryStatement                       = 102
	GQLParserRULE_simpleLinearQueryStatement                        = 103
	GQLParserRULE_simpleQueryStatement                              = 104
	GQLParserRULE_primitiveQueryStatement                           = 105
	GQLParserRULE_matchStatement                                    = 106
	GQLParserRULE_simpleMatchStatement                              = 107
	GQLParserRULE_optionalMatchStatement                            = 108
	GQLParserRULE_optionalOperand                                   = 109
	GQLParserRULE_matchStatementBlock                               = 110
	GQLParserRULE_callQueryStatement                                = 111
	GQLParserRULE_filterStatement                                   = 112
	GQLParserRULE_letStatement                                      = 113
	GQLParserRULE_letVariableDefinitionList                         = 114
	GQLParserRULE_letVariableDefinition                             = 115
	GQLParserRULE_forStatement                                      = 116
	GQLParserRULE_forItem                                           = 117
	GQLParserRULE_forItemAlias                                      = 118
	GQLParserRULE_forItemSource                                     = 119
	GQLParserRULE_forOrdinalityOrOffset                             = 120
	GQLParserRULE_orderByAndPageStatement                           = 121
	GQLParserRULE_primitiveResultStatement                          = 122
	GQLParserRULE_returnStatement                                   = 123
	GQLParserRULE_returnStatementBody                               = 124
	GQLParserRULE_returnItemList                                    = 125
	GQLParserRULE_returnItem                                        = 126
	GQLParserRULE_returnItemAlias                                   = 127
	GQLParserRULE_selectStatement                                   = 128
	GQLParserRULE_selectItemList                                    = 129
	GQLParserRULE_selectItem                                        = 130
	GQLParserRULE_selectItemAlias                                   = 131
	GQLParserRULE_havingClause                                      = 132
	GQLParserRULE_selectStatementBody                               = 133
	GQLParserRULE_selectGraphMatchList                              = 134
	GQLParserRULE_selectGraphMatch                                  = 135
	GQLParserRULE_selectQuerySpecification                          = 136
	GQLParserRULE_callProcedureStatement                            = 137
	GQLParserRULE_procedureCall                                     = 138
	GQLParserRULE_inlineProcedureCall                               = 139
	GQLParserRULE_variableScopeClause                               = 140
	GQLParserRULE_bindingVariableReferenceList                      = 141
	GQLParserRULE_namedProcedureCall                                = 142
	GQLParserRULE_procedureArgumentList                             = 143
	GQLParserRULE_procedureArgument                                 = 144
	GQLParserRULE_atSchemaClause                                    = 145
	GQLParserRULE_useGraphClause                                    = 146
	GQLParserRULE_graphPatternBindingTable                          = 147
	GQLParserRULE_graphPatternYieldClause                           = 148
	GQLParserRULE_graphPatternYieldItemList                         = 149
	GQLParserRULE_graphPatternYieldItem                             = 150
	GQLParserRULE_graphPattern                                      = 151
	GQLParserRULE_matchMode                                         = 152
	GQLParserRULE_repeatableElementsMatchMode                       = 153
	GQLParserRULE_differentEdgesMatchMode                           = 154
	GQLParserRULE_elementBindingsOrElements                         = 155
	GQLParserRULE_edgeBindingsOrEdges                               = 156
	GQLParserRULE_pathPatternList                                   = 157
	GQLParserRULE_pathPattern                                       = 158
	GQLParserRULE_pathVariableDeclaration                           = 159
	GQLParserRULE_keepClause                                        = 160
	GQLParserRULE_graphPatternWhereClause                           = 161
	GQLParserRULE_insertGraphPattern                                = 162
	GQLParserRULE_insertPathPatternList                             = 163
	GQLParserRULE_insertPathPattern                                 = 164
	GQLParserRULE_insertNodePattern                                 = 165
	GQLParserRULE_insertEdgePattern                                 = 166
	GQLParserRULE_insertEdgePointingLeft                            = 167
	GQLParserRULE_insertEdgePointingRight                           = 168
	GQLParserRULE_insertEdgeUndirected                              = 169
	GQLParserRULE_insertElementPatternFiller                        = 170
	GQLParserRULE_labelAndPropertySetSpecification                  = 171
	GQLParserRULE_pathPatternPrefix                                 = 172
	GQLParserRULE_pathModePrefix                                    = 173
	GQLParserRULE_pathMode                                          = 174
	GQLParserRULE_pathSearchPrefix                                  = 175
	GQLParserRULE_allPathSearch                                     = 176
	GQLParserRULE_pathOrPaths                                       = 177
	GQLParserRULE_anyPathSearch                                     = 178
	GQLParserRULE_numberOfPaths                                     = 179
	GQLParserRULE_shortestPathSearch                                = 180
	GQLParserRULE_allShortestPathSearch                             = 181
	GQLParserRULE_anyShortestPathSearch                             = 182
	GQLParserRULE_countedShortestPathSearch                         = 183
	GQLParserRULE_countedShortestGroupSearch                        = 184
	GQLParserRULE_numberOfGroups                                    = 185
	GQLParserRULE_pathPatternExpression                             = 186
	GQLParserRULE_pathTerm                                          = 187
	GQLParserRULE_pathFactor                                        = 188
	GQLParserRULE_pathPrimary                                       = 189
	GQLParserRULE_elementPattern                                    = 190
	GQLParserRULE_nodePattern                                       = 191
	GQLParserRULE_elementPatternFiller                              = 192
	GQLParserRULE_elementVariableDeclaration                        = 193
	GQLParserRULE_isLabelExpression                                 = 194
	GQLParserRULE_isOrColon                                         = 195
	GQLParserRULE_elementPatternPredicate                           = 196
	GQLParserRULE_elementPatternWhereClause                         = 197
	GQLParserRULE_elementPropertySpecification                      = 198
	GQLParserRULE_propertyKeyValuePairList                          = 199
	GQLParserRULE_propertyKeyValuePair                              = 200
	GQLParserRULE_edgePattern                                       = 201
	GQLParserRULE_fullEdgePattern                                   = 202
	GQLParserRULE_fullEdgePointingLeft                              = 203
	GQLParserRULE_fullEdgeUndirected                                = 204
	GQLParserRULE_fullEdgePointingRight                             = 205
	GQLParserRULE_fullEdgeLeftOrUndirected                          = 206
	GQLParserRULE_fullEdgeUndirectedOrRight                         = 207
	GQLParserRULE_fullEdgeLeftOrRight                               = 208
	GQLParserRULE_fullEdgeAnyDirection                              = 209
	GQLParserRULE_abbreviatedEdgePattern                            = 210
	GQLParserRULE_parenthesizedPathPatternExpression                = 211
	GQLParserRULE_subpathVariableDeclaration                        = 212
	GQLParserRULE_parenthesizedPathPatternWhereClause               = 213
	GQLParserRULE_labelExpression                                   = 214
	GQLParserRULE_pathVariableReference                             = 215
	GQLParserRULE_elementVariableReference                          = 216
	GQLParserRULE_graphPatternQuantifier                            = 217
	GQLParserRULE_fixedQuantifier                                   = 218
	GQLParserRULE_generalQuantifier                                 = 219
	GQLParserRULE_lowerBound                                        = 220
	GQLParserRULE_upperBound                                        = 221
	GQLParserRULE_simplifiedPathPatternExpression                   = 222
	GQLParserRULE_simplifiedDefaultingLeft                          = 223
	GQLParserRULE_simplifiedDefaultingUndirected                    = 224
	GQLParserRULE_simplifiedDefaultingRight                         = 225
	GQLParserRULE_simplifiedDefaultingLeftOrUndirected              = 226
	GQLParserRULE_simplifiedDefaultingUndirectedOrRight             = 227
	GQLParserRULE_simplifiedDefaultingLeftOrRight                   = 228
	GQLParserRULE_simplifiedDefaultingAnyDirection                  = 229
	GQLParserRULE_simplifiedContents                                = 230
	GQLParserRULE_simplifiedPathUnion                               = 231
	GQLParserRULE_simplifiedMultisetAlternation                     = 232
	GQLParserRULE_simplifiedTerm                                    = 233
	GQLParserRULE_simplifiedFactorLow                               = 234
	GQLParserRULE_simplifiedFactorHigh                              = 235
	GQLParserRULE_simplifiedQuantified                              = 236
	GQLParserRULE_simplifiedQuestioned                              = 237
	GQLParserRULE_simplifiedTertiary                                = 238
	GQLParserRULE_simplifiedDirectionOverride                       = 239
	GQLParserRULE_simplifiedOverrideLeft                            = 240
	GQLParserRULE_simplifiedOverrideUndirected                      = 241
	GQLParserRULE_simplifiedOverrideRight                           = 242
	GQLParserRULE_simplifiedOverrideLeftOrUndirected                = 243
	GQLParserRULE_simplifiedOverrideUndirectedOrRight               = 244
	GQLParserRULE_simplifiedOverrideLeftOrRight                     = 245
	GQLParserRULE_simplifiedOverrideAnyDirection                    = 246
	GQLParserRULE_simplifiedSecondary                               = 247
	GQLParserRULE_simplifiedNegation                                = 248
	GQLParserRULE_simplifiedPrimary                                 = 249
	GQLParserRULE_whereClause                                       = 250
	GQLParserRULE_yieldClause                                       = 251
	GQLParserRULE_yieldItemList                                     = 252
	GQLParserRULE_yieldItem                                         = 253
	GQLParserRULE_yieldItemName                                     = 254
	GQLParserRULE_yieldItemAlias                                    = 255
	GQLParserRULE_groupByClause                                     = 256
	GQLParserRULE_groupingElementList                               = 257
	GQLParserRULE_groupingElement                                   = 258
	GQLParserRULE_emptyGroupingSet                                  = 259
	GQLParserRULE_orderByClause                                     = 260
	GQLParserRULE_sortSpecificationList                             = 261
	GQLParserRULE_sortSpecification                                 = 262
	GQLParserRULE_sortKey                                           = 263
	GQLParserRULE_orderingSpecification                             = 264
	GQLParserRULE_nullOrdering                                      = 265
	GQLParserRULE_limitClause                                       = 266
	GQLParserRULE_offsetClause                                      = 267
	GQLParserRULE_offsetSynonym                                     = 268
	GQLParserRULE_schemaReference                                   = 269
	GQLParserRULE_absoluteCatalogSchemaReference                    = 270
	GQLParserRULE_catalogSchemaParentAndName                        = 271
	GQLParserRULE_relativeCatalogSchemaReference                    = 272
	GQLParserRULE_predefinedSchemaReference                         = 273
	GQLParserRULE_absoluteDirectoryPath                             = 274
	GQLParserRULE_relativeDirectoryPath                             = 275
	GQLParserRULE_simpleDirectoryPath                               = 276
	GQLParserRULE_graphReference                                    = 277
	GQLParserRULE_catalogGraphParentAndName                         = 278
	GQLParserRULE_homeGraph                                         = 279
	GQLParserRULE_graphTypeReference                                = 280
	GQLParserRULE_catalogGraphTypeParentAndName                     = 281
	GQLParserRULE_bindingTableReference                             = 282
	GQLParserRULE_procedureReference                                = 283
	GQLParserRULE_catalogProcedureParentAndName                     = 284
	GQLParserRULE_catalogObjectParentReference                      = 285
	GQLParserRULE_referenceParameterSpecification                   = 286
	GQLParserRULE_nestedGraphTypeSpecification                      = 287
	GQLParserRULE_graphTypeSpecificationBody                        = 288
	GQLParserRULE_elementTypeList                                   = 289
	GQLParserRULE_elementTypeSpecification                          = 290
	GQLParserRULE_compositePrimaryKey                               = 291
	GQLParserRULE_compositeUniqueConstraint                         = 292
	GQLParserRULE_fieldNameList                                     = 293
	GQLParserRULE_nodeTypeSpecification                             = 294
	GQLParserRULE_nodeTypePattern                                   = 295
	GQLParserRULE_nodeTypePhrase                                    = 296
	GQLParserRULE_nodeTypePhraseFiller                              = 297
	GQLParserRULE_nodeTypeFiller                                    = 298
	GQLParserRULE_localNodeTypeAlias                                = 299
	GQLParserRULE_nodeTypeImpliedContent                            = 300
	GQLParserRULE_nodeTypeKeyLabelSet                               = 301
	GQLParserRULE_nodeTypeLabelSet                                  = 302
	GQLParserRULE_nodeTypePropertyTypes                             = 303
	GQLParserRULE_edgeTypeSpecification                             = 304
	GQLParserRULE_edgeTypePattern                                   = 305
	GQLParserRULE_edgeTypePhrase                                    = 306
	GQLParserRULE_edgeTypePhraseFiller                              = 307
	GQLParserRULE_edgeTypeFiller                                    = 308
	GQLParserRULE_edgeTypeImpliedContent                            = 309
	GQLParserRULE_edgeTypeKeyLabelSet                               = 310
	GQLParserRULE_edgeTypeLabelSet                                  = 311
	GQLParserRULE_edgeTypePropertyTypes                             = 312
	GQLParserRULE_edgeTypePatternDirected                           = 313
	GQLParserRULE_edgeTypePatternPointingRight                      = 314
	GQLParserRULE_edgeTypePatternPointingLeft                       = 315
	GQLParserRULE_edgeTypePatternUndirected                         = 316
	GQLParserRULE_arcTypePointingRight                              = 317
	GQLParserRULE_simpleArcTypePointingRight                        = 318
	GQLParserRULE_arcWithCardinalityPointingRight                   = 319
	GQLParserRULE_arcTypePointingLeft                               = 320
	GQLParserRULE_simpleArcTypePointingLeft                         = 321
	GQLParserRULE_arcWithCardinalityPointingLeft                    = 322
	GQLParserRULE_arcTypeUndirected                                 = 323
	GQLParserRULE_simpleArcTypeUndirected                           = 324
	GQLParserRULE_arcWithCardinalityUndirected                      = 325
	GQLParserRULE_cardinality                                       = 326
	GQLParserRULE_cardinalityFiller                                 = 327
	GQLParserRULE_cardinalityLowerBound                             = 328
	GQLParserRULE_cardinalityUpperBound                             = 329
	GQLParserRULE_sourceNodeTypeReference                           = 330
	GQLParserRULE_destinationNodeTypeReference                      = 331
	GQLParserRULE_edgeKind                                          = 332
	GQLParserRULE_endpointPairPhrase                                = 333
	GQLParserRULE_endpointPair                                      = 334
	GQLParserRULE_endpointPairDirected                              = 335
	GQLParserRULE_endpointPairPointingRight                         = 336
	GQLParserRULE_endpointPairPointingLeft                          = 337
	GQLParserRULE_endpointPairUndirected                            = 338
	GQLParserRULE_connectorPointingRight                            = 339
	GQLParserRULE_connectorUndirected                               = 340
	GQLParserRULE_sourceNodeTypeAlias                               = 341
	GQLParserRULE_destinationNodeTypeAlias                          = 342
	GQLParserRULE_labelSetPhrase                                    = 343
	GQLParserRULE_labelSetSpecification                             = 344
	GQLParserRULE_propertyTypesSpecification                        = 345
	GQLParserRULE_propertyTypeList                                  = 346
	GQLParserRULE_propertyType                                      = 347
	GQLParserRULE_primaryKey                                        = 348
	GQLParserRULE_checkConstraint                                   = 349
	GQLParserRULE_propertyValueType                                 = 350
	GQLParserRULE_bindingTableType                                  = 351
	GQLParserRULE_valueType                                         = 352
	GQLParserRULE_typed                                             = 353
	GQLParserRULE_predefinedType                                    = 354
	GQLParserRULE_booleanType                                       = 355
	GQLParserRULE_characterStringType                               = 356
	GQLParserRULE_byteStringType                                    = 357
	GQLParserRULE_minLength                                         = 358
	GQLParserRULE_maxLength                                         = 359
	GQLParserRULE_fixedLength                                       = 360
	GQLParserRULE_numericType                                       = 361
	GQLParserRULE_exactNumericType                                  = 362
	GQLParserRULE_binaryExactNumericType                            = 363
	GQLParserRULE_signedBinaryExactNumericType                      = 364
	GQLParserRULE_unsignedBinaryExactNumericType                    = 365
	GQLParserRULE_verboseBinaryExactNumericType                     = 366
	GQLParserRULE_decimalExactNumericType                           = 367
	GQLParserRULE_precision                                         = 368
	GQLParserRULE_scale                                             = 369
	GQLParserRULE_approximateNumericType                            = 370
	GQLParserRULE_temporalType                                      = 371
	GQLParserRULE_temporalInstantType                               = 372
	GQLParserRULE_datetimeType                                      = 373
	GQLParserRULE_localdatetimeType                                 = 374
	GQLParserRULE_dateType                                          = 375
	GQLParserRULE_timeType                                          = 376
	GQLParserRULE_localtimeType                                     = 377
	GQLParserRULE_temporalDurationType                              = 378
	GQLParserRULE_temporalDurationQualifier                         = 379
	GQLParserRULE_referenceValueType                                = 380
	GQLParserRULE_immaterialValueType                               = 381
	GQLParserRULE_nullType                                          = 382
	GQLParserRULE_emptyType                                         = 383
	GQLParserRULE_graphReferenceValueType                           = 384
	GQLParserRULE_closedGraphReferenceValueType                     = 385
	GQLParserRULE_openGraphReferenceValueType                       = 386
	GQLParserRULE_bindingTableReferenceValueType                    = 387
	GQLParserRULE_nodeReferenceValueType                            = 388
	GQLParserRULE_closedNodeReferenceValueType                      = 389
	GQLParserRULE_openNodeReferenceValueType                        = 390
	GQLParserRULE_edgeReferenceValueType                            = 391
	GQLParserRULE_closedEdgeReferenceValueType                      = 392
	GQLParserRULE_openEdgeReferenceValueType                        = 393
	GQLParserRULE_pathValueType                                     = 394
	GQLParserRULE_listValueTypeName                                 = 395
	GQLParserRULE_listValueTypeNameSynonym                          = 396
	GQLParserRULE_recordType                                        = 397
	GQLParserRULE_fieldTypesSpecification                           = 398
	GQLParserRULE_fieldTypeList                                     = 399
	GQLParserRULE_notNull                                           = 400
	GQLParserRULE_fieldType                                         = 401
	GQLParserRULE_searchCondition                                   = 402
	GQLParserRULE_predicate                                         = 403
	GQLParserRULE_compOp                                            = 404
	GQLParserRULE_existsPredicate                                   = 405
	GQLParserRULE_nullPredicate                                     = 406
	GQLParserRULE_nullPredicatePart2                                = 407
	GQLParserRULE_valueTypePredicate                                = 408
	GQLParserRULE_valueTypePredicatePart2                           = 409
	GQLParserRULE_normalizedPredicatePart2                          = 410
	GQLParserRULE_directedPredicate                                 = 411
	GQLParserRULE_directedPredicatePart2                            = 412
	GQLParserRULE_labeledPredicate                                  = 413
	GQLParserRULE_labeledPredicatePart2                             = 414
	GQLParserRULE_isLabeledOrColon                                  = 415
	GQLParserRULE_sourceDestinationPredicate                        = 416
	GQLParserRULE_nodeReference                                     = 417
	GQLParserRULE_sourcePredicatePart2                              = 418
	GQLParserRULE_destinationPredicatePart2                         = 419
	GQLParserRULE_edgeReference                                     = 420
	GQLParserRULE_all_differentPredicate                            = 421
	GQLParserRULE_samePredicate                                     = 422
	GQLParserRULE_property_existsPredicate                          = 423
	GQLParserRULE_valueExpression                                   = 424
	GQLParserRULE_valueFunction                                     = 425
	GQLParserRULE_booleanValueExpression                            = 426
	GQLParserRULE_characterOrByteStringFunction                     = 427
	GQLParserRULE_subCharacterOrByteString                          = 428
	GQLParserRULE_trimSingleCharacterOrByteString                   = 429
	GQLParserRULE_foldCharacterString                               = 430
	GQLParserRULE_trimMultiCharacterCharacterString                 = 431
	GQLParserRULE_normalizeCharacterString                          = 432
	GQLParserRULE_nodeReferenceValueExpression                      = 433
	GQLParserRULE_edgeReferenceValueExpression                      = 434
	GQLParserRULE_aggregatingValueExpression                        = 435
	GQLParserRULE_valueExpressionPrimary                            = 436
	GQLParserRULE_parenthesizedValueExpression                      = 437
	GQLParserRULE_nonParenthesizedValueExpressionPrimary            = 438
	GQLParserRULE_nonParenthesizedValueExpressionPrimarySpecialCase = 439
	GQLParserRULE_unsignedValueSpecification                        = 440
	GQLParserRULE_nonNegativeIntegerSpecification                   = 441
	GQLParserRULE_generalValueSpecification                         = 442
	GQLParserRULE_dynamicParameterSpecification                     = 443
	GQLParserRULE_letValueExpression                                = 444
	GQLParserRULE_valueQueryExpression                              = 445
	GQLParserRULE_caseExpression                                    = 446
	GQLParserRULE_caseAbbreviation                                  = 447
	GQLParserRULE_caseSpecification                                 = 448
	GQLParserRULE_simpleCase                                        = 449
	GQLParserRULE_searchedCase                                      = 450
	GQLParserRULE_simpleWhenClause                                  = 451
	GQLParserRULE_searchedWhenClause                                = 452
	GQLParserRULE_elseClause                                        = 453
	GQLParserRULE_caseOperand                                       = 454
	GQLParserRULE_whenOperandList                                   = 455
	GQLParserRULE_whenOperand                                       = 456
	GQLParserRULE_result                                            = 457
	GQLParserRULE_resultExpression                                  = 458
	GQLParserRULE_castSpecification                                 = 459
	GQLParserRULE_castOperand                                       = 460
	GQLParserRULE_castTarget                                        = 461
	GQLParserRULE_aggregateFunction                                 = 462
	GQLParserRULE_generalSetFunction                                = 463
	GQLParserRULE_binarySetFunction                                 = 464
	GQLParserRULE_generalSetFunctionType                            = 465
	GQLParserRULE_setQuantifier                                     = 466
	GQLParserRULE_binarySetFunctionType                             = 467
	GQLParserRULE_dependentValueExpression                          = 468
	GQLParserRULE_independentValueExpression                        = 469
	GQLParserRULE_element_idFunction                                = 470
	GQLParserRULE_bindingVariableReference                          = 471
	GQLParserRULE_pathValueExpression                               = 472
	GQLParserRULE_pathValueConstructor                              = 473
	GQLParserRULE_pathValueConstructorByEnumeration                 = 474
	GQLParserRULE_pathElementList                                   = 475
	GQLParserRULE_pathElementListStart                              = 476
	GQLParserRULE_pathElementListStep                               = 477
	GQLParserRULE_listValueExpression                               = 478
	GQLParserRULE_listValueFunction                                 = 479
	GQLParserRULE_trimListFunction                                  = 480
	GQLParserRULE_elementsFunction                                  = 481
	GQLParserRULE_listValueConstructor                              = 482
	GQLParserRULE_listValueConstructorByEnumeration                 = 483
	GQLParserRULE_listElementList                                   = 484
	GQLParserRULE_listElement                                       = 485
	GQLParserRULE_recordConstructor                                 = 486
	GQLParserRULE_fieldsSpecification                               = 487
	GQLParserRULE_fieldList                                         = 488
	GQLParserRULE_field                                             = 489
	GQLParserRULE_truthValue                                        = 490
	GQLParserRULE_numericValueExpression                            = 491
	GQLParserRULE_numericValueFunction                              = 492
	GQLParserRULE_lengthExpression                                  = 493
	GQLParserRULE_cardinalityExpression                             = 494
	GQLParserRULE_cardinalityExpressionArgument                     = 495
	GQLParserRULE_charLengthExpression                              = 496
	GQLParserRULE_byteLengthExpression                              = 497
	GQLParserRULE_pathLengthExpression                              = 498
	GQLParserRULE_absoluteValueExpression                           = 499
	GQLParserRULE_modulusExpression                                 = 500
	GQLParserRULE_numericValueExpressionDividend                    = 501
	GQLParserRULE_numericValueExpressionDivisor                     = 502
	GQLParserRULE_trigonometricFunction                             = 503
	GQLParserRULE_trigonometricFunctionName                         = 504
	GQLParserRULE_generalLogarithmFunction                          = 505
	GQLParserRULE_generalLogarithmBase                              = 506
	GQLParserRULE_generalLogarithmArgument                          = 507
	GQLParserRULE_commonLogarithm                                   = 508
	GQLParserRULE_naturalLogarithm                                  = 509
	GQLParserRULE_exponentialFunction                               = 510
	GQLParserRULE_powerFunction                                     = 511
	GQLParserRULE_numericValueExpressionBase                        = 512
	GQLParserRULE_numericValueExpressionExponent                    = 513
	GQLParserRULE_squareRoot                                        = 514
	GQLParserRULE_floorFunction                                     = 515
	GQLParserRULE_ceilingFunction                                   = 516
	GQLParserRULE_characterStringValueExpression                    = 517
	GQLParserRULE_byteStringValueExpression                         = 518
	GQLParserRULE_trimOperands                                      = 519
	GQLParserRULE_trimCharacterOrByteStringSource                   = 520
	GQLParserRULE_trimSpecification                                 = 521
	GQLParserRULE_trimCharacterOrByteString                         = 522
	GQLParserRULE_normalForm                                        = 523
	GQLParserRULE_stringLength                                      = 524
	GQLParserRULE_datetimeValueExpression                           = 525
	GQLParserRULE_datetimeValueFunction                             = 526
	GQLParserRULE_dateFunction                                      = 527
	GQLParserRULE_timeFunction                                      = 528
	GQLParserRULE_localtimeFunction                                 = 529
	GQLParserRULE_datetimeFunction                                  = 530
	GQLParserRULE_localdatetimeFunction                             = 531
	GQLParserRULE_dateFunctionParameters                            = 532
	GQLParserRULE_timeFunctionParameters                            = 533
	GQLParserRULE_datetimeFunctionParameters                        = 534
	GQLParserRULE_durationValueExpression                           = 535
	GQLParserRULE_datetimeSubtraction                               = 536
	GQLParserRULE_datetimeSubtractionParameters                     = 537
	GQLParserRULE_datetimeValueExpression1                          = 538
	GQLParserRULE_datetimeValueExpression2                          = 539
	GQLParserRULE_durationValueFunction                             = 540
	GQLParserRULE_durationFunction                                  = 541
	GQLParserRULE_durationFunctionParameters                        = 542
	GQLParserRULE_objectName                                        = 543
	GQLParserRULE_objectNameOrBindingVariable                       = 544
	GQLParserRULE_directoryName                                     = 545
	GQLParserRULE_schemaName                                        = 546
	GQLParserRULE_graphName                                         = 547
	GQLParserRULE_delimitedGraphName                                = 548
	GQLParserRULE_graphTypeName                                     = 549
	GQLParserRULE_nodeTypeName                                      = 550
	GQLParserRULE_edgeTypeName                                      = 551
	GQLParserRULE_bindingTableName                                  = 552
	GQLParserRULE_delimitedBindingTableName                         = 553
	GQLParserRULE_procedureName                                     = 554
	GQLParserRULE_labelName                                         = 555
	GQLParserRULE_propertyName                                      = 556
	GQLParserRULE_fieldName                                         = 557
	GQLParserRULE_elementVariable                                   = 558
	GQLParserRULE_pathVariable                                      = 559
	GQLParserRULE_subpathVariable                                   = 560
	GQLParserRULE_bindingVariable                                   = 561
	GQLParserRULE_unsignedLiteral                                   = 562
	GQLParserRULE_generalLiteral                                    = 563
	GQLParserRULE_temporalLiteral                                   = 564
	GQLParserRULE_dateLiteral                                       = 565
	GQLParserRULE_timeLiteral                                       = 566
	GQLParserRULE_datetimeLiteral                                   = 567
	GQLParserRULE_listLiteral                                       = 568
	GQLParserRULE_recordLiteral                                     = 569
	GQLParserRULE_identifier                                        = 570
	GQLParserRULE_regularIdentifier                                 = 571
	GQLParserRULE_timeZoneString                                    = 572
	GQLParserRULE_characterStringLiteral                            = 573
	GQLParserRULE_unsignedNumericLiteral                            = 574
	GQLParserRULE_exactNumericLiteral                               = 575
	GQLParserRULE_approximateNumericLiteral                         = 576
	GQLParserRULE_unsignedInteger                                   = 577
	GQLParserRULE_unsignedDecimalInteger                            = 578
	GQLParserRULE_nullLiteral                                       = 579
	GQLParserRULE_dateString                                        = 580
	GQLParserRULE_timeString                                        = 581
	GQLParserRULE_datetimeString                                    = 582
	GQLParserRULE_durationLiteral                                   = 583
	GQLParserRULE_durationString                                    = 584
	GQLParserRULE_nodeSynonym                                       = 585
	GQLParserRULE_edgesSynonym                                      = 586
	GQLParserRULE_edgeSynonym                                       = 587
	GQLParserRULE_nonReservedWords                                  = 588
)

// IGqlProgramContext is an interface to support dynamic dispatch.
type IGqlProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProgramActivity() IProgramActivityContext
	EOF() antlr.TerminalNode
	SessionCloseCommand() ISessionCloseCommandContext

	// IsGqlProgramContext differentiates from other interfaces.
	IsGqlProgramContext()
}

type GqlProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGqlProgramContext() *GqlProgramContext {
	var p = new(GqlProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_gqlProgram
	return p
}

func InitEmptyGqlProgramContext(p *GqlProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_gqlProgram
}

func (*GqlProgramContext) IsGqlProgramContext() {}

func NewGqlProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GqlProgramContext {
	var p = new(GqlProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_gqlProgram

	return p
}

func (s *GqlProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *GqlProgramContext) ProgramActivity() IProgramActivityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramActivityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramActivityContext)
}

func (s *GqlProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(GQLParserEOF, 0)
}

func (s *GqlProgramContext) SessionCloseCommand() ISessionCloseCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionCloseCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionCloseCommandContext)
}

func (s *GqlProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GqlProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GqlProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGqlProgram(s)
	}
}

func (s *GqlProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGqlProgram(s)
	}
}

func (p *GQLParser) GqlProgram() (localctx IGqlProgramContext) {
	localctx = NewGqlProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, GQLParserRULE_gqlProgram)
	var _la int

	p.SetState(1187)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1178)
			p.ProgramActivity()
		}
		p.SetState(1180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserSESSION {
			{
				p.SetState(1179)
				p.SessionCloseCommand()
			}

		}
		{
			p.SetState(1182)
			p.Match(GQLParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1184)
			p.SessionCloseCommand()
		}
		{
			p.SetState(1185)
			p.Match(GQLParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProgramActivityContext is an interface to support dynamic dispatch.
type IProgramActivityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SessionActivity() ISessionActivityContext
	TransactionActivity() ITransactionActivityContext

	// IsProgramActivityContext differentiates from other interfaces.
	IsProgramActivityContext()
}

type ProgramActivityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramActivityContext() *ProgramActivityContext {
	var p = new(ProgramActivityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_programActivity
	return p
}

func InitEmptyProgramActivityContext(p *ProgramActivityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_programActivity
}

func (*ProgramActivityContext) IsProgramActivityContext() {}

func NewProgramActivityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramActivityContext {
	var p = new(ProgramActivityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_programActivity

	return p
}

func (s *ProgramActivityContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramActivityContext) SessionActivity() ISessionActivityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionActivityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionActivityContext)
}

func (s *ProgramActivityContext) TransactionActivity() ITransactionActivityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionActivityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionActivityContext)
}

func (s *ProgramActivityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramActivityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramActivityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterProgramActivity(s)
	}
}

func (s *ProgramActivityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitProgramActivity(s)
	}
}

func (p *GQLParser) ProgramActivity() (localctx IProgramActivityContext) {
	localctx = NewProgramActivityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, GQLParserRULE_programActivity)
	p.SetState(1191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserSESSION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1189)
			p.SessionActivity()
		}

	case GQLParserAT, GQLParserCALL, GQLParserCOMMIT, GQLParserCREATE, GQLParserDELETE, GQLParserDETACH, GQLParserDROP, GQLParserFILTER, GQLParserFINISH, GQLParserFOR, GQLParserINSERT, GQLParserLET, GQLParserLIMIT, GQLParserMATCH, GQLParserNODETACH, GQLParserOFFSET, GQLParserOPTIONAL, GQLParserORDER, GQLParserREMOVE, GQLParserRETURN, GQLParserROLLBACK, GQLParserSELECT, GQLParserSET, GQLParserSKIP_RESERVED_WORD, GQLParserSTART, GQLParserUSE, GQLParserVALUE, GQLParserBINDING, GQLParserGRAPH, GQLParserPROPERTY, GQLParserTABLE, GQLParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1190)
			p.TransactionActivity()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionActivityContext is an interface to support dynamic dispatch.
type ISessionActivityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSessionResetCommand() []ISessionResetCommandContext
	SessionResetCommand(i int) ISessionResetCommandContext
	AllSessionSetCommand() []ISessionSetCommandContext
	SessionSetCommand(i int) ISessionSetCommandContext

	// IsSessionActivityContext differentiates from other interfaces.
	IsSessionActivityContext()
}

type SessionActivityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionActivityContext() *SessionActivityContext {
	var p = new(SessionActivityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionActivity
	return p
}

func InitEmptySessionActivityContext(p *SessionActivityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionActivity
}

func (*SessionActivityContext) IsSessionActivityContext() {}

func NewSessionActivityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionActivityContext {
	var p = new(SessionActivityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sessionActivity

	return p
}

func (s *SessionActivityContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionActivityContext) AllSessionResetCommand() []ISessionResetCommandContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISessionResetCommandContext); ok {
			len++
		}
	}

	tst := make([]ISessionResetCommandContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISessionResetCommandContext); ok {
			tst[i] = t.(ISessionResetCommandContext)
			i++
		}
	}

	return tst
}

func (s *SessionActivityContext) SessionResetCommand(i int) ISessionResetCommandContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionResetCommandContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionResetCommandContext)
}

func (s *SessionActivityContext) AllSessionSetCommand() []ISessionSetCommandContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISessionSetCommandContext); ok {
			len++
		}
	}

	tst := make([]ISessionSetCommandContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISessionSetCommandContext); ok {
			tst[i] = t.(ISessionSetCommandContext)
			i++
		}
	}

	return tst
}

func (s *SessionActivityContext) SessionSetCommand(i int) ISessionSetCommandContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionSetCommandContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionSetCommandContext)
}

func (s *SessionActivityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionActivityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionActivityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSessionActivity(s)
	}
}

func (s *SessionActivityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSessionActivity(s)
	}
}

func (p *GQLParser) SessionActivity() (localctx ISessionActivityContext) {
	localctx = NewSessionActivityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, GQLParserRULE_sessionActivity)
	var _alt int

	p.SetState(1209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1193)
					p.SessionResetCommand()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1196)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1199)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1198)
					p.SessionSetCommand()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1201)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1206)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1203)
					p.SessionResetCommand()
				}

			}
			p.SetState(1208)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionActivityContext is an interface to support dynamic dispatch.
type ITransactionActivityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StartTransactionCommand() IStartTransactionCommandContext
	ProcedureSpecification() IProcedureSpecificationContext
	EndTransactionCommand() IEndTransactionCommandContext

	// IsTransactionActivityContext differentiates from other interfaces.
	IsTransactionActivityContext()
}

type TransactionActivityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionActivityContext() *TransactionActivityContext {
	var p = new(TransactionActivityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_transactionActivity
	return p
}

func InitEmptyTransactionActivityContext(p *TransactionActivityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_transactionActivity
}

func (*TransactionActivityContext) IsTransactionActivityContext() {}

func NewTransactionActivityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionActivityContext {
	var p = new(TransactionActivityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_transactionActivity

	return p
}

func (s *TransactionActivityContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionActivityContext) StartTransactionCommand() IStartTransactionCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartTransactionCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartTransactionCommandContext)
}

func (s *TransactionActivityContext) ProcedureSpecification() IProcedureSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSpecificationContext)
}

func (s *TransactionActivityContext) EndTransactionCommand() IEndTransactionCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndTransactionCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndTransactionCommandContext)
}

func (s *TransactionActivityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionActivityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionActivityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTransactionActivity(s)
	}
}

func (s *TransactionActivityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTransactionActivity(s)
	}
}

func (p *GQLParser) TransactionActivity() (localctx ITransactionActivityContext) {
	localctx = NewTransactionActivityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, GQLParserRULE_transactionActivity)
	var _la int

	p.SetState(1223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserSTART:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1211)
			p.StartTransactionCommand()
		}
		p.SetState(1216)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-34)) & ^0x3f) == 0 && ((int64(1)<<(_la-34))&3461332977278001153) != 0) || ((int64((_la-103)) & ^0x3f) == 0 && ((int64(1)<<(_la-103))&6342202976706233345) != 0) || ((int64((_la-180)) & ^0x3f) == 0 && ((int64(1)<<(_la-180))&351843721159689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&34493958145) != 0) || _la == GQLParserLEFT_BRACE {
			{
				p.SetState(1212)
				p.ProcedureSpecification()
			}
			p.SetState(1214)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == GQLParserCOMMIT || _la == GQLParserROLLBACK {
				{
					p.SetState(1213)
					p.EndTransactionCommand()
				}

			}

		}

	case GQLParserAT, GQLParserCALL, GQLParserCREATE, GQLParserDELETE, GQLParserDETACH, GQLParserDROP, GQLParserFILTER, GQLParserFINISH, GQLParserFOR, GQLParserINSERT, GQLParserLET, GQLParserLIMIT, GQLParserMATCH, GQLParserNODETACH, GQLParserOFFSET, GQLParserOPTIONAL, GQLParserORDER, GQLParserREMOVE, GQLParserRETURN, GQLParserSELECT, GQLParserSET, GQLParserSKIP_RESERVED_WORD, GQLParserUSE, GQLParserVALUE, GQLParserBINDING, GQLParserGRAPH, GQLParserPROPERTY, GQLParserTABLE, GQLParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1218)
			p.ProcedureSpecification()
		}
		p.SetState(1220)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserCOMMIT || _la == GQLParserROLLBACK {
			{
				p.SetState(1219)
				p.EndTransactionCommand()
			}

		}

	case GQLParserCOMMIT, GQLParserROLLBACK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1222)
			p.EndTransactionCommand()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEndTransactionCommandContext is an interface to support dynamic dispatch.
type IEndTransactionCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RollbackCommand() IRollbackCommandContext
	CommitCommand() ICommitCommandContext

	// IsEndTransactionCommandContext differentiates from other interfaces.
	IsEndTransactionCommandContext()
}

type EndTransactionCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndTransactionCommandContext() *EndTransactionCommandContext {
	var p = new(EndTransactionCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_endTransactionCommand
	return p
}

func InitEmptyEndTransactionCommandContext(p *EndTransactionCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_endTransactionCommand
}

func (*EndTransactionCommandContext) IsEndTransactionCommandContext() {}

func NewEndTransactionCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndTransactionCommandContext {
	var p = new(EndTransactionCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_endTransactionCommand

	return p
}

func (s *EndTransactionCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *EndTransactionCommandContext) RollbackCommand() IRollbackCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollbackCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollbackCommandContext)
}

func (s *EndTransactionCommandContext) CommitCommand() ICommitCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommitCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommitCommandContext)
}

func (s *EndTransactionCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndTransactionCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndTransactionCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEndTransactionCommand(s)
	}
}

func (s *EndTransactionCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEndTransactionCommand(s)
	}
}

func (p *GQLParser) EndTransactionCommand() (localctx IEndTransactionCommandContext) {
	localctx = NewEndTransactionCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, GQLParserRULE_endTransactionCommand)
	p.SetState(1227)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserROLLBACK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1225)
			p.RollbackCommand()
		}

	case GQLParserCOMMIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1226)
			p.CommitCommand()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionSetCommandContext is an interface to support dynamic dispatch.
type ISessionSetCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SESSION() antlr.TerminalNode
	SET() antlr.TerminalNode
	SessionSetSchemaClause() ISessionSetSchemaClauseContext
	SessionSetGraphClause() ISessionSetGraphClauseContext
	SessionSetTimeZoneClause() ISessionSetTimeZoneClauseContext
	SessionSetParameterClause() ISessionSetParameterClauseContext

	// IsSessionSetCommandContext differentiates from other interfaces.
	IsSessionSetCommandContext()
}

type SessionSetCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionSetCommandContext() *SessionSetCommandContext {
	var p = new(SessionSetCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetCommand
	return p
}

func InitEmptySessionSetCommandContext(p *SessionSetCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetCommand
}

func (*SessionSetCommandContext) IsSessionSetCommandContext() {}

func NewSessionSetCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionSetCommandContext {
	var p = new(SessionSetCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sessionSetCommand

	return p
}

func (s *SessionSetCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionSetCommandContext) SESSION() antlr.TerminalNode {
	return s.GetToken(GQLParserSESSION, 0)
}

func (s *SessionSetCommandContext) SET() antlr.TerminalNode {
	return s.GetToken(GQLParserSET, 0)
}

func (s *SessionSetCommandContext) SessionSetSchemaClause() ISessionSetSchemaClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionSetSchemaClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionSetSchemaClauseContext)
}

func (s *SessionSetCommandContext) SessionSetGraphClause() ISessionSetGraphClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionSetGraphClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionSetGraphClauseContext)
}

func (s *SessionSetCommandContext) SessionSetTimeZoneClause() ISessionSetTimeZoneClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionSetTimeZoneClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionSetTimeZoneClauseContext)
}

func (s *SessionSetCommandContext) SessionSetParameterClause() ISessionSetParameterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionSetParameterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionSetParameterClauseContext)
}

func (s *SessionSetCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionSetCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionSetCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSessionSetCommand(s)
	}
}

func (s *SessionSetCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSessionSetCommand(s)
	}
}

func (p *GQLParser) SessionSetCommand() (localctx ISessionSetCommandContext) {
	localctx = NewSessionSetCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, GQLParserRULE_sessionSetCommand)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1229)
		p.Match(GQLParserSESSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1230)
		p.Match(GQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1235)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1231)
			p.SessionSetSchemaClause()
		}

	case 2:
		{
			p.SetState(1232)
			p.SessionSetGraphClause()
		}

	case 3:
		{
			p.SetState(1233)
			p.SessionSetTimeZoneClause()
		}

	case 4:
		{
			p.SetState(1234)
			p.SessionSetParameterClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionSetSchemaClauseContext is an interface to support dynamic dispatch.
type ISessionSetSchemaClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SCHEMA() antlr.TerminalNode
	SchemaReference() ISchemaReferenceContext

	// IsSessionSetSchemaClauseContext differentiates from other interfaces.
	IsSessionSetSchemaClauseContext()
}

type SessionSetSchemaClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionSetSchemaClauseContext() *SessionSetSchemaClauseContext {
	var p = new(SessionSetSchemaClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetSchemaClause
	return p
}

func InitEmptySessionSetSchemaClauseContext(p *SessionSetSchemaClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetSchemaClause
}

func (*SessionSetSchemaClauseContext) IsSessionSetSchemaClauseContext() {}

func NewSessionSetSchemaClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionSetSchemaClauseContext {
	var p = new(SessionSetSchemaClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sessionSetSchemaClause

	return p
}

func (s *SessionSetSchemaClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionSetSchemaClauseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(GQLParserSCHEMA, 0)
}

func (s *SessionSetSchemaClauseContext) SchemaReference() ISchemaReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaReferenceContext)
}

func (s *SessionSetSchemaClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionSetSchemaClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionSetSchemaClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSessionSetSchemaClause(s)
	}
}

func (s *SessionSetSchemaClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSessionSetSchemaClause(s)
	}
}

func (p *GQLParser) SessionSetSchemaClause() (localctx ISessionSetSchemaClauseContext) {
	localctx = NewSessionSetSchemaClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, GQLParserRULE_sessionSetSchemaClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1237)
		p.Match(GQLParserSCHEMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1238)
		p.SchemaReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionSetGraphClauseContext is an interface to support dynamic dispatch.
type ISessionSetGraphClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GRAPH() antlr.TerminalNode
	GraphExpression() IGraphExpressionContext
	PROPERTY() antlr.TerminalNode

	// IsSessionSetGraphClauseContext differentiates from other interfaces.
	IsSessionSetGraphClauseContext()
}

type SessionSetGraphClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionSetGraphClauseContext() *SessionSetGraphClauseContext {
	var p = new(SessionSetGraphClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetGraphClause
	return p
}

func InitEmptySessionSetGraphClauseContext(p *SessionSetGraphClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetGraphClause
}

func (*SessionSetGraphClauseContext) IsSessionSetGraphClauseContext() {}

func NewSessionSetGraphClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionSetGraphClauseContext {
	var p = new(SessionSetGraphClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sessionSetGraphClause

	return p
}

func (s *SessionSetGraphClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionSetGraphClauseContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserGRAPH, 0)
}

func (s *SessionSetGraphClauseContext) GraphExpression() IGraphExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphExpressionContext)
}

func (s *SessionSetGraphClauseContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY, 0)
}

func (s *SessionSetGraphClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionSetGraphClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionSetGraphClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSessionSetGraphClause(s)
	}
}

func (s *SessionSetGraphClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSessionSetGraphClause(s)
	}
}

func (p *GQLParser) SessionSetGraphClause() (localctx ISessionSetGraphClauseContext) {
	localctx = NewSessionSetGraphClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, GQLParserRULE_sessionSetGraphClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1241)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserPROPERTY {
		{
			p.SetState(1240)
			p.Match(GQLParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1243)
		p.Match(GQLParserGRAPH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1244)
		p.GraphExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionSetTimeZoneClauseContext is an interface to support dynamic dispatch.
type ISessionSetTimeZoneClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TIME() antlr.TerminalNode
	ZONE() antlr.TerminalNode
	SetTimeZoneValue() ISetTimeZoneValueContext

	// IsSessionSetTimeZoneClauseContext differentiates from other interfaces.
	IsSessionSetTimeZoneClauseContext()
}

type SessionSetTimeZoneClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionSetTimeZoneClauseContext() *SessionSetTimeZoneClauseContext {
	var p = new(SessionSetTimeZoneClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetTimeZoneClause
	return p
}

func InitEmptySessionSetTimeZoneClauseContext(p *SessionSetTimeZoneClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetTimeZoneClause
}

func (*SessionSetTimeZoneClauseContext) IsSessionSetTimeZoneClauseContext() {}

func NewSessionSetTimeZoneClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionSetTimeZoneClauseContext {
	var p = new(SessionSetTimeZoneClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sessionSetTimeZoneClause

	return p
}

func (s *SessionSetTimeZoneClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionSetTimeZoneClauseContext) TIME() antlr.TerminalNode {
	return s.GetToken(GQLParserTIME, 0)
}

func (s *SessionSetTimeZoneClauseContext) ZONE() antlr.TerminalNode {
	return s.GetToken(GQLParserZONE, 0)
}

func (s *SessionSetTimeZoneClauseContext) SetTimeZoneValue() ISetTimeZoneValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetTimeZoneValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetTimeZoneValueContext)
}

func (s *SessionSetTimeZoneClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionSetTimeZoneClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionSetTimeZoneClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSessionSetTimeZoneClause(s)
	}
}

func (s *SessionSetTimeZoneClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSessionSetTimeZoneClause(s)
	}
}

func (p *GQLParser) SessionSetTimeZoneClause() (localctx ISessionSetTimeZoneClauseContext) {
	localctx = NewSessionSetTimeZoneClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, GQLParserRULE_sessionSetTimeZoneClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1246)
		p.Match(GQLParserTIME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1247)
		p.Match(GQLParserZONE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1248)
		p.SetTimeZoneValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetTimeZoneValueContext is an interface to support dynamic dispatch.
type ISetTimeZoneValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TimeZoneString() ITimeZoneStringContext

	// IsSetTimeZoneValueContext differentiates from other interfaces.
	IsSetTimeZoneValueContext()
}

type SetTimeZoneValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetTimeZoneValueContext() *SetTimeZoneValueContext {
	var p = new(SetTimeZoneValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setTimeZoneValue
	return p
}

func InitEmptySetTimeZoneValueContext(p *SetTimeZoneValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setTimeZoneValue
}

func (*SetTimeZoneValueContext) IsSetTimeZoneValueContext() {}

func NewSetTimeZoneValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTimeZoneValueContext {
	var p = new(SetTimeZoneValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_setTimeZoneValue

	return p
}

func (s *SetTimeZoneValueContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTimeZoneValueContext) TimeZoneString() ITimeZoneStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeZoneStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeZoneStringContext)
}

func (s *SetTimeZoneValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTimeZoneValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTimeZoneValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSetTimeZoneValue(s)
	}
}

func (s *SetTimeZoneValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSetTimeZoneValue(s)
	}
}

func (p *GQLParser) SetTimeZoneValue() (localctx ISetTimeZoneValueContext) {
	localctx = NewSetTimeZoneValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, GQLParserRULE_setTimeZoneValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1250)
		p.TimeZoneString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionSetParameterClauseContext is an interface to support dynamic dispatch.
type ISessionSetParameterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SessionSetGraphParameterClause() ISessionSetGraphParameterClauseContext
	SessionSetBindingTableParameterClause() ISessionSetBindingTableParameterClauseContext
	SessionSetValueParameterClause() ISessionSetValueParameterClauseContext

	// IsSessionSetParameterClauseContext differentiates from other interfaces.
	IsSessionSetParameterClauseContext()
}

type SessionSetParameterClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionSetParameterClauseContext() *SessionSetParameterClauseContext {
	var p = new(SessionSetParameterClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetParameterClause
	return p
}

func InitEmptySessionSetParameterClauseContext(p *SessionSetParameterClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetParameterClause
}

func (*SessionSetParameterClauseContext) IsSessionSetParameterClauseContext() {}

func NewSessionSetParameterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionSetParameterClauseContext {
	var p = new(SessionSetParameterClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sessionSetParameterClause

	return p
}

func (s *SessionSetParameterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionSetParameterClauseContext) SessionSetGraphParameterClause() ISessionSetGraphParameterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionSetGraphParameterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionSetGraphParameterClauseContext)
}

func (s *SessionSetParameterClauseContext) SessionSetBindingTableParameterClause() ISessionSetBindingTableParameterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionSetBindingTableParameterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionSetBindingTableParameterClauseContext)
}

func (s *SessionSetParameterClauseContext) SessionSetValueParameterClause() ISessionSetValueParameterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionSetValueParameterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionSetValueParameterClauseContext)
}

func (s *SessionSetParameterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionSetParameterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionSetParameterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSessionSetParameterClause(s)
	}
}

func (s *SessionSetParameterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSessionSetParameterClause(s)
	}
}

func (p *GQLParser) SessionSetParameterClause() (localctx ISessionSetParameterClauseContext) {
	localctx = NewSessionSetParameterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, GQLParserRULE_sessionSetParameterClause)
	p.SetState(1255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserGRAPH, GQLParserPROPERTY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1252)
			p.SessionSetGraphParameterClause()
		}

	case GQLParserBINDING, GQLParserTABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1253)
			p.SessionSetBindingTableParameterClause()
		}

	case GQLParserVALUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1254)
			p.SessionSetValueParameterClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionSetGraphParameterClauseContext is an interface to support dynamic dispatch.
type ISessionSetGraphParameterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GRAPH() antlr.TerminalNode
	SessionSetParameterName() ISessionSetParameterNameContext
	OptTypedGraphInitializer() IOptTypedGraphInitializerContext
	PROPERTY() antlr.TerminalNode

	// IsSessionSetGraphParameterClauseContext differentiates from other interfaces.
	IsSessionSetGraphParameterClauseContext()
}

type SessionSetGraphParameterClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionSetGraphParameterClauseContext() *SessionSetGraphParameterClauseContext {
	var p = new(SessionSetGraphParameterClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetGraphParameterClause
	return p
}

func InitEmptySessionSetGraphParameterClauseContext(p *SessionSetGraphParameterClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetGraphParameterClause
}

func (*SessionSetGraphParameterClauseContext) IsSessionSetGraphParameterClauseContext() {}

func NewSessionSetGraphParameterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionSetGraphParameterClauseContext {
	var p = new(SessionSetGraphParameterClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sessionSetGraphParameterClause

	return p
}

func (s *SessionSetGraphParameterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionSetGraphParameterClauseContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserGRAPH, 0)
}

func (s *SessionSetGraphParameterClauseContext) SessionSetParameterName() ISessionSetParameterNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionSetParameterNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionSetParameterNameContext)
}

func (s *SessionSetGraphParameterClauseContext) OptTypedGraphInitializer() IOptTypedGraphInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptTypedGraphInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptTypedGraphInitializerContext)
}

func (s *SessionSetGraphParameterClauseContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY, 0)
}

func (s *SessionSetGraphParameterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionSetGraphParameterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionSetGraphParameterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSessionSetGraphParameterClause(s)
	}
}

func (s *SessionSetGraphParameterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSessionSetGraphParameterClause(s)
	}
}

func (p *GQLParser) SessionSetGraphParameterClause() (localctx ISessionSetGraphParameterClauseContext) {
	localctx = NewSessionSetGraphParameterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, GQLParserRULE_sessionSetGraphParameterClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1258)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserPROPERTY {
		{
			p.SetState(1257)
			p.Match(GQLParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1260)
		p.Match(GQLParserGRAPH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1261)
		p.SessionSetParameterName()
	}
	{
		p.SetState(1262)
		p.OptTypedGraphInitializer()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionSetBindingTableParameterClauseContext is an interface to support dynamic dispatch.
type ISessionSetBindingTableParameterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE() antlr.TerminalNode
	SessionSetParameterName() ISessionSetParameterNameContext
	OptTypedBindingTableInitializer() IOptTypedBindingTableInitializerContext
	BINDING() antlr.TerminalNode

	// IsSessionSetBindingTableParameterClauseContext differentiates from other interfaces.
	IsSessionSetBindingTableParameterClauseContext()
}

type SessionSetBindingTableParameterClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionSetBindingTableParameterClauseContext() *SessionSetBindingTableParameterClauseContext {
	var p = new(SessionSetBindingTableParameterClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetBindingTableParameterClause
	return p
}

func InitEmptySessionSetBindingTableParameterClauseContext(p *SessionSetBindingTableParameterClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetBindingTableParameterClause
}

func (*SessionSetBindingTableParameterClauseContext) IsSessionSetBindingTableParameterClauseContext() {
}

func NewSessionSetBindingTableParameterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionSetBindingTableParameterClauseContext {
	var p = new(SessionSetBindingTableParameterClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sessionSetBindingTableParameterClause

	return p
}

func (s *SessionSetBindingTableParameterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionSetBindingTableParameterClauseContext) TABLE() antlr.TerminalNode {
	return s.GetToken(GQLParserTABLE, 0)
}

func (s *SessionSetBindingTableParameterClauseContext) SessionSetParameterName() ISessionSetParameterNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionSetParameterNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionSetParameterNameContext)
}

func (s *SessionSetBindingTableParameterClauseContext) OptTypedBindingTableInitializer() IOptTypedBindingTableInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptTypedBindingTableInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptTypedBindingTableInitializerContext)
}

func (s *SessionSetBindingTableParameterClauseContext) BINDING() antlr.TerminalNode {
	return s.GetToken(GQLParserBINDING, 0)
}

func (s *SessionSetBindingTableParameterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionSetBindingTableParameterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionSetBindingTableParameterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSessionSetBindingTableParameterClause(s)
	}
}

func (s *SessionSetBindingTableParameterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSessionSetBindingTableParameterClause(s)
	}
}

func (p *GQLParser) SessionSetBindingTableParameterClause() (localctx ISessionSetBindingTableParameterClauseContext) {
	localctx = NewSessionSetBindingTableParameterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, GQLParserRULE_sessionSetBindingTableParameterClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserBINDING {
		{
			p.SetState(1264)
			p.Match(GQLParserBINDING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1267)
		p.Match(GQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1268)
		p.SessionSetParameterName()
	}
	{
		p.SetState(1269)
		p.OptTypedBindingTableInitializer()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionSetValueParameterClauseContext is an interface to support dynamic dispatch.
type ISessionSetValueParameterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUE() antlr.TerminalNode
	SessionSetParameterName() ISessionSetParameterNameContext
	OptTypedValueInitializer() IOptTypedValueInitializerContext

	// IsSessionSetValueParameterClauseContext differentiates from other interfaces.
	IsSessionSetValueParameterClauseContext()
}

type SessionSetValueParameterClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionSetValueParameterClauseContext() *SessionSetValueParameterClauseContext {
	var p = new(SessionSetValueParameterClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetValueParameterClause
	return p
}

func InitEmptySessionSetValueParameterClauseContext(p *SessionSetValueParameterClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetValueParameterClause
}

func (*SessionSetValueParameterClauseContext) IsSessionSetValueParameterClauseContext() {}

func NewSessionSetValueParameterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionSetValueParameterClauseContext {
	var p = new(SessionSetValueParameterClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sessionSetValueParameterClause

	return p
}

func (s *SessionSetValueParameterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionSetValueParameterClauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(GQLParserVALUE, 0)
}

func (s *SessionSetValueParameterClauseContext) SessionSetParameterName() ISessionSetParameterNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionSetParameterNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionSetParameterNameContext)
}

func (s *SessionSetValueParameterClauseContext) OptTypedValueInitializer() IOptTypedValueInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptTypedValueInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptTypedValueInitializerContext)
}

func (s *SessionSetValueParameterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionSetValueParameterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionSetValueParameterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSessionSetValueParameterClause(s)
	}
}

func (s *SessionSetValueParameterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSessionSetValueParameterClause(s)
	}
}

func (p *GQLParser) SessionSetValueParameterClause() (localctx ISessionSetValueParameterClauseContext) {
	localctx = NewSessionSetValueParameterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, GQLParserRULE_sessionSetValueParameterClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1271)
		p.Match(GQLParserVALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1272)
		p.SessionSetParameterName()
	}
	{
		p.SetState(1273)
		p.OptTypedValueInitializer()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionSetParameterNameContext is an interface to support dynamic dispatch.
type ISessionSetParameterNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SessionParameterSpecification() ISessionParameterSpecificationContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsSessionSetParameterNameContext differentiates from other interfaces.
	IsSessionSetParameterNameContext()
}

type SessionSetParameterNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionSetParameterNameContext() *SessionSetParameterNameContext {
	var p = new(SessionSetParameterNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetParameterName
	return p
}

func InitEmptySessionSetParameterNameContext(p *SessionSetParameterNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionSetParameterName
}

func (*SessionSetParameterNameContext) IsSessionSetParameterNameContext() {}

func NewSessionSetParameterNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionSetParameterNameContext {
	var p = new(SessionSetParameterNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sessionSetParameterName

	return p
}

func (s *SessionSetParameterNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionSetParameterNameContext) SessionParameterSpecification() ISessionParameterSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionParameterSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionParameterSpecificationContext)
}

func (s *SessionSetParameterNameContext) IF() antlr.TerminalNode {
	return s.GetToken(GQLParserIF, 0)
}

func (s *SessionSetParameterNameContext) NOT() antlr.TerminalNode {
	return s.GetToken(GQLParserNOT, 0)
}

func (s *SessionSetParameterNameContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(GQLParserEXISTS, 0)
}

func (s *SessionSetParameterNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionSetParameterNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionSetParameterNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSessionSetParameterName(s)
	}
}

func (s *SessionSetParameterNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSessionSetParameterName(s)
	}
}

func (p *GQLParser) SessionSetParameterName() (localctx ISessionSetParameterNameContext) {
	localctx = NewSessionSetParameterNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, GQLParserRULE_sessionSetParameterName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserIF {
		{
			p.SetState(1275)
			p.Match(GQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1276)
			p.Match(GQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1277)
			p.Match(GQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1280)
		p.SessionParameterSpecification()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionResetCommandContext is an interface to support dynamic dispatch.
type ISessionResetCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SESSION() antlr.TerminalNode
	RESET() antlr.TerminalNode
	SessionResetArguments() ISessionResetArgumentsContext

	// IsSessionResetCommandContext differentiates from other interfaces.
	IsSessionResetCommandContext()
}

type SessionResetCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionResetCommandContext() *SessionResetCommandContext {
	var p = new(SessionResetCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionResetCommand
	return p
}

func InitEmptySessionResetCommandContext(p *SessionResetCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionResetCommand
}

func (*SessionResetCommandContext) IsSessionResetCommandContext() {}

func NewSessionResetCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionResetCommandContext {
	var p = new(SessionResetCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sessionResetCommand

	return p
}

func (s *SessionResetCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionResetCommandContext) SESSION() antlr.TerminalNode {
	return s.GetToken(GQLParserSESSION, 0)
}

func (s *SessionResetCommandContext) RESET() antlr.TerminalNode {
	return s.GetToken(GQLParserRESET, 0)
}

func (s *SessionResetCommandContext) SessionResetArguments() ISessionResetArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionResetArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionResetArgumentsContext)
}

func (s *SessionResetCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionResetCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionResetCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSessionResetCommand(s)
	}
}

func (s *SessionResetCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSessionResetCommand(s)
	}
}

func (p *GQLParser) SessionResetCommand() (localctx ISessionResetCommandContext) {
	localctx = NewSessionResetCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, GQLParserRULE_sessionResetCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1282)
		p.Match(GQLParserSESSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1283)
		p.Match(GQLParserRESET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1285)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserALL || _la == GQLParserCHARACTERISTICS || ((int64((_la-167)) & ^0x3f) == 0 && ((int64(1)<<(_la-167))&8796095119363) != 0) || ((int64((_la-292)) & ^0x3f) == 0 && ((int64(1)<<(_la-292))&137439019009) != 0) {
		{
			p.SetState(1284)
			p.SessionResetArguments()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionResetArgumentsContext is an interface to support dynamic dispatch.
type ISessionResetArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARAMETERS() antlr.TerminalNode
	CHARACTERISTICS() antlr.TerminalNode
	ALL() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	GRAPH() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	TIME() antlr.TerminalNode
	ZONE() antlr.TerminalNode
	SessionParameterSpecification() ISessionParameterSpecificationContext
	PARAMETER() antlr.TerminalNode

	// IsSessionResetArgumentsContext differentiates from other interfaces.
	IsSessionResetArgumentsContext()
}

type SessionResetArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionResetArgumentsContext() *SessionResetArgumentsContext {
	var p = new(SessionResetArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionResetArguments
	return p
}

func InitEmptySessionResetArgumentsContext(p *SessionResetArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionResetArguments
}

func (*SessionResetArgumentsContext) IsSessionResetArgumentsContext() {}

func NewSessionResetArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionResetArgumentsContext {
	var p = new(SessionResetArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sessionResetArguments

	return p
}

func (s *SessionResetArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionResetArgumentsContext) PARAMETERS() antlr.TerminalNode {
	return s.GetToken(GQLParserPARAMETERS, 0)
}

func (s *SessionResetArgumentsContext) CHARACTERISTICS() antlr.TerminalNode {
	return s.GetToken(GQLParserCHARACTERISTICS, 0)
}

func (s *SessionResetArgumentsContext) ALL() antlr.TerminalNode {
	return s.GetToken(GQLParserALL, 0)
}

func (s *SessionResetArgumentsContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(GQLParserSCHEMA, 0)
}

func (s *SessionResetArgumentsContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserGRAPH, 0)
}

func (s *SessionResetArgumentsContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY, 0)
}

func (s *SessionResetArgumentsContext) TIME() antlr.TerminalNode {
	return s.GetToken(GQLParserTIME, 0)
}

func (s *SessionResetArgumentsContext) ZONE() antlr.TerminalNode {
	return s.GetToken(GQLParserZONE, 0)
}

func (s *SessionResetArgumentsContext) SessionParameterSpecification() ISessionParameterSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionParameterSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionParameterSpecificationContext)
}

func (s *SessionResetArgumentsContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(GQLParserPARAMETER, 0)
}

func (s *SessionResetArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionResetArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionResetArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSessionResetArguments(s)
	}
}

func (s *SessionResetArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSessionResetArguments(s)
	}
}

func (p *GQLParser) SessionResetArguments() (localctx ISessionResetArgumentsContext) {
	localctx = NewSessionResetArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, GQLParserRULE_sessionResetArguments)
	var _la int

	p.SetState(1302)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserALL, GQLParserCHARACTERISTICS, GQLParserPARAMETERS:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1288)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserALL {
			{
				p.SetState(1287)
				p.Match(GQLParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1290)
			_la = p.GetTokenStream().LA(1)

			if !(_la == GQLParserCHARACTERISTICS || _la == GQLParserPARAMETERS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case GQLParserSCHEMA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1291)
			p.Match(GQLParserSCHEMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserGRAPH, GQLParserPROPERTY:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1293)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserPROPERTY {
			{
				p.SetState(1292)
				p.Match(GQLParserPROPERTY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1295)
			p.Match(GQLParserGRAPH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserTIME:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1296)
			p.Match(GQLParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1297)
			p.Match(GQLParserZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserPARAMETER, GQLParserGENERAL_PARAMETER_REFERENCE:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1299)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserPARAMETER {
			{
				p.SetState(1298)
				p.Match(GQLParserPARAMETER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1301)
			p.SessionParameterSpecification()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionCloseCommandContext is an interface to support dynamic dispatch.
type ISessionCloseCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SESSION() antlr.TerminalNode
	CLOSE() antlr.TerminalNode

	// IsSessionCloseCommandContext differentiates from other interfaces.
	IsSessionCloseCommandContext()
}

type SessionCloseCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionCloseCommandContext() *SessionCloseCommandContext {
	var p = new(SessionCloseCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionCloseCommand
	return p
}

func InitEmptySessionCloseCommandContext(p *SessionCloseCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionCloseCommand
}

func (*SessionCloseCommandContext) IsSessionCloseCommandContext() {}

func NewSessionCloseCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionCloseCommandContext {
	var p = new(SessionCloseCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sessionCloseCommand

	return p
}

func (s *SessionCloseCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionCloseCommandContext) SESSION() antlr.TerminalNode {
	return s.GetToken(GQLParserSESSION, 0)
}

func (s *SessionCloseCommandContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(GQLParserCLOSE, 0)
}

func (s *SessionCloseCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionCloseCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionCloseCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSessionCloseCommand(s)
	}
}

func (s *SessionCloseCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSessionCloseCommand(s)
	}
}

func (p *GQLParser) SessionCloseCommand() (localctx ISessionCloseCommandContext) {
	localctx = NewSessionCloseCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, GQLParserRULE_sessionCloseCommand)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1304)
		p.Match(GQLParserSESSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1305)
		p.Match(GQLParserCLOSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionParameterSpecificationContext is an interface to support dynamic dispatch.
type ISessionParameterSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GENERAL_PARAMETER_REFERENCE() antlr.TerminalNode

	// IsSessionParameterSpecificationContext differentiates from other interfaces.
	IsSessionParameterSpecificationContext()
}

type SessionParameterSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionParameterSpecificationContext() *SessionParameterSpecificationContext {
	var p = new(SessionParameterSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionParameterSpecification
	return p
}

func InitEmptySessionParameterSpecificationContext(p *SessionParameterSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sessionParameterSpecification
}

func (*SessionParameterSpecificationContext) IsSessionParameterSpecificationContext() {}

func NewSessionParameterSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionParameterSpecificationContext {
	var p = new(SessionParameterSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sessionParameterSpecification

	return p
}

func (s *SessionParameterSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionParameterSpecificationContext) GENERAL_PARAMETER_REFERENCE() antlr.TerminalNode {
	return s.GetToken(GQLParserGENERAL_PARAMETER_REFERENCE, 0)
}

func (s *SessionParameterSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionParameterSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionParameterSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSessionParameterSpecification(s)
	}
}

func (s *SessionParameterSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSessionParameterSpecification(s)
	}
}

func (p *GQLParser) SessionParameterSpecification() (localctx ISessionParameterSpecificationContext) {
	localctx = NewSessionParameterSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, GQLParserRULE_sessionParameterSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1307)
		p.Match(GQLParserGENERAL_PARAMETER_REFERENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStartTransactionCommandContext is an interface to support dynamic dispatch.
type IStartTransactionCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TransactionCharacteristics() ITransactionCharacteristicsContext

	// IsStartTransactionCommandContext differentiates from other interfaces.
	IsStartTransactionCommandContext()
}

type StartTransactionCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartTransactionCommandContext() *StartTransactionCommandContext {
	var p = new(StartTransactionCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_startTransactionCommand
	return p
}

func InitEmptyStartTransactionCommandContext(p *StartTransactionCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_startTransactionCommand
}

func (*StartTransactionCommandContext) IsStartTransactionCommandContext() {}

func NewStartTransactionCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartTransactionCommandContext {
	var p = new(StartTransactionCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_startTransactionCommand

	return p
}

func (s *StartTransactionCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *StartTransactionCommandContext) START() antlr.TerminalNode {
	return s.GetToken(GQLParserSTART, 0)
}

func (s *StartTransactionCommandContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(GQLParserTRANSACTION, 0)
}

func (s *StartTransactionCommandContext) TransactionCharacteristics() ITransactionCharacteristicsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionCharacteristicsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionCharacteristicsContext)
}

func (s *StartTransactionCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartTransactionCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartTransactionCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterStartTransactionCommand(s)
	}
}

func (s *StartTransactionCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitStartTransactionCommand(s)
	}
}

func (p *GQLParser) StartTransactionCommand() (localctx IStartTransactionCommandContext) {
	localctx = NewStartTransactionCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, GQLParserRULE_startTransactionCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1309)
		p.Match(GQLParserSTART)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1310)
		p.Match(GQLParserTRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1312)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserREAD {
		{
			p.SetState(1311)
			p.TransactionCharacteristics()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionCharacteristicsContext is an interface to support dynamic dispatch.
type ITransactionCharacteristicsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTransactionMode() []ITransactionModeContext
	TransactionMode(i int) ITransactionModeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTransactionCharacteristicsContext differentiates from other interfaces.
	IsTransactionCharacteristicsContext()
}

type TransactionCharacteristicsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionCharacteristicsContext() *TransactionCharacteristicsContext {
	var p = new(TransactionCharacteristicsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_transactionCharacteristics
	return p
}

func InitEmptyTransactionCharacteristicsContext(p *TransactionCharacteristicsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_transactionCharacteristics
}

func (*TransactionCharacteristicsContext) IsTransactionCharacteristicsContext() {}

func NewTransactionCharacteristicsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionCharacteristicsContext {
	var p = new(TransactionCharacteristicsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_transactionCharacteristics

	return p
}

func (s *TransactionCharacteristicsContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionCharacteristicsContext) AllTransactionMode() []ITransactionModeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransactionModeContext); ok {
			len++
		}
	}

	tst := make([]ITransactionModeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransactionModeContext); ok {
			tst[i] = t.(ITransactionModeContext)
			i++
		}
	}

	return tst
}

func (s *TransactionCharacteristicsContext) TransactionMode(i int) ITransactionModeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionModeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionModeContext)
}

func (s *TransactionCharacteristicsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *TransactionCharacteristicsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *TransactionCharacteristicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionCharacteristicsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionCharacteristicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTransactionCharacteristics(s)
	}
}

func (s *TransactionCharacteristicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTransactionCharacteristics(s)
	}
}

func (p *GQLParser) TransactionCharacteristics() (localctx ITransactionCharacteristicsContext) {
	localctx = NewTransactionCharacteristicsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, GQLParserRULE_transactionCharacteristics)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1314)
		p.TransactionMode()
	}
	p.SetState(1319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(1315)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1316)
			p.TransactionMode()
		}

		p.SetState(1321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionModeContext is an interface to support dynamic dispatch.
type ITransactionModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TransactionAccessMode() ITransactionAccessModeContext

	// IsTransactionModeContext differentiates from other interfaces.
	IsTransactionModeContext()
}

type TransactionModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionModeContext() *TransactionModeContext {
	var p = new(TransactionModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_transactionMode
	return p
}

func InitEmptyTransactionModeContext(p *TransactionModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_transactionMode
}

func (*TransactionModeContext) IsTransactionModeContext() {}

func NewTransactionModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionModeContext {
	var p = new(TransactionModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_transactionMode

	return p
}

func (s *TransactionModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionModeContext) TransactionAccessMode() ITransactionAccessModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionAccessModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionAccessModeContext)
}

func (s *TransactionModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTransactionMode(s)
	}
}

func (s *TransactionModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTransactionMode(s)
	}
}

func (p *GQLParser) TransactionMode() (localctx ITransactionModeContext) {
	localctx = NewTransactionModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, GQLParserRULE_transactionMode)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1322)
		p.TransactionAccessMode()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionAccessModeContext is an interface to support dynamic dispatch.
type ITransactionAccessModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	WRITE() antlr.TerminalNode

	// IsTransactionAccessModeContext differentiates from other interfaces.
	IsTransactionAccessModeContext()
}

type TransactionAccessModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionAccessModeContext() *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_transactionAccessMode
	return p
}

func InitEmptyTransactionAccessModeContext(p *TransactionAccessModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_transactionAccessMode
}

func (*TransactionAccessModeContext) IsTransactionAccessModeContext() {}

func NewTransactionAccessModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_transactionAccessMode

	return p
}

func (s *TransactionAccessModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionAccessModeContext) READ() antlr.TerminalNode {
	return s.GetToken(GQLParserREAD, 0)
}

func (s *TransactionAccessModeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(GQLParserONLY, 0)
}

func (s *TransactionAccessModeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(GQLParserWRITE, 0)
}

func (s *TransactionAccessModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionAccessModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionAccessModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTransactionAccessMode(s)
	}
}

func (p *GQLParser) TransactionAccessMode() (localctx ITransactionAccessModeContext) {
	localctx = NewTransactionAccessModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, GQLParserRULE_transactionAccessMode)
	p.SetState(1328)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1324)
			p.Match(GQLParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1325)
			p.Match(GQLParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1326)
			p.Match(GQLParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1327)
			p.Match(GQLParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollbackCommandContext is an interface to support dynamic dispatch.
type IRollbackCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLBACK() antlr.TerminalNode

	// IsRollbackCommandContext differentiates from other interfaces.
	IsRollbackCommandContext()
}

type RollbackCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollbackCommandContext() *RollbackCommandContext {
	var p = new(RollbackCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_rollbackCommand
	return p
}

func InitEmptyRollbackCommandContext(p *RollbackCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_rollbackCommand
}

func (*RollbackCommandContext) IsRollbackCommandContext() {}

func NewRollbackCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackCommandContext {
	var p = new(RollbackCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_rollbackCommand

	return p
}

func (s *RollbackCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackCommandContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(GQLParserROLLBACK, 0)
}

func (s *RollbackCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollbackCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterRollbackCommand(s)
	}
}

func (s *RollbackCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitRollbackCommand(s)
	}
}

func (p *GQLParser) RollbackCommand() (localctx IRollbackCommandContext) {
	localctx = NewRollbackCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, GQLParserRULE_rollbackCommand)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1330)
		p.Match(GQLParserROLLBACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommitCommandContext is an interface to support dynamic dispatch.
type ICommitCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMIT() antlr.TerminalNode

	// IsCommitCommandContext differentiates from other interfaces.
	IsCommitCommandContext()
}

type CommitCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommitCommandContext() *CommitCommandContext {
	var p = new(CommitCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_commitCommand
	return p
}

func InitEmptyCommitCommandContext(p *CommitCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_commitCommand
}

func (*CommitCommandContext) IsCommitCommandContext() {}

func NewCommitCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitCommandContext {
	var p = new(CommitCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_commitCommand

	return p
}

func (s *CommitCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitCommandContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMIT, 0)
}

func (s *CommitCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommitCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCommitCommand(s)
	}
}

func (s *CommitCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCommitCommand(s)
	}
}

func (p *GQLParser) CommitCommand() (localctx ICommitCommandContext) {
	localctx = NewCommitCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, GQLParserRULE_commitCommand)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1332)
		p.Match(GQLParserCOMMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INestedProcedureSpecificationContext is an interface to support dynamic dispatch.
type INestedProcedureSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_BRACE() antlr.TerminalNode
	ProcedureSpecification() IProcedureSpecificationContext
	RIGHT_BRACE() antlr.TerminalNode

	// IsNestedProcedureSpecificationContext differentiates from other interfaces.
	IsNestedProcedureSpecificationContext()
}

type NestedProcedureSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedProcedureSpecificationContext() *NestedProcedureSpecificationContext {
	var p = new(NestedProcedureSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nestedProcedureSpecification
	return p
}

func InitEmptyNestedProcedureSpecificationContext(p *NestedProcedureSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nestedProcedureSpecification
}

func (*NestedProcedureSpecificationContext) IsNestedProcedureSpecificationContext() {}

func NewNestedProcedureSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedProcedureSpecificationContext {
	var p = new(NestedProcedureSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nestedProcedureSpecification

	return p
}

func (s *NestedProcedureSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedProcedureSpecificationContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACE, 0)
}

func (s *NestedProcedureSpecificationContext) ProcedureSpecification() IProcedureSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSpecificationContext)
}

func (s *NestedProcedureSpecificationContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACE, 0)
}

func (s *NestedProcedureSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedProcedureSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedProcedureSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNestedProcedureSpecification(s)
	}
}

func (s *NestedProcedureSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNestedProcedureSpecification(s)
	}
}

func (p *GQLParser) NestedProcedureSpecification() (localctx INestedProcedureSpecificationContext) {
	localctx = NewNestedProcedureSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, GQLParserRULE_nestedProcedureSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1334)
		p.Match(GQLParserLEFT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1335)
		p.ProcedureSpecification()
	}
	{
		p.SetState(1336)
		p.Match(GQLParserRIGHT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureSpecificationContext is an interface to support dynamic dispatch.
type IProcedureSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureBody() IProcedureBodyContext

	// IsProcedureSpecificationContext differentiates from other interfaces.
	IsProcedureSpecificationContext()
}

type ProcedureSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureSpecificationContext() *ProcedureSpecificationContext {
	var p = new(ProcedureSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_procedureSpecification
	return p
}

func InitEmptyProcedureSpecificationContext(p *ProcedureSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_procedureSpecification
}

func (*ProcedureSpecificationContext) IsProcedureSpecificationContext() {}

func NewProcedureSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureSpecificationContext {
	var p = new(ProcedureSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_procedureSpecification

	return p
}

func (s *ProcedureSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureSpecificationContext) ProcedureBody() IProcedureBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureBodyContext)
}

func (s *ProcedureSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterProcedureSpecification(s)
	}
}

func (s *ProcedureSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitProcedureSpecification(s)
	}
}

func (p *GQLParser) ProcedureSpecification() (localctx IProcedureSpecificationContext) {
	localctx = NewProcedureSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, GQLParserRULE_procedureSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1338)
		p.ProcedureBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INestedDataModifyingProcedureSpecificationContext is an interface to support dynamic dispatch.
type INestedDataModifyingProcedureSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_BRACE() antlr.TerminalNode
	ProcedureBody() IProcedureBodyContext
	RIGHT_BRACE() antlr.TerminalNode

	// IsNestedDataModifyingProcedureSpecificationContext differentiates from other interfaces.
	IsNestedDataModifyingProcedureSpecificationContext()
}

type NestedDataModifyingProcedureSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedDataModifyingProcedureSpecificationContext() *NestedDataModifyingProcedureSpecificationContext {
	var p = new(NestedDataModifyingProcedureSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nestedDataModifyingProcedureSpecification
	return p
}

func InitEmptyNestedDataModifyingProcedureSpecificationContext(p *NestedDataModifyingProcedureSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nestedDataModifyingProcedureSpecification
}

func (*NestedDataModifyingProcedureSpecificationContext) IsNestedDataModifyingProcedureSpecificationContext() {
}

func NewNestedDataModifyingProcedureSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedDataModifyingProcedureSpecificationContext {
	var p = new(NestedDataModifyingProcedureSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nestedDataModifyingProcedureSpecification

	return p
}

func (s *NestedDataModifyingProcedureSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedDataModifyingProcedureSpecificationContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACE, 0)
}

func (s *NestedDataModifyingProcedureSpecificationContext) ProcedureBody() IProcedureBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureBodyContext)
}

func (s *NestedDataModifyingProcedureSpecificationContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACE, 0)
}

func (s *NestedDataModifyingProcedureSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedDataModifyingProcedureSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedDataModifyingProcedureSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNestedDataModifyingProcedureSpecification(s)
	}
}

func (s *NestedDataModifyingProcedureSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNestedDataModifyingProcedureSpecification(s)
	}
}

func (p *GQLParser) NestedDataModifyingProcedureSpecification() (localctx INestedDataModifyingProcedureSpecificationContext) {
	localctx = NewNestedDataModifyingProcedureSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, GQLParserRULE_nestedDataModifyingProcedureSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1340)
		p.Match(GQLParserLEFT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1341)
		p.ProcedureBody()
	}
	{
		p.SetState(1342)
		p.Match(GQLParserRIGHT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INestedQuerySpecificationContext is an interface to support dynamic dispatch.
type INestedQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_BRACE() antlr.TerminalNode
	ProcedureBody() IProcedureBodyContext
	RIGHT_BRACE() antlr.TerminalNode

	// IsNestedQuerySpecificationContext differentiates from other interfaces.
	IsNestedQuerySpecificationContext()
}

type NestedQuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedQuerySpecificationContext() *NestedQuerySpecificationContext {
	var p = new(NestedQuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nestedQuerySpecification
	return p
}

func InitEmptyNestedQuerySpecificationContext(p *NestedQuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nestedQuerySpecification
}

func (*NestedQuerySpecificationContext) IsNestedQuerySpecificationContext() {}

func NewNestedQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedQuerySpecificationContext {
	var p = new(NestedQuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nestedQuerySpecification

	return p
}

func (s *NestedQuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedQuerySpecificationContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACE, 0)
}

func (s *NestedQuerySpecificationContext) ProcedureBody() IProcedureBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureBodyContext)
}

func (s *NestedQuerySpecificationContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACE, 0)
}

func (s *NestedQuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedQuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedQuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNestedQuerySpecification(s)
	}
}

func (s *NestedQuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNestedQuerySpecification(s)
	}
}

func (p *GQLParser) NestedQuerySpecification() (localctx INestedQuerySpecificationContext) {
	localctx = NewNestedQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, GQLParserRULE_nestedQuerySpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1344)
		p.Match(GQLParserLEFT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1345)
		p.ProcedureBody()
	}
	{
		p.SetState(1346)
		p.Match(GQLParserRIGHT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureBodyContext is an interface to support dynamic dispatch.
type IProcedureBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StatementBlock() IStatementBlockContext
	AtSchemaClause() IAtSchemaClauseContext
	BindingVariableDefinitionBlock() IBindingVariableDefinitionBlockContext

	// IsProcedureBodyContext differentiates from other interfaces.
	IsProcedureBodyContext()
}

type ProcedureBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureBodyContext() *ProcedureBodyContext {
	var p = new(ProcedureBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_procedureBody
	return p
}

func InitEmptyProcedureBodyContext(p *ProcedureBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_procedureBody
}

func (*ProcedureBodyContext) IsProcedureBodyContext() {}

func NewProcedureBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureBodyContext {
	var p = new(ProcedureBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_procedureBody

	return p
}

func (s *ProcedureBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureBodyContext) StatementBlock() IStatementBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementBlockContext)
}

func (s *ProcedureBodyContext) AtSchemaClause() IAtSchemaClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtSchemaClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtSchemaClauseContext)
}

func (s *ProcedureBodyContext) BindingVariableDefinitionBlock() IBindingVariableDefinitionBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableDefinitionBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableDefinitionBlockContext)
}

func (s *ProcedureBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterProcedureBody(s)
	}
}

func (s *ProcedureBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitProcedureBody(s)
	}
}

func (p *GQLParser) ProcedureBody() (localctx IProcedureBodyContext) {
	localctx = NewProcedureBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, GQLParserRULE_procedureBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserAT {
		{
			p.SetState(1348)
			p.AtSchemaClause()
		}

	}
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserVALUE || _la == GQLParserBINDING || ((int64((_la-292)) & ^0x3f) == 0 && ((int64(1)<<(_la-292))&16842753) != 0) {
		{
			p.SetState(1351)
			p.BindingVariableDefinitionBlock()
		}

	}
	{
		p.SetState(1354)
		p.StatementBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindingVariableDefinitionBlockContext is an interface to support dynamic dispatch.
type IBindingVariableDefinitionBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBindingVariableDefinition() []IBindingVariableDefinitionContext
	BindingVariableDefinition(i int) IBindingVariableDefinitionContext

	// IsBindingVariableDefinitionBlockContext differentiates from other interfaces.
	IsBindingVariableDefinitionBlockContext()
}

type BindingVariableDefinitionBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingVariableDefinitionBlockContext() *BindingVariableDefinitionBlockContext {
	var p = new(BindingVariableDefinitionBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingVariableDefinitionBlock
	return p
}

func InitEmptyBindingVariableDefinitionBlockContext(p *BindingVariableDefinitionBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingVariableDefinitionBlock
}

func (*BindingVariableDefinitionBlockContext) IsBindingVariableDefinitionBlockContext() {}

func NewBindingVariableDefinitionBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingVariableDefinitionBlockContext {
	var p = new(BindingVariableDefinitionBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_bindingVariableDefinitionBlock

	return p
}

func (s *BindingVariableDefinitionBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingVariableDefinitionBlockContext) AllBindingVariableDefinition() []IBindingVariableDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBindingVariableDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IBindingVariableDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBindingVariableDefinitionContext); ok {
			tst[i] = t.(IBindingVariableDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *BindingVariableDefinitionBlockContext) BindingVariableDefinition(i int) IBindingVariableDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableDefinitionContext)
}

func (s *BindingVariableDefinitionBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingVariableDefinitionBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingVariableDefinitionBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBindingVariableDefinitionBlock(s)
	}
}

func (s *BindingVariableDefinitionBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBindingVariableDefinitionBlock(s)
	}
}

func (p *GQLParser) BindingVariableDefinitionBlock() (localctx IBindingVariableDefinitionBlockContext) {
	localctx = NewBindingVariableDefinitionBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, GQLParserRULE_bindingVariableDefinitionBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == GQLParserVALUE || _la == GQLParserBINDING || ((int64((_la-292)) & ^0x3f) == 0 && ((int64(1)<<(_la-292))&16842753) != 0) {
		{
			p.SetState(1356)
			p.BindingVariableDefinition()
		}

		p.SetState(1359)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindingVariableDefinitionContext is an interface to support dynamic dispatch.
type IBindingVariableDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GraphVariableDefinition() IGraphVariableDefinitionContext
	BindingTableVariableDefinition() IBindingTableVariableDefinitionContext
	ValueVariableDefinition() IValueVariableDefinitionContext

	// IsBindingVariableDefinitionContext differentiates from other interfaces.
	IsBindingVariableDefinitionContext()
}

type BindingVariableDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingVariableDefinitionContext() *BindingVariableDefinitionContext {
	var p = new(BindingVariableDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingVariableDefinition
	return p
}

func InitEmptyBindingVariableDefinitionContext(p *BindingVariableDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingVariableDefinition
}

func (*BindingVariableDefinitionContext) IsBindingVariableDefinitionContext() {}

func NewBindingVariableDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingVariableDefinitionContext {
	var p = new(BindingVariableDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_bindingVariableDefinition

	return p
}

func (s *BindingVariableDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingVariableDefinitionContext) GraphVariableDefinition() IGraphVariableDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphVariableDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphVariableDefinitionContext)
}

func (s *BindingVariableDefinitionContext) BindingTableVariableDefinition() IBindingTableVariableDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingTableVariableDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingTableVariableDefinitionContext)
}

func (s *BindingVariableDefinitionContext) ValueVariableDefinition() IValueVariableDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueVariableDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueVariableDefinitionContext)
}

func (s *BindingVariableDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingVariableDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingVariableDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBindingVariableDefinition(s)
	}
}

func (s *BindingVariableDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBindingVariableDefinition(s)
	}
}

func (p *GQLParser) BindingVariableDefinition() (localctx IBindingVariableDefinitionContext) {
	localctx = NewBindingVariableDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, GQLParserRULE_bindingVariableDefinition)
	p.SetState(1364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserGRAPH, GQLParserPROPERTY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1361)
			p.GraphVariableDefinition()
		}

	case GQLParserBINDING, GQLParserTABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1362)
			p.BindingTableVariableDefinition()
		}

	case GQLParserVALUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1363)
			p.ValueVariableDefinition()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementBlockContext is an interface to support dynamic dispatch.
type IStatementBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	AllNextStatement() []INextStatementContext
	NextStatement(i int) INextStatementContext

	// IsStatementBlockContext differentiates from other interfaces.
	IsStatementBlockContext()
}

type StatementBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementBlockContext() *StatementBlockContext {
	var p = new(StatementBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_statementBlock
	return p
}

func InitEmptyStatementBlockContext(p *StatementBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_statementBlock
}

func (*StatementBlockContext) IsStatementBlockContext() {}

func NewStatementBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementBlockContext {
	var p = new(StatementBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_statementBlock

	return p
}

func (s *StatementBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementBlockContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementBlockContext) AllNextStatement() []INextStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INextStatementContext); ok {
			len++
		}
	}

	tst := make([]INextStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INextStatementContext); ok {
			tst[i] = t.(INextStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementBlockContext) NextStatement(i int) INextStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INextStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INextStatementContext)
}

func (s *StatementBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterStatementBlock(s)
	}
}

func (s *StatementBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitStatementBlock(s)
	}
}

func (p *GQLParser) StatementBlock() (localctx IStatementBlockContext) {
	localctx = NewStatementBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, GQLParserRULE_statementBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1366)
		p.Statement()
	}
	p.SetState(1370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserNEXT {
		{
			p.SetState(1367)
			p.NextStatement()
		}

		p.SetState(1372)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LinearCatalogModifyingStatement() ILinearCatalogModifyingStatementContext
	LinearDataModifyingStatement() ILinearDataModifyingStatementContext
	CompositeQueryStatement() ICompositeQueryStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) LinearCatalogModifyingStatement() ILinearCatalogModifyingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinearCatalogModifyingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinearCatalogModifyingStatementContext)
}

func (s *StatementContext) LinearDataModifyingStatement() ILinearDataModifyingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinearDataModifyingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinearDataModifyingStatementContext)
}

func (s *StatementContext) CompositeQueryStatement() ICompositeQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompositeQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompositeQueryStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *GQLParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, GQLParserRULE_statement)
	p.SetState(1376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1373)
			p.LinearCatalogModifyingStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1374)
			p.LinearDataModifyingStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1375)
			p.CompositeQueryStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INextStatementContext is an interface to support dynamic dispatch.
type INextStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NEXT() antlr.TerminalNode
	Statement() IStatementContext
	YieldClause() IYieldClauseContext

	// IsNextStatementContext differentiates from other interfaces.
	IsNextStatementContext()
}

type NextStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNextStatementContext() *NextStatementContext {
	var p = new(NextStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nextStatement
	return p
}

func InitEmptyNextStatementContext(p *NextStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nextStatement
}

func (*NextStatementContext) IsNextStatementContext() {}

func NewNextStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NextStatementContext {
	var p = new(NextStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nextStatement

	return p
}

func (s *NextStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *NextStatementContext) NEXT() antlr.TerminalNode {
	return s.GetToken(GQLParserNEXT, 0)
}

func (s *NextStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NextStatementContext) YieldClause() IYieldClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldClauseContext)
}

func (s *NextStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NextStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NextStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNextStatement(s)
	}
}

func (s *NextStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNextStatement(s)
	}
}

func (p *GQLParser) NextStatement() (localctx INextStatementContext) {
	localctx = NewNextStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, GQLParserRULE_nextStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1378)
		p.Match(GQLParserNEXT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserYIELD {
		{
			p.SetState(1379)
			p.YieldClause()
		}

	}
	{
		p.SetState(1382)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphVariableDefinitionContext is an interface to support dynamic dispatch.
type IGraphVariableDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GRAPH() antlr.TerminalNode
	BindingVariable() IBindingVariableContext
	OptTypedGraphInitializer() IOptTypedGraphInitializerContext
	PROPERTY() antlr.TerminalNode

	// IsGraphVariableDefinitionContext differentiates from other interfaces.
	IsGraphVariableDefinitionContext()
}

type GraphVariableDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphVariableDefinitionContext() *GraphVariableDefinitionContext {
	var p = new(GraphVariableDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphVariableDefinition
	return p
}

func InitEmptyGraphVariableDefinitionContext(p *GraphVariableDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphVariableDefinition
}

func (*GraphVariableDefinitionContext) IsGraphVariableDefinitionContext() {}

func NewGraphVariableDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphVariableDefinitionContext {
	var p = new(GraphVariableDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphVariableDefinition

	return p
}

func (s *GraphVariableDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphVariableDefinitionContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserGRAPH, 0)
}

func (s *GraphVariableDefinitionContext) BindingVariable() IBindingVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableContext)
}

func (s *GraphVariableDefinitionContext) OptTypedGraphInitializer() IOptTypedGraphInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptTypedGraphInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptTypedGraphInitializerContext)
}

func (s *GraphVariableDefinitionContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY, 0)
}

func (s *GraphVariableDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphVariableDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphVariableDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphVariableDefinition(s)
	}
}

func (s *GraphVariableDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphVariableDefinition(s)
	}
}

func (p *GQLParser) GraphVariableDefinition() (localctx IGraphVariableDefinitionContext) {
	localctx = NewGraphVariableDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, GQLParserRULE_graphVariableDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserPROPERTY {
		{
			p.SetState(1384)
			p.Match(GQLParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1387)
		p.Match(GQLParserGRAPH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1388)
		p.BindingVariable()
	}
	{
		p.SetState(1389)
		p.OptTypedGraphInitializer()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptTypedGraphInitializerContext is an interface to support dynamic dispatch.
type IOptTypedGraphInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GraphInitializer() IGraphInitializerContext
	GraphReferenceValueType() IGraphReferenceValueTypeContext
	Typed() ITypedContext

	// IsOptTypedGraphInitializerContext differentiates from other interfaces.
	IsOptTypedGraphInitializerContext()
}

type OptTypedGraphInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptTypedGraphInitializerContext() *OptTypedGraphInitializerContext {
	var p = new(OptTypedGraphInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_optTypedGraphInitializer
	return p
}

func InitEmptyOptTypedGraphInitializerContext(p *OptTypedGraphInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_optTypedGraphInitializer
}

func (*OptTypedGraphInitializerContext) IsOptTypedGraphInitializerContext() {}

func NewOptTypedGraphInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptTypedGraphInitializerContext {
	var p = new(OptTypedGraphInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_optTypedGraphInitializer

	return p
}

func (s *OptTypedGraphInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *OptTypedGraphInitializerContext) GraphInitializer() IGraphInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphInitializerContext)
}

func (s *OptTypedGraphInitializerContext) GraphReferenceValueType() IGraphReferenceValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphReferenceValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphReferenceValueTypeContext)
}

func (s *OptTypedGraphInitializerContext) Typed() ITypedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedContext)
}

func (s *OptTypedGraphInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptTypedGraphInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptTypedGraphInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOptTypedGraphInitializer(s)
	}
}

func (s *OptTypedGraphInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOptTypedGraphInitializer(s)
	}
}

func (p *GQLParser) OptTypedGraphInitializer() (localctx IOptTypedGraphInitializerContext) {
	localctx = NewOptTypedGraphInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, GQLParserRULE_optTypedGraphInitializer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1395)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserANY || _la == GQLParserTYPED || ((int64((_la-292)) & ^0x3f) == 0 && ((int64(1)<<(_la-292))&4398046576641) != 0) {
		p.SetState(1392)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserTYPED || _la == GQLParserDOUBLE_COLON {
			{
				p.SetState(1391)
				p.Typed()
			}

		}
		{
			p.SetState(1394)
			p.GraphReferenceValueType()
		}

	}
	{
		p.SetState(1397)
		p.GraphInitializer()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphInitializerContext is an interface to support dynamic dispatch.
type IGraphInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUALS_OPERATOR() antlr.TerminalNode
	GraphExpression() IGraphExpressionContext

	// IsGraphInitializerContext differentiates from other interfaces.
	IsGraphInitializerContext()
}

type GraphInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphInitializerContext() *GraphInitializerContext {
	var p = new(GraphInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphInitializer
	return p
}

func InitEmptyGraphInitializerContext(p *GraphInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphInitializer
}

func (*GraphInitializerContext) IsGraphInitializerContext() {}

func NewGraphInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphInitializerContext {
	var p = new(GraphInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphInitializer

	return p
}

func (s *GraphInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphInitializerContext) EQUALS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(GQLParserEQUALS_OPERATOR, 0)
}

func (s *GraphInitializerContext) GraphExpression() IGraphExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphExpressionContext)
}

func (s *GraphInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphInitializer(s)
	}
}

func (s *GraphInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphInitializer(s)
	}
}

func (p *GQLParser) GraphInitializer() (localctx IGraphInitializerContext) {
	localctx = NewGraphInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, GQLParserRULE_graphInitializer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1399)
		p.Match(GQLParserEQUALS_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1400)
		p.GraphExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindingTableVariableDefinitionContext is an interface to support dynamic dispatch.
type IBindingTableVariableDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE() antlr.TerminalNode
	BindingVariable() IBindingVariableContext
	OptTypedBindingTableInitializer() IOptTypedBindingTableInitializerContext
	BINDING() antlr.TerminalNode

	// IsBindingTableVariableDefinitionContext differentiates from other interfaces.
	IsBindingTableVariableDefinitionContext()
}

type BindingTableVariableDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingTableVariableDefinitionContext() *BindingTableVariableDefinitionContext {
	var p = new(BindingTableVariableDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingTableVariableDefinition
	return p
}

func InitEmptyBindingTableVariableDefinitionContext(p *BindingTableVariableDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingTableVariableDefinition
}

func (*BindingTableVariableDefinitionContext) IsBindingTableVariableDefinitionContext() {}

func NewBindingTableVariableDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingTableVariableDefinitionContext {
	var p = new(BindingTableVariableDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_bindingTableVariableDefinition

	return p
}

func (s *BindingTableVariableDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingTableVariableDefinitionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(GQLParserTABLE, 0)
}

func (s *BindingTableVariableDefinitionContext) BindingVariable() IBindingVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableContext)
}

func (s *BindingTableVariableDefinitionContext) OptTypedBindingTableInitializer() IOptTypedBindingTableInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptTypedBindingTableInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptTypedBindingTableInitializerContext)
}

func (s *BindingTableVariableDefinitionContext) BINDING() antlr.TerminalNode {
	return s.GetToken(GQLParserBINDING, 0)
}

func (s *BindingTableVariableDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingTableVariableDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingTableVariableDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBindingTableVariableDefinition(s)
	}
}

func (s *BindingTableVariableDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBindingTableVariableDefinition(s)
	}
}

func (p *GQLParser) BindingTableVariableDefinition() (localctx IBindingTableVariableDefinitionContext) {
	localctx = NewBindingTableVariableDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, GQLParserRULE_bindingTableVariableDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserBINDING {
		{
			p.SetState(1402)
			p.Match(GQLParserBINDING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1405)
		p.Match(GQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1406)
		p.BindingVariable()
	}
	{
		p.SetState(1407)
		p.OptTypedBindingTableInitializer()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptTypedBindingTableInitializerContext is an interface to support dynamic dispatch.
type IOptTypedBindingTableInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingTableInitializer() IBindingTableInitializerContext
	BindingTableReferenceValueType() IBindingTableReferenceValueTypeContext
	Typed() ITypedContext

	// IsOptTypedBindingTableInitializerContext differentiates from other interfaces.
	IsOptTypedBindingTableInitializerContext()
}

type OptTypedBindingTableInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptTypedBindingTableInitializerContext() *OptTypedBindingTableInitializerContext {
	var p = new(OptTypedBindingTableInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_optTypedBindingTableInitializer
	return p
}

func InitEmptyOptTypedBindingTableInitializerContext(p *OptTypedBindingTableInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_optTypedBindingTableInitializer
}

func (*OptTypedBindingTableInitializerContext) IsOptTypedBindingTableInitializerContext() {}

func NewOptTypedBindingTableInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptTypedBindingTableInitializerContext {
	var p = new(OptTypedBindingTableInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_optTypedBindingTableInitializer

	return p
}

func (s *OptTypedBindingTableInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *OptTypedBindingTableInitializerContext) BindingTableInitializer() IBindingTableInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingTableInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingTableInitializerContext)
}

func (s *OptTypedBindingTableInitializerContext) BindingTableReferenceValueType() IBindingTableReferenceValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingTableReferenceValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingTableReferenceValueTypeContext)
}

func (s *OptTypedBindingTableInitializerContext) Typed() ITypedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedContext)
}

func (s *OptTypedBindingTableInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptTypedBindingTableInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptTypedBindingTableInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOptTypedBindingTableInitializer(s)
	}
}

func (s *OptTypedBindingTableInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOptTypedBindingTableInitializer(s)
	}
}

func (p *GQLParser) OptTypedBindingTableInitializer() (localctx IOptTypedBindingTableInitializerContext) {
	localctx = NewOptTypedBindingTableInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, GQLParserRULE_optTypedBindingTableInitializer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1413)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserTYPED || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&9007233614479361) != 0) {
		p.SetState(1410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserTYPED || _la == GQLParserDOUBLE_COLON {
			{
				p.SetState(1409)
				p.Typed()
			}

		}
		{
			p.SetState(1412)
			p.BindingTableReferenceValueType()
		}

	}
	{
		p.SetState(1415)
		p.BindingTableInitializer()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindingTableInitializerContext is an interface to support dynamic dispatch.
type IBindingTableInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUALS_OPERATOR() antlr.TerminalNode
	BindingTableExpression() IBindingTableExpressionContext

	// IsBindingTableInitializerContext differentiates from other interfaces.
	IsBindingTableInitializerContext()
}

type BindingTableInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingTableInitializerContext() *BindingTableInitializerContext {
	var p = new(BindingTableInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingTableInitializer
	return p
}

func InitEmptyBindingTableInitializerContext(p *BindingTableInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingTableInitializer
}

func (*BindingTableInitializerContext) IsBindingTableInitializerContext() {}

func NewBindingTableInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingTableInitializerContext {
	var p = new(BindingTableInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_bindingTableInitializer

	return p
}

func (s *BindingTableInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingTableInitializerContext) EQUALS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(GQLParserEQUALS_OPERATOR, 0)
}

func (s *BindingTableInitializerContext) BindingTableExpression() IBindingTableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingTableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingTableExpressionContext)
}

func (s *BindingTableInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingTableInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingTableInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBindingTableInitializer(s)
	}
}

func (s *BindingTableInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBindingTableInitializer(s)
	}
}

func (p *GQLParser) BindingTableInitializer() (localctx IBindingTableInitializerContext) {
	localctx = NewBindingTableInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, GQLParserRULE_bindingTableInitializer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1417)
		p.Match(GQLParserEQUALS_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1418)
		p.BindingTableExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueVariableDefinitionContext is an interface to support dynamic dispatch.
type IValueVariableDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUE() antlr.TerminalNode
	BindingVariable() IBindingVariableContext
	OptTypedValueInitializer() IOptTypedValueInitializerContext

	// IsValueVariableDefinitionContext differentiates from other interfaces.
	IsValueVariableDefinitionContext()
}

type ValueVariableDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueVariableDefinitionContext() *ValueVariableDefinitionContext {
	var p = new(ValueVariableDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueVariableDefinition
	return p
}

func InitEmptyValueVariableDefinitionContext(p *ValueVariableDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueVariableDefinition
}

func (*ValueVariableDefinitionContext) IsValueVariableDefinitionContext() {}

func NewValueVariableDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueVariableDefinitionContext {
	var p = new(ValueVariableDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_valueVariableDefinition

	return p
}

func (s *ValueVariableDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueVariableDefinitionContext) VALUE() antlr.TerminalNode {
	return s.GetToken(GQLParserVALUE, 0)
}

func (s *ValueVariableDefinitionContext) BindingVariable() IBindingVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableContext)
}

func (s *ValueVariableDefinitionContext) OptTypedValueInitializer() IOptTypedValueInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptTypedValueInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptTypedValueInitializerContext)
}

func (s *ValueVariableDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueVariableDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueVariableDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterValueVariableDefinition(s)
	}
}

func (s *ValueVariableDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitValueVariableDefinition(s)
	}
}

func (p *GQLParser) ValueVariableDefinition() (localctx IValueVariableDefinitionContext) {
	localctx = NewValueVariableDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, GQLParserRULE_valueVariableDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1420)
		p.Match(GQLParserVALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1421)
		p.BindingVariable()
	}
	{
		p.SetState(1422)
		p.OptTypedValueInitializer()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptTypedValueInitializerContext is an interface to support dynamic dispatch.
type IOptTypedValueInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueInitializer() IValueInitializerContext
	ValueType() IValueTypeContext
	Typed() ITypedContext

	// IsOptTypedValueInitializerContext differentiates from other interfaces.
	IsOptTypedValueInitializerContext()
}

type OptTypedValueInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptTypedValueInitializerContext() *OptTypedValueInitializerContext {
	var p = new(OptTypedValueInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_optTypedValueInitializer
	return p
}

func InitEmptyOptTypedValueInitializerContext(p *OptTypedValueInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_optTypedValueInitializer
}

func (*OptTypedValueInitializerContext) IsOptTypedValueInitializerContext() {}

func NewOptTypedValueInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptTypedValueInitializerContext {
	var p = new(OptTypedValueInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_optTypedValueInitializer

	return p
}

func (s *OptTypedValueInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *OptTypedValueInitializerContext) ValueInitializer() IValueInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueInitializerContext)
}

func (s *OptTypedValueInitializerContext) ValueType() IValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueTypeContext)
}

func (s *OptTypedValueInitializerContext) Typed() ITypedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedContext)
}

func (s *OptTypedValueInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptTypedValueInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptTypedValueInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOptTypedValueInitializer(s)
	}
}

func (s *OptTypedValueInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOptTypedValueInitializer(s)
	}
}

func (p *GQLParser) OptTypedValueInitializer() (localctx IOptTypedValueInitializerContext) {
	localctx = NewOptTypedValueInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, GQLParserRULE_optTypedValueInitializer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9081829411782656) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&-9187345438330574823) != 0) || ((int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&6989589922362163201) != 0) || ((int64((_la-205)) & ^0x3f) == 0 && ((int64(1)<<(_la-205))&8645246561) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&9010532828842081) != 0) || _la == GQLParserLEFT_BRACE || _la == GQLParserLEFT_PAREN {
		p.SetState(1425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserTYPED || _la == GQLParserDOUBLE_COLON {
			{
				p.SetState(1424)
				p.Typed()
			}

		}
		{
			p.SetState(1427)
			p.valueType(0)
		}

	}
	{
		p.SetState(1430)
		p.ValueInitializer()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueInitializerContext is an interface to support dynamic dispatch.
type IValueInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUALS_OPERATOR() antlr.TerminalNode
	ValueExpression() IValueExpressionContext

	// IsValueInitializerContext differentiates from other interfaces.
	IsValueInitializerContext()
}

type ValueInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueInitializerContext() *ValueInitializerContext {
	var p = new(ValueInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueInitializer
	return p
}

func InitEmptyValueInitializerContext(p *ValueInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueInitializer
}

func (*ValueInitializerContext) IsValueInitializerContext() {}

func NewValueInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueInitializerContext {
	var p = new(ValueInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_valueInitializer

	return p
}

func (s *ValueInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueInitializerContext) EQUALS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(GQLParserEQUALS_OPERATOR, 0)
}

func (s *ValueInitializerContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ValueInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterValueInitializer(s)
	}
}

func (s *ValueInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitValueInitializer(s)
	}
}

func (p *GQLParser) ValueInitializer() (localctx IValueInitializerContext) {
	localctx = NewValueInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, GQLParserRULE_valueInitializer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1432)
		p.Match(GQLParserEQUALS_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1433)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphExpressionContext is an interface to support dynamic dispatch.
type IGraphExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GraphReference() IGraphReferenceContext
	ObjectExpressionPrimary() IObjectExpressionPrimaryContext
	ObjectNameOrBindingVariable() IObjectNameOrBindingVariableContext
	CurrentGraph() ICurrentGraphContext

	// IsGraphExpressionContext differentiates from other interfaces.
	IsGraphExpressionContext()
}

type GraphExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphExpressionContext() *GraphExpressionContext {
	var p = new(GraphExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphExpression
	return p
}

func InitEmptyGraphExpressionContext(p *GraphExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphExpression
}

func (*GraphExpressionContext) IsGraphExpressionContext() {}

func NewGraphExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphExpressionContext {
	var p = new(GraphExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphExpression

	return p
}

func (s *GraphExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphExpressionContext) GraphReference() IGraphReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphReferenceContext)
}

func (s *GraphExpressionContext) ObjectExpressionPrimary() IObjectExpressionPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectExpressionPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectExpressionPrimaryContext)
}

func (s *GraphExpressionContext) ObjectNameOrBindingVariable() IObjectNameOrBindingVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectNameOrBindingVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectNameOrBindingVariableContext)
}

func (s *GraphExpressionContext) CurrentGraph() ICurrentGraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentGraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentGraphContext)
}

func (s *GraphExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphExpression(s)
	}
}

func (s *GraphExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphExpression(s)
	}
}

func (p *GQLParser) GraphExpression() (localctx IGraphExpressionContext) {
	localctx = NewGraphExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, GQLParserRULE_graphExpression)
	p.SetState(1439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1435)
			p.GraphReference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1436)
			p.ObjectExpressionPrimary()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1437)
			p.ObjectNameOrBindingVariable()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1438)
			p.CurrentGraph()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICurrentGraphContext is an interface to support dynamic dispatch.
type ICurrentGraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT_PROPERTY_GRAPH() antlr.TerminalNode
	CURRENT_GRAPH() antlr.TerminalNode

	// IsCurrentGraphContext differentiates from other interfaces.
	IsCurrentGraphContext()
}

type CurrentGraphContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCurrentGraphContext() *CurrentGraphContext {
	var p = new(CurrentGraphContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_currentGraph
	return p
}

func InitEmptyCurrentGraphContext(p *CurrentGraphContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_currentGraph
}

func (*CurrentGraphContext) IsCurrentGraphContext() {}

func NewCurrentGraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CurrentGraphContext {
	var p = new(CurrentGraphContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_currentGraph

	return p
}

func (s *CurrentGraphContext) GetParser() antlr.Parser { return s.parser }

func (s *CurrentGraphContext) CURRENT_PROPERTY_GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserCURRENT_PROPERTY_GRAPH, 0)
}

func (s *CurrentGraphContext) CURRENT_GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserCURRENT_GRAPH, 0)
}

func (s *CurrentGraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentGraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CurrentGraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCurrentGraph(s)
	}
}

func (s *CurrentGraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCurrentGraph(s)
	}
}

func (p *GQLParser) CurrentGraph() (localctx ICurrentGraphContext) {
	localctx = NewCurrentGraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, GQLParserRULE_currentGraph)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1441)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserCURRENT_GRAPH || _la == GQLParserCURRENT_PROPERTY_GRAPH) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindingTableExpressionContext is an interface to support dynamic dispatch.
type IBindingTableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NestedBindingTableQuerySpecification() INestedBindingTableQuerySpecificationContext
	BindingTableReference() IBindingTableReferenceContext
	ObjectExpressionPrimary() IObjectExpressionPrimaryContext
	ObjectNameOrBindingVariable() IObjectNameOrBindingVariableContext

	// IsBindingTableExpressionContext differentiates from other interfaces.
	IsBindingTableExpressionContext()
}

type BindingTableExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingTableExpressionContext() *BindingTableExpressionContext {
	var p = new(BindingTableExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingTableExpression
	return p
}

func InitEmptyBindingTableExpressionContext(p *BindingTableExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingTableExpression
}

func (*BindingTableExpressionContext) IsBindingTableExpressionContext() {}

func NewBindingTableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingTableExpressionContext {
	var p = new(BindingTableExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_bindingTableExpression

	return p
}

func (s *BindingTableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingTableExpressionContext) NestedBindingTableQuerySpecification() INestedBindingTableQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedBindingTableQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedBindingTableQuerySpecificationContext)
}

func (s *BindingTableExpressionContext) BindingTableReference() IBindingTableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingTableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingTableReferenceContext)
}

func (s *BindingTableExpressionContext) ObjectExpressionPrimary() IObjectExpressionPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectExpressionPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectExpressionPrimaryContext)
}

func (s *BindingTableExpressionContext) ObjectNameOrBindingVariable() IObjectNameOrBindingVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectNameOrBindingVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectNameOrBindingVariableContext)
}

func (s *BindingTableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingTableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingTableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBindingTableExpression(s)
	}
}

func (s *BindingTableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBindingTableExpression(s)
	}
}

func (p *GQLParser) BindingTableExpression() (localctx IBindingTableExpressionContext) {
	localctx = NewBindingTableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, GQLParserRULE_bindingTableExpression)
	p.SetState(1447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1443)
			p.NestedBindingTableQuerySpecification()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1444)
			p.BindingTableReference()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1445)
			p.ObjectExpressionPrimary()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1446)
			p.ObjectNameOrBindingVariable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INestedBindingTableQuerySpecificationContext is an interface to support dynamic dispatch.
type INestedBindingTableQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NestedQuerySpecification() INestedQuerySpecificationContext

	// IsNestedBindingTableQuerySpecificationContext differentiates from other interfaces.
	IsNestedBindingTableQuerySpecificationContext()
}

type NestedBindingTableQuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedBindingTableQuerySpecificationContext() *NestedBindingTableQuerySpecificationContext {
	var p = new(NestedBindingTableQuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nestedBindingTableQuerySpecification
	return p
}

func InitEmptyNestedBindingTableQuerySpecificationContext(p *NestedBindingTableQuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nestedBindingTableQuerySpecification
}

func (*NestedBindingTableQuerySpecificationContext) IsNestedBindingTableQuerySpecificationContext() {}

func NewNestedBindingTableQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedBindingTableQuerySpecificationContext {
	var p = new(NestedBindingTableQuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nestedBindingTableQuerySpecification

	return p
}

func (s *NestedBindingTableQuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedBindingTableQuerySpecificationContext) NestedQuerySpecification() INestedQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedQuerySpecificationContext)
}

func (s *NestedBindingTableQuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedBindingTableQuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedBindingTableQuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNestedBindingTableQuerySpecification(s)
	}
}

func (s *NestedBindingTableQuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNestedBindingTableQuerySpecification(s)
	}
}

func (p *GQLParser) NestedBindingTableQuerySpecification() (localctx INestedBindingTableQuerySpecificationContext) {
	localctx = NewNestedBindingTableQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, GQLParserRULE_nestedBindingTableQuerySpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1449)
		p.NestedQuerySpecification()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectExpressionPrimaryContext is an interface to support dynamic dispatch.
type IObjectExpressionPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VARIABLE() antlr.TerminalNode
	ValueExpressionPrimary() IValueExpressionPrimaryContext
	ParenthesizedValueExpression() IParenthesizedValueExpressionContext
	NonParenthesizedValueExpressionPrimarySpecialCase() INonParenthesizedValueExpressionPrimarySpecialCaseContext

	// IsObjectExpressionPrimaryContext differentiates from other interfaces.
	IsObjectExpressionPrimaryContext()
}

type ObjectExpressionPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectExpressionPrimaryContext() *ObjectExpressionPrimaryContext {
	var p = new(ObjectExpressionPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_objectExpressionPrimary
	return p
}

func InitEmptyObjectExpressionPrimaryContext(p *ObjectExpressionPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_objectExpressionPrimary
}

func (*ObjectExpressionPrimaryContext) IsObjectExpressionPrimaryContext() {}

func NewObjectExpressionPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectExpressionPrimaryContext {
	var p = new(ObjectExpressionPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_objectExpressionPrimary

	return p
}

func (s *ObjectExpressionPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectExpressionPrimaryContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(GQLParserVARIABLE, 0)
}

func (s *ObjectExpressionPrimaryContext) ValueExpressionPrimary() IValueExpressionPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionPrimaryContext)
}

func (s *ObjectExpressionPrimaryContext) ParenthesizedValueExpression() IParenthesizedValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedValueExpressionContext)
}

func (s *ObjectExpressionPrimaryContext) NonParenthesizedValueExpressionPrimarySpecialCase() INonParenthesizedValueExpressionPrimarySpecialCaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonParenthesizedValueExpressionPrimarySpecialCaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonParenthesizedValueExpressionPrimarySpecialCaseContext)
}

func (s *ObjectExpressionPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectExpressionPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectExpressionPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterObjectExpressionPrimary(s)
	}
}

func (s *ObjectExpressionPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitObjectExpressionPrimary(s)
	}
}

func (p *GQLParser) ObjectExpressionPrimary() (localctx IObjectExpressionPrimaryContext) {
	localctx = NewObjectExpressionPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, GQLParserRULE_objectExpressionPrimary)
	p.SetState(1455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1451)
			p.Match(GQLParserVARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1452)
			p.valueExpressionPrimary(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1453)
			p.ParenthesizedValueExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1454)
			p.NonParenthesizedValueExpressionPrimarySpecialCase()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILinearCatalogModifyingStatementContext is an interface to support dynamic dispatch.
type ILinearCatalogModifyingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleCatalogModifyingStatement() []ISimpleCatalogModifyingStatementContext
	SimpleCatalogModifyingStatement(i int) ISimpleCatalogModifyingStatementContext

	// IsLinearCatalogModifyingStatementContext differentiates from other interfaces.
	IsLinearCatalogModifyingStatementContext()
}

type LinearCatalogModifyingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinearCatalogModifyingStatementContext() *LinearCatalogModifyingStatementContext {
	var p = new(LinearCatalogModifyingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_linearCatalogModifyingStatement
	return p
}

func InitEmptyLinearCatalogModifyingStatementContext(p *LinearCatalogModifyingStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_linearCatalogModifyingStatement
}

func (*LinearCatalogModifyingStatementContext) IsLinearCatalogModifyingStatementContext() {}

func NewLinearCatalogModifyingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinearCatalogModifyingStatementContext {
	var p = new(LinearCatalogModifyingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_linearCatalogModifyingStatement

	return p
}

func (s *LinearCatalogModifyingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LinearCatalogModifyingStatementContext) AllSimpleCatalogModifyingStatement() []ISimpleCatalogModifyingStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleCatalogModifyingStatementContext); ok {
			len++
		}
	}

	tst := make([]ISimpleCatalogModifyingStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleCatalogModifyingStatementContext); ok {
			tst[i] = t.(ISimpleCatalogModifyingStatementContext)
			i++
		}
	}

	return tst
}

func (s *LinearCatalogModifyingStatementContext) SimpleCatalogModifyingStatement(i int) ISimpleCatalogModifyingStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleCatalogModifyingStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleCatalogModifyingStatementContext)
}

func (s *LinearCatalogModifyingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinearCatalogModifyingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinearCatalogModifyingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLinearCatalogModifyingStatement(s)
	}
}

func (s *LinearCatalogModifyingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLinearCatalogModifyingStatement(s)
	}
}

func (p *GQLParser) LinearCatalogModifyingStatement() (localctx ILinearCatalogModifyingStatementContext) {
	localctx = NewLinearCatalogModifyingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, GQLParserRULE_linearCatalogModifyingStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-47)) & ^0x3f) == 0 && ((int64(1)<<(_la-47))&274878431233) != 0) || _la == GQLParserOPTIONAL {
		{
			p.SetState(1457)
			p.SimpleCatalogModifyingStatement()
		}

		p.SetState(1460)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleCatalogModifyingStatementContext is an interface to support dynamic dispatch.
type ISimpleCatalogModifyingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimitiveCatalogModifyingStatement() IPrimitiveCatalogModifyingStatementContext
	CallCatalogModifyingProcedureStatement() ICallCatalogModifyingProcedureStatementContext

	// IsSimpleCatalogModifyingStatementContext differentiates from other interfaces.
	IsSimpleCatalogModifyingStatementContext()
}

type SimpleCatalogModifyingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleCatalogModifyingStatementContext() *SimpleCatalogModifyingStatementContext {
	var p = new(SimpleCatalogModifyingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleCatalogModifyingStatement
	return p
}

func InitEmptySimpleCatalogModifyingStatementContext(p *SimpleCatalogModifyingStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleCatalogModifyingStatement
}

func (*SimpleCatalogModifyingStatementContext) IsSimpleCatalogModifyingStatementContext() {}

func NewSimpleCatalogModifyingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleCatalogModifyingStatementContext {
	var p = new(SimpleCatalogModifyingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simpleCatalogModifyingStatement

	return p
}

func (s *SimpleCatalogModifyingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleCatalogModifyingStatementContext) PrimitiveCatalogModifyingStatement() IPrimitiveCatalogModifyingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveCatalogModifyingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveCatalogModifyingStatementContext)
}

func (s *SimpleCatalogModifyingStatementContext) CallCatalogModifyingProcedureStatement() ICallCatalogModifyingProcedureStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallCatalogModifyingProcedureStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallCatalogModifyingProcedureStatementContext)
}

func (s *SimpleCatalogModifyingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCatalogModifyingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleCatalogModifyingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimpleCatalogModifyingStatement(s)
	}
}

func (s *SimpleCatalogModifyingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimpleCatalogModifyingStatement(s)
	}
}

func (p *GQLParser) SimpleCatalogModifyingStatement() (localctx ISimpleCatalogModifyingStatementContext) {
	localctx = NewSimpleCatalogModifyingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, GQLParserRULE_simpleCatalogModifyingStatement)
	p.SetState(1464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserCREATE, GQLParserDROP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1462)
			p.PrimitiveCatalogModifyingStatement()
		}

	case GQLParserCALL, GQLParserOPTIONAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1463)
			p.CallCatalogModifyingProcedureStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveCatalogModifyingStatementContext is an interface to support dynamic dispatch.
type IPrimitiveCatalogModifyingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateSchemaStatement() ICreateSchemaStatementContext
	DropSchemaStatement() IDropSchemaStatementContext
	CreateGraphStatement() ICreateGraphStatementContext
	DropGraphStatement() IDropGraphStatementContext
	CreateGraphTypeStatement() ICreateGraphTypeStatementContext
	DropGraphTypeStatement() IDropGraphTypeStatementContext

	// IsPrimitiveCatalogModifyingStatementContext differentiates from other interfaces.
	IsPrimitiveCatalogModifyingStatementContext()
}

type PrimitiveCatalogModifyingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveCatalogModifyingStatementContext() *PrimitiveCatalogModifyingStatementContext {
	var p = new(PrimitiveCatalogModifyingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_primitiveCatalogModifyingStatement
	return p
}

func InitEmptyPrimitiveCatalogModifyingStatementContext(p *PrimitiveCatalogModifyingStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_primitiveCatalogModifyingStatement
}

func (*PrimitiveCatalogModifyingStatementContext) IsPrimitiveCatalogModifyingStatementContext() {}

func NewPrimitiveCatalogModifyingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveCatalogModifyingStatementContext {
	var p = new(PrimitiveCatalogModifyingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_primitiveCatalogModifyingStatement

	return p
}

func (s *PrimitiveCatalogModifyingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveCatalogModifyingStatementContext) CreateSchemaStatement() ICreateSchemaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateSchemaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateSchemaStatementContext)
}

func (s *PrimitiveCatalogModifyingStatementContext) DropSchemaStatement() IDropSchemaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropSchemaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropSchemaStatementContext)
}

func (s *PrimitiveCatalogModifyingStatementContext) CreateGraphStatement() ICreateGraphStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateGraphStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateGraphStatementContext)
}

func (s *PrimitiveCatalogModifyingStatementContext) DropGraphStatement() IDropGraphStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropGraphStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropGraphStatementContext)
}

func (s *PrimitiveCatalogModifyingStatementContext) CreateGraphTypeStatement() ICreateGraphTypeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateGraphTypeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateGraphTypeStatementContext)
}

func (s *PrimitiveCatalogModifyingStatementContext) DropGraphTypeStatement() IDropGraphTypeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropGraphTypeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropGraphTypeStatementContext)
}

func (s *PrimitiveCatalogModifyingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveCatalogModifyingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveCatalogModifyingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPrimitiveCatalogModifyingStatement(s)
	}
}

func (s *PrimitiveCatalogModifyingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPrimitiveCatalogModifyingStatement(s)
	}
}

func (p *GQLParser) PrimitiveCatalogModifyingStatement() (localctx IPrimitiveCatalogModifyingStatementContext) {
	localctx = NewPrimitiveCatalogModifyingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, GQLParserRULE_primitiveCatalogModifyingStatement)
	p.SetState(1472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1466)
			p.CreateSchemaStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1467)
			p.DropSchemaStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1468)
			p.CreateGraphStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1469)
			p.DropGraphStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1470)
			p.CreateGraphTypeStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1471)
			p.DropGraphTypeStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateSchemaStatementContext is an interface to support dynamic dispatch.
type ICreateSchemaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	CatalogSchemaParentAndName() ICatalogSchemaParentAndNameContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreateSchemaStatementContext differentiates from other interfaces.
	IsCreateSchemaStatementContext()
}

type CreateSchemaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateSchemaStatementContext() *CreateSchemaStatementContext {
	var p = new(CreateSchemaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_createSchemaStatement
	return p
}

func InitEmptyCreateSchemaStatementContext(p *CreateSchemaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_createSchemaStatement
}

func (*CreateSchemaStatementContext) IsCreateSchemaStatementContext() {}

func NewCreateSchemaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateSchemaStatementContext {
	var p = new(CreateSchemaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_createSchemaStatement

	return p
}

func (s *CreateSchemaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateSchemaStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(GQLParserCREATE, 0)
}

func (s *CreateSchemaStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(GQLParserSCHEMA, 0)
}

func (s *CreateSchemaStatementContext) CatalogSchemaParentAndName() ICatalogSchemaParentAndNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogSchemaParentAndNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogSchemaParentAndNameContext)
}

func (s *CreateSchemaStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(GQLParserIF, 0)
}

func (s *CreateSchemaStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(GQLParserNOT, 0)
}

func (s *CreateSchemaStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(GQLParserEXISTS, 0)
}

func (s *CreateSchemaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSchemaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateSchemaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCreateSchemaStatement(s)
	}
}

func (s *CreateSchemaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCreateSchemaStatement(s)
	}
}

func (p *GQLParser) CreateSchemaStatement() (localctx ICreateSchemaStatementContext) {
	localctx = NewCreateSchemaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, GQLParserRULE_createSchemaStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1474)
		p.Match(GQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1475)
		p.Match(GQLParserSCHEMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserIF {
		{
			p.SetState(1476)
			p.Match(GQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1477)
			p.Match(GQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1478)
			p.Match(GQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1481)
		p.CatalogSchemaParentAndName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropSchemaStatementContext is an interface to support dynamic dispatch.
type IDropSchemaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	CatalogSchemaParentAndName() ICatalogSchemaParentAndNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropSchemaStatementContext differentiates from other interfaces.
	IsDropSchemaStatementContext()
}

type DropSchemaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropSchemaStatementContext() *DropSchemaStatementContext {
	var p = new(DropSchemaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dropSchemaStatement
	return p
}

func InitEmptyDropSchemaStatementContext(p *DropSchemaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dropSchemaStatement
}

func (*DropSchemaStatementContext) IsDropSchemaStatementContext() {}

func NewDropSchemaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropSchemaStatementContext {
	var p = new(DropSchemaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_dropSchemaStatement

	return p
}

func (s *DropSchemaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropSchemaStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(GQLParserDROP, 0)
}

func (s *DropSchemaStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(GQLParserSCHEMA, 0)
}

func (s *DropSchemaStatementContext) CatalogSchemaParentAndName() ICatalogSchemaParentAndNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogSchemaParentAndNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogSchemaParentAndNameContext)
}

func (s *DropSchemaStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(GQLParserIF, 0)
}

func (s *DropSchemaStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(GQLParserEXISTS, 0)
}

func (s *DropSchemaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSchemaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropSchemaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDropSchemaStatement(s)
	}
}

func (s *DropSchemaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDropSchemaStatement(s)
	}
}

func (p *GQLParser) DropSchemaStatement() (localctx IDropSchemaStatementContext) {
	localctx = NewDropSchemaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, GQLParserRULE_dropSchemaStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1483)
		p.Match(GQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1484)
		p.Match(GQLParserSCHEMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserIF {
		{
			p.SetState(1485)
			p.Match(GQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1486)
			p.Match(GQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1489)
		p.CatalogSchemaParentAndName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateGraphStatementContext is an interface to support dynamic dispatch.
type ICreateGraphStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	CatalogGraphParentAndName() ICatalogGraphParentAndNameContext
	GRAPH() antlr.TerminalNode
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	OpenGraphType() IOpenGraphTypeContext
	OfGraphType() IOfGraphTypeContext
	GraphSource() IGraphSourceContext
	PROPERTY() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreateGraphStatementContext differentiates from other interfaces.
	IsCreateGraphStatementContext()
}

type CreateGraphStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateGraphStatementContext() *CreateGraphStatementContext {
	var p = new(CreateGraphStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_createGraphStatement
	return p
}

func InitEmptyCreateGraphStatementContext(p *CreateGraphStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_createGraphStatement
}

func (*CreateGraphStatementContext) IsCreateGraphStatementContext() {}

func NewCreateGraphStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateGraphStatementContext {
	var p = new(CreateGraphStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_createGraphStatement

	return p
}

func (s *CreateGraphStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateGraphStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(GQLParserCREATE, 0)
}

func (s *CreateGraphStatementContext) CatalogGraphParentAndName() ICatalogGraphParentAndNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogGraphParentAndNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogGraphParentAndNameContext)
}

func (s *CreateGraphStatementContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserGRAPH, 0)
}

func (s *CreateGraphStatementContext) OR() antlr.TerminalNode {
	return s.GetToken(GQLParserOR, 0)
}

func (s *CreateGraphStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(GQLParserREPLACE, 0)
}

func (s *CreateGraphStatementContext) OpenGraphType() IOpenGraphTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenGraphTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenGraphTypeContext)
}

func (s *CreateGraphStatementContext) OfGraphType() IOfGraphTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOfGraphTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOfGraphTypeContext)
}

func (s *CreateGraphStatementContext) GraphSource() IGraphSourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphSourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphSourceContext)
}

func (s *CreateGraphStatementContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY, 0)
}

func (s *CreateGraphStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(GQLParserIF, 0)
}

func (s *CreateGraphStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(GQLParserNOT, 0)
}

func (s *CreateGraphStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(GQLParserEXISTS, 0)
}

func (s *CreateGraphStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateGraphStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateGraphStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCreateGraphStatement(s)
	}
}

func (s *CreateGraphStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCreateGraphStatement(s)
	}
}

func (p *GQLParser) CreateGraphStatement() (localctx ICreateGraphStatementContext) {
	localctx = NewCreateGraphStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, GQLParserRULE_createGraphStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1491)
		p.Match(GQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserGRAPH, GQLParserPROPERTY:
		p.SetState(1493)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserPROPERTY {
			{
				p.SetState(1492)
				p.Match(GQLParserPROPERTY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1495)
			p.Match(GQLParserGRAPH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1499)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserIF {
			{
				p.SetState(1496)
				p.Match(GQLParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1497)
				p.Match(GQLParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1498)
				p.Match(GQLParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case GQLParserOR:
		{
			p.SetState(1501)
			p.Match(GQLParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1502)
			p.Match(GQLParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1504)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserPROPERTY {
			{
				p.SetState(1503)
				p.Match(GQLParserPROPERTY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1506)
			p.Match(GQLParserGRAPH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1509)
		p.CatalogGraphParentAndName()
	}
	p.SetState(1512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1510)
			p.OpenGraphType()
		}

	case 2:
		{
			p.SetState(1511)
			p.OfGraphType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserAS {
		{
			p.SetState(1514)
			p.GraphSource()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpenGraphTypeContext is an interface to support dynamic dispatch.
type IOpenGraphTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANY() antlr.TerminalNode
	Typed() ITypedContext
	GRAPH() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode

	// IsOpenGraphTypeContext differentiates from other interfaces.
	IsOpenGraphTypeContext()
}

type OpenGraphTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenGraphTypeContext() *OpenGraphTypeContext {
	var p = new(OpenGraphTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_openGraphType
	return p
}

func InitEmptyOpenGraphTypeContext(p *OpenGraphTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_openGraphType
}

func (*OpenGraphTypeContext) IsOpenGraphTypeContext() {}

func NewOpenGraphTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenGraphTypeContext {
	var p = new(OpenGraphTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_openGraphType

	return p
}

func (s *OpenGraphTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenGraphTypeContext) ANY() antlr.TerminalNode {
	return s.GetToken(GQLParserANY, 0)
}

func (s *OpenGraphTypeContext) Typed() ITypedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedContext)
}

func (s *OpenGraphTypeContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserGRAPH, 0)
}

func (s *OpenGraphTypeContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY, 0)
}

func (s *OpenGraphTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenGraphTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenGraphTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOpenGraphType(s)
	}
}

func (s *OpenGraphTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOpenGraphType(s)
	}
}

func (p *GQLParser) OpenGraphType() (localctx IOpenGraphTypeContext) {
	localctx = NewOpenGraphTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, GQLParserRULE_openGraphType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1518)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserTYPED || _la == GQLParserDOUBLE_COLON {
		{
			p.SetState(1517)
			p.Typed()
		}

	}
	{
		p.SetState(1520)
		p.Match(GQLParserANY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserGRAPH || _la == GQLParserPROPERTY {
		p.SetState(1522)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserPROPERTY {
			{
				p.SetState(1521)
				p.Match(GQLParserPROPERTY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1524)
			p.Match(GQLParserGRAPH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOfGraphTypeContext is an interface to support dynamic dispatch.
type IOfGraphTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GraphTypeLikeGraph() IGraphTypeLikeGraphContext
	GraphTypeReference() IGraphTypeReferenceContext
	Typed() ITypedContext
	NestedGraphTypeSpecification() INestedGraphTypeSpecificationContext
	GRAPH() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode

	// IsOfGraphTypeContext differentiates from other interfaces.
	IsOfGraphTypeContext()
}

type OfGraphTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOfGraphTypeContext() *OfGraphTypeContext {
	var p = new(OfGraphTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_ofGraphType
	return p
}

func InitEmptyOfGraphTypeContext(p *OfGraphTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_ofGraphType
}

func (*OfGraphTypeContext) IsOfGraphTypeContext() {}

func NewOfGraphTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OfGraphTypeContext {
	var p = new(OfGraphTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_ofGraphType

	return p
}

func (s *OfGraphTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OfGraphTypeContext) GraphTypeLikeGraph() IGraphTypeLikeGraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphTypeLikeGraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphTypeLikeGraphContext)
}

func (s *OfGraphTypeContext) GraphTypeReference() IGraphTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphTypeReferenceContext)
}

func (s *OfGraphTypeContext) Typed() ITypedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedContext)
}

func (s *OfGraphTypeContext) NestedGraphTypeSpecification() INestedGraphTypeSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedGraphTypeSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedGraphTypeSpecificationContext)
}

func (s *OfGraphTypeContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserGRAPH, 0)
}

func (s *OfGraphTypeContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY, 0)
}

func (s *OfGraphTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OfGraphTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OfGraphTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOfGraphType(s)
	}
}

func (s *OfGraphTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOfGraphType(s)
	}
}

func (p *GQLParser) OfGraphType() (localctx IOfGraphTypeContext) {
	localctx = NewOfGraphTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, GQLParserRULE_ofGraphType)
	var _la int

	p.SetState(1542)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1527)
			p.GraphTypeLikeGraph()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserTYPED || _la == GQLParserDOUBLE_COLON {
			{
				p.SetState(1528)
				p.Typed()
			}

		}
		{
			p.SetState(1531)
			p.GraphTypeReference()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1533)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserTYPED || _la == GQLParserDOUBLE_COLON {
			{
				p.SetState(1532)
				p.Typed()
			}

		}
		p.SetState(1539)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserGRAPH || _la == GQLParserPROPERTY {
			p.SetState(1536)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == GQLParserPROPERTY {
				{
					p.SetState(1535)
					p.Match(GQLParserPROPERTY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1538)
				p.Match(GQLParserGRAPH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1541)
			p.NestedGraphTypeSpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphTypeLikeGraphContext is an interface to support dynamic dispatch.
type IGraphTypeLikeGraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE() antlr.TerminalNode
	GraphExpression() IGraphExpressionContext

	// IsGraphTypeLikeGraphContext differentiates from other interfaces.
	IsGraphTypeLikeGraphContext()
}

type GraphTypeLikeGraphContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphTypeLikeGraphContext() *GraphTypeLikeGraphContext {
	var p = new(GraphTypeLikeGraphContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphTypeLikeGraph
	return p
}

func InitEmptyGraphTypeLikeGraphContext(p *GraphTypeLikeGraphContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphTypeLikeGraph
}

func (*GraphTypeLikeGraphContext) IsGraphTypeLikeGraphContext() {}

func NewGraphTypeLikeGraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphTypeLikeGraphContext {
	var p = new(GraphTypeLikeGraphContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphTypeLikeGraph

	return p
}

func (s *GraphTypeLikeGraphContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphTypeLikeGraphContext) LIKE() antlr.TerminalNode {
	return s.GetToken(GQLParserLIKE, 0)
}

func (s *GraphTypeLikeGraphContext) GraphExpression() IGraphExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphExpressionContext)
}

func (s *GraphTypeLikeGraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphTypeLikeGraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphTypeLikeGraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphTypeLikeGraph(s)
	}
}

func (s *GraphTypeLikeGraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphTypeLikeGraph(s)
	}
}

func (p *GQLParser) GraphTypeLikeGraph() (localctx IGraphTypeLikeGraphContext) {
	localctx = NewGraphTypeLikeGraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, GQLParserRULE_graphTypeLikeGraph)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1544)
		p.Match(GQLParserLIKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1545)
		p.GraphExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphSourceContext is an interface to support dynamic dispatch.
type IGraphSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	COPY() antlr.TerminalNode
	OF() antlr.TerminalNode
	GraphExpression() IGraphExpressionContext

	// IsGraphSourceContext differentiates from other interfaces.
	IsGraphSourceContext()
}

type GraphSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphSourceContext() *GraphSourceContext {
	var p = new(GraphSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphSource
	return p
}

func InitEmptyGraphSourceContext(p *GraphSourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphSource
}

func (*GraphSourceContext) IsGraphSourceContext() {}

func NewGraphSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphSourceContext {
	var p = new(GraphSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphSource

	return p
}

func (s *GraphSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphSourceContext) AS() antlr.TerminalNode {
	return s.GetToken(GQLParserAS, 0)
}

func (s *GraphSourceContext) COPY() antlr.TerminalNode {
	return s.GetToken(GQLParserCOPY, 0)
}

func (s *GraphSourceContext) OF() antlr.TerminalNode {
	return s.GetToken(GQLParserOF, 0)
}

func (s *GraphSourceContext) GraphExpression() IGraphExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphExpressionContext)
}

func (s *GraphSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphSource(s)
	}
}

func (s *GraphSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphSource(s)
	}
}

func (p *GQLParser) GraphSource() (localctx IGraphSourceContext) {
	localctx = NewGraphSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, GQLParserRULE_graphSource)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1547)
		p.Match(GQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1548)
		p.Match(GQLParserCOPY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1549)
		p.Match(GQLParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1550)
		p.GraphExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropGraphStatementContext is an interface to support dynamic dispatch.
type IDropGraphStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	GRAPH() antlr.TerminalNode
	CatalogGraphParentAndName() ICatalogGraphParentAndNameContext
	PROPERTY() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropGraphStatementContext differentiates from other interfaces.
	IsDropGraphStatementContext()
}

type DropGraphStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropGraphStatementContext() *DropGraphStatementContext {
	var p = new(DropGraphStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dropGraphStatement
	return p
}

func InitEmptyDropGraphStatementContext(p *DropGraphStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dropGraphStatement
}

func (*DropGraphStatementContext) IsDropGraphStatementContext() {}

func NewDropGraphStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropGraphStatementContext {
	var p = new(DropGraphStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_dropGraphStatement

	return p
}

func (s *DropGraphStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropGraphStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(GQLParserDROP, 0)
}

func (s *DropGraphStatementContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserGRAPH, 0)
}

func (s *DropGraphStatementContext) CatalogGraphParentAndName() ICatalogGraphParentAndNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogGraphParentAndNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogGraphParentAndNameContext)
}

func (s *DropGraphStatementContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY, 0)
}

func (s *DropGraphStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(GQLParserIF, 0)
}

func (s *DropGraphStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(GQLParserEXISTS, 0)
}

func (s *DropGraphStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropGraphStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropGraphStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDropGraphStatement(s)
	}
}

func (s *DropGraphStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDropGraphStatement(s)
	}
}

func (p *GQLParser) DropGraphStatement() (localctx IDropGraphStatementContext) {
	localctx = NewDropGraphStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, GQLParserRULE_dropGraphStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1552)
		p.Match(GQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserPROPERTY {
		{
			p.SetState(1553)
			p.Match(GQLParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1556)
		p.Match(GQLParserGRAPH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserIF {
		{
			p.SetState(1557)
			p.Match(GQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1558)
			p.Match(GQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1561)
		p.CatalogGraphParentAndName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateGraphTypeStatementContext is an interface to support dynamic dispatch.
type ICreateGraphTypeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	CatalogGraphTypeParentAndName() ICatalogGraphTypeParentAndNameContext
	GraphTypeSource() IGraphTypeSourceContext
	GRAPH() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreateGraphTypeStatementContext differentiates from other interfaces.
	IsCreateGraphTypeStatementContext()
}

type CreateGraphTypeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateGraphTypeStatementContext() *CreateGraphTypeStatementContext {
	var p = new(CreateGraphTypeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_createGraphTypeStatement
	return p
}

func InitEmptyCreateGraphTypeStatementContext(p *CreateGraphTypeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_createGraphTypeStatement
}

func (*CreateGraphTypeStatementContext) IsCreateGraphTypeStatementContext() {}

func NewCreateGraphTypeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateGraphTypeStatementContext {
	var p = new(CreateGraphTypeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_createGraphTypeStatement

	return p
}

func (s *CreateGraphTypeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateGraphTypeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(GQLParserCREATE, 0)
}

func (s *CreateGraphTypeStatementContext) CatalogGraphTypeParentAndName() ICatalogGraphTypeParentAndNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogGraphTypeParentAndNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogGraphTypeParentAndNameContext)
}

func (s *CreateGraphTypeStatementContext) GraphTypeSource() IGraphTypeSourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphTypeSourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphTypeSourceContext)
}

func (s *CreateGraphTypeStatementContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserGRAPH, 0)
}

func (s *CreateGraphTypeStatementContext) TYPE() antlr.TerminalNode {
	return s.GetToken(GQLParserTYPE, 0)
}

func (s *CreateGraphTypeStatementContext) OR() antlr.TerminalNode {
	return s.GetToken(GQLParserOR, 0)
}

func (s *CreateGraphTypeStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(GQLParserREPLACE, 0)
}

func (s *CreateGraphTypeStatementContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY, 0)
}

func (s *CreateGraphTypeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(GQLParserIF, 0)
}

func (s *CreateGraphTypeStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(GQLParserNOT, 0)
}

func (s *CreateGraphTypeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(GQLParserEXISTS, 0)
}

func (s *CreateGraphTypeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateGraphTypeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateGraphTypeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCreateGraphTypeStatement(s)
	}
}

func (s *CreateGraphTypeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCreateGraphTypeStatement(s)
	}
}

func (p *GQLParser) CreateGraphTypeStatement() (localctx ICreateGraphTypeStatementContext) {
	localctx = NewCreateGraphTypeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, GQLParserRULE_createGraphTypeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1563)
		p.Match(GQLParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserGRAPH, GQLParserPROPERTY:
		p.SetState(1565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserPROPERTY {
			{
				p.SetState(1564)
				p.Match(GQLParserPROPERTY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1567)
			p.Match(GQLParserGRAPH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1568)
			p.Match(GQLParserTYPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1572)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserIF {
			{
				p.SetState(1569)
				p.Match(GQLParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1570)
				p.Match(GQLParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1571)
				p.Match(GQLParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case GQLParserOR:
		{
			p.SetState(1574)
			p.Match(GQLParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1575)
			p.Match(GQLParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1577)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserPROPERTY {
			{
				p.SetState(1576)
				p.Match(GQLParserPROPERTY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1579)
			p.Match(GQLParserGRAPH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1580)
			p.Match(GQLParserTYPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1583)
		p.CatalogGraphTypeParentAndName()
	}
	{
		p.SetState(1584)
		p.GraphTypeSource()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphTypeSourceContext is an interface to support dynamic dispatch.
type IGraphTypeSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CopyOfGraphType() ICopyOfGraphTypeContext
	AS() antlr.TerminalNode
	GraphTypeLikeGraph() IGraphTypeLikeGraphContext
	NestedGraphTypeSpecification() INestedGraphTypeSpecificationContext

	// IsGraphTypeSourceContext differentiates from other interfaces.
	IsGraphTypeSourceContext()
}

type GraphTypeSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphTypeSourceContext() *GraphTypeSourceContext {
	var p = new(GraphTypeSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphTypeSource
	return p
}

func InitEmptyGraphTypeSourceContext(p *GraphTypeSourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphTypeSource
}

func (*GraphTypeSourceContext) IsGraphTypeSourceContext() {}

func NewGraphTypeSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphTypeSourceContext {
	var p = new(GraphTypeSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphTypeSource

	return p
}

func (s *GraphTypeSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphTypeSourceContext) CopyOfGraphType() ICopyOfGraphTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopyOfGraphTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopyOfGraphTypeContext)
}

func (s *GraphTypeSourceContext) AS() antlr.TerminalNode {
	return s.GetToken(GQLParserAS, 0)
}

func (s *GraphTypeSourceContext) GraphTypeLikeGraph() IGraphTypeLikeGraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphTypeLikeGraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphTypeLikeGraphContext)
}

func (s *GraphTypeSourceContext) NestedGraphTypeSpecification() INestedGraphTypeSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedGraphTypeSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedGraphTypeSpecificationContext)
}

func (s *GraphTypeSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphTypeSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphTypeSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphTypeSource(s)
	}
}

func (s *GraphTypeSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphTypeSource(s)
	}
}

func (p *GQLParser) GraphTypeSource() (localctx IGraphTypeSourceContext) {
	localctx = NewGraphTypeSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, GQLParserRULE_graphTypeSource)
	var _la int

	p.SetState(1595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1587)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserAS {
			{
				p.SetState(1586)
				p.Match(GQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1589)
			p.CopyOfGraphType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1590)
			p.GraphTypeLikeGraph()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1592)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserAS {
			{
				p.SetState(1591)
				p.Match(GQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1594)
			p.NestedGraphTypeSpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopyOfGraphTypeContext is an interface to support dynamic dispatch.
type ICopyOfGraphTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COPY() antlr.TerminalNode
	OF() antlr.TerminalNode
	GraphTypeReference() IGraphTypeReferenceContext

	// IsCopyOfGraphTypeContext differentiates from other interfaces.
	IsCopyOfGraphTypeContext()
}

type CopyOfGraphTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopyOfGraphTypeContext() *CopyOfGraphTypeContext {
	var p = new(CopyOfGraphTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_copyOfGraphType
	return p
}

func InitEmptyCopyOfGraphTypeContext(p *CopyOfGraphTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_copyOfGraphType
}

func (*CopyOfGraphTypeContext) IsCopyOfGraphTypeContext() {}

func NewCopyOfGraphTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CopyOfGraphTypeContext {
	var p = new(CopyOfGraphTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_copyOfGraphType

	return p
}

func (s *CopyOfGraphTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CopyOfGraphTypeContext) COPY() antlr.TerminalNode {
	return s.GetToken(GQLParserCOPY, 0)
}

func (s *CopyOfGraphTypeContext) OF() antlr.TerminalNode {
	return s.GetToken(GQLParserOF, 0)
}

func (s *CopyOfGraphTypeContext) GraphTypeReference() IGraphTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphTypeReferenceContext)
}

func (s *CopyOfGraphTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopyOfGraphTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CopyOfGraphTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCopyOfGraphType(s)
	}
}

func (s *CopyOfGraphTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCopyOfGraphType(s)
	}
}

func (p *GQLParser) CopyOfGraphType() (localctx ICopyOfGraphTypeContext) {
	localctx = NewCopyOfGraphTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, GQLParserRULE_copyOfGraphType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1597)
		p.Match(GQLParserCOPY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1598)
		p.Match(GQLParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1599)
		p.GraphTypeReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropGraphTypeStatementContext is an interface to support dynamic dispatch.
type IDropGraphTypeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	GRAPH() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	CatalogGraphTypeParentAndName() ICatalogGraphTypeParentAndNameContext
	PROPERTY() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropGraphTypeStatementContext differentiates from other interfaces.
	IsDropGraphTypeStatementContext()
}

type DropGraphTypeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropGraphTypeStatementContext() *DropGraphTypeStatementContext {
	var p = new(DropGraphTypeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dropGraphTypeStatement
	return p
}

func InitEmptyDropGraphTypeStatementContext(p *DropGraphTypeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dropGraphTypeStatement
}

func (*DropGraphTypeStatementContext) IsDropGraphTypeStatementContext() {}

func NewDropGraphTypeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropGraphTypeStatementContext {
	var p = new(DropGraphTypeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_dropGraphTypeStatement

	return p
}

func (s *DropGraphTypeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropGraphTypeStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(GQLParserDROP, 0)
}

func (s *DropGraphTypeStatementContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserGRAPH, 0)
}

func (s *DropGraphTypeStatementContext) TYPE() antlr.TerminalNode {
	return s.GetToken(GQLParserTYPE, 0)
}

func (s *DropGraphTypeStatementContext) CatalogGraphTypeParentAndName() ICatalogGraphTypeParentAndNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogGraphTypeParentAndNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogGraphTypeParentAndNameContext)
}

func (s *DropGraphTypeStatementContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY, 0)
}

func (s *DropGraphTypeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(GQLParserIF, 0)
}

func (s *DropGraphTypeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(GQLParserEXISTS, 0)
}

func (s *DropGraphTypeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropGraphTypeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropGraphTypeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDropGraphTypeStatement(s)
	}
}

func (s *DropGraphTypeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDropGraphTypeStatement(s)
	}
}

func (p *GQLParser) DropGraphTypeStatement() (localctx IDropGraphTypeStatementContext) {
	localctx = NewDropGraphTypeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, GQLParserRULE_dropGraphTypeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1601)
		p.Match(GQLParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserPROPERTY {
		{
			p.SetState(1602)
			p.Match(GQLParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1605)
		p.Match(GQLParserGRAPH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1606)
		p.Match(GQLParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserIF {
		{
			p.SetState(1607)
			p.Match(GQLParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1608)
			p.Match(GQLParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1611)
		p.CatalogGraphTypeParentAndName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallCatalogModifyingProcedureStatementContext is an interface to support dynamic dispatch.
type ICallCatalogModifyingProcedureStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CallProcedureStatement() ICallProcedureStatementContext

	// IsCallCatalogModifyingProcedureStatementContext differentiates from other interfaces.
	IsCallCatalogModifyingProcedureStatementContext()
}

type CallCatalogModifyingProcedureStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallCatalogModifyingProcedureStatementContext() *CallCatalogModifyingProcedureStatementContext {
	var p = new(CallCatalogModifyingProcedureStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_callCatalogModifyingProcedureStatement
	return p
}

func InitEmptyCallCatalogModifyingProcedureStatementContext(p *CallCatalogModifyingProcedureStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_callCatalogModifyingProcedureStatement
}

func (*CallCatalogModifyingProcedureStatementContext) IsCallCatalogModifyingProcedureStatementContext() {
}

func NewCallCatalogModifyingProcedureStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallCatalogModifyingProcedureStatementContext {
	var p = new(CallCatalogModifyingProcedureStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_callCatalogModifyingProcedureStatement

	return p
}

func (s *CallCatalogModifyingProcedureStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CallCatalogModifyingProcedureStatementContext) CallProcedureStatement() ICallProcedureStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallProcedureStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallProcedureStatementContext)
}

func (s *CallCatalogModifyingProcedureStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallCatalogModifyingProcedureStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallCatalogModifyingProcedureStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCallCatalogModifyingProcedureStatement(s)
	}
}

func (s *CallCatalogModifyingProcedureStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCallCatalogModifyingProcedureStatement(s)
	}
}

func (p *GQLParser) CallCatalogModifyingProcedureStatement() (localctx ICallCatalogModifyingProcedureStatementContext) {
	localctx = NewCallCatalogModifyingProcedureStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, GQLParserRULE_callCatalogModifyingProcedureStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1613)
		p.CallProcedureStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILinearDataModifyingStatementContext is an interface to support dynamic dispatch.
type ILinearDataModifyingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FocusedLinearDataModifyingStatement() IFocusedLinearDataModifyingStatementContext
	AmbientLinearDataModifyingStatement() IAmbientLinearDataModifyingStatementContext

	// IsLinearDataModifyingStatementContext differentiates from other interfaces.
	IsLinearDataModifyingStatementContext()
}

type LinearDataModifyingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinearDataModifyingStatementContext() *LinearDataModifyingStatementContext {
	var p = new(LinearDataModifyingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_linearDataModifyingStatement
	return p
}

func InitEmptyLinearDataModifyingStatementContext(p *LinearDataModifyingStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_linearDataModifyingStatement
}

func (*LinearDataModifyingStatementContext) IsLinearDataModifyingStatementContext() {}

func NewLinearDataModifyingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinearDataModifyingStatementContext {
	var p = new(LinearDataModifyingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_linearDataModifyingStatement

	return p
}

func (s *LinearDataModifyingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LinearDataModifyingStatementContext) FocusedLinearDataModifyingStatement() IFocusedLinearDataModifyingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFocusedLinearDataModifyingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFocusedLinearDataModifyingStatementContext)
}

func (s *LinearDataModifyingStatementContext) AmbientLinearDataModifyingStatement() IAmbientLinearDataModifyingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAmbientLinearDataModifyingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAmbientLinearDataModifyingStatementContext)
}

func (s *LinearDataModifyingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinearDataModifyingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinearDataModifyingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLinearDataModifyingStatement(s)
	}
}

func (s *LinearDataModifyingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLinearDataModifyingStatement(s)
	}
}

func (p *GQLParser) LinearDataModifyingStatement() (localctx ILinearDataModifyingStatementContext) {
	localctx = NewLinearDataModifyingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, GQLParserRULE_linearDataModifyingStatement)
	p.SetState(1617)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserUSE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1615)
			p.FocusedLinearDataModifyingStatement()
		}

	case GQLParserCALL, GQLParserDELETE, GQLParserDETACH, GQLParserFILTER, GQLParserFOR, GQLParserINSERT, GQLParserLET, GQLParserLIMIT, GQLParserMATCH, GQLParserNODETACH, GQLParserOFFSET, GQLParserOPTIONAL, GQLParserORDER, GQLParserREMOVE, GQLParserSET, GQLParserSKIP_RESERVED_WORD, GQLParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1616)
			p.AmbientLinearDataModifyingStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFocusedLinearDataModifyingStatementContext is an interface to support dynamic dispatch.
type IFocusedLinearDataModifyingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FocusedLinearDataModifyingStatementBody() IFocusedLinearDataModifyingStatementBodyContext
	FocusedNestedDataModifyingProcedureSpecification() IFocusedNestedDataModifyingProcedureSpecificationContext

	// IsFocusedLinearDataModifyingStatementContext differentiates from other interfaces.
	IsFocusedLinearDataModifyingStatementContext()
}

type FocusedLinearDataModifyingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFocusedLinearDataModifyingStatementContext() *FocusedLinearDataModifyingStatementContext {
	var p = new(FocusedLinearDataModifyingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedLinearDataModifyingStatement
	return p
}

func InitEmptyFocusedLinearDataModifyingStatementContext(p *FocusedLinearDataModifyingStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedLinearDataModifyingStatement
}

func (*FocusedLinearDataModifyingStatementContext) IsFocusedLinearDataModifyingStatementContext() {}

func NewFocusedLinearDataModifyingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FocusedLinearDataModifyingStatementContext {
	var p = new(FocusedLinearDataModifyingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_focusedLinearDataModifyingStatement

	return p
}

func (s *FocusedLinearDataModifyingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FocusedLinearDataModifyingStatementContext) FocusedLinearDataModifyingStatementBody() IFocusedLinearDataModifyingStatementBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFocusedLinearDataModifyingStatementBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFocusedLinearDataModifyingStatementBodyContext)
}

func (s *FocusedLinearDataModifyingStatementContext) FocusedNestedDataModifyingProcedureSpecification() IFocusedNestedDataModifyingProcedureSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFocusedNestedDataModifyingProcedureSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFocusedNestedDataModifyingProcedureSpecificationContext)
}

func (s *FocusedLinearDataModifyingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FocusedLinearDataModifyingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FocusedLinearDataModifyingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFocusedLinearDataModifyingStatement(s)
	}
}

func (s *FocusedLinearDataModifyingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFocusedLinearDataModifyingStatement(s)
	}
}

func (p *GQLParser) FocusedLinearDataModifyingStatement() (localctx IFocusedLinearDataModifyingStatementContext) {
	localctx = NewFocusedLinearDataModifyingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, GQLParserRULE_focusedLinearDataModifyingStatement)
	p.SetState(1621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1619)
			p.FocusedLinearDataModifyingStatementBody()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1620)
			p.FocusedNestedDataModifyingProcedureSpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFocusedLinearDataModifyingStatementBodyContext is an interface to support dynamic dispatch.
type IFocusedLinearDataModifyingStatementBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UseGraphClause() IUseGraphClauseContext
	SimpleLinearDataAccessingStatement() ISimpleLinearDataAccessingStatementContext
	PrimitiveResultStatement() IPrimitiveResultStatementContext

	// IsFocusedLinearDataModifyingStatementBodyContext differentiates from other interfaces.
	IsFocusedLinearDataModifyingStatementBodyContext()
}

type FocusedLinearDataModifyingStatementBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFocusedLinearDataModifyingStatementBodyContext() *FocusedLinearDataModifyingStatementBodyContext {
	var p = new(FocusedLinearDataModifyingStatementBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedLinearDataModifyingStatementBody
	return p
}

func InitEmptyFocusedLinearDataModifyingStatementBodyContext(p *FocusedLinearDataModifyingStatementBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedLinearDataModifyingStatementBody
}

func (*FocusedLinearDataModifyingStatementBodyContext) IsFocusedLinearDataModifyingStatementBodyContext() {
}

func NewFocusedLinearDataModifyingStatementBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FocusedLinearDataModifyingStatementBodyContext {
	var p = new(FocusedLinearDataModifyingStatementBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_focusedLinearDataModifyingStatementBody

	return p
}

func (s *FocusedLinearDataModifyingStatementBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FocusedLinearDataModifyingStatementBodyContext) UseGraphClause() IUseGraphClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseGraphClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseGraphClauseContext)
}

func (s *FocusedLinearDataModifyingStatementBodyContext) SimpleLinearDataAccessingStatement() ISimpleLinearDataAccessingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLinearDataAccessingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLinearDataAccessingStatementContext)
}

func (s *FocusedLinearDataModifyingStatementBodyContext) PrimitiveResultStatement() IPrimitiveResultStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveResultStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveResultStatementContext)
}

func (s *FocusedLinearDataModifyingStatementBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FocusedLinearDataModifyingStatementBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FocusedLinearDataModifyingStatementBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFocusedLinearDataModifyingStatementBody(s)
	}
}

func (s *FocusedLinearDataModifyingStatementBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFocusedLinearDataModifyingStatementBody(s)
	}
}

func (p *GQLParser) FocusedLinearDataModifyingStatementBody() (localctx IFocusedLinearDataModifyingStatementBodyContext) {
	localctx = NewFocusedLinearDataModifyingStatementBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, GQLParserRULE_focusedLinearDataModifyingStatementBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1623)
		p.UseGraphClause()
	}
	{
		p.SetState(1624)
		p.SimpleLinearDataAccessingStatement()
	}
	p.SetState(1626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserFINISH || _la == GQLParserRETURN {
		{
			p.SetState(1625)
			p.PrimitiveResultStatement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFocusedNestedDataModifyingProcedureSpecificationContext is an interface to support dynamic dispatch.
type IFocusedNestedDataModifyingProcedureSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UseGraphClause() IUseGraphClauseContext
	NestedDataModifyingProcedureSpecification() INestedDataModifyingProcedureSpecificationContext

	// IsFocusedNestedDataModifyingProcedureSpecificationContext differentiates from other interfaces.
	IsFocusedNestedDataModifyingProcedureSpecificationContext()
}

type FocusedNestedDataModifyingProcedureSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFocusedNestedDataModifyingProcedureSpecificationContext() *FocusedNestedDataModifyingProcedureSpecificationContext {
	var p = new(FocusedNestedDataModifyingProcedureSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedNestedDataModifyingProcedureSpecification
	return p
}

func InitEmptyFocusedNestedDataModifyingProcedureSpecificationContext(p *FocusedNestedDataModifyingProcedureSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedNestedDataModifyingProcedureSpecification
}

func (*FocusedNestedDataModifyingProcedureSpecificationContext) IsFocusedNestedDataModifyingProcedureSpecificationContext() {
}

func NewFocusedNestedDataModifyingProcedureSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FocusedNestedDataModifyingProcedureSpecificationContext {
	var p = new(FocusedNestedDataModifyingProcedureSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_focusedNestedDataModifyingProcedureSpecification

	return p
}

func (s *FocusedNestedDataModifyingProcedureSpecificationContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *FocusedNestedDataModifyingProcedureSpecificationContext) UseGraphClause() IUseGraphClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseGraphClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseGraphClauseContext)
}

func (s *FocusedNestedDataModifyingProcedureSpecificationContext) NestedDataModifyingProcedureSpecification() INestedDataModifyingProcedureSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedDataModifyingProcedureSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedDataModifyingProcedureSpecificationContext)
}

func (s *FocusedNestedDataModifyingProcedureSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FocusedNestedDataModifyingProcedureSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FocusedNestedDataModifyingProcedureSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFocusedNestedDataModifyingProcedureSpecification(s)
	}
}

func (s *FocusedNestedDataModifyingProcedureSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFocusedNestedDataModifyingProcedureSpecification(s)
	}
}

func (p *GQLParser) FocusedNestedDataModifyingProcedureSpecification() (localctx IFocusedNestedDataModifyingProcedureSpecificationContext) {
	localctx = NewFocusedNestedDataModifyingProcedureSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, GQLParserRULE_focusedNestedDataModifyingProcedureSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1628)
		p.UseGraphClause()
	}
	{
		p.SetState(1629)
		p.NestedDataModifyingProcedureSpecification()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAmbientLinearDataModifyingStatementContext is an interface to support dynamic dispatch.
type IAmbientLinearDataModifyingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AmbientLinearDataModifyingStatementBody() IAmbientLinearDataModifyingStatementBodyContext
	NestedDataModifyingProcedureSpecification() INestedDataModifyingProcedureSpecificationContext

	// IsAmbientLinearDataModifyingStatementContext differentiates from other interfaces.
	IsAmbientLinearDataModifyingStatementContext()
}

type AmbientLinearDataModifyingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAmbientLinearDataModifyingStatementContext() *AmbientLinearDataModifyingStatementContext {
	var p = new(AmbientLinearDataModifyingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_ambientLinearDataModifyingStatement
	return p
}

func InitEmptyAmbientLinearDataModifyingStatementContext(p *AmbientLinearDataModifyingStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_ambientLinearDataModifyingStatement
}

func (*AmbientLinearDataModifyingStatementContext) IsAmbientLinearDataModifyingStatementContext() {}

func NewAmbientLinearDataModifyingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AmbientLinearDataModifyingStatementContext {
	var p = new(AmbientLinearDataModifyingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_ambientLinearDataModifyingStatement

	return p
}

func (s *AmbientLinearDataModifyingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AmbientLinearDataModifyingStatementContext) AmbientLinearDataModifyingStatementBody() IAmbientLinearDataModifyingStatementBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAmbientLinearDataModifyingStatementBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAmbientLinearDataModifyingStatementBodyContext)
}

func (s *AmbientLinearDataModifyingStatementContext) NestedDataModifyingProcedureSpecification() INestedDataModifyingProcedureSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedDataModifyingProcedureSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedDataModifyingProcedureSpecificationContext)
}

func (s *AmbientLinearDataModifyingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AmbientLinearDataModifyingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AmbientLinearDataModifyingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAmbientLinearDataModifyingStatement(s)
	}
}

func (s *AmbientLinearDataModifyingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAmbientLinearDataModifyingStatement(s)
	}
}

func (p *GQLParser) AmbientLinearDataModifyingStatement() (localctx IAmbientLinearDataModifyingStatementContext) {
	localctx = NewAmbientLinearDataModifyingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, GQLParserRULE_ambientLinearDataModifyingStatement)
	p.SetState(1633)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserCALL, GQLParserDELETE, GQLParserDETACH, GQLParserFILTER, GQLParserFOR, GQLParserINSERT, GQLParserLET, GQLParserLIMIT, GQLParserMATCH, GQLParserNODETACH, GQLParserOFFSET, GQLParserOPTIONAL, GQLParserORDER, GQLParserREMOVE, GQLParserSET, GQLParserSKIP_RESERVED_WORD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1631)
			p.AmbientLinearDataModifyingStatementBody()
		}

	case GQLParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1632)
			p.NestedDataModifyingProcedureSpecification()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAmbientLinearDataModifyingStatementBodyContext is an interface to support dynamic dispatch.
type IAmbientLinearDataModifyingStatementBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleLinearDataAccessingStatement() ISimpleLinearDataAccessingStatementContext
	PrimitiveResultStatement() IPrimitiveResultStatementContext

	// IsAmbientLinearDataModifyingStatementBodyContext differentiates from other interfaces.
	IsAmbientLinearDataModifyingStatementBodyContext()
}

type AmbientLinearDataModifyingStatementBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAmbientLinearDataModifyingStatementBodyContext() *AmbientLinearDataModifyingStatementBodyContext {
	var p = new(AmbientLinearDataModifyingStatementBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_ambientLinearDataModifyingStatementBody
	return p
}

func InitEmptyAmbientLinearDataModifyingStatementBodyContext(p *AmbientLinearDataModifyingStatementBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_ambientLinearDataModifyingStatementBody
}

func (*AmbientLinearDataModifyingStatementBodyContext) IsAmbientLinearDataModifyingStatementBodyContext() {
}

func NewAmbientLinearDataModifyingStatementBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AmbientLinearDataModifyingStatementBodyContext {
	var p = new(AmbientLinearDataModifyingStatementBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_ambientLinearDataModifyingStatementBody

	return p
}

func (s *AmbientLinearDataModifyingStatementBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *AmbientLinearDataModifyingStatementBodyContext) SimpleLinearDataAccessingStatement() ISimpleLinearDataAccessingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLinearDataAccessingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLinearDataAccessingStatementContext)
}

func (s *AmbientLinearDataModifyingStatementBodyContext) PrimitiveResultStatement() IPrimitiveResultStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveResultStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveResultStatementContext)
}

func (s *AmbientLinearDataModifyingStatementBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AmbientLinearDataModifyingStatementBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AmbientLinearDataModifyingStatementBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAmbientLinearDataModifyingStatementBody(s)
	}
}

func (s *AmbientLinearDataModifyingStatementBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAmbientLinearDataModifyingStatementBody(s)
	}
}

func (p *GQLParser) AmbientLinearDataModifyingStatementBody() (localctx IAmbientLinearDataModifyingStatementBodyContext) {
	localctx = NewAmbientLinearDataModifyingStatementBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, GQLParserRULE_ambientLinearDataModifyingStatementBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1635)
		p.SimpleLinearDataAccessingStatement()
	}
	p.SetState(1637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserFINISH || _la == GQLParserRETURN {
		{
			p.SetState(1636)
			p.PrimitiveResultStatement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleLinearDataAccessingStatementContext is an interface to support dynamic dispatch.
type ISimpleLinearDataAccessingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleDataAccessingStatement() []ISimpleDataAccessingStatementContext
	SimpleDataAccessingStatement(i int) ISimpleDataAccessingStatementContext

	// IsSimpleLinearDataAccessingStatementContext differentiates from other interfaces.
	IsSimpleLinearDataAccessingStatementContext()
}

type SimpleLinearDataAccessingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleLinearDataAccessingStatementContext() *SimpleLinearDataAccessingStatementContext {
	var p = new(SimpleLinearDataAccessingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleLinearDataAccessingStatement
	return p
}

func InitEmptySimpleLinearDataAccessingStatementContext(p *SimpleLinearDataAccessingStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleLinearDataAccessingStatement
}

func (*SimpleLinearDataAccessingStatementContext) IsSimpleLinearDataAccessingStatementContext() {}

func NewSimpleLinearDataAccessingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleLinearDataAccessingStatementContext {
	var p = new(SimpleLinearDataAccessingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simpleLinearDataAccessingStatement

	return p
}

func (s *SimpleLinearDataAccessingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleLinearDataAccessingStatementContext) AllSimpleDataAccessingStatement() []ISimpleDataAccessingStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleDataAccessingStatementContext); ok {
			len++
		}
	}

	tst := make([]ISimpleDataAccessingStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleDataAccessingStatementContext); ok {
			tst[i] = t.(ISimpleDataAccessingStatementContext)
			i++
		}
	}

	return tst
}

func (s *SimpleLinearDataAccessingStatementContext) SimpleDataAccessingStatement(i int) ISimpleDataAccessingStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleDataAccessingStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleDataAccessingStatementContext)
}

func (s *SimpleLinearDataAccessingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleLinearDataAccessingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleLinearDataAccessingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimpleLinearDataAccessingStatement(s)
	}
}

func (s *SimpleLinearDataAccessingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimpleLinearDataAccessingStatement(s)
	}
}

func (p *GQLParser) SimpleLinearDataAccessingStatement() (localctx ISimpleLinearDataAccessingStatementContext) {
	localctx = NewSimpleLinearDataAccessingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, GQLParserRULE_simpleLinearDataAccessingStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == GQLParserCALL || ((int64((_la-79)) & ^0x3f) == 0 && ((int64(1)<<(_la-79))&90072009744089097) != 0) || ((int64((_la-146)) & ^0x3f) == 0 && ((int64(1)<<(_la-146))&4644354296316033) != 0) {
		{
			p.SetState(1639)
			p.SimpleDataAccessingStatement()
		}

		p.SetState(1642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleDataAccessingStatementContext is an interface to support dynamic dispatch.
type ISimpleDataAccessingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleQueryStatement() ISimpleQueryStatementContext
	SimpleDataModifyingStatement() ISimpleDataModifyingStatementContext

	// IsSimpleDataAccessingStatementContext differentiates from other interfaces.
	IsSimpleDataAccessingStatementContext()
}

type SimpleDataAccessingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleDataAccessingStatementContext() *SimpleDataAccessingStatementContext {
	var p = new(SimpleDataAccessingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleDataAccessingStatement
	return p
}

func InitEmptySimpleDataAccessingStatementContext(p *SimpleDataAccessingStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleDataAccessingStatement
}

func (*SimpleDataAccessingStatementContext) IsSimpleDataAccessingStatementContext() {}

func NewSimpleDataAccessingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleDataAccessingStatementContext {
	var p = new(SimpleDataAccessingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simpleDataAccessingStatement

	return p
}

func (s *SimpleDataAccessingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleDataAccessingStatementContext) SimpleQueryStatement() ISimpleQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleQueryStatementContext)
}

func (s *SimpleDataAccessingStatementContext) SimpleDataModifyingStatement() ISimpleDataModifyingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleDataModifyingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleDataModifyingStatementContext)
}

func (s *SimpleDataAccessingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDataAccessingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleDataAccessingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimpleDataAccessingStatement(s)
	}
}

func (s *SimpleDataAccessingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimpleDataAccessingStatement(s)
	}
}

func (p *GQLParser) SimpleDataAccessingStatement() (localctx ISimpleDataAccessingStatementContext) {
	localctx = NewSimpleDataAccessingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, GQLParserRULE_simpleDataAccessingStatement)
	p.SetState(1646)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1644)
			p.SimpleQueryStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1645)
			p.SimpleDataModifyingStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleDataModifyingStatementContext is an interface to support dynamic dispatch.
type ISimpleDataModifyingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimitiveDataModifyingStatement() IPrimitiveDataModifyingStatementContext
	CallDataModifyingProcedureStatement() ICallDataModifyingProcedureStatementContext

	// IsSimpleDataModifyingStatementContext differentiates from other interfaces.
	IsSimpleDataModifyingStatementContext()
}

type SimpleDataModifyingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleDataModifyingStatementContext() *SimpleDataModifyingStatementContext {
	var p = new(SimpleDataModifyingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleDataModifyingStatement
	return p
}

func InitEmptySimpleDataModifyingStatementContext(p *SimpleDataModifyingStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleDataModifyingStatement
}

func (*SimpleDataModifyingStatementContext) IsSimpleDataModifyingStatementContext() {}

func NewSimpleDataModifyingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleDataModifyingStatementContext {
	var p = new(SimpleDataModifyingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simpleDataModifyingStatement

	return p
}

func (s *SimpleDataModifyingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleDataModifyingStatementContext) PrimitiveDataModifyingStatement() IPrimitiveDataModifyingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveDataModifyingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveDataModifyingStatementContext)
}

func (s *SimpleDataModifyingStatementContext) CallDataModifyingProcedureStatement() ICallDataModifyingProcedureStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallDataModifyingProcedureStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallDataModifyingProcedureStatementContext)
}

func (s *SimpleDataModifyingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDataModifyingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleDataModifyingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimpleDataModifyingStatement(s)
	}
}

func (s *SimpleDataModifyingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimpleDataModifyingStatement(s)
	}
}

func (p *GQLParser) SimpleDataModifyingStatement() (localctx ISimpleDataModifyingStatementContext) {
	localctx = NewSimpleDataModifyingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, GQLParserRULE_simpleDataModifyingStatement)
	p.SetState(1650)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserDELETE, GQLParserDETACH, GQLParserINSERT, GQLParserNODETACH, GQLParserREMOVE, GQLParserSET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1648)
			p.PrimitiveDataModifyingStatement()
		}

	case GQLParserCALL, GQLParserOPTIONAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1649)
			p.CallDataModifyingProcedureStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveDataModifyingStatementContext is an interface to support dynamic dispatch.
type IPrimitiveDataModifyingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InsertStatement() IInsertStatementContext
	SetStatement() ISetStatementContext
	RemoveStatement() IRemoveStatementContext
	DeleteStatement() IDeleteStatementContext

	// IsPrimitiveDataModifyingStatementContext differentiates from other interfaces.
	IsPrimitiveDataModifyingStatementContext()
}

type PrimitiveDataModifyingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveDataModifyingStatementContext() *PrimitiveDataModifyingStatementContext {
	var p = new(PrimitiveDataModifyingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_primitiveDataModifyingStatement
	return p
}

func InitEmptyPrimitiveDataModifyingStatementContext(p *PrimitiveDataModifyingStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_primitiveDataModifyingStatement
}

func (*PrimitiveDataModifyingStatementContext) IsPrimitiveDataModifyingStatementContext() {}

func NewPrimitiveDataModifyingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveDataModifyingStatementContext {
	var p = new(PrimitiveDataModifyingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_primitiveDataModifyingStatement

	return p
}

func (s *PrimitiveDataModifyingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveDataModifyingStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *PrimitiveDataModifyingStatementContext) SetStatement() ISetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *PrimitiveDataModifyingStatementContext) RemoveStatement() IRemoveStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRemoveStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRemoveStatementContext)
}

func (s *PrimitiveDataModifyingStatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *PrimitiveDataModifyingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveDataModifyingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveDataModifyingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPrimitiveDataModifyingStatement(s)
	}
}

func (s *PrimitiveDataModifyingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPrimitiveDataModifyingStatement(s)
	}
}

func (p *GQLParser) PrimitiveDataModifyingStatement() (localctx IPrimitiveDataModifyingStatementContext) {
	localctx = NewPrimitiveDataModifyingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, GQLParserRULE_primitiveDataModifyingStatement)
	p.SetState(1656)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserINSERT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1652)
			p.InsertStatement()
		}

	case GQLParserSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1653)
			p.SetStatement()
		}

	case GQLParserREMOVE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1654)
			p.RemoveStatement()
		}

	case GQLParserDELETE, GQLParserDETACH, GQLParserNODETACH:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1655)
			p.DeleteStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSERT() antlr.TerminalNode
	InsertGraphPattern() IInsertGraphPatternContext

	// IsInsertStatementContext differentiates from other interfaces.
	IsInsertStatementContext()
}

type InsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertStatementContext() *InsertStatementContext {
	var p = new(InsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertStatement
	return p
}

func InitEmptyInsertStatementContext(p *InsertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertStatement
}

func (*InsertStatementContext) IsInsertStatementContext() {}

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext {
	var p = new(InsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_insertStatement

	return p
}

func (s *InsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(GQLParserINSERT, 0)
}

func (s *InsertStatementContext) InsertGraphPattern() IInsertGraphPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertGraphPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertGraphPatternContext)
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterInsertStatement(s)
	}
}

func (s *InsertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitInsertStatement(s)
	}
}

func (p *GQLParser) InsertStatement() (localctx IInsertStatementContext) {
	localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, GQLParserRULE_insertStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1658)
		p.Match(GQLParserINSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1659)
		p.InsertGraphPattern()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	SetItemList() ISetItemListContext

	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setStatement
	return p
}

func InitEmptySetStatementContext(p *SetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setStatement
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(GQLParserSET, 0)
}

func (s *SetStatementContext) SetItemList() ISetItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetItemListContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSetStatement(s)
	}
}

func (s *SetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSetStatement(s)
	}
}

func (p *GQLParser) SetStatement() (localctx ISetStatementContext) {
	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, GQLParserRULE_setStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1661)
		p.Match(GQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1662)
		p.SetItemList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetItemListContext is an interface to support dynamic dispatch.
type ISetItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSetItem() []ISetItemContext
	SetItem(i int) ISetItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSetItemListContext differentiates from other interfaces.
	IsSetItemListContext()
}

type SetItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetItemListContext() *SetItemListContext {
	var p = new(SetItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setItemList
	return p
}

func InitEmptySetItemListContext(p *SetItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setItemList
}

func (*SetItemListContext) IsSetItemListContext() {}

func NewSetItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetItemListContext {
	var p = new(SetItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_setItemList

	return p
}

func (s *SetItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *SetItemListContext) AllSetItem() []ISetItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISetItemContext); ok {
			len++
		}
	}

	tst := make([]ISetItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISetItemContext); ok {
			tst[i] = t.(ISetItemContext)
			i++
		}
	}

	return tst
}

func (s *SetItemListContext) SetItem(i int) ISetItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetItemContext)
}

func (s *SetItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *SetItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *SetItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSetItemList(s)
	}
}

func (s *SetItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSetItemList(s)
	}
}

func (p *GQLParser) SetItemList() (localctx ISetItemListContext) {
	localctx = NewSetItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, GQLParserRULE_setItemList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1664)
		p.SetItem()
	}
	p.SetState(1669)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(1665)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1666)
			p.SetItem()
		}

		p.SetState(1671)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetItemContext is an interface to support dynamic dispatch.
type ISetItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SetPropertyItem() ISetPropertyItemContext
	SetAllPropertiesItem() ISetAllPropertiesItemContext
	SetLabelItem() ISetLabelItemContext

	// IsSetItemContext differentiates from other interfaces.
	IsSetItemContext()
}

type SetItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetItemContext() *SetItemContext {
	var p = new(SetItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setItem
	return p
}

func InitEmptySetItemContext(p *SetItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setItem
}

func (*SetItemContext) IsSetItemContext() {}

func NewSetItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetItemContext {
	var p = new(SetItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_setItem

	return p
}

func (s *SetItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SetItemContext) SetPropertyItem() ISetPropertyItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetPropertyItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetPropertyItemContext)
}

func (s *SetItemContext) SetAllPropertiesItem() ISetAllPropertiesItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetAllPropertiesItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetAllPropertiesItemContext)
}

func (s *SetItemContext) SetLabelItem() ISetLabelItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetLabelItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetLabelItemContext)
}

func (s *SetItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSetItem(s)
	}
}

func (s *SetItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSetItem(s)
	}
}

func (p *GQLParser) SetItem() (localctx ISetItemContext) {
	localctx = NewSetItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, GQLParserRULE_setItem)
	p.SetState(1675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1672)
			p.SetPropertyItem()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1673)
			p.SetAllPropertiesItem()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1674)
			p.SetLabelItem()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetPropertyItemContext is an interface to support dynamic dispatch.
type ISetPropertyItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingVariableReference() IBindingVariableReferenceContext
	PERIOD() antlr.TerminalNode
	PropertyName() IPropertyNameContext
	EQUALS_OPERATOR() antlr.TerminalNode
	ValueExpression() IValueExpressionContext

	// IsSetPropertyItemContext differentiates from other interfaces.
	IsSetPropertyItemContext()
}

type SetPropertyItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetPropertyItemContext() *SetPropertyItemContext {
	var p = new(SetPropertyItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setPropertyItem
	return p
}

func InitEmptySetPropertyItemContext(p *SetPropertyItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setPropertyItem
}

func (*SetPropertyItemContext) IsSetPropertyItemContext() {}

func NewSetPropertyItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetPropertyItemContext {
	var p = new(SetPropertyItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_setPropertyItem

	return p
}

func (s *SetPropertyItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SetPropertyItemContext) BindingVariableReference() IBindingVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableReferenceContext)
}

func (s *SetPropertyItemContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(GQLParserPERIOD, 0)
}

func (s *SetPropertyItemContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *SetPropertyItemContext) EQUALS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(GQLParserEQUALS_OPERATOR, 0)
}

func (s *SetPropertyItemContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SetPropertyItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPropertyItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetPropertyItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSetPropertyItem(s)
	}
}

func (s *SetPropertyItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSetPropertyItem(s)
	}
}

func (p *GQLParser) SetPropertyItem() (localctx ISetPropertyItemContext) {
	localctx = NewSetPropertyItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, GQLParserRULE_setPropertyItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1677)
		p.BindingVariableReference()
	}
	{
		p.SetState(1678)
		p.Match(GQLParserPERIOD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1679)
		p.PropertyName()
	}
	{
		p.SetState(1680)
		p.Match(GQLParserEQUALS_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1681)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetAllPropertiesItemContext is an interface to support dynamic dispatch.
type ISetAllPropertiesItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingVariableReference() IBindingVariableReferenceContext
	EQUALS_OPERATOR() antlr.TerminalNode
	LEFT_BRACE() antlr.TerminalNode
	RIGHT_BRACE() antlr.TerminalNode
	PropertyKeyValuePairList() IPropertyKeyValuePairListContext

	// IsSetAllPropertiesItemContext differentiates from other interfaces.
	IsSetAllPropertiesItemContext()
}

type SetAllPropertiesItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetAllPropertiesItemContext() *SetAllPropertiesItemContext {
	var p = new(SetAllPropertiesItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setAllPropertiesItem
	return p
}

func InitEmptySetAllPropertiesItemContext(p *SetAllPropertiesItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setAllPropertiesItem
}

func (*SetAllPropertiesItemContext) IsSetAllPropertiesItemContext() {}

func NewSetAllPropertiesItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetAllPropertiesItemContext {
	var p = new(SetAllPropertiesItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_setAllPropertiesItem

	return p
}

func (s *SetAllPropertiesItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SetAllPropertiesItemContext) BindingVariableReference() IBindingVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableReferenceContext)
}

func (s *SetAllPropertiesItemContext) EQUALS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(GQLParserEQUALS_OPERATOR, 0)
}

func (s *SetAllPropertiesItemContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACE, 0)
}

func (s *SetAllPropertiesItemContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACE, 0)
}

func (s *SetAllPropertiesItemContext) PropertyKeyValuePairList() IPropertyKeyValuePairListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeyValuePairListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyValuePairListContext)
}

func (s *SetAllPropertiesItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAllPropertiesItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetAllPropertiesItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSetAllPropertiesItem(s)
	}
}

func (s *SetAllPropertiesItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSetAllPropertiesItem(s)
	}
}

func (p *GQLParser) SetAllPropertiesItem() (localctx ISetAllPropertiesItemContext) {
	localctx = NewSetAllPropertiesItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, GQLParserRULE_setAllPropertiesItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1683)
		p.BindingVariableReference()
	}
	{
		p.SetState(1684)
		p.Match(GQLParserEQUALS_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1685)
		p.Match(GQLParserLEFT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1687)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&281474976710655) != 0) {
		{
			p.SetState(1686)
			p.PropertyKeyValuePairList()
		}

	}
	{
		p.SetState(1689)
		p.Match(GQLParserRIGHT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetLabelItemContext is an interface to support dynamic dispatch.
type ISetLabelItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingVariableReference() IBindingVariableReferenceContext
	IsOrColon() IIsOrColonContext
	LabelName() ILabelNameContext

	// IsSetLabelItemContext differentiates from other interfaces.
	IsSetLabelItemContext()
}

type SetLabelItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetLabelItemContext() *SetLabelItemContext {
	var p = new(SetLabelItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setLabelItem
	return p
}

func InitEmptySetLabelItemContext(p *SetLabelItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setLabelItem
}

func (*SetLabelItemContext) IsSetLabelItemContext() {}

func NewSetLabelItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetLabelItemContext {
	var p = new(SetLabelItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_setLabelItem

	return p
}

func (s *SetLabelItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SetLabelItemContext) BindingVariableReference() IBindingVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableReferenceContext)
}

func (s *SetLabelItemContext) IsOrColon() IIsOrColonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsOrColonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsOrColonContext)
}

func (s *SetLabelItemContext) LabelName() ILabelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelNameContext)
}

func (s *SetLabelItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetLabelItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetLabelItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSetLabelItem(s)
	}
}

func (s *SetLabelItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSetLabelItem(s)
	}
}

func (p *GQLParser) SetLabelItem() (localctx ISetLabelItemContext) {
	localctx = NewSetLabelItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, GQLParserRULE_setLabelItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1691)
		p.BindingVariableReference()
	}
	{
		p.SetState(1692)
		p.IsOrColon()
	}
	{
		p.SetState(1693)
		p.LabelName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRemoveStatementContext is an interface to support dynamic dispatch.
type IRemoveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REMOVE() antlr.TerminalNode
	RemoveItemList() IRemoveItemListContext

	// IsRemoveStatementContext differentiates from other interfaces.
	IsRemoveStatementContext()
}

type RemoveStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemoveStatementContext() *RemoveStatementContext {
	var p = new(RemoveStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_removeStatement
	return p
}

func InitEmptyRemoveStatementContext(p *RemoveStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_removeStatement
}

func (*RemoveStatementContext) IsRemoveStatementContext() {}

func NewRemoveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemoveStatementContext {
	var p = new(RemoveStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_removeStatement

	return p
}

func (s *RemoveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RemoveStatementContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(GQLParserREMOVE, 0)
}

func (s *RemoveStatementContext) RemoveItemList() IRemoveItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRemoveItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRemoveItemListContext)
}

func (s *RemoveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemoveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemoveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterRemoveStatement(s)
	}
}

func (s *RemoveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitRemoveStatement(s)
	}
}

func (p *GQLParser) RemoveStatement() (localctx IRemoveStatementContext) {
	localctx = NewRemoveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, GQLParserRULE_removeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1695)
		p.Match(GQLParserREMOVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1696)
		p.RemoveItemList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRemoveItemListContext is an interface to support dynamic dispatch.
type IRemoveItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRemoveItem() []IRemoveItemContext
	RemoveItem(i int) IRemoveItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRemoveItemListContext differentiates from other interfaces.
	IsRemoveItemListContext()
}

type RemoveItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemoveItemListContext() *RemoveItemListContext {
	var p = new(RemoveItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_removeItemList
	return p
}

func InitEmptyRemoveItemListContext(p *RemoveItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_removeItemList
}

func (*RemoveItemListContext) IsRemoveItemListContext() {}

func NewRemoveItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemoveItemListContext {
	var p = new(RemoveItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_removeItemList

	return p
}

func (s *RemoveItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *RemoveItemListContext) AllRemoveItem() []IRemoveItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRemoveItemContext); ok {
			len++
		}
	}

	tst := make([]IRemoveItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRemoveItemContext); ok {
			tst[i] = t.(IRemoveItemContext)
			i++
		}
	}

	return tst
}

func (s *RemoveItemListContext) RemoveItem(i int) IRemoveItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRemoveItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRemoveItemContext)
}

func (s *RemoveItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *RemoveItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *RemoveItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemoveItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemoveItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterRemoveItemList(s)
	}
}

func (s *RemoveItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitRemoveItemList(s)
	}
}

func (p *GQLParser) RemoveItemList() (localctx IRemoveItemListContext) {
	localctx = NewRemoveItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, GQLParserRULE_removeItemList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1698)
		p.RemoveItem()
	}
	p.SetState(1703)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(1699)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1700)
			p.RemoveItem()
		}

		p.SetState(1705)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRemoveItemContext is an interface to support dynamic dispatch.
type IRemoveItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RemovePropertyItem() IRemovePropertyItemContext
	RemoveLabelItem() IRemoveLabelItemContext

	// IsRemoveItemContext differentiates from other interfaces.
	IsRemoveItemContext()
}

type RemoveItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemoveItemContext() *RemoveItemContext {
	var p = new(RemoveItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_removeItem
	return p
}

func InitEmptyRemoveItemContext(p *RemoveItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_removeItem
}

func (*RemoveItemContext) IsRemoveItemContext() {}

func NewRemoveItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemoveItemContext {
	var p = new(RemoveItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_removeItem

	return p
}

func (s *RemoveItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RemoveItemContext) RemovePropertyItem() IRemovePropertyItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRemovePropertyItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRemovePropertyItemContext)
}

func (s *RemoveItemContext) RemoveLabelItem() IRemoveLabelItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRemoveLabelItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRemoveLabelItemContext)
}

func (s *RemoveItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemoveItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemoveItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterRemoveItem(s)
	}
}

func (s *RemoveItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitRemoveItem(s)
	}
}

func (p *GQLParser) RemoveItem() (localctx IRemoveItemContext) {
	localctx = NewRemoveItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, GQLParserRULE_removeItem)
	p.SetState(1708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1706)
			p.RemovePropertyItem()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1707)
			p.RemoveLabelItem()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRemovePropertyItemContext is an interface to support dynamic dispatch.
type IRemovePropertyItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingVariableReference() IBindingVariableReferenceContext
	PERIOD() antlr.TerminalNode
	PropertyName() IPropertyNameContext

	// IsRemovePropertyItemContext differentiates from other interfaces.
	IsRemovePropertyItemContext()
}

type RemovePropertyItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemovePropertyItemContext() *RemovePropertyItemContext {
	var p = new(RemovePropertyItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_removePropertyItem
	return p
}

func InitEmptyRemovePropertyItemContext(p *RemovePropertyItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_removePropertyItem
}

func (*RemovePropertyItemContext) IsRemovePropertyItemContext() {}

func NewRemovePropertyItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemovePropertyItemContext {
	var p = new(RemovePropertyItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_removePropertyItem

	return p
}

func (s *RemovePropertyItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RemovePropertyItemContext) BindingVariableReference() IBindingVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableReferenceContext)
}

func (s *RemovePropertyItemContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(GQLParserPERIOD, 0)
}

func (s *RemovePropertyItemContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *RemovePropertyItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemovePropertyItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemovePropertyItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterRemovePropertyItem(s)
	}
}

func (s *RemovePropertyItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitRemovePropertyItem(s)
	}
}

func (p *GQLParser) RemovePropertyItem() (localctx IRemovePropertyItemContext) {
	localctx = NewRemovePropertyItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, GQLParserRULE_removePropertyItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1710)
		p.BindingVariableReference()
	}
	{
		p.SetState(1711)
		p.Match(GQLParserPERIOD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1712)
		p.PropertyName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRemoveLabelItemContext is an interface to support dynamic dispatch.
type IRemoveLabelItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingVariableReference() IBindingVariableReferenceContext
	IsOrColon() IIsOrColonContext
	LabelName() ILabelNameContext

	// IsRemoveLabelItemContext differentiates from other interfaces.
	IsRemoveLabelItemContext()
}

type RemoveLabelItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemoveLabelItemContext() *RemoveLabelItemContext {
	var p = new(RemoveLabelItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_removeLabelItem
	return p
}

func InitEmptyRemoveLabelItemContext(p *RemoveLabelItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_removeLabelItem
}

func (*RemoveLabelItemContext) IsRemoveLabelItemContext() {}

func NewRemoveLabelItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemoveLabelItemContext {
	var p = new(RemoveLabelItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_removeLabelItem

	return p
}

func (s *RemoveLabelItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RemoveLabelItemContext) BindingVariableReference() IBindingVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableReferenceContext)
}

func (s *RemoveLabelItemContext) IsOrColon() IIsOrColonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsOrColonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsOrColonContext)
}

func (s *RemoveLabelItemContext) LabelName() ILabelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelNameContext)
}

func (s *RemoveLabelItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemoveLabelItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemoveLabelItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterRemoveLabelItem(s)
	}
}

func (s *RemoveLabelItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitRemoveLabelItem(s)
	}
}

func (p *GQLParser) RemoveLabelItem() (localctx IRemoveLabelItemContext) {
	localctx = NewRemoveLabelItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, GQLParserRULE_removeLabelItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1714)
		p.BindingVariableReference()
	}
	{
		p.SetState(1715)
		p.IsOrColon()
	}
	{
		p.SetState(1716)
		p.LabelName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	DeleteItemList() IDeleteItemListContext
	DETACH() antlr.TerminalNode
	NODETACH() antlr.TerminalNode

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_deleteStatement
	return p
}

func InitEmptyDeleteStatementContext(p *DeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_deleteStatement
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(GQLParserDELETE, 0)
}

func (s *DeleteStatementContext) DeleteItemList() IDeleteItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteItemListContext)
}

func (s *DeleteStatementContext) DETACH() antlr.TerminalNode {
	return s.GetToken(GQLParserDETACH, 0)
}

func (s *DeleteStatementContext) NODETACH() antlr.TerminalNode {
	return s.GetToken(GQLParserNODETACH, 0)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (p *GQLParser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, GQLParserRULE_deleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserDETACH || _la == GQLParserNODETACH {
		{
			p.SetState(1718)
			_la = p.GetTokenStream().LA(1)

			if !(_la == GQLParserDETACH || _la == GQLParserNODETACH) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1721)
		p.Match(GQLParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1722)
		p.DeleteItemList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteItemListContext is an interface to support dynamic dispatch.
type IDeleteItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDeleteItem() []IDeleteItemContext
	DeleteItem(i int) IDeleteItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDeleteItemListContext differentiates from other interfaces.
	IsDeleteItemListContext()
}

type DeleteItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteItemListContext() *DeleteItemListContext {
	var p = new(DeleteItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_deleteItemList
	return p
}

func InitEmptyDeleteItemListContext(p *DeleteItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_deleteItemList
}

func (*DeleteItemListContext) IsDeleteItemListContext() {}

func NewDeleteItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteItemListContext {
	var p = new(DeleteItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_deleteItemList

	return p
}

func (s *DeleteItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteItemListContext) AllDeleteItem() []IDeleteItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeleteItemContext); ok {
			len++
		}
	}

	tst := make([]IDeleteItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeleteItemContext); ok {
			tst[i] = t.(IDeleteItemContext)
			i++
		}
	}

	return tst
}

func (s *DeleteItemListContext) DeleteItem(i int) IDeleteItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteItemContext)
}

func (s *DeleteItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *DeleteItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *DeleteItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDeleteItemList(s)
	}
}

func (s *DeleteItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDeleteItemList(s)
	}
}

func (p *GQLParser) DeleteItemList() (localctx IDeleteItemListContext) {
	localctx = NewDeleteItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, GQLParserRULE_deleteItemList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1724)
		p.DeleteItem()
	}
	p.SetState(1729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(1725)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1726)
			p.DeleteItem()
		}

		p.SetState(1731)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteItemContext is an interface to support dynamic dispatch.
type IDeleteItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsDeleteItemContext differentiates from other interfaces.
	IsDeleteItemContext()
}

type DeleteItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteItemContext() *DeleteItemContext {
	var p = new(DeleteItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_deleteItem
	return p
}

func InitEmptyDeleteItemContext(p *DeleteItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_deleteItem
}

func (*DeleteItemContext) IsDeleteItemContext() {}

func NewDeleteItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteItemContext {
	var p = new(DeleteItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_deleteItem

	return p
}

func (s *DeleteItemContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteItemContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DeleteItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDeleteItem(s)
	}
}

func (s *DeleteItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDeleteItem(s)
	}
}

func (p *GQLParser) DeleteItem() (localctx IDeleteItemContext) {
	localctx = NewDeleteItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, GQLParserRULE_deleteItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1732)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallDataModifyingProcedureStatementContext is an interface to support dynamic dispatch.
type ICallDataModifyingProcedureStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CallProcedureStatement() ICallProcedureStatementContext

	// IsCallDataModifyingProcedureStatementContext differentiates from other interfaces.
	IsCallDataModifyingProcedureStatementContext()
}

type CallDataModifyingProcedureStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallDataModifyingProcedureStatementContext() *CallDataModifyingProcedureStatementContext {
	var p = new(CallDataModifyingProcedureStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_callDataModifyingProcedureStatement
	return p
}

func InitEmptyCallDataModifyingProcedureStatementContext(p *CallDataModifyingProcedureStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_callDataModifyingProcedureStatement
}

func (*CallDataModifyingProcedureStatementContext) IsCallDataModifyingProcedureStatementContext() {}

func NewCallDataModifyingProcedureStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallDataModifyingProcedureStatementContext {
	var p = new(CallDataModifyingProcedureStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_callDataModifyingProcedureStatement

	return p
}

func (s *CallDataModifyingProcedureStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CallDataModifyingProcedureStatementContext) CallProcedureStatement() ICallProcedureStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallProcedureStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallProcedureStatementContext)
}

func (s *CallDataModifyingProcedureStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallDataModifyingProcedureStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallDataModifyingProcedureStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCallDataModifyingProcedureStatement(s)
	}
}

func (s *CallDataModifyingProcedureStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCallDataModifyingProcedureStatement(s)
	}
}

func (p *GQLParser) CallDataModifyingProcedureStatement() (localctx ICallDataModifyingProcedureStatementContext) {
	localctx = NewCallDataModifyingProcedureStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, GQLParserRULE_callDataModifyingProcedureStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1734)
		p.CallProcedureStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompositeQueryStatementContext is an interface to support dynamic dispatch.
type ICompositeQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CompositeQueryExpression() ICompositeQueryExpressionContext

	// IsCompositeQueryStatementContext differentiates from other interfaces.
	IsCompositeQueryStatementContext()
}

type CompositeQueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompositeQueryStatementContext() *CompositeQueryStatementContext {
	var p = new(CompositeQueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_compositeQueryStatement
	return p
}

func InitEmptyCompositeQueryStatementContext(p *CompositeQueryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_compositeQueryStatement
}

func (*CompositeQueryStatementContext) IsCompositeQueryStatementContext() {}

func NewCompositeQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompositeQueryStatementContext {
	var p = new(CompositeQueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_compositeQueryStatement

	return p
}

func (s *CompositeQueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompositeQueryStatementContext) CompositeQueryExpression() ICompositeQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompositeQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompositeQueryExpressionContext)
}

func (s *CompositeQueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompositeQueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompositeQueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCompositeQueryStatement(s)
	}
}

func (s *CompositeQueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCompositeQueryStatement(s)
	}
}

func (p *GQLParser) CompositeQueryStatement() (localctx ICompositeQueryStatementContext) {
	localctx = NewCompositeQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, GQLParserRULE_compositeQueryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1736)
		p.compositeQueryExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompositeQueryExpressionContext is an interface to support dynamic dispatch.
type ICompositeQueryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CompositeQueryPrimary() ICompositeQueryPrimaryContext
	CompositeQueryExpression() ICompositeQueryExpressionContext
	QueryConjunction() IQueryConjunctionContext

	// IsCompositeQueryExpressionContext differentiates from other interfaces.
	IsCompositeQueryExpressionContext()
}

type CompositeQueryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompositeQueryExpressionContext() *CompositeQueryExpressionContext {
	var p = new(CompositeQueryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_compositeQueryExpression
	return p
}

func InitEmptyCompositeQueryExpressionContext(p *CompositeQueryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_compositeQueryExpression
}

func (*CompositeQueryExpressionContext) IsCompositeQueryExpressionContext() {}

func NewCompositeQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompositeQueryExpressionContext {
	var p = new(CompositeQueryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_compositeQueryExpression

	return p
}

func (s *CompositeQueryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CompositeQueryExpressionContext) CompositeQueryPrimary() ICompositeQueryPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompositeQueryPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompositeQueryPrimaryContext)
}

func (s *CompositeQueryExpressionContext) CompositeQueryExpression() ICompositeQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompositeQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompositeQueryExpressionContext)
}

func (s *CompositeQueryExpressionContext) QueryConjunction() IQueryConjunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryConjunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryConjunctionContext)
}

func (s *CompositeQueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompositeQueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompositeQueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCompositeQueryExpression(s)
	}
}

func (s *CompositeQueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCompositeQueryExpression(s)
	}
}

func (p *GQLParser) CompositeQueryExpression() (localctx ICompositeQueryExpressionContext) {
	return p.compositeQueryExpression(0)
}

func (p *GQLParser) compositeQueryExpression(_p int) (localctx ICompositeQueryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewCompositeQueryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ICompositeQueryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 184
	p.EnterRecursionRule(localctx, 184, GQLParserRULE_compositeQueryExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1739)
		p.CompositeQueryPrimary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewCompositeQueryExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_compositeQueryExpression)
			p.SetState(1741)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(1742)
				p.QueryConjunction()
			}
			{
				p.SetState(1743)
				p.CompositeQueryPrimary()
			}

		}
		p.SetState(1749)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryConjunctionContext is an interface to support dynamic dispatch.
type IQueryConjunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SetOperator() ISetOperatorContext
	OTHERWISE() antlr.TerminalNode

	// IsQueryConjunctionContext differentiates from other interfaces.
	IsQueryConjunctionContext()
}

type QueryConjunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryConjunctionContext() *QueryConjunctionContext {
	var p = new(QueryConjunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_queryConjunction
	return p
}

func InitEmptyQueryConjunctionContext(p *QueryConjunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_queryConjunction
}

func (*QueryConjunctionContext) IsQueryConjunctionContext() {}

func NewQueryConjunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryConjunctionContext {
	var p = new(QueryConjunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_queryConjunction

	return p
}

func (s *QueryConjunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryConjunctionContext) SetOperator() ISetOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetOperatorContext)
}

func (s *QueryConjunctionContext) OTHERWISE() antlr.TerminalNode {
	return s.GetToken(GQLParserOTHERWISE, 0)
}

func (s *QueryConjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryConjunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryConjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterQueryConjunction(s)
	}
}

func (s *QueryConjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitQueryConjunction(s)
	}
}

func (p *GQLParser) QueryConjunction() (localctx IQueryConjunctionContext) {
	localctx = NewQueryConjunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, GQLParserRULE_queryConjunction)
	p.SetState(1752)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserEXCEPT, GQLParserINTERSECT, GQLParserUNION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1750)
			p.SetOperator()
		}

	case GQLParserOTHERWISE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1751)
			p.Match(GQLParserOTHERWISE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetOperatorContext is an interface to support dynamic dispatch.
type ISetOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION() antlr.TerminalNode
	SetQuantifier() ISetQuantifierContext
	EXCEPT() antlr.TerminalNode
	INTERSECT() antlr.TerminalNode

	// IsSetOperatorContext differentiates from other interfaces.
	IsSetOperatorContext()
}

type SetOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetOperatorContext() *SetOperatorContext {
	var p = new(SetOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setOperator
	return p
}

func InitEmptySetOperatorContext(p *SetOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setOperator
}

func (*SetOperatorContext) IsSetOperatorContext() {}

func NewSetOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetOperatorContext {
	var p = new(SetOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_setOperator

	return p
}

func (s *SetOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *SetOperatorContext) UNION() antlr.TerminalNode {
	return s.GetToken(GQLParserUNION, 0)
}

func (s *SetOperatorContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperatorContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(GQLParserEXCEPT, 0)
}

func (s *SetOperatorContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(GQLParserINTERSECT, 0)
}

func (s *SetOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSetOperator(s)
	}
}

func (s *SetOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSetOperator(s)
	}
}

func (p *GQLParser) SetOperator() (localctx ISetOperatorContext) {
	localctx = NewSetOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, GQLParserRULE_setOperator)
	var _la int

	p.SetState(1766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserUNION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1754)
			p.Match(GQLParserUNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1756)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserALL || _la == GQLParserDISTINCT {
			{
				p.SetState(1755)
				p.SetQuantifier()
			}

		}

	case GQLParserEXCEPT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1758)
			p.Match(GQLParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1760)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserALL || _la == GQLParserDISTINCT {
			{
				p.SetState(1759)
				p.SetQuantifier()
			}

		}

	case GQLParserINTERSECT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1762)
			p.Match(GQLParserINTERSECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1764)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserALL || _la == GQLParserDISTINCT {
			{
				p.SetState(1763)
				p.SetQuantifier()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompositeQueryPrimaryContext is an interface to support dynamic dispatch.
type ICompositeQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LinearQueryStatement() ILinearQueryStatementContext

	// IsCompositeQueryPrimaryContext differentiates from other interfaces.
	IsCompositeQueryPrimaryContext()
}

type CompositeQueryPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompositeQueryPrimaryContext() *CompositeQueryPrimaryContext {
	var p = new(CompositeQueryPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_compositeQueryPrimary
	return p
}

func InitEmptyCompositeQueryPrimaryContext(p *CompositeQueryPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_compositeQueryPrimary
}

func (*CompositeQueryPrimaryContext) IsCompositeQueryPrimaryContext() {}

func NewCompositeQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompositeQueryPrimaryContext {
	var p = new(CompositeQueryPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_compositeQueryPrimary

	return p
}

func (s *CompositeQueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *CompositeQueryPrimaryContext) LinearQueryStatement() ILinearQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinearQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinearQueryStatementContext)
}

func (s *CompositeQueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompositeQueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompositeQueryPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCompositeQueryPrimary(s)
	}
}

func (s *CompositeQueryPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCompositeQueryPrimary(s)
	}
}

func (p *GQLParser) CompositeQueryPrimary() (localctx ICompositeQueryPrimaryContext) {
	localctx = NewCompositeQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, GQLParserRULE_compositeQueryPrimary)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1768)
		p.LinearQueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILinearQueryStatementContext is an interface to support dynamic dispatch.
type ILinearQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FocusedLinearQueryStatement() IFocusedLinearQueryStatementContext
	AmbientLinearQueryStatement() IAmbientLinearQueryStatementContext

	// IsLinearQueryStatementContext differentiates from other interfaces.
	IsLinearQueryStatementContext()
}

type LinearQueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinearQueryStatementContext() *LinearQueryStatementContext {
	var p = new(LinearQueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_linearQueryStatement
	return p
}

func InitEmptyLinearQueryStatementContext(p *LinearQueryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_linearQueryStatement
}

func (*LinearQueryStatementContext) IsLinearQueryStatementContext() {}

func NewLinearQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinearQueryStatementContext {
	var p = new(LinearQueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_linearQueryStatement

	return p
}

func (s *LinearQueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LinearQueryStatementContext) FocusedLinearQueryStatement() IFocusedLinearQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFocusedLinearQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFocusedLinearQueryStatementContext)
}

func (s *LinearQueryStatementContext) AmbientLinearQueryStatement() IAmbientLinearQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAmbientLinearQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAmbientLinearQueryStatementContext)
}

func (s *LinearQueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinearQueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinearQueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLinearQueryStatement(s)
	}
}

func (s *LinearQueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLinearQueryStatement(s)
	}
}

func (p *GQLParser) LinearQueryStatement() (localctx ILinearQueryStatementContext) {
	localctx = NewLinearQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, GQLParserRULE_linearQueryStatement)
	p.SetState(1772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserSELECT, GQLParserUSE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1770)
			p.FocusedLinearQueryStatement()
		}

	case GQLParserCALL, GQLParserFILTER, GQLParserFINISH, GQLParserFOR, GQLParserLET, GQLParserLIMIT, GQLParserMATCH, GQLParserOFFSET, GQLParserOPTIONAL, GQLParserORDER, GQLParserRETURN, GQLParserSKIP_RESERVED_WORD, GQLParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1771)
			p.AmbientLinearQueryStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFocusedLinearQueryStatementContext is an interface to support dynamic dispatch.
type IFocusedLinearQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FocusedLinearQueryAndPrimitiveResultStatementPart() IFocusedLinearQueryAndPrimitiveResultStatementPartContext
	AllFocusedLinearQueryStatementPart() []IFocusedLinearQueryStatementPartContext
	FocusedLinearQueryStatementPart(i int) IFocusedLinearQueryStatementPartContext
	FocusedPrimitiveResultStatement() IFocusedPrimitiveResultStatementContext
	FocusedNestedQuerySpecification() IFocusedNestedQuerySpecificationContext
	SelectStatement() ISelectStatementContext

	// IsFocusedLinearQueryStatementContext differentiates from other interfaces.
	IsFocusedLinearQueryStatementContext()
}

type FocusedLinearQueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFocusedLinearQueryStatementContext() *FocusedLinearQueryStatementContext {
	var p = new(FocusedLinearQueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedLinearQueryStatement
	return p
}

func InitEmptyFocusedLinearQueryStatementContext(p *FocusedLinearQueryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedLinearQueryStatement
}

func (*FocusedLinearQueryStatementContext) IsFocusedLinearQueryStatementContext() {}

func NewFocusedLinearQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FocusedLinearQueryStatementContext {
	var p = new(FocusedLinearQueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_focusedLinearQueryStatement

	return p
}

func (s *FocusedLinearQueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FocusedLinearQueryStatementContext) FocusedLinearQueryAndPrimitiveResultStatementPart() IFocusedLinearQueryAndPrimitiveResultStatementPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFocusedLinearQueryAndPrimitiveResultStatementPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFocusedLinearQueryAndPrimitiveResultStatementPartContext)
}

func (s *FocusedLinearQueryStatementContext) AllFocusedLinearQueryStatementPart() []IFocusedLinearQueryStatementPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFocusedLinearQueryStatementPartContext); ok {
			len++
		}
	}

	tst := make([]IFocusedLinearQueryStatementPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFocusedLinearQueryStatementPartContext); ok {
			tst[i] = t.(IFocusedLinearQueryStatementPartContext)
			i++
		}
	}

	return tst
}

func (s *FocusedLinearQueryStatementContext) FocusedLinearQueryStatementPart(i int) IFocusedLinearQueryStatementPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFocusedLinearQueryStatementPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFocusedLinearQueryStatementPartContext)
}

func (s *FocusedLinearQueryStatementContext) FocusedPrimitiveResultStatement() IFocusedPrimitiveResultStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFocusedPrimitiveResultStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFocusedPrimitiveResultStatementContext)
}

func (s *FocusedLinearQueryStatementContext) FocusedNestedQuerySpecification() IFocusedNestedQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFocusedNestedQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFocusedNestedQuerySpecificationContext)
}

func (s *FocusedLinearQueryStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *FocusedLinearQueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FocusedLinearQueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FocusedLinearQueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFocusedLinearQueryStatement(s)
	}
}

func (s *FocusedLinearQueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFocusedLinearQueryStatement(s)
	}
}

func (p *GQLParser) FocusedLinearQueryStatement() (localctx IFocusedLinearQueryStatementContext) {
	localctx = NewFocusedLinearQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, GQLParserRULE_focusedLinearQueryStatement)
	var _alt int

	p.SetState(1784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1777)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1774)
					p.FocusedLinearQueryStatementPart()
				}

			}
			p.SetState(1779)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(1780)
			p.FocusedLinearQueryAndPrimitiveResultStatementPart()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1781)
			p.FocusedPrimitiveResultStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1782)
			p.FocusedNestedQuerySpecification()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1783)
			p.SelectStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFocusedLinearQueryStatementPartContext is an interface to support dynamic dispatch.
type IFocusedLinearQueryStatementPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UseGraphClause() IUseGraphClauseContext
	SimpleLinearQueryStatement() ISimpleLinearQueryStatementContext

	// IsFocusedLinearQueryStatementPartContext differentiates from other interfaces.
	IsFocusedLinearQueryStatementPartContext()
}

type FocusedLinearQueryStatementPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFocusedLinearQueryStatementPartContext() *FocusedLinearQueryStatementPartContext {
	var p = new(FocusedLinearQueryStatementPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedLinearQueryStatementPart
	return p
}

func InitEmptyFocusedLinearQueryStatementPartContext(p *FocusedLinearQueryStatementPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedLinearQueryStatementPart
}

func (*FocusedLinearQueryStatementPartContext) IsFocusedLinearQueryStatementPartContext() {}

func NewFocusedLinearQueryStatementPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FocusedLinearQueryStatementPartContext {
	var p = new(FocusedLinearQueryStatementPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_focusedLinearQueryStatementPart

	return p
}

func (s *FocusedLinearQueryStatementPartContext) GetParser() antlr.Parser { return s.parser }

func (s *FocusedLinearQueryStatementPartContext) UseGraphClause() IUseGraphClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseGraphClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseGraphClauseContext)
}

func (s *FocusedLinearQueryStatementPartContext) SimpleLinearQueryStatement() ISimpleLinearQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLinearQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLinearQueryStatementContext)
}

func (s *FocusedLinearQueryStatementPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FocusedLinearQueryStatementPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FocusedLinearQueryStatementPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFocusedLinearQueryStatementPart(s)
	}
}

func (s *FocusedLinearQueryStatementPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFocusedLinearQueryStatementPart(s)
	}
}

func (p *GQLParser) FocusedLinearQueryStatementPart() (localctx IFocusedLinearQueryStatementPartContext) {
	localctx = NewFocusedLinearQueryStatementPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, GQLParserRULE_focusedLinearQueryStatementPart)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1786)
		p.UseGraphClause()
	}
	{
		p.SetState(1787)
		p.SimpleLinearQueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFocusedLinearQueryAndPrimitiveResultStatementPartContext is an interface to support dynamic dispatch.
type IFocusedLinearQueryAndPrimitiveResultStatementPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UseGraphClause() IUseGraphClauseContext
	SimpleLinearQueryStatement() ISimpleLinearQueryStatementContext
	PrimitiveResultStatement() IPrimitiveResultStatementContext

	// IsFocusedLinearQueryAndPrimitiveResultStatementPartContext differentiates from other interfaces.
	IsFocusedLinearQueryAndPrimitiveResultStatementPartContext()
}

type FocusedLinearQueryAndPrimitiveResultStatementPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFocusedLinearQueryAndPrimitiveResultStatementPartContext() *FocusedLinearQueryAndPrimitiveResultStatementPartContext {
	var p = new(FocusedLinearQueryAndPrimitiveResultStatementPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedLinearQueryAndPrimitiveResultStatementPart
	return p
}

func InitEmptyFocusedLinearQueryAndPrimitiveResultStatementPartContext(p *FocusedLinearQueryAndPrimitiveResultStatementPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedLinearQueryAndPrimitiveResultStatementPart
}

func (*FocusedLinearQueryAndPrimitiveResultStatementPartContext) IsFocusedLinearQueryAndPrimitiveResultStatementPartContext() {
}

func NewFocusedLinearQueryAndPrimitiveResultStatementPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FocusedLinearQueryAndPrimitiveResultStatementPartContext {
	var p = new(FocusedLinearQueryAndPrimitiveResultStatementPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_focusedLinearQueryAndPrimitiveResultStatementPart

	return p
}

func (s *FocusedLinearQueryAndPrimitiveResultStatementPartContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *FocusedLinearQueryAndPrimitiveResultStatementPartContext) UseGraphClause() IUseGraphClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseGraphClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseGraphClauseContext)
}

func (s *FocusedLinearQueryAndPrimitiveResultStatementPartContext) SimpleLinearQueryStatement() ISimpleLinearQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLinearQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLinearQueryStatementContext)
}

func (s *FocusedLinearQueryAndPrimitiveResultStatementPartContext) PrimitiveResultStatement() IPrimitiveResultStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveResultStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveResultStatementContext)
}

func (s *FocusedLinearQueryAndPrimitiveResultStatementPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FocusedLinearQueryAndPrimitiveResultStatementPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FocusedLinearQueryAndPrimitiveResultStatementPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFocusedLinearQueryAndPrimitiveResultStatementPart(s)
	}
}

func (s *FocusedLinearQueryAndPrimitiveResultStatementPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFocusedLinearQueryAndPrimitiveResultStatementPart(s)
	}
}

func (p *GQLParser) FocusedLinearQueryAndPrimitiveResultStatementPart() (localctx IFocusedLinearQueryAndPrimitiveResultStatementPartContext) {
	localctx = NewFocusedLinearQueryAndPrimitiveResultStatementPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, GQLParserRULE_focusedLinearQueryAndPrimitiveResultStatementPart)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1789)
		p.UseGraphClause()
	}
	{
		p.SetState(1790)
		p.SimpleLinearQueryStatement()
	}
	{
		p.SetState(1791)
		p.PrimitiveResultStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFocusedPrimitiveResultStatementContext is an interface to support dynamic dispatch.
type IFocusedPrimitiveResultStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UseGraphClause() IUseGraphClauseContext
	PrimitiveResultStatement() IPrimitiveResultStatementContext

	// IsFocusedPrimitiveResultStatementContext differentiates from other interfaces.
	IsFocusedPrimitiveResultStatementContext()
}

type FocusedPrimitiveResultStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFocusedPrimitiveResultStatementContext() *FocusedPrimitiveResultStatementContext {
	var p = new(FocusedPrimitiveResultStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedPrimitiveResultStatement
	return p
}

func InitEmptyFocusedPrimitiveResultStatementContext(p *FocusedPrimitiveResultStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedPrimitiveResultStatement
}

func (*FocusedPrimitiveResultStatementContext) IsFocusedPrimitiveResultStatementContext() {}

func NewFocusedPrimitiveResultStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FocusedPrimitiveResultStatementContext {
	var p = new(FocusedPrimitiveResultStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_focusedPrimitiveResultStatement

	return p
}

func (s *FocusedPrimitiveResultStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FocusedPrimitiveResultStatementContext) UseGraphClause() IUseGraphClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseGraphClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseGraphClauseContext)
}

func (s *FocusedPrimitiveResultStatementContext) PrimitiveResultStatement() IPrimitiveResultStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveResultStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveResultStatementContext)
}

func (s *FocusedPrimitiveResultStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FocusedPrimitiveResultStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FocusedPrimitiveResultStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFocusedPrimitiveResultStatement(s)
	}
}

func (s *FocusedPrimitiveResultStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFocusedPrimitiveResultStatement(s)
	}
}

func (p *GQLParser) FocusedPrimitiveResultStatement() (localctx IFocusedPrimitiveResultStatementContext) {
	localctx = NewFocusedPrimitiveResultStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, GQLParserRULE_focusedPrimitiveResultStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1793)
		p.UseGraphClause()
	}
	{
		p.SetState(1794)
		p.PrimitiveResultStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFocusedNestedQuerySpecificationContext is an interface to support dynamic dispatch.
type IFocusedNestedQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UseGraphClause() IUseGraphClauseContext
	NestedQuerySpecification() INestedQuerySpecificationContext

	// IsFocusedNestedQuerySpecificationContext differentiates from other interfaces.
	IsFocusedNestedQuerySpecificationContext()
}

type FocusedNestedQuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFocusedNestedQuerySpecificationContext() *FocusedNestedQuerySpecificationContext {
	var p = new(FocusedNestedQuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedNestedQuerySpecification
	return p
}

func InitEmptyFocusedNestedQuerySpecificationContext(p *FocusedNestedQuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_focusedNestedQuerySpecification
}

func (*FocusedNestedQuerySpecificationContext) IsFocusedNestedQuerySpecificationContext() {}

func NewFocusedNestedQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FocusedNestedQuerySpecificationContext {
	var p = new(FocusedNestedQuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_focusedNestedQuerySpecification

	return p
}

func (s *FocusedNestedQuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *FocusedNestedQuerySpecificationContext) UseGraphClause() IUseGraphClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseGraphClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseGraphClauseContext)
}

func (s *FocusedNestedQuerySpecificationContext) NestedQuerySpecification() INestedQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedQuerySpecificationContext)
}

func (s *FocusedNestedQuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FocusedNestedQuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FocusedNestedQuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFocusedNestedQuerySpecification(s)
	}
}

func (s *FocusedNestedQuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFocusedNestedQuerySpecification(s)
	}
}

func (p *GQLParser) FocusedNestedQuerySpecification() (localctx IFocusedNestedQuerySpecificationContext) {
	localctx = NewFocusedNestedQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, GQLParserRULE_focusedNestedQuerySpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1796)
		p.UseGraphClause()
	}
	{
		p.SetState(1797)
		p.NestedQuerySpecification()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAmbientLinearQueryStatementContext is an interface to support dynamic dispatch.
type IAmbientLinearQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimitiveResultStatement() IPrimitiveResultStatementContext
	SimpleLinearQueryStatement() ISimpleLinearQueryStatementContext
	NestedQuerySpecification() INestedQuerySpecificationContext

	// IsAmbientLinearQueryStatementContext differentiates from other interfaces.
	IsAmbientLinearQueryStatementContext()
}

type AmbientLinearQueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAmbientLinearQueryStatementContext() *AmbientLinearQueryStatementContext {
	var p = new(AmbientLinearQueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_ambientLinearQueryStatement
	return p
}

func InitEmptyAmbientLinearQueryStatementContext(p *AmbientLinearQueryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_ambientLinearQueryStatement
}

func (*AmbientLinearQueryStatementContext) IsAmbientLinearQueryStatementContext() {}

func NewAmbientLinearQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AmbientLinearQueryStatementContext {
	var p = new(AmbientLinearQueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_ambientLinearQueryStatement

	return p
}

func (s *AmbientLinearQueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AmbientLinearQueryStatementContext) PrimitiveResultStatement() IPrimitiveResultStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveResultStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveResultStatementContext)
}

func (s *AmbientLinearQueryStatementContext) SimpleLinearQueryStatement() ISimpleLinearQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLinearQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLinearQueryStatementContext)
}

func (s *AmbientLinearQueryStatementContext) NestedQuerySpecification() INestedQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedQuerySpecificationContext)
}

func (s *AmbientLinearQueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AmbientLinearQueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AmbientLinearQueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAmbientLinearQueryStatement(s)
	}
}

func (s *AmbientLinearQueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAmbientLinearQueryStatement(s)
	}
}

func (p *GQLParser) AmbientLinearQueryStatement() (localctx IAmbientLinearQueryStatementContext) {
	localctx = NewAmbientLinearQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, GQLParserRULE_ambientLinearQueryStatement)
	var _la int

	p.SetState(1804)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserCALL, GQLParserFILTER, GQLParserFINISH, GQLParserFOR, GQLParserLET, GQLParserLIMIT, GQLParserMATCH, GQLParserOFFSET, GQLParserOPTIONAL, GQLParserORDER, GQLParserRETURN, GQLParserSKIP_RESERVED_WORD:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1800)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserCALL || ((int64((_la-94)) & ^0x3f) == 0 && ((int64(1)<<(_la-94))&4506348406440449) != 0) || ((int64((_la-162)) & ^0x3f) == 0 && ((int64(1)<<(_la-162))&68719476747) != 0) {
			{
				p.SetState(1799)
				p.SimpleLinearQueryStatement()
			}

		}
		{
			p.SetState(1802)
			p.PrimitiveResultStatement()
		}

	case GQLParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1803)
			p.NestedQuerySpecification()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleLinearQueryStatementContext is an interface to support dynamic dispatch.
type ISimpleLinearQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleQueryStatement() []ISimpleQueryStatementContext
	SimpleQueryStatement(i int) ISimpleQueryStatementContext

	// IsSimpleLinearQueryStatementContext differentiates from other interfaces.
	IsSimpleLinearQueryStatementContext()
}

type SimpleLinearQueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleLinearQueryStatementContext() *SimpleLinearQueryStatementContext {
	var p = new(SimpleLinearQueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleLinearQueryStatement
	return p
}

func InitEmptySimpleLinearQueryStatementContext(p *SimpleLinearQueryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleLinearQueryStatement
}

func (*SimpleLinearQueryStatementContext) IsSimpleLinearQueryStatementContext() {}

func NewSimpleLinearQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleLinearQueryStatementContext {
	var p = new(SimpleLinearQueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simpleLinearQueryStatement

	return p
}

func (s *SimpleLinearQueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleLinearQueryStatementContext) AllSimpleQueryStatement() []ISimpleQueryStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleQueryStatementContext); ok {
			len++
		}
	}

	tst := make([]ISimpleQueryStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleQueryStatementContext); ok {
			tst[i] = t.(ISimpleQueryStatementContext)
			i++
		}
	}

	return tst
}

func (s *SimpleLinearQueryStatementContext) SimpleQueryStatement(i int) ISimpleQueryStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleQueryStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleQueryStatementContext)
}

func (s *SimpleLinearQueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleLinearQueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleLinearQueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimpleLinearQueryStatement(s)
	}
}

func (s *SimpleLinearQueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimpleLinearQueryStatement(s)
	}
}

func (p *GQLParser) SimpleLinearQueryStatement() (localctx ISimpleLinearQueryStatementContext) {
	localctx = NewSimpleLinearQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, GQLParserRULE_simpleLinearQueryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == GQLParserCALL || ((int64((_la-94)) & ^0x3f) == 0 && ((int64(1)<<(_la-94))&4506348406440449) != 0) || ((int64((_la-162)) & ^0x3f) == 0 && ((int64(1)<<(_la-162))&68719476747) != 0) {
		{
			p.SetState(1806)
			p.SimpleQueryStatement()
		}

		p.SetState(1809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleQueryStatementContext is an interface to support dynamic dispatch.
type ISimpleQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimitiveQueryStatement() IPrimitiveQueryStatementContext
	CallQueryStatement() ICallQueryStatementContext

	// IsSimpleQueryStatementContext differentiates from other interfaces.
	IsSimpleQueryStatementContext()
}

type SimpleQueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleQueryStatementContext() *SimpleQueryStatementContext {
	var p = new(SimpleQueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleQueryStatement
	return p
}

func InitEmptySimpleQueryStatementContext(p *SimpleQueryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleQueryStatement
}

func (*SimpleQueryStatementContext) IsSimpleQueryStatementContext() {}

func NewSimpleQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleQueryStatementContext {
	var p = new(SimpleQueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simpleQueryStatement

	return p
}

func (s *SimpleQueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleQueryStatementContext) PrimitiveQueryStatement() IPrimitiveQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveQueryStatementContext)
}

func (s *SimpleQueryStatementContext) CallQueryStatement() ICallQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallQueryStatementContext)
}

func (s *SimpleQueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleQueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleQueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimpleQueryStatement(s)
	}
}

func (s *SimpleQueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimpleQueryStatement(s)
	}
}

func (p *GQLParser) SimpleQueryStatement() (localctx ISimpleQueryStatementContext) {
	localctx = NewSimpleQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, GQLParserRULE_simpleQueryStatement)
	p.SetState(1813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1811)
			p.PrimitiveQueryStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1812)
			p.CallQueryStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveQueryStatementContext is an interface to support dynamic dispatch.
type IPrimitiveQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MatchStatement() IMatchStatementContext
	LetStatement() ILetStatementContext
	ForStatement() IForStatementContext
	FilterStatement() IFilterStatementContext
	OrderByAndPageStatement() IOrderByAndPageStatementContext

	// IsPrimitiveQueryStatementContext differentiates from other interfaces.
	IsPrimitiveQueryStatementContext()
}

type PrimitiveQueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveQueryStatementContext() *PrimitiveQueryStatementContext {
	var p = new(PrimitiveQueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_primitiveQueryStatement
	return p
}

func InitEmptyPrimitiveQueryStatementContext(p *PrimitiveQueryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_primitiveQueryStatement
}

func (*PrimitiveQueryStatementContext) IsPrimitiveQueryStatementContext() {}

func NewPrimitiveQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveQueryStatementContext {
	var p = new(PrimitiveQueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_primitiveQueryStatement

	return p
}

func (s *PrimitiveQueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveQueryStatementContext) MatchStatement() IMatchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchStatementContext)
}

func (s *PrimitiveQueryStatementContext) LetStatement() ILetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetStatementContext)
}

func (s *PrimitiveQueryStatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *PrimitiveQueryStatementContext) FilterStatement() IFilterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterStatementContext)
}

func (s *PrimitiveQueryStatementContext) OrderByAndPageStatement() IOrderByAndPageStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByAndPageStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByAndPageStatementContext)
}

func (s *PrimitiveQueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveQueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveQueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPrimitiveQueryStatement(s)
	}
}

func (s *PrimitiveQueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPrimitiveQueryStatement(s)
	}
}

func (p *GQLParser) PrimitiveQueryStatement() (localctx IPrimitiveQueryStatementContext) {
	localctx = NewPrimitiveQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, GQLParserRULE_primitiveQueryStatement)
	p.SetState(1820)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserMATCH, GQLParserOPTIONAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1815)
			p.MatchStatement()
		}

	case GQLParserLET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1816)
			p.LetStatement()
		}

	case GQLParserFOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1817)
			p.ForStatement()
		}

	case GQLParserFILTER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1818)
			p.FilterStatement()
		}

	case GQLParserLIMIT, GQLParserOFFSET, GQLParserORDER, GQLParserSKIP_RESERVED_WORD:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1819)
			p.OrderByAndPageStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchStatementContext is an interface to support dynamic dispatch.
type IMatchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleMatchStatement() ISimpleMatchStatementContext
	OptionalMatchStatement() IOptionalMatchStatementContext

	// IsMatchStatementContext differentiates from other interfaces.
	IsMatchStatementContext()
}

type MatchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchStatementContext() *MatchStatementContext {
	var p = new(MatchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_matchStatement
	return p
}

func InitEmptyMatchStatementContext(p *MatchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_matchStatement
}

func (*MatchStatementContext) IsMatchStatementContext() {}

func NewMatchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchStatementContext {
	var p = new(MatchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_matchStatement

	return p
}

func (s *MatchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchStatementContext) SimpleMatchStatement() ISimpleMatchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleMatchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleMatchStatementContext)
}

func (s *MatchStatementContext) OptionalMatchStatement() IOptionalMatchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionalMatchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionalMatchStatementContext)
}

func (s *MatchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterMatchStatement(s)
	}
}

func (s *MatchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitMatchStatement(s)
	}
}

func (p *GQLParser) MatchStatement() (localctx IMatchStatementContext) {
	localctx = NewMatchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, GQLParserRULE_matchStatement)
	p.SetState(1824)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserMATCH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1822)
			p.SimpleMatchStatement()
		}

	case GQLParserOPTIONAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1823)
			p.OptionalMatchStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleMatchStatementContext is an interface to support dynamic dispatch.
type ISimpleMatchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MATCH() antlr.TerminalNode
	GraphPatternBindingTable() IGraphPatternBindingTableContext

	// IsSimpleMatchStatementContext differentiates from other interfaces.
	IsSimpleMatchStatementContext()
}

type SimpleMatchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleMatchStatementContext() *SimpleMatchStatementContext {
	var p = new(SimpleMatchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleMatchStatement
	return p
}

func InitEmptySimpleMatchStatementContext(p *SimpleMatchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleMatchStatement
}

func (*SimpleMatchStatementContext) IsSimpleMatchStatementContext() {}

func NewSimpleMatchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleMatchStatementContext {
	var p = new(SimpleMatchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simpleMatchStatement

	return p
}

func (s *SimpleMatchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleMatchStatementContext) MATCH() antlr.TerminalNode {
	return s.GetToken(GQLParserMATCH, 0)
}

func (s *SimpleMatchStatementContext) GraphPatternBindingTable() IGraphPatternBindingTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphPatternBindingTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphPatternBindingTableContext)
}

func (s *SimpleMatchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleMatchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleMatchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimpleMatchStatement(s)
	}
}

func (s *SimpleMatchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimpleMatchStatement(s)
	}
}

func (p *GQLParser) SimpleMatchStatement() (localctx ISimpleMatchStatementContext) {
	localctx = NewSimpleMatchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, GQLParserRULE_simpleMatchStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1826)
		p.Match(GQLParserMATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1827)
		p.GraphPatternBindingTable()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionalMatchStatementContext is an interface to support dynamic dispatch.
type IOptionalMatchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPTIONAL() antlr.TerminalNode
	OptionalOperand() IOptionalOperandContext

	// IsOptionalMatchStatementContext differentiates from other interfaces.
	IsOptionalMatchStatementContext()
}

type OptionalMatchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalMatchStatementContext() *OptionalMatchStatementContext {
	var p = new(OptionalMatchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_optionalMatchStatement
	return p
}

func InitEmptyOptionalMatchStatementContext(p *OptionalMatchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_optionalMatchStatement
}

func (*OptionalMatchStatementContext) IsOptionalMatchStatementContext() {}

func NewOptionalMatchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalMatchStatementContext {
	var p = new(OptionalMatchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_optionalMatchStatement

	return p
}

func (s *OptionalMatchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalMatchStatementContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(GQLParserOPTIONAL, 0)
}

func (s *OptionalMatchStatementContext) OptionalOperand() IOptionalOperandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionalOperandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionalOperandContext)
}

func (s *OptionalMatchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalMatchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalMatchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOptionalMatchStatement(s)
	}
}

func (s *OptionalMatchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOptionalMatchStatement(s)
	}
}

func (p *GQLParser) OptionalMatchStatement() (localctx IOptionalMatchStatementContext) {
	localctx = NewOptionalMatchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, GQLParserRULE_optionalMatchStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1829)
		p.Match(GQLParserOPTIONAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1830)
		p.OptionalOperand()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionalOperandContext is an interface to support dynamic dispatch.
type IOptionalOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleMatchStatement() ISimpleMatchStatementContext
	LEFT_BRACE() antlr.TerminalNode
	MatchStatementBlock() IMatchStatementBlockContext
	RIGHT_BRACE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsOptionalOperandContext differentiates from other interfaces.
	IsOptionalOperandContext()
}

type OptionalOperandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalOperandContext() *OptionalOperandContext {
	var p = new(OptionalOperandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_optionalOperand
	return p
}

func InitEmptyOptionalOperandContext(p *OptionalOperandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_optionalOperand
}

func (*OptionalOperandContext) IsOptionalOperandContext() {}

func NewOptionalOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalOperandContext {
	var p = new(OptionalOperandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_optionalOperand

	return p
}

func (s *OptionalOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalOperandContext) SimpleMatchStatement() ISimpleMatchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleMatchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleMatchStatementContext)
}

func (s *OptionalOperandContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACE, 0)
}

func (s *OptionalOperandContext) MatchStatementBlock() IMatchStatementBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchStatementBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchStatementBlockContext)
}

func (s *OptionalOperandContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACE, 0)
}

func (s *OptionalOperandContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *OptionalOperandContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *OptionalOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOptionalOperand(s)
	}
}

func (s *OptionalOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOptionalOperand(s)
	}
}

func (p *GQLParser) OptionalOperand() (localctx IOptionalOperandContext) {
	localctx = NewOptionalOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, GQLParserRULE_optionalOperand)
	p.SetState(1841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserMATCH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1832)
			p.SimpleMatchStatement()
		}

	case GQLParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1833)
			p.Match(GQLParserLEFT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1834)
			p.MatchStatementBlock()
		}
		{
			p.SetState(1835)
			p.Match(GQLParserRIGHT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1837)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1838)
			p.MatchStatementBlock()
		}
		{
			p.SetState(1839)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchStatementBlockContext is an interface to support dynamic dispatch.
type IMatchStatementBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMatchStatement() []IMatchStatementContext
	MatchStatement(i int) IMatchStatementContext

	// IsMatchStatementBlockContext differentiates from other interfaces.
	IsMatchStatementBlockContext()
}

type MatchStatementBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchStatementBlockContext() *MatchStatementBlockContext {
	var p = new(MatchStatementBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_matchStatementBlock
	return p
}

func InitEmptyMatchStatementBlockContext(p *MatchStatementBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_matchStatementBlock
}

func (*MatchStatementBlockContext) IsMatchStatementBlockContext() {}

func NewMatchStatementBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchStatementBlockContext {
	var p = new(MatchStatementBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_matchStatementBlock

	return p
}

func (s *MatchStatementBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchStatementBlockContext) AllMatchStatement() []IMatchStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMatchStatementContext); ok {
			len++
		}
	}

	tst := make([]IMatchStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMatchStatementContext); ok {
			tst[i] = t.(IMatchStatementContext)
			i++
		}
	}

	return tst
}

func (s *MatchStatementBlockContext) MatchStatement(i int) IMatchStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchStatementContext)
}

func (s *MatchStatementBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchStatementBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchStatementBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterMatchStatementBlock(s)
	}
}

func (s *MatchStatementBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitMatchStatementBlock(s)
	}
}

func (p *GQLParser) MatchStatementBlock() (localctx IMatchStatementBlockContext) {
	localctx = NewMatchStatementBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, GQLParserRULE_matchStatementBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1844)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == GQLParserMATCH || _la == GQLParserOPTIONAL {
		{
			p.SetState(1843)
			p.MatchStatement()
		}

		p.SetState(1846)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallQueryStatementContext is an interface to support dynamic dispatch.
type ICallQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CallProcedureStatement() ICallProcedureStatementContext

	// IsCallQueryStatementContext differentiates from other interfaces.
	IsCallQueryStatementContext()
}

type CallQueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallQueryStatementContext() *CallQueryStatementContext {
	var p = new(CallQueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_callQueryStatement
	return p
}

func InitEmptyCallQueryStatementContext(p *CallQueryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_callQueryStatement
}

func (*CallQueryStatementContext) IsCallQueryStatementContext() {}

func NewCallQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallQueryStatementContext {
	var p = new(CallQueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_callQueryStatement

	return p
}

func (s *CallQueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CallQueryStatementContext) CallProcedureStatement() ICallProcedureStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallProcedureStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallProcedureStatementContext)
}

func (s *CallQueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallQueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallQueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCallQueryStatement(s)
	}
}

func (s *CallQueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCallQueryStatement(s)
	}
}

func (p *GQLParser) CallQueryStatement() (localctx ICallQueryStatementContext) {
	localctx = NewCallQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, GQLParserRULE_callQueryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1848)
		p.CallProcedureStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterStatementContext is an interface to support dynamic dispatch.
type IFilterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILTER() antlr.TerminalNode
	WhereClause() IWhereClauseContext
	SearchCondition() ISearchConditionContext

	// IsFilterStatementContext differentiates from other interfaces.
	IsFilterStatementContext()
}

type FilterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterStatementContext() *FilterStatementContext {
	var p = new(FilterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_filterStatement
	return p
}

func InitEmptyFilterStatementContext(p *FilterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_filterStatement
}

func (*FilterStatementContext) IsFilterStatementContext() {}

func NewFilterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterStatementContext {
	var p = new(FilterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_filterStatement

	return p
}

func (s *FilterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterStatementContext) FILTER() antlr.TerminalNode {
	return s.GetToken(GQLParserFILTER, 0)
}

func (s *FilterStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *FilterStatementContext) SearchCondition() ISearchConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchConditionContext)
}

func (s *FilterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFilterStatement(s)
	}
}

func (s *FilterStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFilterStatement(s)
	}
}

func (p *GQLParser) FilterStatement() (localctx IFilterStatementContext) {
	localctx = NewFilterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, GQLParserRULE_filterStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1850)
		p.Match(GQLParserFILTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1853)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserWHERE:
		{
			p.SetState(1851)
			p.WhereClause()
		}

	case GQLParserBOOLEAN_LITERAL, GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE, GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, GQLParserBYTE_STRING_LITERAL, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER, GQLParserUNSIGNED_HEXADECIMAL_INTEGER, GQLParserUNSIGNED_OCTAL_INTEGER, GQLParserUNSIGNED_BINARY_INTEGER, GQLParserABS, GQLParserACOS, GQLParserALL_DIFFERENT, GQLParserARRAY, GQLParserASIN, GQLParserATAN, GQLParserAVG, GQLParserBTRIM, GQLParserBYTE_LENGTH, GQLParserCARDINALITY, GQLParserCASE, GQLParserCAST, GQLParserCEIL, GQLParserCEILING, GQLParserCHAR_LENGTH, GQLParserCHARACTER_LENGTH, GQLParserCOALESCE, GQLParserCOLLECT_LIST, GQLParserCOS, GQLParserCOSH, GQLParserCOT, GQLParserCOUNT, GQLParserCURRENT_DATE, GQLParserCURRENT_TIME, GQLParserCURRENT_TIMESTAMP, GQLParserDATE, GQLParserDATETIME, GQLParserDEGREES, GQLParserDURATION, GQLParserDURATION_BETWEEN, GQLParserELEMENT_ID, GQLParserEXISTS, GQLParserEXP, GQLParserFLOOR, GQLParserLEFT, GQLParserLET, GQLParserLIST, GQLParserLN, GQLParserLOCAL_DATETIME, GQLParserLOCAL_TIME, GQLParserLOCAL_TIMESTAMP, GQLParserLOG_KW, GQLParserLOG10, GQLParserLOWER, GQLParserLTRIM, GQLParserMAX, GQLParserMIN, GQLParserMOD, GQLParserNORMALIZE, GQLParserNOT, GQLParserNULL_KW, GQLParserNULLIF, GQLParserOCTET_LENGTH, GQLParserPATH, GQLParserPATH_LENGTH, GQLParserPERCENTILE_CONT, GQLParserPERCENTILE_DISC, GQLParserPOWER, GQLParserPROPERTY_EXISTS, GQLParserRADIANS, GQLParserRECORD, GQLParserRIGHT, GQLParserRTRIM, GQLParserSAME, GQLParserSESSION_USER, GQLParserSIN, GQLParserSINH, GQLParserSIZE, GQLParserSQRT, GQLParserSTDDEV_POP, GQLParserSTDDEV_SAMP, GQLParserSUM, GQLParserTAN, GQLParserTANH, GQLParserTIME, GQLParserTIMESTAMP, GQLParserTRIM, GQLParserUPPER, GQLParserVALUE, GQLParserZONED_DATETIME, GQLParserZONED_TIME, GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE, GQLParserREGULAR_IDENTIFIER, GQLParserGENERAL_PARAMETER_REFERENCE, GQLParserLEFT_BRACE, GQLParserLEFT_BRACKET, GQLParserLEFT_PAREN, GQLParserMINUS_SIGN, GQLParserPLUS_SIGN:
		{
			p.SetState(1852)
			p.SearchCondition()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetStatementContext is an interface to support dynamic dispatch.
type ILetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LET() antlr.TerminalNode
	LetVariableDefinitionList() ILetVariableDefinitionListContext

	// IsLetStatementContext differentiates from other interfaces.
	IsLetStatementContext()
}

type LetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetStatementContext() *LetStatementContext {
	var p = new(LetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_letStatement
	return p
}

func InitEmptyLetStatementContext(p *LetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_letStatement
}

func (*LetStatementContext) IsLetStatementContext() {}

func NewLetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetStatementContext {
	var p = new(LetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_letStatement

	return p
}

func (s *LetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LetStatementContext) LET() antlr.TerminalNode {
	return s.GetToken(GQLParserLET, 0)
}

func (s *LetStatementContext) LetVariableDefinitionList() ILetVariableDefinitionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetVariableDefinitionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetVariableDefinitionListContext)
}

func (s *LetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLetStatement(s)
	}
}

func (s *LetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLetStatement(s)
	}
}

func (p *GQLParser) LetStatement() (localctx ILetStatementContext) {
	localctx = NewLetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, GQLParserRULE_letStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1855)
		p.Match(GQLParserLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1856)
		p.LetVariableDefinitionList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetVariableDefinitionListContext is an interface to support dynamic dispatch.
type ILetVariableDefinitionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLetVariableDefinition() []ILetVariableDefinitionContext
	LetVariableDefinition(i int) ILetVariableDefinitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLetVariableDefinitionListContext differentiates from other interfaces.
	IsLetVariableDefinitionListContext()
}

type LetVariableDefinitionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetVariableDefinitionListContext() *LetVariableDefinitionListContext {
	var p = new(LetVariableDefinitionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_letVariableDefinitionList
	return p
}

func InitEmptyLetVariableDefinitionListContext(p *LetVariableDefinitionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_letVariableDefinitionList
}

func (*LetVariableDefinitionListContext) IsLetVariableDefinitionListContext() {}

func NewLetVariableDefinitionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetVariableDefinitionListContext {
	var p = new(LetVariableDefinitionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_letVariableDefinitionList

	return p
}

func (s *LetVariableDefinitionListContext) GetParser() antlr.Parser { return s.parser }

func (s *LetVariableDefinitionListContext) AllLetVariableDefinition() []ILetVariableDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetVariableDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ILetVariableDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetVariableDefinitionContext); ok {
			tst[i] = t.(ILetVariableDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *LetVariableDefinitionListContext) LetVariableDefinition(i int) ILetVariableDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetVariableDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetVariableDefinitionContext)
}

func (s *LetVariableDefinitionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *LetVariableDefinitionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *LetVariableDefinitionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetVariableDefinitionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetVariableDefinitionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLetVariableDefinitionList(s)
	}
}

func (s *LetVariableDefinitionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLetVariableDefinitionList(s)
	}
}

func (p *GQLParser) LetVariableDefinitionList() (localctx ILetVariableDefinitionListContext) {
	localctx = NewLetVariableDefinitionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, GQLParserRULE_letVariableDefinitionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1858)
		p.LetVariableDefinition()
	}
	p.SetState(1863)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(1859)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1860)
			p.LetVariableDefinition()
		}

		p.SetState(1865)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetVariableDefinitionContext is an interface to support dynamic dispatch.
type ILetVariableDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueVariableDefinition() IValueVariableDefinitionContext
	BindingVariable() IBindingVariableContext
	EQUALS_OPERATOR() antlr.TerminalNode
	ValueExpression() IValueExpressionContext

	// IsLetVariableDefinitionContext differentiates from other interfaces.
	IsLetVariableDefinitionContext()
}

type LetVariableDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetVariableDefinitionContext() *LetVariableDefinitionContext {
	var p = new(LetVariableDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_letVariableDefinition
	return p
}

func InitEmptyLetVariableDefinitionContext(p *LetVariableDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_letVariableDefinition
}

func (*LetVariableDefinitionContext) IsLetVariableDefinitionContext() {}

func NewLetVariableDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetVariableDefinitionContext {
	var p = new(LetVariableDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_letVariableDefinition

	return p
}

func (s *LetVariableDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *LetVariableDefinitionContext) ValueVariableDefinition() IValueVariableDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueVariableDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueVariableDefinitionContext)
}

func (s *LetVariableDefinitionContext) BindingVariable() IBindingVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableContext)
}

func (s *LetVariableDefinitionContext) EQUALS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(GQLParserEQUALS_OPERATOR, 0)
}

func (s *LetVariableDefinitionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LetVariableDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetVariableDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetVariableDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLetVariableDefinition(s)
	}
}

func (s *LetVariableDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLetVariableDefinition(s)
	}
}

func (p *GQLParser) LetVariableDefinition() (localctx ILetVariableDefinitionContext) {
	localctx = NewLetVariableDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, GQLParserRULE_letVariableDefinition)
	p.SetState(1871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserVALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1866)
			p.ValueVariableDefinition()
		}

	case GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE, GQLParserREGULAR_IDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1867)
			p.BindingVariable()
		}
		{
			p.SetState(1868)
			p.Match(GQLParserEQUALS_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1869)
			p.valueExpression(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	ForItem() IForItemContext
	ForOrdinalityOrOffset() IForOrdinalityOrOffsetContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(GQLParserFOR, 0)
}

func (s *ForStatementContext) ForItem() IForItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForItemContext)
}

func (s *ForStatementContext) ForOrdinalityOrOffset() IForOrdinalityOrOffsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForOrdinalityOrOffsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForOrdinalityOrOffsetContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *GQLParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, GQLParserRULE_forStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1873)
		p.Match(GQLParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1874)
		p.ForItem()
	}
	p.SetState(1876)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserWITH {
		{
			p.SetState(1875)
			p.ForOrdinalityOrOffset()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForItemContext is an interface to support dynamic dispatch.
type IForItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForItemAlias() IForItemAliasContext
	ForItemSource() IForItemSourceContext

	// IsForItemContext differentiates from other interfaces.
	IsForItemContext()
}

type ForItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForItemContext() *ForItemContext {
	var p = new(ForItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_forItem
	return p
}

func InitEmptyForItemContext(p *ForItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_forItem
}

func (*ForItemContext) IsForItemContext() {}

func NewForItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForItemContext {
	var p = new(ForItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_forItem

	return p
}

func (s *ForItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ForItemContext) ForItemAlias() IForItemAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForItemAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForItemAliasContext)
}

func (s *ForItemContext) ForItemSource() IForItemSourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForItemSourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForItemSourceContext)
}

func (s *ForItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterForItem(s)
	}
}

func (s *ForItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitForItem(s)
	}
}

func (p *GQLParser) ForItem() (localctx IForItemContext) {
	localctx = NewForItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, GQLParserRULE_forItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1878)
		p.ForItemAlias()
	}
	{
		p.SetState(1879)
		p.ForItemSource()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForItemAliasContext is an interface to support dynamic dispatch.
type IForItemAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingVariable() IBindingVariableContext
	IN() antlr.TerminalNode

	// IsForItemAliasContext differentiates from other interfaces.
	IsForItemAliasContext()
}

type ForItemAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForItemAliasContext() *ForItemAliasContext {
	var p = new(ForItemAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_forItemAlias
	return p
}

func InitEmptyForItemAliasContext(p *ForItemAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_forItemAlias
}

func (*ForItemAliasContext) IsForItemAliasContext() {}

func NewForItemAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForItemAliasContext {
	var p = new(ForItemAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_forItemAlias

	return p
}

func (s *ForItemAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *ForItemAliasContext) BindingVariable() IBindingVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableContext)
}

func (s *ForItemAliasContext) IN() antlr.TerminalNode {
	return s.GetToken(GQLParserIN, 0)
}

func (s *ForItemAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForItemAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForItemAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterForItemAlias(s)
	}
}

func (s *ForItemAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitForItemAlias(s)
	}
}

func (p *GQLParser) ForItemAlias() (localctx IForItemAliasContext) {
	localctx = NewForItemAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, GQLParserRULE_forItemAlias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1881)
		p.BindingVariable()
	}
	{
		p.SetState(1882)
		p.Match(GQLParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForItemSourceContext is an interface to support dynamic dispatch.
type IForItemSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsForItemSourceContext differentiates from other interfaces.
	IsForItemSourceContext()
}

type ForItemSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForItemSourceContext() *ForItemSourceContext {
	var p = new(ForItemSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_forItemSource
	return p
}

func InitEmptyForItemSourceContext(p *ForItemSourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_forItemSource
}

func (*ForItemSourceContext) IsForItemSourceContext() {}

func NewForItemSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForItemSourceContext {
	var p = new(ForItemSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_forItemSource

	return p
}

func (s *ForItemSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *ForItemSourceContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ForItemSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForItemSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForItemSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterForItemSource(s)
	}
}

func (s *ForItemSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitForItemSource(s)
	}
}

func (p *GQLParser) ForItemSource() (localctx IForItemSourceContext) {
	localctx = NewForItemSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, GQLParserRULE_forItemSource)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1884)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForOrdinalityOrOffsetContext is an interface to support dynamic dispatch.
type IForOrdinalityOrOffsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	BindingVariable() IBindingVariableContext
	ORDINALITY() antlr.TerminalNode
	OFFSET() antlr.TerminalNode

	// IsForOrdinalityOrOffsetContext differentiates from other interfaces.
	IsForOrdinalityOrOffsetContext()
}

type ForOrdinalityOrOffsetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForOrdinalityOrOffsetContext() *ForOrdinalityOrOffsetContext {
	var p = new(ForOrdinalityOrOffsetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_forOrdinalityOrOffset
	return p
}

func InitEmptyForOrdinalityOrOffsetContext(p *ForOrdinalityOrOffsetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_forOrdinalityOrOffset
}

func (*ForOrdinalityOrOffsetContext) IsForOrdinalityOrOffsetContext() {}

func NewForOrdinalityOrOffsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForOrdinalityOrOffsetContext {
	var p = new(ForOrdinalityOrOffsetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_forOrdinalityOrOffset

	return p
}

func (s *ForOrdinalityOrOffsetContext) GetParser() antlr.Parser { return s.parser }

func (s *ForOrdinalityOrOffsetContext) WITH() antlr.TerminalNode {
	return s.GetToken(GQLParserWITH, 0)
}

func (s *ForOrdinalityOrOffsetContext) BindingVariable() IBindingVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableContext)
}

func (s *ForOrdinalityOrOffsetContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(GQLParserORDINALITY, 0)
}

func (s *ForOrdinalityOrOffsetContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(GQLParserOFFSET, 0)
}

func (s *ForOrdinalityOrOffsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForOrdinalityOrOffsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForOrdinalityOrOffsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterForOrdinalityOrOffset(s)
	}
}

func (s *ForOrdinalityOrOffsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitForOrdinalityOrOffset(s)
	}
}

func (p *GQLParser) ForOrdinalityOrOffset() (localctx IForOrdinalityOrOffsetContext) {
	localctx = NewForOrdinalityOrOffsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, GQLParserRULE_forOrdinalityOrOffset)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1886)
		p.Match(GQLParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1887)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserOFFSET || _la == GQLParserORDINALITY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1888)
		p.BindingVariable()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByAndPageStatementContext is an interface to support dynamic dispatch.
type IOrderByAndPageStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OrderByClause() IOrderByClauseContext
	OffsetClause() IOffsetClauseContext
	LimitClause() ILimitClauseContext

	// IsOrderByAndPageStatementContext differentiates from other interfaces.
	IsOrderByAndPageStatementContext()
}

type OrderByAndPageStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByAndPageStatementContext() *OrderByAndPageStatementContext {
	var p = new(OrderByAndPageStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_orderByAndPageStatement
	return p
}

func InitEmptyOrderByAndPageStatementContext(p *OrderByAndPageStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_orderByAndPageStatement
}

func (*OrderByAndPageStatementContext) IsOrderByAndPageStatementContext() {}

func NewOrderByAndPageStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByAndPageStatementContext {
	var p = new(OrderByAndPageStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_orderByAndPageStatement

	return p
}

func (s *OrderByAndPageStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByAndPageStatementContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *OrderByAndPageStatementContext) OffsetClause() IOffsetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOffsetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOffsetClauseContext)
}

func (s *OrderByAndPageStatementContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *OrderByAndPageStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByAndPageStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByAndPageStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOrderByAndPageStatement(s)
	}
}

func (s *OrderByAndPageStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOrderByAndPageStatement(s)
	}
}

func (p *GQLParser) OrderByAndPageStatement() (localctx IOrderByAndPageStatementContext) {
	localctx = NewOrderByAndPageStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, GQLParserRULE_orderByAndPageStatement)
	p.SetState(1902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserORDER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1890)
			p.OrderByClause()
		}
		p.SetState(1892)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1891)
				p.OffsetClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1895)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1894)
				p.LimitClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserOFFSET, GQLParserSKIP_RESERVED_WORD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1897)
			p.OffsetClause()
		}
		p.SetState(1899)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1898)
				p.LimitClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserLIMIT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1901)
			p.LimitClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveResultStatementContext is an interface to support dynamic dispatch.
type IPrimitiveResultStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReturnStatement() IReturnStatementContext
	OrderByAndPageStatement() IOrderByAndPageStatementContext
	FINISH() antlr.TerminalNode

	// IsPrimitiveResultStatementContext differentiates from other interfaces.
	IsPrimitiveResultStatementContext()
}

type PrimitiveResultStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveResultStatementContext() *PrimitiveResultStatementContext {
	var p = new(PrimitiveResultStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_primitiveResultStatement
	return p
}

func InitEmptyPrimitiveResultStatementContext(p *PrimitiveResultStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_primitiveResultStatement
}

func (*PrimitiveResultStatementContext) IsPrimitiveResultStatementContext() {}

func NewPrimitiveResultStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveResultStatementContext {
	var p = new(PrimitiveResultStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_primitiveResultStatement

	return p
}

func (s *PrimitiveResultStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveResultStatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *PrimitiveResultStatementContext) OrderByAndPageStatement() IOrderByAndPageStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByAndPageStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByAndPageStatementContext)
}

func (s *PrimitiveResultStatementContext) FINISH() antlr.TerminalNode {
	return s.GetToken(GQLParserFINISH, 0)
}

func (s *PrimitiveResultStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveResultStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveResultStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPrimitiveResultStatement(s)
	}
}

func (s *PrimitiveResultStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPrimitiveResultStatement(s)
	}
}

func (p *GQLParser) PrimitiveResultStatement() (localctx IPrimitiveResultStatementContext) {
	localctx = NewPrimitiveResultStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, GQLParserRULE_primitiveResultStatement)
	p.SetState(1909)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserRETURN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1904)
			p.ReturnStatement()
		}
		p.SetState(1906)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1905)
				p.OrderByAndPageStatement()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserFINISH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1908)
			p.Match(GQLParserFINISH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	ReturnStatementBody() IReturnStatementBodyContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(GQLParserRETURN, 0)
}

func (s *ReturnStatementContext) ReturnStatementBody() IReturnStatementBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementBodyContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *GQLParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, GQLParserRULE_returnStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1911)
		p.Match(GQLParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1912)
		p.ReturnStatementBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementBodyContext is an interface to support dynamic dispatch.
type IReturnStatementBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASTERISK() antlr.TerminalNode
	ReturnItemList() IReturnItemListContext
	SetQuantifier() ISetQuantifierContext
	GroupByClause() IGroupByClauseContext

	// IsReturnStatementBodyContext differentiates from other interfaces.
	IsReturnStatementBodyContext()
}

type ReturnStatementBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementBodyContext() *ReturnStatementBodyContext {
	var p = new(ReturnStatementBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_returnStatementBody
	return p
}

func InitEmptyReturnStatementBodyContext(p *ReturnStatementBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_returnStatementBody
}

func (*ReturnStatementBodyContext) IsReturnStatementBodyContext() {}

func NewReturnStatementBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementBodyContext {
	var p = new(ReturnStatementBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_returnStatementBody

	return p
}

func (s *ReturnStatementBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementBodyContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(GQLParserASTERISK, 0)
}

func (s *ReturnStatementBodyContext) ReturnItemList() IReturnItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnItemListContext)
}

func (s *ReturnStatementBodyContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *ReturnStatementBodyContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *ReturnStatementBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterReturnStatementBody(s)
	}
}

func (s *ReturnStatementBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitReturnStatementBody(s)
	}
}

func (p *GQLParser) ReturnStatementBody() (localctx IReturnStatementBodyContext) {
	localctx = NewReturnStatementBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, GQLParserRULE_returnStatementBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserALL || _la == GQLParserDISTINCT {
		{
			p.SetState(1914)
			p.SetQuantifier()
		}

	}
	p.SetState(1919)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserASTERISK:
		{
			p.SetState(1917)
			p.Match(GQLParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserBOOLEAN_LITERAL, GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE, GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, GQLParserBYTE_STRING_LITERAL, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER, GQLParserUNSIGNED_HEXADECIMAL_INTEGER, GQLParserUNSIGNED_OCTAL_INTEGER, GQLParserUNSIGNED_BINARY_INTEGER, GQLParserABS, GQLParserACOS, GQLParserALL_DIFFERENT, GQLParserARRAY, GQLParserASIN, GQLParserATAN, GQLParserAVG, GQLParserBTRIM, GQLParserBYTE_LENGTH, GQLParserCARDINALITY, GQLParserCASE, GQLParserCAST, GQLParserCEIL, GQLParserCEILING, GQLParserCHAR_LENGTH, GQLParserCHARACTER_LENGTH, GQLParserCOALESCE, GQLParserCOLLECT_LIST, GQLParserCOS, GQLParserCOSH, GQLParserCOT, GQLParserCOUNT, GQLParserCURRENT_DATE, GQLParserCURRENT_TIME, GQLParserCURRENT_TIMESTAMP, GQLParserDATE, GQLParserDATETIME, GQLParserDEGREES, GQLParserDURATION, GQLParserDURATION_BETWEEN, GQLParserELEMENT_ID, GQLParserEXISTS, GQLParserEXP, GQLParserFLOOR, GQLParserLEFT, GQLParserLET, GQLParserLIST, GQLParserLN, GQLParserLOCAL_DATETIME, GQLParserLOCAL_TIME, GQLParserLOCAL_TIMESTAMP, GQLParserLOG_KW, GQLParserLOG10, GQLParserLOWER, GQLParserLTRIM, GQLParserMAX, GQLParserMIN, GQLParserMOD, GQLParserNORMALIZE, GQLParserNOT, GQLParserNULL_KW, GQLParserNULLIF, GQLParserOCTET_LENGTH, GQLParserPATH, GQLParserPATH_LENGTH, GQLParserPERCENTILE_CONT, GQLParserPERCENTILE_DISC, GQLParserPOWER, GQLParserPROPERTY_EXISTS, GQLParserRADIANS, GQLParserRECORD, GQLParserRIGHT, GQLParserRTRIM, GQLParserSAME, GQLParserSESSION_USER, GQLParserSIN, GQLParserSINH, GQLParserSIZE, GQLParserSQRT, GQLParserSTDDEV_POP, GQLParserSTDDEV_SAMP, GQLParserSUM, GQLParserTAN, GQLParserTANH, GQLParserTIME, GQLParserTIMESTAMP, GQLParserTRIM, GQLParserUPPER, GQLParserVALUE, GQLParserZONED_DATETIME, GQLParserZONED_TIME, GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE, GQLParserREGULAR_IDENTIFIER, GQLParserGENERAL_PARAMETER_REFERENCE, GQLParserLEFT_BRACE, GQLParserLEFT_BRACKET, GQLParserLEFT_PAREN, GQLParserMINUS_SIGN, GQLParserPLUS_SIGN:
		{
			p.SetState(1918)
			p.ReturnItemList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1922)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1921)
			p.GroupByClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnItemListContext is an interface to support dynamic dispatch.
type IReturnItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllReturnItem() []IReturnItemContext
	ReturnItem(i int) IReturnItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsReturnItemListContext differentiates from other interfaces.
	IsReturnItemListContext()
}

type ReturnItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnItemListContext() *ReturnItemListContext {
	var p = new(ReturnItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_returnItemList
	return p
}

func InitEmptyReturnItemListContext(p *ReturnItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_returnItemList
}

func (*ReturnItemListContext) IsReturnItemListContext() {}

func NewReturnItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnItemListContext {
	var p = new(ReturnItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_returnItemList

	return p
}

func (s *ReturnItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnItemListContext) AllReturnItem() []IReturnItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReturnItemContext); ok {
			len++
		}
	}

	tst := make([]IReturnItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReturnItemContext); ok {
			tst[i] = t.(IReturnItemContext)
			i++
		}
	}

	return tst
}

func (s *ReturnItemListContext) ReturnItem(i int) IReturnItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnItemContext)
}

func (s *ReturnItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *ReturnItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *ReturnItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterReturnItemList(s)
	}
}

func (s *ReturnItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitReturnItemList(s)
	}
}

func (p *GQLParser) ReturnItemList() (localctx IReturnItemListContext) {
	localctx = NewReturnItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, GQLParserRULE_returnItemList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1924)
		p.ReturnItem()
	}
	p.SetState(1929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1925)
				p.Match(GQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1926)
				p.ReturnItem()
			}

		}
		p.SetState(1931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnItemContext is an interface to support dynamic dispatch.
type IReturnItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AggregatingValueExpression() IAggregatingValueExpressionContext
	ReturnItemAlias() IReturnItemAliasContext

	// IsReturnItemContext differentiates from other interfaces.
	IsReturnItemContext()
}

type ReturnItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnItemContext() *ReturnItemContext {
	var p = new(ReturnItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_returnItem
	return p
}

func InitEmptyReturnItemContext(p *ReturnItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_returnItem
}

func (*ReturnItemContext) IsReturnItemContext() {}

func NewReturnItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnItemContext {
	var p = new(ReturnItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_returnItem

	return p
}

func (s *ReturnItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnItemContext) AggregatingValueExpression() IAggregatingValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregatingValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregatingValueExpressionContext)
}

func (s *ReturnItemContext) ReturnItemAlias() IReturnItemAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnItemAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnItemAliasContext)
}

func (s *ReturnItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterReturnItem(s)
	}
}

func (s *ReturnItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitReturnItem(s)
	}
}

func (p *GQLParser) ReturnItem() (localctx IReturnItemContext) {
	localctx = NewReturnItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, GQLParserRULE_returnItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1932)
		p.AggregatingValueExpression()
	}
	p.SetState(1934)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1933)
			p.ReturnItemAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnItemAliasContext is an interface to support dynamic dispatch.
type IReturnItemAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsReturnItemAliasContext differentiates from other interfaces.
	IsReturnItemAliasContext()
}

type ReturnItemAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnItemAliasContext() *ReturnItemAliasContext {
	var p = new(ReturnItemAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_returnItemAlias
	return p
}

func InitEmptyReturnItemAliasContext(p *ReturnItemAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_returnItemAlias
}

func (*ReturnItemAliasContext) IsReturnItemAliasContext() {}

func NewReturnItemAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnItemAliasContext {
	var p = new(ReturnItemAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_returnItemAlias

	return p
}

func (s *ReturnItemAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnItemAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(GQLParserAS, 0)
}

func (s *ReturnItemAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReturnItemAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnItemAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnItemAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterReturnItemAlias(s)
	}
}

func (s *ReturnItemAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitReturnItemAlias(s)
	}
}

func (p *GQLParser) ReturnItemAlias() (localctx IReturnItemAliasContext) {
	localctx = NewReturnItemAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, GQLParserRULE_returnItemAlias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1936)
		p.Match(GQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1937)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStatementContext is an interface to support dynamic dispatch.
type ISelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode
	SelectItemList() ISelectItemListContext
	SetQuantifier() ISetQuantifierContext
	SelectStatementBody() ISelectStatementBodyContext
	WhereClause() IWhereClauseContext
	GroupByClause() IGroupByClauseContext
	HavingClause() IHavingClauseContext
	OrderByClause() IOrderByClauseContext
	OffsetClause() IOffsetClauseContext
	LimitClause() ILimitClauseContext

	// IsSelectStatementContext differentiates from other interfaces.
	IsSelectStatementContext()
}

type SelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStatementContext() *SelectStatementContext {
	var p = new(SelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectStatement
	return p
}

func InitEmptySelectStatementContext(p *SelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectStatement
}

func (*SelectStatementContext) IsSelectStatementContext() {}

func NewSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementContext {
	var p = new(SelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_selectStatement

	return p
}

func (s *SelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementContext) SELECT() antlr.TerminalNode {
	return s.GetToken(GQLParserSELECT, 0)
}

func (s *SelectStatementContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(GQLParserASTERISK, 0)
}

func (s *SelectStatementContext) SelectItemList() ISelectItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemListContext)
}

func (s *SelectStatementContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SelectStatementContext) SelectStatementBody() ISelectStatementBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementBodyContext)
}

func (s *SelectStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *SelectStatementContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *SelectStatementContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *SelectStatementContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SelectStatementContext) OffsetClause() IOffsetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOffsetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOffsetClauseContext)
}

func (s *SelectStatementContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *SelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSelectStatement(s)
	}
}

func (s *SelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSelectStatement(s)
	}
}

func (p *GQLParser) SelectStatement() (localctx ISelectStatementContext) {
	localctx = NewSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, GQLParserRULE_selectStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1939)
		p.Match(GQLParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1941)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserALL || _la == GQLParserDISTINCT {
		{
			p.SetState(1940)
			p.SetQuantifier()
		}

	}
	p.SetState(1945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserASTERISK:
		{
			p.SetState(1943)
			p.Match(GQLParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserBOOLEAN_LITERAL, GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE, GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, GQLParserBYTE_STRING_LITERAL, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER, GQLParserUNSIGNED_HEXADECIMAL_INTEGER, GQLParserUNSIGNED_OCTAL_INTEGER, GQLParserUNSIGNED_BINARY_INTEGER, GQLParserABS, GQLParserACOS, GQLParserALL_DIFFERENT, GQLParserARRAY, GQLParserASIN, GQLParserATAN, GQLParserAVG, GQLParserBTRIM, GQLParserBYTE_LENGTH, GQLParserCARDINALITY, GQLParserCASE, GQLParserCAST, GQLParserCEIL, GQLParserCEILING, GQLParserCHAR_LENGTH, GQLParserCHARACTER_LENGTH, GQLParserCOALESCE, GQLParserCOLLECT_LIST, GQLParserCOS, GQLParserCOSH, GQLParserCOT, GQLParserCOUNT, GQLParserCURRENT_DATE, GQLParserCURRENT_TIME, GQLParserCURRENT_TIMESTAMP, GQLParserDATE, GQLParserDATETIME, GQLParserDEGREES, GQLParserDURATION, GQLParserDURATION_BETWEEN, GQLParserELEMENT_ID, GQLParserEXISTS, GQLParserEXP, GQLParserFLOOR, GQLParserLEFT, GQLParserLET, GQLParserLIST, GQLParserLN, GQLParserLOCAL_DATETIME, GQLParserLOCAL_TIME, GQLParserLOCAL_TIMESTAMP, GQLParserLOG_KW, GQLParserLOG10, GQLParserLOWER, GQLParserLTRIM, GQLParserMAX, GQLParserMIN, GQLParserMOD, GQLParserNORMALIZE, GQLParserNOT, GQLParserNULL_KW, GQLParserNULLIF, GQLParserOCTET_LENGTH, GQLParserPATH, GQLParserPATH_LENGTH, GQLParserPERCENTILE_CONT, GQLParserPERCENTILE_DISC, GQLParserPOWER, GQLParserPROPERTY_EXISTS, GQLParserRADIANS, GQLParserRECORD, GQLParserRIGHT, GQLParserRTRIM, GQLParserSAME, GQLParserSESSION_USER, GQLParserSIN, GQLParserSINH, GQLParserSIZE, GQLParserSQRT, GQLParserSTDDEV_POP, GQLParserSTDDEV_SAMP, GQLParserSUM, GQLParserTAN, GQLParserTANH, GQLParserTIME, GQLParserTIMESTAMP, GQLParserTRIM, GQLParserUPPER, GQLParserVALUE, GQLParserZONED_DATETIME, GQLParserZONED_TIME, GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE, GQLParserREGULAR_IDENTIFIER, GQLParserGENERAL_PARAMETER_REFERENCE, GQLParserLEFT_BRACE, GQLParserLEFT_BRACKET, GQLParserLEFT_PAREN, GQLParserMINUS_SIGN, GQLParserPLUS_SIGN:
		{
			p.SetState(1944)
			p.SelectItemList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1966)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1947)
			p.SelectStatementBody()
		}
		p.SetState(1949)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1948)
				p.WhereClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1952)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1951)
				p.GroupByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1955)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1954)
				p.HavingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1958)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1957)
				p.OrderByClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1961)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1960)
				p.OffsetClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1964)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1963)
				p.LimitClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectItemListContext is an interface to support dynamic dispatch.
type ISelectItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectItemListContext differentiates from other interfaces.
	IsSelectItemListContext()
}

type SelectItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemListContext() *SelectItemListContext {
	var p = new(SelectItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectItemList
	return p
}

func InitEmptySelectItemListContext(p *SelectItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectItemList
}

func (*SelectItemListContext) IsSelectItemListContext() {}

func NewSelectItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemListContext {
	var p = new(SelectItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_selectItemList

	return p
}

func (s *SelectItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemListContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *SelectItemListContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *SelectItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *SelectItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *SelectItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSelectItemList(s)
	}
}

func (s *SelectItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSelectItemList(s)
	}
}

func (p *GQLParser) SelectItemList() (localctx ISelectItemListContext) {
	localctx = NewSelectItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, GQLParserRULE_selectItemList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1968)
		p.SelectItem()
	}
	p.SetState(1973)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1969)
				p.Match(GQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1970)
				p.SelectItem()
			}

		}
		p.SetState(1975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AggregatingValueExpression() IAggregatingValueExpressionContext
	SelectItemAlias() ISelectItemAliasContext

	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectItem
	return p
}

func InitEmptySelectItemContext(p *SelectItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectItem
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) AggregatingValueExpression() IAggregatingValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregatingValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregatingValueExpressionContext)
}

func (s *SelectItemContext) SelectItemAlias() ISelectItemAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemAliasContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSelectItem(s)
	}
}

func (s *SelectItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSelectItem(s)
	}
}

func (p *GQLParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, GQLParserRULE_selectItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1976)
		p.AggregatingValueExpression()
	}
	p.SetState(1978)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1977)
			p.SelectItemAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectItemAliasContext is an interface to support dynamic dispatch.
type ISelectItemAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsSelectItemAliasContext differentiates from other interfaces.
	IsSelectItemAliasContext()
}

type SelectItemAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemAliasContext() *SelectItemAliasContext {
	var p = new(SelectItemAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectItemAlias
	return p
}

func InitEmptySelectItemAliasContext(p *SelectItemAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectItemAlias
}

func (*SelectItemAliasContext) IsSelectItemAliasContext() {}

func NewSelectItemAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemAliasContext {
	var p = new(SelectItemAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_selectItemAlias

	return p
}

func (s *SelectItemAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(GQLParserAS, 0)
}

func (s *SelectItemAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectItemAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectItemAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSelectItemAlias(s)
	}
}

func (s *SelectItemAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSelectItemAlias(s)
	}
}

func (p *GQLParser) SelectItemAlias() (localctx ISelectItemAliasContext) {
	localctx = NewSelectItemAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, GQLParserRULE_selectItemAlias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1980)
		p.Match(GQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1981)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAVING() antlr.TerminalNode
	SearchCondition() ISearchConditionContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(GQLParserHAVING, 0)
}

func (s *HavingClauseContext) SearchCondition() ISearchConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchConditionContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (p *GQLParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, GQLParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1983)
		p.Match(GQLParserHAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1984)
		p.SearchCondition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStatementBodyContext is an interface to support dynamic dispatch.
type ISelectStatementBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	SelectGraphMatchList() ISelectGraphMatchListContext
	SelectQuerySpecification() ISelectQuerySpecificationContext

	// IsSelectStatementBodyContext differentiates from other interfaces.
	IsSelectStatementBodyContext()
}

type SelectStatementBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStatementBodyContext() *SelectStatementBodyContext {
	var p = new(SelectStatementBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectStatementBody
	return p
}

func InitEmptySelectStatementBodyContext(p *SelectStatementBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectStatementBody
}

func (*SelectStatementBodyContext) IsSelectStatementBodyContext() {}

func NewSelectStatementBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementBodyContext {
	var p = new(SelectStatementBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_selectStatementBody

	return p
}

func (s *SelectStatementBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementBodyContext) FROM() antlr.TerminalNode {
	return s.GetToken(GQLParserFROM, 0)
}

func (s *SelectStatementBodyContext) SelectGraphMatchList() ISelectGraphMatchListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectGraphMatchListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectGraphMatchListContext)
}

func (s *SelectStatementBodyContext) SelectQuerySpecification() ISelectQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectQuerySpecificationContext)
}

func (s *SelectStatementBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStatementBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSelectStatementBody(s)
	}
}

func (s *SelectStatementBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSelectStatementBody(s)
	}
}

func (p *GQLParser) SelectStatementBody() (localctx ISelectStatementBodyContext) {
	localctx = NewSelectStatementBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, GQLParserRULE_selectStatementBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1986)
		p.Match(GQLParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1989)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1987)
			p.SelectGraphMatchList()
		}

	case 2:
		{
			p.SetState(1988)
			p.SelectQuerySpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectGraphMatchListContext is an interface to support dynamic dispatch.
type ISelectGraphMatchListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelectGraphMatch() []ISelectGraphMatchContext
	SelectGraphMatch(i int) ISelectGraphMatchContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectGraphMatchListContext differentiates from other interfaces.
	IsSelectGraphMatchListContext()
}

type SelectGraphMatchListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectGraphMatchListContext() *SelectGraphMatchListContext {
	var p = new(SelectGraphMatchListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectGraphMatchList
	return p
}

func InitEmptySelectGraphMatchListContext(p *SelectGraphMatchListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectGraphMatchList
}

func (*SelectGraphMatchListContext) IsSelectGraphMatchListContext() {}

func NewSelectGraphMatchListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectGraphMatchListContext {
	var p = new(SelectGraphMatchListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_selectGraphMatchList

	return p
}

func (s *SelectGraphMatchListContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectGraphMatchListContext) AllSelectGraphMatch() []ISelectGraphMatchContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectGraphMatchContext); ok {
			len++
		}
	}

	tst := make([]ISelectGraphMatchContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectGraphMatchContext); ok {
			tst[i] = t.(ISelectGraphMatchContext)
			i++
		}
	}

	return tst
}

func (s *SelectGraphMatchListContext) SelectGraphMatch(i int) ISelectGraphMatchContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectGraphMatchContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectGraphMatchContext)
}

func (s *SelectGraphMatchListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *SelectGraphMatchListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *SelectGraphMatchListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectGraphMatchListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectGraphMatchListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSelectGraphMatchList(s)
	}
}

func (s *SelectGraphMatchListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSelectGraphMatchList(s)
	}
}

func (p *GQLParser) SelectGraphMatchList() (localctx ISelectGraphMatchListContext) {
	localctx = NewSelectGraphMatchListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, GQLParserRULE_selectGraphMatchList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1991)
		p.SelectGraphMatch()
	}
	p.SetState(1996)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1992)
				p.Match(GQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1993)
				p.SelectGraphMatch()
			}

		}
		p.SetState(1998)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectGraphMatchContext is an interface to support dynamic dispatch.
type ISelectGraphMatchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GraphExpression() IGraphExpressionContext
	MatchStatement() IMatchStatementContext

	// IsSelectGraphMatchContext differentiates from other interfaces.
	IsSelectGraphMatchContext()
}

type SelectGraphMatchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectGraphMatchContext() *SelectGraphMatchContext {
	var p = new(SelectGraphMatchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectGraphMatch
	return p
}

func InitEmptySelectGraphMatchContext(p *SelectGraphMatchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectGraphMatch
}

func (*SelectGraphMatchContext) IsSelectGraphMatchContext() {}

func NewSelectGraphMatchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectGraphMatchContext {
	var p = new(SelectGraphMatchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_selectGraphMatch

	return p
}

func (s *SelectGraphMatchContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectGraphMatchContext) GraphExpression() IGraphExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphExpressionContext)
}

func (s *SelectGraphMatchContext) MatchStatement() IMatchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchStatementContext)
}

func (s *SelectGraphMatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectGraphMatchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectGraphMatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSelectGraphMatch(s)
	}
}

func (s *SelectGraphMatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSelectGraphMatch(s)
	}
}

func (p *GQLParser) SelectGraphMatch() (localctx ISelectGraphMatchContext) {
	localctx = NewSelectGraphMatchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, GQLParserRULE_selectGraphMatch)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1999)
		p.GraphExpression()
	}
	{
		p.SetState(2000)
		p.MatchStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectQuerySpecificationContext is an interface to support dynamic dispatch.
type ISelectQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NestedQuerySpecification() INestedQuerySpecificationContext
	GraphExpression() IGraphExpressionContext

	// IsSelectQuerySpecificationContext differentiates from other interfaces.
	IsSelectQuerySpecificationContext()
}

type SelectQuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectQuerySpecificationContext() *SelectQuerySpecificationContext {
	var p = new(SelectQuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectQuerySpecification
	return p
}

func InitEmptySelectQuerySpecificationContext(p *SelectQuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_selectQuerySpecification
}

func (*SelectQuerySpecificationContext) IsSelectQuerySpecificationContext() {}

func NewSelectQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectQuerySpecificationContext {
	var p = new(SelectQuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_selectQuerySpecification

	return p
}

func (s *SelectQuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectQuerySpecificationContext) NestedQuerySpecification() INestedQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedQuerySpecificationContext)
}

func (s *SelectQuerySpecificationContext) GraphExpression() IGraphExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphExpressionContext)
}

func (s *SelectQuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectQuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectQuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSelectQuerySpecification(s)
	}
}

func (s *SelectQuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSelectQuerySpecification(s)
	}
}

func (p *GQLParser) SelectQuerySpecification() (localctx ISelectQuerySpecificationContext) {
	localctx = NewSelectQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, GQLParserRULE_selectQuerySpecification)
	p.SetState(2006)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2002)
			p.NestedQuerySpecification()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2003)
			p.GraphExpression()
		}
		{
			p.SetState(2004)
			p.NestedQuerySpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallProcedureStatementContext is an interface to support dynamic dispatch.
type ICallProcedureStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CALL() antlr.TerminalNode
	ProcedureCall() IProcedureCallContext
	OPTIONAL() antlr.TerminalNode

	// IsCallProcedureStatementContext differentiates from other interfaces.
	IsCallProcedureStatementContext()
}

type CallProcedureStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallProcedureStatementContext() *CallProcedureStatementContext {
	var p = new(CallProcedureStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_callProcedureStatement
	return p
}

func InitEmptyCallProcedureStatementContext(p *CallProcedureStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_callProcedureStatement
}

func (*CallProcedureStatementContext) IsCallProcedureStatementContext() {}

func NewCallProcedureStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallProcedureStatementContext {
	var p = new(CallProcedureStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_callProcedureStatement

	return p
}

func (s *CallProcedureStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CallProcedureStatementContext) CALL() antlr.TerminalNode {
	return s.GetToken(GQLParserCALL, 0)
}

func (s *CallProcedureStatementContext) ProcedureCall() IProcedureCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureCallContext)
}

func (s *CallProcedureStatementContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(GQLParserOPTIONAL, 0)
}

func (s *CallProcedureStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallProcedureStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallProcedureStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCallProcedureStatement(s)
	}
}

func (s *CallProcedureStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCallProcedureStatement(s)
	}
}

func (p *GQLParser) CallProcedureStatement() (localctx ICallProcedureStatementContext) {
	localctx = NewCallProcedureStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, GQLParserRULE_callProcedureStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserOPTIONAL {
		{
			p.SetState(2008)
			p.Match(GQLParserOPTIONAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2011)
		p.Match(GQLParserCALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2012)
		p.ProcedureCall()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureCallContext is an interface to support dynamic dispatch.
type IProcedureCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InlineProcedureCall() IInlineProcedureCallContext
	NamedProcedureCall() INamedProcedureCallContext

	// IsProcedureCallContext differentiates from other interfaces.
	IsProcedureCallContext()
}

type ProcedureCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureCallContext() *ProcedureCallContext {
	var p = new(ProcedureCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_procedureCall
	return p
}

func InitEmptyProcedureCallContext(p *ProcedureCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_procedureCall
}

func (*ProcedureCallContext) IsProcedureCallContext() {}

func NewProcedureCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureCallContext {
	var p = new(ProcedureCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_procedureCall

	return p
}

func (s *ProcedureCallContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureCallContext) InlineProcedureCall() IInlineProcedureCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineProcedureCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineProcedureCallContext)
}

func (s *ProcedureCallContext) NamedProcedureCall() INamedProcedureCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedProcedureCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedProcedureCallContext)
}

func (s *ProcedureCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterProcedureCall(s)
	}
}

func (s *ProcedureCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitProcedureCall(s)
	}
}

func (p *GQLParser) ProcedureCall() (localctx IProcedureCallContext) {
	localctx = NewProcedureCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, GQLParserRULE_procedureCall)
	p.SetState(2016)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserLEFT_BRACE, GQLParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2014)
			p.InlineProcedureCall()
		}

	case GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE, GQLParserCURRENT_SCHEMA, GQLParserHOME_SCHEMA, GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE, GQLParserREGULAR_IDENTIFIER, GQLParserSUBSTITUTED_PARAMETER_REFERENCE, GQLParserDOUBLE_PERIOD, GQLParserPERIOD, GQLParserSOLIDUS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2015)
			p.NamedProcedureCall()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineProcedureCallContext is an interface to support dynamic dispatch.
type IInlineProcedureCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NestedProcedureSpecification() INestedProcedureSpecificationContext
	VariableScopeClause() IVariableScopeClauseContext

	// IsInlineProcedureCallContext differentiates from other interfaces.
	IsInlineProcedureCallContext()
}

type InlineProcedureCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineProcedureCallContext() *InlineProcedureCallContext {
	var p = new(InlineProcedureCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_inlineProcedureCall
	return p
}

func InitEmptyInlineProcedureCallContext(p *InlineProcedureCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_inlineProcedureCall
}

func (*InlineProcedureCallContext) IsInlineProcedureCallContext() {}

func NewInlineProcedureCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineProcedureCallContext {
	var p = new(InlineProcedureCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_inlineProcedureCall

	return p
}

func (s *InlineProcedureCallContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineProcedureCallContext) NestedProcedureSpecification() INestedProcedureSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedProcedureSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedProcedureSpecificationContext)
}

func (s *InlineProcedureCallContext) VariableScopeClause() IVariableScopeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableScopeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableScopeClauseContext)
}

func (s *InlineProcedureCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineProcedureCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineProcedureCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterInlineProcedureCall(s)
	}
}

func (s *InlineProcedureCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitInlineProcedureCall(s)
	}
}

func (p *GQLParser) InlineProcedureCall() (localctx IInlineProcedureCallContext) {
	localctx = NewInlineProcedureCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, GQLParserRULE_inlineProcedureCall)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserLEFT_PAREN {
		{
			p.SetState(2018)
			p.VariableScopeClause()
		}

	}
	{
		p.SetState(2021)
		p.NestedProcedureSpecification()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableScopeClauseContext is an interface to support dynamic dispatch.
type IVariableScopeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	BindingVariableReferenceList() IBindingVariableReferenceListContext

	// IsVariableScopeClauseContext differentiates from other interfaces.
	IsVariableScopeClauseContext()
}

type VariableScopeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableScopeClauseContext() *VariableScopeClauseContext {
	var p = new(VariableScopeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_variableScopeClause
	return p
}

func InitEmptyVariableScopeClauseContext(p *VariableScopeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_variableScopeClause
}

func (*VariableScopeClauseContext) IsVariableScopeClauseContext() {}

func NewVariableScopeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableScopeClauseContext {
	var p = new(VariableScopeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_variableScopeClause

	return p
}

func (s *VariableScopeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableScopeClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *VariableScopeClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *VariableScopeClauseContext) BindingVariableReferenceList() IBindingVariableReferenceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableReferenceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableReferenceListContext)
}

func (s *VariableScopeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableScopeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableScopeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterVariableScopeClause(s)
	}
}

func (s *VariableScopeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitVariableScopeClause(s)
	}
}

func (p *GQLParser) VariableScopeClause() (localctx IVariableScopeClauseContext) {
	localctx = NewVariableScopeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, GQLParserRULE_variableScopeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2023)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&281474976710655) != 0 {
		{
			p.SetState(2024)
			p.BindingVariableReferenceList()
		}

	}
	{
		p.SetState(2027)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindingVariableReferenceListContext is an interface to support dynamic dispatch.
type IBindingVariableReferenceListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBindingVariableReference() []IBindingVariableReferenceContext
	BindingVariableReference(i int) IBindingVariableReferenceContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsBindingVariableReferenceListContext differentiates from other interfaces.
	IsBindingVariableReferenceListContext()
}

type BindingVariableReferenceListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingVariableReferenceListContext() *BindingVariableReferenceListContext {
	var p = new(BindingVariableReferenceListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingVariableReferenceList
	return p
}

func InitEmptyBindingVariableReferenceListContext(p *BindingVariableReferenceListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingVariableReferenceList
}

func (*BindingVariableReferenceListContext) IsBindingVariableReferenceListContext() {}

func NewBindingVariableReferenceListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingVariableReferenceListContext {
	var p = new(BindingVariableReferenceListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_bindingVariableReferenceList

	return p
}

func (s *BindingVariableReferenceListContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingVariableReferenceListContext) AllBindingVariableReference() []IBindingVariableReferenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBindingVariableReferenceContext); ok {
			len++
		}
	}

	tst := make([]IBindingVariableReferenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBindingVariableReferenceContext); ok {
			tst[i] = t.(IBindingVariableReferenceContext)
			i++
		}
	}

	return tst
}

func (s *BindingVariableReferenceListContext) BindingVariableReference(i int) IBindingVariableReferenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableReferenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableReferenceContext)
}

func (s *BindingVariableReferenceListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *BindingVariableReferenceListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *BindingVariableReferenceListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingVariableReferenceListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingVariableReferenceListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBindingVariableReferenceList(s)
	}
}

func (s *BindingVariableReferenceListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBindingVariableReferenceList(s)
	}
}

func (p *GQLParser) BindingVariableReferenceList() (localctx IBindingVariableReferenceListContext) {
	localctx = NewBindingVariableReferenceListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, GQLParserRULE_bindingVariableReferenceList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2029)
		p.BindingVariableReference()
	}
	p.SetState(2034)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(2030)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2031)
			p.BindingVariableReference()
		}

		p.SetState(2036)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedProcedureCallContext is an interface to support dynamic dispatch.
type INamedProcedureCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureReference() IProcedureReferenceContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	ProcedureArgumentList() IProcedureArgumentListContext
	YieldClause() IYieldClauseContext

	// IsNamedProcedureCallContext differentiates from other interfaces.
	IsNamedProcedureCallContext()
}

type NamedProcedureCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedProcedureCallContext() *NamedProcedureCallContext {
	var p = new(NamedProcedureCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_namedProcedureCall
	return p
}

func InitEmptyNamedProcedureCallContext(p *NamedProcedureCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_namedProcedureCall
}

func (*NamedProcedureCallContext) IsNamedProcedureCallContext() {}

func NewNamedProcedureCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedProcedureCallContext {
	var p = new(NamedProcedureCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_namedProcedureCall

	return p
}

func (s *NamedProcedureCallContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedProcedureCallContext) ProcedureReference() IProcedureReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureReferenceContext)
}

func (s *NamedProcedureCallContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *NamedProcedureCallContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *NamedProcedureCallContext) ProcedureArgumentList() IProcedureArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureArgumentListContext)
}

func (s *NamedProcedureCallContext) YieldClause() IYieldClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldClauseContext)
}

func (s *NamedProcedureCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedProcedureCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedProcedureCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNamedProcedureCall(s)
	}
}

func (s *NamedProcedureCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNamedProcedureCall(s)
	}
}

func (p *GQLParser) NamedProcedureCall() (localctx INamedProcedureCallContext) {
	localctx = NewNamedProcedureCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, GQLParserRULE_namedProcedureCall)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2037)
		p.ProcedureReference()
	}
	{
		p.SetState(2038)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2040)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3684181877393982240) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&275712591755) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&-8011702113698201677) != 0) || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&26393111092643) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&844424930131967) != 0) || ((int64((_la-371)) & ^0x3f) == 0 && ((int64(1)<<(_la-371))&151) != 0) {
		{
			p.SetState(2039)
			p.ProcedureArgumentList()
		}

	}
	{
		p.SetState(2042)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2044)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserYIELD {
		{
			p.SetState(2043)
			p.YieldClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureArgumentListContext is an interface to support dynamic dispatch.
type IProcedureArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProcedureArgument() []IProcedureArgumentContext
	ProcedureArgument(i int) IProcedureArgumentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsProcedureArgumentListContext differentiates from other interfaces.
	IsProcedureArgumentListContext()
}

type ProcedureArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureArgumentListContext() *ProcedureArgumentListContext {
	var p = new(ProcedureArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_procedureArgumentList
	return p
}

func InitEmptyProcedureArgumentListContext(p *ProcedureArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_procedureArgumentList
}

func (*ProcedureArgumentListContext) IsProcedureArgumentListContext() {}

func NewProcedureArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureArgumentListContext {
	var p = new(ProcedureArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_procedureArgumentList

	return p
}

func (s *ProcedureArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureArgumentListContext) AllProcedureArgument() []IProcedureArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureArgumentContext); ok {
			len++
		}
	}

	tst := make([]IProcedureArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureArgumentContext); ok {
			tst[i] = t.(IProcedureArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ProcedureArgumentListContext) ProcedureArgument(i int) IProcedureArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureArgumentContext)
}

func (s *ProcedureArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *ProcedureArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *ProcedureArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterProcedureArgumentList(s)
	}
}

func (s *ProcedureArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitProcedureArgumentList(s)
	}
}

func (p *GQLParser) ProcedureArgumentList() (localctx IProcedureArgumentListContext) {
	localctx = NewProcedureArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, GQLParserRULE_procedureArgumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2046)
		p.ProcedureArgument()
	}
	p.SetState(2051)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(2047)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2048)
			p.ProcedureArgument()
		}

		p.SetState(2053)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureArgumentContext is an interface to support dynamic dispatch.
type IProcedureArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsProcedureArgumentContext differentiates from other interfaces.
	IsProcedureArgumentContext()
}

type ProcedureArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureArgumentContext() *ProcedureArgumentContext {
	var p = new(ProcedureArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_procedureArgument
	return p
}

func InitEmptyProcedureArgumentContext(p *ProcedureArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_procedureArgument
}

func (*ProcedureArgumentContext) IsProcedureArgumentContext() {}

func NewProcedureArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureArgumentContext {
	var p = new(ProcedureArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_procedureArgument

	return p
}

func (s *ProcedureArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureArgumentContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ProcedureArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterProcedureArgument(s)
	}
}

func (s *ProcedureArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitProcedureArgument(s)
	}
}

func (p *GQLParser) ProcedureArgument() (localctx IProcedureArgumentContext) {
	localctx = NewProcedureArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, GQLParserRULE_procedureArgument)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2054)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtSchemaClauseContext is an interface to support dynamic dispatch.
type IAtSchemaClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	SchemaReference() ISchemaReferenceContext

	// IsAtSchemaClauseContext differentiates from other interfaces.
	IsAtSchemaClauseContext()
}

type AtSchemaClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtSchemaClauseContext() *AtSchemaClauseContext {
	var p = new(AtSchemaClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_atSchemaClause
	return p
}

func InitEmptyAtSchemaClauseContext(p *AtSchemaClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_atSchemaClause
}

func (*AtSchemaClauseContext) IsAtSchemaClauseContext() {}

func NewAtSchemaClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtSchemaClauseContext {
	var p = new(AtSchemaClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_atSchemaClause

	return p
}

func (s *AtSchemaClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AtSchemaClauseContext) AT() antlr.TerminalNode {
	return s.GetToken(GQLParserAT, 0)
}

func (s *AtSchemaClauseContext) SchemaReference() ISchemaReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaReferenceContext)
}

func (s *AtSchemaClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtSchemaClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtSchemaClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAtSchemaClause(s)
	}
}

func (s *AtSchemaClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAtSchemaClause(s)
	}
}

func (p *GQLParser) AtSchemaClause() (localctx IAtSchemaClauseContext) {
	localctx = NewAtSchemaClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, GQLParserRULE_atSchemaClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2056)
		p.Match(GQLParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2057)
		p.SchemaReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseGraphClauseContext is an interface to support dynamic dispatch.
type IUseGraphClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	GraphExpression() IGraphExpressionContext

	// IsUseGraphClauseContext differentiates from other interfaces.
	IsUseGraphClauseContext()
}

type UseGraphClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseGraphClauseContext() *UseGraphClauseContext {
	var p = new(UseGraphClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_useGraphClause
	return p
}

func InitEmptyUseGraphClauseContext(p *UseGraphClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_useGraphClause
}

func (*UseGraphClauseContext) IsUseGraphClauseContext() {}

func NewUseGraphClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseGraphClauseContext {
	var p = new(UseGraphClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_useGraphClause

	return p
}

func (s *UseGraphClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UseGraphClauseContext) USE() antlr.TerminalNode {
	return s.GetToken(GQLParserUSE, 0)
}

func (s *UseGraphClauseContext) GraphExpression() IGraphExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphExpressionContext)
}

func (s *UseGraphClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseGraphClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseGraphClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterUseGraphClause(s)
	}
}

func (s *UseGraphClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitUseGraphClause(s)
	}
}

func (p *GQLParser) UseGraphClause() (localctx IUseGraphClauseContext) {
	localctx = NewUseGraphClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, GQLParserRULE_useGraphClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2059)
		p.Match(GQLParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2060)
		p.GraphExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphPatternBindingTableContext is an interface to support dynamic dispatch.
type IGraphPatternBindingTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GraphPattern() IGraphPatternContext
	GraphPatternYieldClause() IGraphPatternYieldClauseContext

	// IsGraphPatternBindingTableContext differentiates from other interfaces.
	IsGraphPatternBindingTableContext()
}

type GraphPatternBindingTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphPatternBindingTableContext() *GraphPatternBindingTableContext {
	var p = new(GraphPatternBindingTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphPatternBindingTable
	return p
}

func InitEmptyGraphPatternBindingTableContext(p *GraphPatternBindingTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphPatternBindingTable
}

func (*GraphPatternBindingTableContext) IsGraphPatternBindingTableContext() {}

func NewGraphPatternBindingTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphPatternBindingTableContext {
	var p = new(GraphPatternBindingTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphPatternBindingTable

	return p
}

func (s *GraphPatternBindingTableContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphPatternBindingTableContext) GraphPattern() IGraphPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphPatternContext)
}

func (s *GraphPatternBindingTableContext) GraphPatternYieldClause() IGraphPatternYieldClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphPatternYieldClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphPatternYieldClauseContext)
}

func (s *GraphPatternBindingTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphPatternBindingTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphPatternBindingTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphPatternBindingTable(s)
	}
}

func (s *GraphPatternBindingTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphPatternBindingTable(s)
	}
}

func (p *GQLParser) GraphPatternBindingTable() (localctx IGraphPatternBindingTableContext) {
	localctx = NewGraphPatternBindingTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, GQLParserRULE_graphPatternBindingTable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2062)
		p.GraphPattern()
	}
	p.SetState(2064)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2063)
			p.GraphPatternYieldClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphPatternYieldClauseContext is an interface to support dynamic dispatch.
type IGraphPatternYieldClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YIELD() antlr.TerminalNode
	GraphPatternYieldItemList() IGraphPatternYieldItemListContext

	// IsGraphPatternYieldClauseContext differentiates from other interfaces.
	IsGraphPatternYieldClauseContext()
}

type GraphPatternYieldClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphPatternYieldClauseContext() *GraphPatternYieldClauseContext {
	var p = new(GraphPatternYieldClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphPatternYieldClause
	return p
}

func InitEmptyGraphPatternYieldClauseContext(p *GraphPatternYieldClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphPatternYieldClause
}

func (*GraphPatternYieldClauseContext) IsGraphPatternYieldClauseContext() {}

func NewGraphPatternYieldClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphPatternYieldClauseContext {
	var p = new(GraphPatternYieldClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphPatternYieldClause

	return p
}

func (s *GraphPatternYieldClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphPatternYieldClauseContext) YIELD() antlr.TerminalNode {
	return s.GetToken(GQLParserYIELD, 0)
}

func (s *GraphPatternYieldClauseContext) GraphPatternYieldItemList() IGraphPatternYieldItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphPatternYieldItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphPatternYieldItemListContext)
}

func (s *GraphPatternYieldClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphPatternYieldClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphPatternYieldClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphPatternYieldClause(s)
	}
}

func (s *GraphPatternYieldClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphPatternYieldClause(s)
	}
}

func (p *GQLParser) GraphPatternYieldClause() (localctx IGraphPatternYieldClauseContext) {
	localctx = NewGraphPatternYieldClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, GQLParserRULE_graphPatternYieldClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2066)
		p.Match(GQLParserYIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2067)
		p.GraphPatternYieldItemList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphPatternYieldItemListContext is an interface to support dynamic dispatch.
type IGraphPatternYieldItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGraphPatternYieldItem() []IGraphPatternYieldItemContext
	GraphPatternYieldItem(i int) IGraphPatternYieldItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGraphPatternYieldItemListContext differentiates from other interfaces.
	IsGraphPatternYieldItemListContext()
}

type GraphPatternYieldItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphPatternYieldItemListContext() *GraphPatternYieldItemListContext {
	var p = new(GraphPatternYieldItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphPatternYieldItemList
	return p
}

func InitEmptyGraphPatternYieldItemListContext(p *GraphPatternYieldItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphPatternYieldItemList
}

func (*GraphPatternYieldItemListContext) IsGraphPatternYieldItemListContext() {}

func NewGraphPatternYieldItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphPatternYieldItemListContext {
	var p = new(GraphPatternYieldItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphPatternYieldItemList

	return p
}

func (s *GraphPatternYieldItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphPatternYieldItemListContext) AllGraphPatternYieldItem() []IGraphPatternYieldItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGraphPatternYieldItemContext); ok {
			len++
		}
	}

	tst := make([]IGraphPatternYieldItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGraphPatternYieldItemContext); ok {
			tst[i] = t.(IGraphPatternYieldItemContext)
			i++
		}
	}

	return tst
}

func (s *GraphPatternYieldItemListContext) GraphPatternYieldItem(i int) IGraphPatternYieldItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphPatternYieldItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphPatternYieldItemContext)
}

func (s *GraphPatternYieldItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *GraphPatternYieldItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *GraphPatternYieldItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphPatternYieldItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphPatternYieldItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphPatternYieldItemList(s)
	}
}

func (s *GraphPatternYieldItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphPatternYieldItemList(s)
	}
}

func (p *GQLParser) GraphPatternYieldItemList() (localctx IGraphPatternYieldItemListContext) {
	localctx = NewGraphPatternYieldItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, GQLParserRULE_graphPatternYieldItemList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2069)
		p.GraphPatternYieldItem()
	}
	p.SetState(2074)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2070)
				p.Match(GQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2071)
				p.GraphPatternYieldItem()
			}

		}
		p.SetState(2076)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphPatternYieldItemContext is an interface to support dynamic dispatch.
type IGraphPatternYieldItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingVariableReference() IBindingVariableReferenceContext

	// IsGraphPatternYieldItemContext differentiates from other interfaces.
	IsGraphPatternYieldItemContext()
}

type GraphPatternYieldItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphPatternYieldItemContext() *GraphPatternYieldItemContext {
	var p = new(GraphPatternYieldItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphPatternYieldItem
	return p
}

func InitEmptyGraphPatternYieldItemContext(p *GraphPatternYieldItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphPatternYieldItem
}

func (*GraphPatternYieldItemContext) IsGraphPatternYieldItemContext() {}

func NewGraphPatternYieldItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphPatternYieldItemContext {
	var p = new(GraphPatternYieldItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphPatternYieldItem

	return p
}

func (s *GraphPatternYieldItemContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphPatternYieldItemContext) BindingVariableReference() IBindingVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableReferenceContext)
}

func (s *GraphPatternYieldItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphPatternYieldItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphPatternYieldItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphPatternYieldItem(s)
	}
}

func (s *GraphPatternYieldItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphPatternYieldItem(s)
	}
}

func (p *GQLParser) GraphPatternYieldItem() (localctx IGraphPatternYieldItemContext) {
	localctx = NewGraphPatternYieldItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, GQLParserRULE_graphPatternYieldItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2077)
		p.BindingVariableReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphPatternContext is an interface to support dynamic dispatch.
type IGraphPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PathPatternList() IPathPatternListContext
	MatchMode() IMatchModeContext
	KeepClause() IKeepClauseContext
	GraphPatternWhereClause() IGraphPatternWhereClauseContext

	// IsGraphPatternContext differentiates from other interfaces.
	IsGraphPatternContext()
}

type GraphPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphPatternContext() *GraphPatternContext {
	var p = new(GraphPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphPattern
	return p
}

func InitEmptyGraphPatternContext(p *GraphPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphPattern
}

func (*GraphPatternContext) IsGraphPatternContext() {}

func NewGraphPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphPatternContext {
	var p = new(GraphPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphPattern

	return p
}

func (s *GraphPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphPatternContext) PathPatternList() IPathPatternListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathPatternListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathPatternListContext)
}

func (s *GraphPatternContext) MatchMode() IMatchModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchModeContext)
}

func (s *GraphPatternContext) KeepClause() IKeepClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeepClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeepClauseContext)
}

func (s *GraphPatternContext) GraphPatternWhereClause() IGraphPatternWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphPatternWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphPatternWhereClauseContext)
}

func (s *GraphPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphPattern(s)
	}
}

func (s *GraphPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphPattern(s)
	}
}

func (p *GQLParser) GraphPattern() (localctx IGraphPatternContext) {
	localctx = NewGraphPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, GQLParserRULE_graphPattern)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2080)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2079)
			p.MatchMode()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2082)
		p.PathPatternList()
	}
	p.SetState(2084)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2083)
			p.KeepClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2087)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2086)
			p.GraphPatternWhereClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchModeContext is an interface to support dynamic dispatch.
type IMatchModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RepeatableElementsMatchMode() IRepeatableElementsMatchModeContext
	DifferentEdgesMatchMode() IDifferentEdgesMatchModeContext

	// IsMatchModeContext differentiates from other interfaces.
	IsMatchModeContext()
}

type MatchModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchModeContext() *MatchModeContext {
	var p = new(MatchModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_matchMode
	return p
}

func InitEmptyMatchModeContext(p *MatchModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_matchMode
}

func (*MatchModeContext) IsMatchModeContext() {}

func NewMatchModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchModeContext {
	var p = new(MatchModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_matchMode

	return p
}

func (s *MatchModeContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchModeContext) RepeatableElementsMatchMode() IRepeatableElementsMatchModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatableElementsMatchModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatableElementsMatchModeContext)
}

func (s *MatchModeContext) DifferentEdgesMatchMode() IDifferentEdgesMatchModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDifferentEdgesMatchModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDifferentEdgesMatchModeContext)
}

func (s *MatchModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterMatchMode(s)
	}
}

func (s *MatchModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitMatchMode(s)
	}
}

func (p *GQLParser) MatchMode() (localctx IMatchModeContext) {
	localctx = NewMatchModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, GQLParserRULE_matchMode)
	p.SetState(2091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserREPEATABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2089)
			p.RepeatableElementsMatchMode()
		}

	case GQLParserDIFFERENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2090)
			p.DifferentEdgesMatchMode()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepeatableElementsMatchModeContext is an interface to support dynamic dispatch.
type IRepeatableElementsMatchModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEATABLE() antlr.TerminalNode
	ElementBindingsOrElements() IElementBindingsOrElementsContext

	// IsRepeatableElementsMatchModeContext differentiates from other interfaces.
	IsRepeatableElementsMatchModeContext()
}

type RepeatableElementsMatchModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatableElementsMatchModeContext() *RepeatableElementsMatchModeContext {
	var p = new(RepeatableElementsMatchModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_repeatableElementsMatchMode
	return p
}

func InitEmptyRepeatableElementsMatchModeContext(p *RepeatableElementsMatchModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_repeatableElementsMatchMode
}

func (*RepeatableElementsMatchModeContext) IsRepeatableElementsMatchModeContext() {}

func NewRepeatableElementsMatchModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepeatableElementsMatchModeContext {
	var p = new(RepeatableElementsMatchModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_repeatableElementsMatchMode

	return p
}

func (s *RepeatableElementsMatchModeContext) GetParser() antlr.Parser { return s.parser }

func (s *RepeatableElementsMatchModeContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(GQLParserREPEATABLE, 0)
}

func (s *RepeatableElementsMatchModeContext) ElementBindingsOrElements() IElementBindingsOrElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementBindingsOrElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementBindingsOrElementsContext)
}

func (s *RepeatableElementsMatchModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatableElementsMatchModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepeatableElementsMatchModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterRepeatableElementsMatchMode(s)
	}
}

func (s *RepeatableElementsMatchModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitRepeatableElementsMatchMode(s)
	}
}

func (p *GQLParser) RepeatableElementsMatchMode() (localctx IRepeatableElementsMatchModeContext) {
	localctx = NewRepeatableElementsMatchModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, GQLParserRULE_repeatableElementsMatchMode)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2093)
		p.Match(GQLParserREPEATABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2094)
		p.ElementBindingsOrElements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDifferentEdgesMatchModeContext is an interface to support dynamic dispatch.
type IDifferentEdgesMatchModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DIFFERENT() antlr.TerminalNode
	EdgeBindingsOrEdges() IEdgeBindingsOrEdgesContext

	// IsDifferentEdgesMatchModeContext differentiates from other interfaces.
	IsDifferentEdgesMatchModeContext()
}

type DifferentEdgesMatchModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDifferentEdgesMatchModeContext() *DifferentEdgesMatchModeContext {
	var p = new(DifferentEdgesMatchModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_differentEdgesMatchMode
	return p
}

func InitEmptyDifferentEdgesMatchModeContext(p *DifferentEdgesMatchModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_differentEdgesMatchMode
}

func (*DifferentEdgesMatchModeContext) IsDifferentEdgesMatchModeContext() {}

func NewDifferentEdgesMatchModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DifferentEdgesMatchModeContext {
	var p = new(DifferentEdgesMatchModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_differentEdgesMatchMode

	return p
}

func (s *DifferentEdgesMatchModeContext) GetParser() antlr.Parser { return s.parser }

func (s *DifferentEdgesMatchModeContext) DIFFERENT() antlr.TerminalNode {
	return s.GetToken(GQLParserDIFFERENT, 0)
}

func (s *DifferentEdgesMatchModeContext) EdgeBindingsOrEdges() IEdgeBindingsOrEdgesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeBindingsOrEdgesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeBindingsOrEdgesContext)
}

func (s *DifferentEdgesMatchModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DifferentEdgesMatchModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DifferentEdgesMatchModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDifferentEdgesMatchMode(s)
	}
}

func (s *DifferentEdgesMatchModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDifferentEdgesMatchMode(s)
	}
}

func (p *GQLParser) DifferentEdgesMatchMode() (localctx IDifferentEdgesMatchModeContext) {
	localctx = NewDifferentEdgesMatchModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, GQLParserRULE_differentEdgesMatchMode)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2096)
		p.Match(GQLParserDIFFERENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2097)
		p.EdgeBindingsOrEdges()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementBindingsOrElementsContext is an interface to support dynamic dispatch.
type IElementBindingsOrElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELEMENT() antlr.TerminalNode
	BINDINGS() antlr.TerminalNode
	ELEMENTS() antlr.TerminalNode

	// IsElementBindingsOrElementsContext differentiates from other interfaces.
	IsElementBindingsOrElementsContext()
}

type ElementBindingsOrElementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementBindingsOrElementsContext() *ElementBindingsOrElementsContext {
	var p = new(ElementBindingsOrElementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementBindingsOrElements
	return p
}

func InitEmptyElementBindingsOrElementsContext(p *ElementBindingsOrElementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementBindingsOrElements
}

func (*ElementBindingsOrElementsContext) IsElementBindingsOrElementsContext() {}

func NewElementBindingsOrElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementBindingsOrElementsContext {
	var p = new(ElementBindingsOrElementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_elementBindingsOrElements

	return p
}

func (s *ElementBindingsOrElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementBindingsOrElementsContext) ELEMENT() antlr.TerminalNode {
	return s.GetToken(GQLParserELEMENT, 0)
}

func (s *ElementBindingsOrElementsContext) BINDINGS() antlr.TerminalNode {
	return s.GetToken(GQLParserBINDINGS, 0)
}

func (s *ElementBindingsOrElementsContext) ELEMENTS() antlr.TerminalNode {
	return s.GetToken(GQLParserELEMENTS, 0)
}

func (s *ElementBindingsOrElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementBindingsOrElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementBindingsOrElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterElementBindingsOrElements(s)
	}
}

func (s *ElementBindingsOrElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitElementBindingsOrElements(s)
	}
}

func (p *GQLParser) ElementBindingsOrElements() (localctx IElementBindingsOrElementsContext) {
	localctx = NewElementBindingsOrElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, GQLParserRULE_elementBindingsOrElements)
	p.SetState(2104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserELEMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2099)
			p.Match(GQLParserELEMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2101)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2100)
				p.Match(GQLParserBINDINGS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserELEMENTS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2103)
			p.Match(GQLParserELEMENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeBindingsOrEdgesContext is an interface to support dynamic dispatch.
type IEdgeBindingsOrEdgesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EdgeSynonym() IEdgeSynonymContext
	BINDINGS() antlr.TerminalNode
	EdgesSynonym() IEdgesSynonymContext

	// IsEdgeBindingsOrEdgesContext differentiates from other interfaces.
	IsEdgeBindingsOrEdgesContext()
}

type EdgeBindingsOrEdgesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeBindingsOrEdgesContext() *EdgeBindingsOrEdgesContext {
	var p = new(EdgeBindingsOrEdgesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeBindingsOrEdges
	return p
}

func InitEmptyEdgeBindingsOrEdgesContext(p *EdgeBindingsOrEdgesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeBindingsOrEdges
}

func (*EdgeBindingsOrEdgesContext) IsEdgeBindingsOrEdgesContext() {}

func NewEdgeBindingsOrEdgesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeBindingsOrEdgesContext {
	var p = new(EdgeBindingsOrEdgesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeBindingsOrEdges

	return p
}

func (s *EdgeBindingsOrEdgesContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeBindingsOrEdgesContext) EdgeSynonym() IEdgeSynonymContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeSynonymContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeSynonymContext)
}

func (s *EdgeBindingsOrEdgesContext) BINDINGS() antlr.TerminalNode {
	return s.GetToken(GQLParserBINDINGS, 0)
}

func (s *EdgeBindingsOrEdgesContext) EdgesSynonym() IEdgesSynonymContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgesSynonymContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgesSynonymContext)
}

func (s *EdgeBindingsOrEdgesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeBindingsOrEdgesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeBindingsOrEdgesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeBindingsOrEdges(s)
	}
}

func (s *EdgeBindingsOrEdgesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeBindingsOrEdges(s)
	}
}

func (p *GQLParser) EdgeBindingsOrEdges() (localctx IEdgeBindingsOrEdgesContext) {
	localctx = NewEdgeBindingsOrEdgesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, GQLParserRULE_edgeBindingsOrEdges)
	p.SetState(2111)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserEDGE, GQLParserRELATIONSHIP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2106)
			p.EdgeSynonym()
		}
		p.SetState(2108)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 152, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2107)
				p.Match(GQLParserBINDINGS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserEDGES, GQLParserRELATIONSHIPS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2110)
			p.EdgesSynonym()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathPatternListContext is an interface to support dynamic dispatch.
type IPathPatternListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPathPattern() []IPathPatternContext
	PathPattern(i int) IPathPatternContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPathPatternListContext differentiates from other interfaces.
	IsPathPatternListContext()
}

type PathPatternListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathPatternListContext() *PathPatternListContext {
	var p = new(PathPatternListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathPatternList
	return p
}

func InitEmptyPathPatternListContext(p *PathPatternListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathPatternList
}

func (*PathPatternListContext) IsPathPatternListContext() {}

func NewPathPatternListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathPatternListContext {
	var p = new(PathPatternListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathPatternList

	return p
}

func (s *PathPatternListContext) GetParser() antlr.Parser { return s.parser }

func (s *PathPatternListContext) AllPathPattern() []IPathPatternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPathPatternContext); ok {
			len++
		}
	}

	tst := make([]IPathPatternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPathPatternContext); ok {
			tst[i] = t.(IPathPatternContext)
			i++
		}
	}

	return tst
}

func (s *PathPatternListContext) PathPattern(i int) IPathPatternContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathPatternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathPatternContext)
}

func (s *PathPatternListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *PathPatternListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *PathPatternListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathPatternListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathPatternListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathPatternList(s)
	}
}

func (s *PathPatternListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathPatternList(s)
	}
}

func (p *GQLParser) PathPatternList() (localctx IPathPatternListContext) {
	localctx = NewPathPatternListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, GQLParserRULE_pathPatternList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2113)
		p.PathPattern()
	}
	p.SetState(2118)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2114)
				p.Match(GQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2115)
				p.PathPattern()
			}

		}
		p.SetState(2120)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathPatternContext is an interface to support dynamic dispatch.
type IPathPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PathPatternExpression() IPathPatternExpressionContext
	PathVariableDeclaration() IPathVariableDeclarationContext
	PathPatternPrefix() IPathPatternPrefixContext

	// IsPathPatternContext differentiates from other interfaces.
	IsPathPatternContext()
}

type PathPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathPatternContext() *PathPatternContext {
	var p = new(PathPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathPattern
	return p
}

func InitEmptyPathPatternContext(p *PathPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathPattern
}

func (*PathPatternContext) IsPathPatternContext() {}

func NewPathPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathPatternContext {
	var p = new(PathPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathPattern

	return p
}

func (s *PathPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *PathPatternContext) PathPatternExpression() IPathPatternExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathPatternExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathPatternExpressionContext)
}

func (s *PathPatternContext) PathVariableDeclaration() IPathVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathVariableDeclarationContext)
}

func (s *PathPatternContext) PathPatternPrefix() IPathPatternPrefixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathPatternPrefixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathPatternPrefixContext)
}

func (s *PathPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathPattern(s)
	}
}

func (s *PathPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathPattern(s)
	}
}

func (p *GQLParser) PathPattern() (localctx IPathPatternContext) {
	localctx = NewPathPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, GQLParserRULE_pathPattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2122)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2121)
			p.PathVariableDeclaration()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2125)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserALL || _la == GQLParserANY || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&9096740732929) != 0) {
		{
			p.SetState(2124)
			p.PathPatternPrefix()
		}

	}
	{
		p.SetState(2127)
		p.PathPatternExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathVariableDeclarationContext is an interface to support dynamic dispatch.
type IPathVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PathVariable() IPathVariableContext
	EQUALS_OPERATOR() antlr.TerminalNode

	// IsPathVariableDeclarationContext differentiates from other interfaces.
	IsPathVariableDeclarationContext()
}

type PathVariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathVariableDeclarationContext() *PathVariableDeclarationContext {
	var p = new(PathVariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathVariableDeclaration
	return p
}

func InitEmptyPathVariableDeclarationContext(p *PathVariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathVariableDeclaration
}

func (*PathVariableDeclarationContext) IsPathVariableDeclarationContext() {}

func NewPathVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathVariableDeclarationContext {
	var p = new(PathVariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathVariableDeclaration

	return p
}

func (s *PathVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PathVariableDeclarationContext) PathVariable() IPathVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathVariableContext)
}

func (s *PathVariableDeclarationContext) EQUALS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(GQLParserEQUALS_OPERATOR, 0)
}

func (s *PathVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathVariableDeclaration(s)
	}
}

func (s *PathVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathVariableDeclaration(s)
	}
}

func (p *GQLParser) PathVariableDeclaration() (localctx IPathVariableDeclarationContext) {
	localctx = NewPathVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, GQLParserRULE_pathVariableDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2129)
		p.PathVariable()
	}
	{
		p.SetState(2130)
		p.Match(GQLParserEQUALS_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeepClauseContext is an interface to support dynamic dispatch.
type IKeepClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEEP() antlr.TerminalNode
	PathPatternPrefix() IPathPatternPrefixContext

	// IsKeepClauseContext differentiates from other interfaces.
	IsKeepClauseContext()
}

type KeepClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeepClauseContext() *KeepClauseContext {
	var p = new(KeepClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_keepClause
	return p
}

func InitEmptyKeepClauseContext(p *KeepClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_keepClause
}

func (*KeepClauseContext) IsKeepClauseContext() {}

func NewKeepClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeepClauseContext {
	var p = new(KeepClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_keepClause

	return p
}

func (s *KeepClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *KeepClauseContext) KEEP() antlr.TerminalNode {
	return s.GetToken(GQLParserKEEP, 0)
}

func (s *KeepClauseContext) PathPatternPrefix() IPathPatternPrefixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathPatternPrefixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathPatternPrefixContext)
}

func (s *KeepClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeepClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeepClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterKeepClause(s)
	}
}

func (s *KeepClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitKeepClause(s)
	}
}

func (p *GQLParser) KeepClause() (localctx IKeepClauseContext) {
	localctx = NewKeepClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, GQLParserRULE_keepClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2132)
		p.Match(GQLParserKEEP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2133)
		p.PathPatternPrefix()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphPatternWhereClauseContext is an interface to support dynamic dispatch.
type IGraphPatternWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	SearchCondition() ISearchConditionContext

	// IsGraphPatternWhereClauseContext differentiates from other interfaces.
	IsGraphPatternWhereClauseContext()
}

type GraphPatternWhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphPatternWhereClauseContext() *GraphPatternWhereClauseContext {
	var p = new(GraphPatternWhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphPatternWhereClause
	return p
}

func InitEmptyGraphPatternWhereClauseContext(p *GraphPatternWhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphPatternWhereClause
}

func (*GraphPatternWhereClauseContext) IsGraphPatternWhereClauseContext() {}

func NewGraphPatternWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphPatternWhereClauseContext {
	var p = new(GraphPatternWhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphPatternWhereClause

	return p
}

func (s *GraphPatternWhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphPatternWhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(GQLParserWHERE, 0)
}

func (s *GraphPatternWhereClauseContext) SearchCondition() ISearchConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchConditionContext)
}

func (s *GraphPatternWhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphPatternWhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphPatternWhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphPatternWhereClause(s)
	}
}

func (s *GraphPatternWhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphPatternWhereClause(s)
	}
}

func (p *GQLParser) GraphPatternWhereClause() (localctx IGraphPatternWhereClauseContext) {
	localctx = NewGraphPatternWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, GQLParserRULE_graphPatternWhereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2135)
		p.Match(GQLParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2136)
		p.SearchCondition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertGraphPatternContext is an interface to support dynamic dispatch.
type IInsertGraphPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InsertPathPatternList() IInsertPathPatternListContext

	// IsInsertGraphPatternContext differentiates from other interfaces.
	IsInsertGraphPatternContext()
}

type InsertGraphPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertGraphPatternContext() *InsertGraphPatternContext {
	var p = new(InsertGraphPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertGraphPattern
	return p
}

func InitEmptyInsertGraphPatternContext(p *InsertGraphPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertGraphPattern
}

func (*InsertGraphPatternContext) IsInsertGraphPatternContext() {}

func NewInsertGraphPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertGraphPatternContext {
	var p = new(InsertGraphPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_insertGraphPattern

	return p
}

func (s *InsertGraphPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertGraphPatternContext) InsertPathPatternList() IInsertPathPatternListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertPathPatternListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertPathPatternListContext)
}

func (s *InsertGraphPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertGraphPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertGraphPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterInsertGraphPattern(s)
	}
}

func (s *InsertGraphPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitInsertGraphPattern(s)
	}
}

func (p *GQLParser) InsertGraphPattern() (localctx IInsertGraphPatternContext) {
	localctx = NewInsertGraphPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, GQLParserRULE_insertGraphPattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2138)
		p.InsertPathPatternList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertPathPatternListContext is an interface to support dynamic dispatch.
type IInsertPathPatternListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInsertPathPattern() []IInsertPathPatternContext
	InsertPathPattern(i int) IInsertPathPatternContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInsertPathPatternListContext differentiates from other interfaces.
	IsInsertPathPatternListContext()
}

type InsertPathPatternListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertPathPatternListContext() *InsertPathPatternListContext {
	var p = new(InsertPathPatternListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertPathPatternList
	return p
}

func InitEmptyInsertPathPatternListContext(p *InsertPathPatternListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertPathPatternList
}

func (*InsertPathPatternListContext) IsInsertPathPatternListContext() {}

func NewInsertPathPatternListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertPathPatternListContext {
	var p = new(InsertPathPatternListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_insertPathPatternList

	return p
}

func (s *InsertPathPatternListContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertPathPatternListContext) AllInsertPathPattern() []IInsertPathPatternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInsertPathPatternContext); ok {
			len++
		}
	}

	tst := make([]IInsertPathPatternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInsertPathPatternContext); ok {
			tst[i] = t.(IInsertPathPatternContext)
			i++
		}
	}

	return tst
}

func (s *InsertPathPatternListContext) InsertPathPattern(i int) IInsertPathPatternContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertPathPatternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertPathPatternContext)
}

func (s *InsertPathPatternListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *InsertPathPatternListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *InsertPathPatternListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertPathPatternListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertPathPatternListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterInsertPathPatternList(s)
	}
}

func (s *InsertPathPatternListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitInsertPathPatternList(s)
	}
}

func (p *GQLParser) InsertPathPatternList() (localctx IInsertPathPatternListContext) {
	localctx = NewInsertPathPatternListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, GQLParserRULE_insertPathPatternList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2140)
		p.InsertPathPattern()
	}
	p.SetState(2145)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(2141)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2142)
			p.InsertPathPattern()
		}

		p.SetState(2147)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertPathPatternContext is an interface to support dynamic dispatch.
type IInsertPathPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInsertNodePattern() []IInsertNodePatternContext
	InsertNodePattern(i int) IInsertNodePatternContext
	AllInsertEdgePattern() []IInsertEdgePatternContext
	InsertEdgePattern(i int) IInsertEdgePatternContext

	// IsInsertPathPatternContext differentiates from other interfaces.
	IsInsertPathPatternContext()
}

type InsertPathPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertPathPatternContext() *InsertPathPatternContext {
	var p = new(InsertPathPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertPathPattern
	return p
}

func InitEmptyInsertPathPatternContext(p *InsertPathPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertPathPattern
}

func (*InsertPathPatternContext) IsInsertPathPatternContext() {}

func NewInsertPathPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertPathPatternContext {
	var p = new(InsertPathPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_insertPathPattern

	return p
}

func (s *InsertPathPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertPathPatternContext) AllInsertNodePattern() []IInsertNodePatternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInsertNodePatternContext); ok {
			len++
		}
	}

	tst := make([]IInsertNodePatternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInsertNodePatternContext); ok {
			tst[i] = t.(IInsertNodePatternContext)
			i++
		}
	}

	return tst
}

func (s *InsertPathPatternContext) InsertNodePattern(i int) IInsertNodePatternContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertNodePatternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertNodePatternContext)
}

func (s *InsertPathPatternContext) AllInsertEdgePattern() []IInsertEdgePatternContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInsertEdgePatternContext); ok {
			len++
		}
	}

	tst := make([]IInsertEdgePatternContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInsertEdgePatternContext); ok {
			tst[i] = t.(IInsertEdgePatternContext)
			i++
		}
	}

	return tst
}

func (s *InsertPathPatternContext) InsertEdgePattern(i int) IInsertEdgePatternContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertEdgePatternContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertEdgePatternContext)
}

func (s *InsertPathPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertPathPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertPathPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterInsertPathPattern(s)
	}
}

func (s *InsertPathPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitInsertPathPattern(s)
	}
}

func (p *GQLParser) InsertPathPattern() (localctx IInsertPathPatternContext) {
	localctx = NewInsertPathPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, GQLParserRULE_insertPathPattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2148)
		p.InsertNodePattern()
	}
	p.SetState(2154)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-340)) & ^0x3f) == 0 && ((int64(1)<<(_la-340))&131137) != 0 {
		{
			p.SetState(2149)
			p.InsertEdgePattern()
		}
		{
			p.SetState(2150)
			p.InsertNodePattern()
		}

		p.SetState(2156)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertNodePatternContext is an interface to support dynamic dispatch.
type IInsertNodePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	InsertElementPatternFiller() IInsertElementPatternFillerContext

	// IsInsertNodePatternContext differentiates from other interfaces.
	IsInsertNodePatternContext()
}

type InsertNodePatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertNodePatternContext() *InsertNodePatternContext {
	var p = new(InsertNodePatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertNodePattern
	return p
}

func InitEmptyInsertNodePatternContext(p *InsertNodePatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertNodePattern
}

func (*InsertNodePatternContext) IsInsertNodePatternContext() {}

func NewInsertNodePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertNodePatternContext {
	var p = new(InsertNodePatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_insertNodePattern

	return p
}

func (s *InsertNodePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertNodePatternContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *InsertNodePatternContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *InsertNodePatternContext) InsertElementPatternFiller() IInsertElementPatternFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertElementPatternFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertElementPatternFillerContext)
}

func (s *InsertNodePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertNodePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertNodePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterInsertNodePattern(s)
	}
}

func (s *InsertNodePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitInsertNodePattern(s)
	}
}

func (p *GQLParser) InsertNodePattern() (localctx IInsertNodePatternContext) {
	localctx = NewInsertNodePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, GQLParserRULE_insertNodePattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2157)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserIS || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&281474976710655) != 0) || _la == GQLParserCOLON || _la == GQLParserLEFT_BRACE {
		{
			p.SetState(2158)
			p.InsertElementPatternFiller()
		}

	}
	{
		p.SetState(2161)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertEdgePatternContext is an interface to support dynamic dispatch.
type IInsertEdgePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InsertEdgePointingLeft() IInsertEdgePointingLeftContext
	InsertEdgePointingRight() IInsertEdgePointingRightContext
	InsertEdgeUndirected() IInsertEdgeUndirectedContext

	// IsInsertEdgePatternContext differentiates from other interfaces.
	IsInsertEdgePatternContext()
}

type InsertEdgePatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertEdgePatternContext() *InsertEdgePatternContext {
	var p = new(InsertEdgePatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertEdgePattern
	return p
}

func InitEmptyInsertEdgePatternContext(p *InsertEdgePatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertEdgePattern
}

func (*InsertEdgePatternContext) IsInsertEdgePatternContext() {}

func NewInsertEdgePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertEdgePatternContext {
	var p = new(InsertEdgePatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_insertEdgePattern

	return p
}

func (s *InsertEdgePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertEdgePatternContext) InsertEdgePointingLeft() IInsertEdgePointingLeftContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertEdgePointingLeftContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertEdgePointingLeftContext)
}

func (s *InsertEdgePatternContext) InsertEdgePointingRight() IInsertEdgePointingRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertEdgePointingRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertEdgePointingRightContext)
}

func (s *InsertEdgePatternContext) InsertEdgeUndirected() IInsertEdgeUndirectedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertEdgeUndirectedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertEdgeUndirectedContext)
}

func (s *InsertEdgePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertEdgePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertEdgePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterInsertEdgePattern(s)
	}
}

func (s *InsertEdgePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitInsertEdgePattern(s)
	}
}

func (p *GQLParser) InsertEdgePattern() (localctx IInsertEdgePatternContext) {
	localctx = NewInsertEdgePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, GQLParserRULE_insertEdgePattern)
	p.SetState(2166)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserLEFT_ARROW_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2163)
			p.InsertEdgePointingLeft()
		}

	case GQLParserMINUS_LEFT_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2164)
			p.InsertEdgePointingRight()
		}

	case GQLParserTILDE_LEFT_BRACKET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2165)
			p.InsertEdgeUndirected()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertEdgePointingLeftContext is an interface to support dynamic dispatch.
type IInsertEdgePointingLeftContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_ARROW_BRACKET() antlr.TerminalNode
	RIGHT_BRACKET_MINUS() antlr.TerminalNode
	InsertElementPatternFiller() IInsertElementPatternFillerContext

	// IsInsertEdgePointingLeftContext differentiates from other interfaces.
	IsInsertEdgePointingLeftContext()
}

type InsertEdgePointingLeftContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertEdgePointingLeftContext() *InsertEdgePointingLeftContext {
	var p = new(InsertEdgePointingLeftContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertEdgePointingLeft
	return p
}

func InitEmptyInsertEdgePointingLeftContext(p *InsertEdgePointingLeftContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertEdgePointingLeft
}

func (*InsertEdgePointingLeftContext) IsInsertEdgePointingLeftContext() {}

func NewInsertEdgePointingLeftContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertEdgePointingLeftContext {
	var p = new(InsertEdgePointingLeftContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_insertEdgePointingLeft

	return p
}

func (s *InsertEdgePointingLeftContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertEdgePointingLeftContext) LEFT_ARROW_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_ARROW_BRACKET, 0)
}

func (s *InsertEdgePointingLeftContext) RIGHT_BRACKET_MINUS() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET_MINUS, 0)
}

func (s *InsertEdgePointingLeftContext) InsertElementPatternFiller() IInsertElementPatternFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertElementPatternFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertElementPatternFillerContext)
}

func (s *InsertEdgePointingLeftContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertEdgePointingLeftContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertEdgePointingLeftContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterInsertEdgePointingLeft(s)
	}
}

func (s *InsertEdgePointingLeftContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitInsertEdgePointingLeft(s)
	}
}

func (p *GQLParser) InsertEdgePointingLeft() (localctx IInsertEdgePointingLeftContext) {
	localctx = NewInsertEdgePointingLeftContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, GQLParserRULE_insertEdgePointingLeft)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2168)
		p.Match(GQLParserLEFT_ARROW_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserIS || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&281474976710655) != 0) || _la == GQLParserCOLON || _la == GQLParserLEFT_BRACE {
		{
			p.SetState(2169)
			p.InsertElementPatternFiller()
		}

	}
	{
		p.SetState(2172)
		p.Match(GQLParserRIGHT_BRACKET_MINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertEdgePointingRightContext is an interface to support dynamic dispatch.
type IInsertEdgePointingRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS_LEFT_BRACKET() antlr.TerminalNode
	BRACKET_RIGHT_ARROW() antlr.TerminalNode
	InsertElementPatternFiller() IInsertElementPatternFillerContext

	// IsInsertEdgePointingRightContext differentiates from other interfaces.
	IsInsertEdgePointingRightContext()
}

type InsertEdgePointingRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertEdgePointingRightContext() *InsertEdgePointingRightContext {
	var p = new(InsertEdgePointingRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertEdgePointingRight
	return p
}

func InitEmptyInsertEdgePointingRightContext(p *InsertEdgePointingRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertEdgePointingRight
}

func (*InsertEdgePointingRightContext) IsInsertEdgePointingRightContext() {}

func NewInsertEdgePointingRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertEdgePointingRightContext {
	var p = new(InsertEdgePointingRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_insertEdgePointingRight

	return p
}

func (s *InsertEdgePointingRightContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertEdgePointingRightContext) MINUS_LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserMINUS_LEFT_BRACKET, 0)
}

func (s *InsertEdgePointingRightContext) BRACKET_RIGHT_ARROW() antlr.TerminalNode {
	return s.GetToken(GQLParserBRACKET_RIGHT_ARROW, 0)
}

func (s *InsertEdgePointingRightContext) InsertElementPatternFiller() IInsertElementPatternFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertElementPatternFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertElementPatternFillerContext)
}

func (s *InsertEdgePointingRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertEdgePointingRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertEdgePointingRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterInsertEdgePointingRight(s)
	}
}

func (s *InsertEdgePointingRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitInsertEdgePointingRight(s)
	}
}

func (p *GQLParser) InsertEdgePointingRight() (localctx IInsertEdgePointingRightContext) {
	localctx = NewInsertEdgePointingRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, GQLParserRULE_insertEdgePointingRight)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2174)
		p.Match(GQLParserMINUS_LEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2176)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserIS || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&281474976710655) != 0) || _la == GQLParserCOLON || _la == GQLParserLEFT_BRACE {
		{
			p.SetState(2175)
			p.InsertElementPatternFiller()
		}

	}
	{
		p.SetState(2178)
		p.Match(GQLParserBRACKET_RIGHT_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertEdgeUndirectedContext is an interface to support dynamic dispatch.
type IInsertEdgeUndirectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TILDE_LEFT_BRACKET() antlr.TerminalNode
	RIGHT_BRACKET_TILDE() antlr.TerminalNode
	InsertElementPatternFiller() IInsertElementPatternFillerContext

	// IsInsertEdgeUndirectedContext differentiates from other interfaces.
	IsInsertEdgeUndirectedContext()
}

type InsertEdgeUndirectedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertEdgeUndirectedContext() *InsertEdgeUndirectedContext {
	var p = new(InsertEdgeUndirectedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertEdgeUndirected
	return p
}

func InitEmptyInsertEdgeUndirectedContext(p *InsertEdgeUndirectedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertEdgeUndirected
}

func (*InsertEdgeUndirectedContext) IsInsertEdgeUndirectedContext() {}

func NewInsertEdgeUndirectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertEdgeUndirectedContext {
	var p = new(InsertEdgeUndirectedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_insertEdgeUndirected

	return p
}

func (s *InsertEdgeUndirectedContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertEdgeUndirectedContext) TILDE_LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserTILDE_LEFT_BRACKET, 0)
}

func (s *InsertEdgeUndirectedContext) RIGHT_BRACKET_TILDE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET_TILDE, 0)
}

func (s *InsertEdgeUndirectedContext) InsertElementPatternFiller() IInsertElementPatternFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertElementPatternFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertElementPatternFillerContext)
}

func (s *InsertEdgeUndirectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertEdgeUndirectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertEdgeUndirectedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterInsertEdgeUndirected(s)
	}
}

func (s *InsertEdgeUndirectedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitInsertEdgeUndirected(s)
	}
}

func (p *GQLParser) InsertEdgeUndirected() (localctx IInsertEdgeUndirectedContext) {
	localctx = NewInsertEdgeUndirectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, GQLParserRULE_insertEdgeUndirected)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2180)
		p.Match(GQLParserTILDE_LEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2182)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserIS || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&281474976710655) != 0) || _la == GQLParserCOLON || _la == GQLParserLEFT_BRACE {
		{
			p.SetState(2181)
			p.InsertElementPatternFiller()
		}

	}
	{
		p.SetState(2184)
		p.Match(GQLParserRIGHT_BRACKET_TILDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertElementPatternFillerContext is an interface to support dynamic dispatch.
type IInsertElementPatternFillerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementVariableDeclaration() IElementVariableDeclarationContext
	LabelAndPropertySetSpecification() ILabelAndPropertySetSpecificationContext

	// IsInsertElementPatternFillerContext differentiates from other interfaces.
	IsInsertElementPatternFillerContext()
}

type InsertElementPatternFillerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertElementPatternFillerContext() *InsertElementPatternFillerContext {
	var p = new(InsertElementPatternFillerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertElementPatternFiller
	return p
}

func InitEmptyInsertElementPatternFillerContext(p *InsertElementPatternFillerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_insertElementPatternFiller
}

func (*InsertElementPatternFillerContext) IsInsertElementPatternFillerContext() {}

func NewInsertElementPatternFillerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertElementPatternFillerContext {
	var p = new(InsertElementPatternFillerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_insertElementPatternFiller

	return p
}

func (s *InsertElementPatternFillerContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertElementPatternFillerContext) ElementVariableDeclaration() IElementVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementVariableDeclarationContext)
}

func (s *InsertElementPatternFillerContext) LabelAndPropertySetSpecification() ILabelAndPropertySetSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelAndPropertySetSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelAndPropertySetSpecificationContext)
}

func (s *InsertElementPatternFillerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertElementPatternFillerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertElementPatternFillerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterInsertElementPatternFiller(s)
	}
}

func (s *InsertElementPatternFillerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitInsertElementPatternFiller(s)
	}
}

func (p *GQLParser) InsertElementPatternFiller() (localctx IInsertElementPatternFillerContext) {
	localctx = NewInsertElementPatternFillerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, GQLParserRULE_insertElementPatternFiller)
	var _la int

	p.SetState(2194)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2186)
			p.ElementVariableDeclaration()
		}
		p.SetState(2188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserIS || _la == GQLParserCOLON || _la == GQLParserLEFT_BRACE {
			{
				p.SetState(2187)
				p.LabelAndPropertySetSpecification()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2191)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&281474976710655) != 0 {
			{
				p.SetState(2190)
				p.ElementVariableDeclaration()
			}

		}
		{
			p.SetState(2193)
			p.LabelAndPropertySetSpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelAndPropertySetSpecificationContext is an interface to support dynamic dispatch.
type ILabelAndPropertySetSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IsOrColon() IIsOrColonContext
	LabelSetSpecification() ILabelSetSpecificationContext
	ElementPropertySpecification() IElementPropertySpecificationContext

	// IsLabelAndPropertySetSpecificationContext differentiates from other interfaces.
	IsLabelAndPropertySetSpecificationContext()
}

type LabelAndPropertySetSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelAndPropertySetSpecificationContext() *LabelAndPropertySetSpecificationContext {
	var p = new(LabelAndPropertySetSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_labelAndPropertySetSpecification
	return p
}

func InitEmptyLabelAndPropertySetSpecificationContext(p *LabelAndPropertySetSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_labelAndPropertySetSpecification
}

func (*LabelAndPropertySetSpecificationContext) IsLabelAndPropertySetSpecificationContext() {}

func NewLabelAndPropertySetSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelAndPropertySetSpecificationContext {
	var p = new(LabelAndPropertySetSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_labelAndPropertySetSpecification

	return p
}

func (s *LabelAndPropertySetSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelAndPropertySetSpecificationContext) IsOrColon() IIsOrColonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsOrColonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsOrColonContext)
}

func (s *LabelAndPropertySetSpecificationContext) LabelSetSpecification() ILabelSetSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelSetSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelSetSpecificationContext)
}

func (s *LabelAndPropertySetSpecificationContext) ElementPropertySpecification() IElementPropertySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementPropertySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementPropertySpecificationContext)
}

func (s *LabelAndPropertySetSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelAndPropertySetSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelAndPropertySetSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLabelAndPropertySetSpecification(s)
	}
}

func (s *LabelAndPropertySetSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLabelAndPropertySetSpecification(s)
	}
}

func (p *GQLParser) LabelAndPropertySetSpecification() (localctx ILabelAndPropertySetSpecificationContext) {
	localctx = NewLabelAndPropertySetSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, GQLParserRULE_labelAndPropertySetSpecification)
	var _la int

	p.SetState(2207)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2196)
			p.IsOrColon()
		}
		{
			p.SetState(2197)
			p.LabelSetSpecification()
		}
		p.SetState(2199)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserLEFT_BRACE {
			{
				p.SetState(2198)
				p.ElementPropertySpecification()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserIS || _la == GQLParserCOLON {
			{
				p.SetState(2201)
				p.IsOrColon()
			}
			{
				p.SetState(2202)
				p.LabelSetSpecification()
			}

		}
		{
			p.SetState(2206)
			p.ElementPropertySpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathPatternPrefixContext is an interface to support dynamic dispatch.
type IPathPatternPrefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PathModePrefix() IPathModePrefixContext
	PathSearchPrefix() IPathSearchPrefixContext

	// IsPathPatternPrefixContext differentiates from other interfaces.
	IsPathPatternPrefixContext()
}

type PathPatternPrefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathPatternPrefixContext() *PathPatternPrefixContext {
	var p = new(PathPatternPrefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathPatternPrefix
	return p
}

func InitEmptyPathPatternPrefixContext(p *PathPatternPrefixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathPatternPrefix
}

func (*PathPatternPrefixContext) IsPathPatternPrefixContext() {}

func NewPathPatternPrefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathPatternPrefixContext {
	var p = new(PathPatternPrefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathPatternPrefix

	return p
}

func (s *PathPatternPrefixContext) GetParser() antlr.Parser { return s.parser }

func (s *PathPatternPrefixContext) PathModePrefix() IPathModePrefixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathModePrefixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathModePrefixContext)
}

func (s *PathPatternPrefixContext) PathSearchPrefix() IPathSearchPrefixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathSearchPrefixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathSearchPrefixContext)
}

func (s *PathPatternPrefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathPatternPrefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathPatternPrefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathPatternPrefix(s)
	}
}

func (s *PathPatternPrefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathPatternPrefix(s)
	}
}

func (p *GQLParser) PathPatternPrefix() (localctx IPathPatternPrefixContext) {
	localctx = NewPathPatternPrefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, GQLParserRULE_pathPatternPrefix)
	p.SetState(2211)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserACYCLIC, GQLParserSIMPLE, GQLParserTRAIL, GQLParserWALK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2209)
			p.PathModePrefix()
		}

	case GQLParserALL, GQLParserANY, GQLParserSHORTEST:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2210)
			p.PathSearchPrefix()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathModePrefixContext is an interface to support dynamic dispatch.
type IPathModePrefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PathMode() IPathModeContext
	PathOrPaths() IPathOrPathsContext

	// IsPathModePrefixContext differentiates from other interfaces.
	IsPathModePrefixContext()
}

type PathModePrefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathModePrefixContext() *PathModePrefixContext {
	var p = new(PathModePrefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathModePrefix
	return p
}

func InitEmptyPathModePrefixContext(p *PathModePrefixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathModePrefix
}

func (*PathModePrefixContext) IsPathModePrefixContext() {}

func NewPathModePrefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathModePrefixContext {
	var p = new(PathModePrefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathModePrefix

	return p
}

func (s *PathModePrefixContext) GetParser() antlr.Parser { return s.parser }

func (s *PathModePrefixContext) PathMode() IPathModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathModeContext)
}

func (s *PathModePrefixContext) PathOrPaths() IPathOrPathsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathOrPathsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathOrPathsContext)
}

func (s *PathModePrefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathModePrefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathModePrefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathModePrefix(s)
	}
}

func (s *PathModePrefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathModePrefix(s)
	}
}

func (p *GQLParser) PathModePrefix() (localctx IPathModePrefixContext) {
	localctx = NewPathModePrefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, GQLParserRULE_pathModePrefix)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2213)
		p.PathMode()
	}
	p.SetState(2215)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2214)
			p.PathOrPaths()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathModeContext is an interface to support dynamic dispatch.
type IPathModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WALK() antlr.TerminalNode
	TRAIL() antlr.TerminalNode
	SIMPLE() antlr.TerminalNode
	ACYCLIC() antlr.TerminalNode

	// IsPathModeContext differentiates from other interfaces.
	IsPathModeContext()
}

type PathModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathModeContext() *PathModeContext {
	var p = new(PathModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathMode
	return p
}

func InitEmptyPathModeContext(p *PathModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathMode
}

func (*PathModeContext) IsPathModeContext() {}

func NewPathModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathModeContext {
	var p = new(PathModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathMode

	return p
}

func (s *PathModeContext) GetParser() antlr.Parser { return s.parser }

func (s *PathModeContext) WALK() antlr.TerminalNode {
	return s.GetToken(GQLParserWALK, 0)
}

func (s *PathModeContext) TRAIL() antlr.TerminalNode {
	return s.GetToken(GQLParserTRAIL, 0)
}

func (s *PathModeContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(GQLParserSIMPLE, 0)
}

func (s *PathModeContext) ACYCLIC() antlr.TerminalNode {
	return s.GetToken(GQLParserACYCLIC, 0)
}

func (s *PathModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathMode(s)
	}
}

func (s *PathModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathMode(s)
	}
}

func (p *GQLParser) PathMode() (localctx IPathModeContext) {
	localctx = NewPathModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, GQLParserRULE_pathMode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2217)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&9088150798337) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathSearchPrefixContext is an interface to support dynamic dispatch.
type IPathSearchPrefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPathSearch() IAllPathSearchContext
	AnyPathSearch() IAnyPathSearchContext
	ShortestPathSearch() IShortestPathSearchContext

	// IsPathSearchPrefixContext differentiates from other interfaces.
	IsPathSearchPrefixContext()
}

type PathSearchPrefixContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathSearchPrefixContext() *PathSearchPrefixContext {
	var p = new(PathSearchPrefixContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathSearchPrefix
	return p
}

func InitEmptyPathSearchPrefixContext(p *PathSearchPrefixContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathSearchPrefix
}

func (*PathSearchPrefixContext) IsPathSearchPrefixContext() {}

func NewPathSearchPrefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathSearchPrefixContext {
	var p = new(PathSearchPrefixContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathSearchPrefix

	return p
}

func (s *PathSearchPrefixContext) GetParser() antlr.Parser { return s.parser }

func (s *PathSearchPrefixContext) AllPathSearch() IAllPathSearchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllPathSearchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllPathSearchContext)
}

func (s *PathSearchPrefixContext) AnyPathSearch() IAnyPathSearchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyPathSearchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyPathSearchContext)
}

func (s *PathSearchPrefixContext) ShortestPathSearch() IShortestPathSearchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShortestPathSearchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShortestPathSearchContext)
}

func (s *PathSearchPrefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathSearchPrefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathSearchPrefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathSearchPrefix(s)
	}
}

func (s *PathSearchPrefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathSearchPrefix(s)
	}
}

func (p *GQLParser) PathSearchPrefix() (localctx IPathSearchPrefixContext) {
	localctx = NewPathSearchPrefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, GQLParserRULE_pathSearchPrefix)
	p.SetState(2222)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2219)
			p.AllPathSearch()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2220)
			p.AnyPathSearch()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2221)
			p.ShortestPathSearch()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAllPathSearchContext is an interface to support dynamic dispatch.
type IAllPathSearchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	PathMode() IPathModeContext
	PathOrPaths() IPathOrPathsContext

	// IsAllPathSearchContext differentiates from other interfaces.
	IsAllPathSearchContext()
}

type AllPathSearchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllPathSearchContext() *AllPathSearchContext {
	var p = new(AllPathSearchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_allPathSearch
	return p
}

func InitEmptyAllPathSearchContext(p *AllPathSearchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_allPathSearch
}

func (*AllPathSearchContext) IsAllPathSearchContext() {}

func NewAllPathSearchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllPathSearchContext {
	var p = new(AllPathSearchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_allPathSearch

	return p
}

func (s *AllPathSearchContext) GetParser() antlr.Parser { return s.parser }

func (s *AllPathSearchContext) ALL() antlr.TerminalNode {
	return s.GetToken(GQLParserALL, 0)
}

func (s *AllPathSearchContext) PathMode() IPathModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathModeContext)
}

func (s *AllPathSearchContext) PathOrPaths() IPathOrPathsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathOrPathsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathOrPathsContext)
}

func (s *AllPathSearchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllPathSearchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AllPathSearchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAllPathSearch(s)
	}
}

func (s *AllPathSearchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAllPathSearch(s)
	}
}

func (p *GQLParser) AllPathSearch() (localctx IAllPathSearchContext) {
	localctx = NewAllPathSearchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, GQLParserRULE_allPathSearch)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2224)
		p.Match(GQLParserALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2226)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2225)
			p.PathMode()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2229)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2228)
			p.PathOrPaths()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathOrPathsContext is an interface to support dynamic dispatch.
type IPathOrPathsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PATH() antlr.TerminalNode
	PATHS() antlr.TerminalNode

	// IsPathOrPathsContext differentiates from other interfaces.
	IsPathOrPathsContext()
}

type PathOrPathsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathOrPathsContext() *PathOrPathsContext {
	var p = new(PathOrPathsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathOrPaths
	return p
}

func InitEmptyPathOrPathsContext(p *PathOrPathsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathOrPaths
}

func (*PathOrPathsContext) IsPathOrPathsContext() {}

func NewPathOrPathsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathOrPathsContext {
	var p = new(PathOrPathsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathOrPaths

	return p
}

func (s *PathOrPathsContext) GetParser() antlr.Parser { return s.parser }

func (s *PathOrPathsContext) PATH() antlr.TerminalNode {
	return s.GetToken(GQLParserPATH, 0)
}

func (s *PathOrPathsContext) PATHS() antlr.TerminalNode {
	return s.GetToken(GQLParserPATHS, 0)
}

func (s *PathOrPathsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathOrPathsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathOrPathsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathOrPaths(s)
	}
}

func (s *PathOrPathsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathOrPaths(s)
	}
}

func (p *GQLParser) PathOrPaths() (localctx IPathOrPathsContext) {
	localctx = NewPathOrPathsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, GQLParserRULE_pathOrPaths)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2231)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserPATH || _la == GQLParserPATHS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnyPathSearchContext is an interface to support dynamic dispatch.
type IAnyPathSearchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANY() antlr.TerminalNode
	NumberOfPaths() INumberOfPathsContext
	PathMode() IPathModeContext
	PathOrPaths() IPathOrPathsContext

	// IsAnyPathSearchContext differentiates from other interfaces.
	IsAnyPathSearchContext()
}

type AnyPathSearchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyPathSearchContext() *AnyPathSearchContext {
	var p = new(AnyPathSearchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_anyPathSearch
	return p
}

func InitEmptyAnyPathSearchContext(p *AnyPathSearchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_anyPathSearch
}

func (*AnyPathSearchContext) IsAnyPathSearchContext() {}

func NewAnyPathSearchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyPathSearchContext {
	var p = new(AnyPathSearchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_anyPathSearch

	return p
}

func (s *AnyPathSearchContext) GetParser() antlr.Parser { return s.parser }

func (s *AnyPathSearchContext) ANY() antlr.TerminalNode {
	return s.GetToken(GQLParserANY, 0)
}

func (s *AnyPathSearchContext) NumberOfPaths() INumberOfPathsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberOfPathsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberOfPathsContext)
}

func (s *AnyPathSearchContext) PathMode() IPathModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathModeContext)
}

func (s *AnyPathSearchContext) PathOrPaths() IPathOrPathsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathOrPathsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathOrPathsContext)
}

func (s *AnyPathSearchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyPathSearchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnyPathSearchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAnyPathSearch(s)
	}
}

func (s *AnyPathSearchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAnyPathSearch(s)
	}
}

func (p *GQLParser) AnyPathSearch() (localctx IAnyPathSearchContext) {
	localctx = NewAnyPathSearchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, GQLParserRULE_anyPathSearch)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2233)
		p.Match(GQLParserANY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2235)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2234)
			p.NumberOfPaths()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2238)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2237)
			p.PathMode()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2241)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2240)
			p.PathOrPaths()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberOfPathsContext is an interface to support dynamic dispatch.
type INumberOfPathsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NonNegativeIntegerSpecification() INonNegativeIntegerSpecificationContext

	// IsNumberOfPathsContext differentiates from other interfaces.
	IsNumberOfPathsContext()
}

type NumberOfPathsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberOfPathsContext() *NumberOfPathsContext {
	var p = new(NumberOfPathsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numberOfPaths
	return p
}

func InitEmptyNumberOfPathsContext(p *NumberOfPathsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numberOfPaths
}

func (*NumberOfPathsContext) IsNumberOfPathsContext() {}

func NewNumberOfPathsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberOfPathsContext {
	var p = new(NumberOfPathsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_numberOfPaths

	return p
}

func (s *NumberOfPathsContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberOfPathsContext) NonNegativeIntegerSpecification() INonNegativeIntegerSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonNegativeIntegerSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonNegativeIntegerSpecificationContext)
}

func (s *NumberOfPathsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberOfPathsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberOfPathsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNumberOfPaths(s)
	}
}

func (s *NumberOfPathsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNumberOfPaths(s)
	}
}

func (p *GQLParser) NumberOfPaths() (localctx INumberOfPathsContext) {
	localctx = NewNumberOfPathsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, GQLParserRULE_numberOfPaths)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2243)
		p.NonNegativeIntegerSpecification()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShortestPathSearchContext is an interface to support dynamic dispatch.
type IShortestPathSearchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllShortestPathSearch() IAllShortestPathSearchContext
	AnyShortestPathSearch() IAnyShortestPathSearchContext
	CountedShortestPathSearch() ICountedShortestPathSearchContext
	CountedShortestGroupSearch() ICountedShortestGroupSearchContext

	// IsShortestPathSearchContext differentiates from other interfaces.
	IsShortestPathSearchContext()
}

type ShortestPathSearchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShortestPathSearchContext() *ShortestPathSearchContext {
	var p = new(ShortestPathSearchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_shortestPathSearch
	return p
}

func InitEmptyShortestPathSearchContext(p *ShortestPathSearchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_shortestPathSearch
}

func (*ShortestPathSearchContext) IsShortestPathSearchContext() {}

func NewShortestPathSearchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShortestPathSearchContext {
	var p = new(ShortestPathSearchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_shortestPathSearch

	return p
}

func (s *ShortestPathSearchContext) GetParser() antlr.Parser { return s.parser }

func (s *ShortestPathSearchContext) AllShortestPathSearch() IAllShortestPathSearchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllShortestPathSearchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllShortestPathSearchContext)
}

func (s *ShortestPathSearchContext) AnyShortestPathSearch() IAnyShortestPathSearchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyShortestPathSearchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyShortestPathSearchContext)
}

func (s *ShortestPathSearchContext) CountedShortestPathSearch() ICountedShortestPathSearchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICountedShortestPathSearchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICountedShortestPathSearchContext)
}

func (s *ShortestPathSearchContext) CountedShortestGroupSearch() ICountedShortestGroupSearchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICountedShortestGroupSearchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICountedShortestGroupSearchContext)
}

func (s *ShortestPathSearchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortestPathSearchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShortestPathSearchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterShortestPathSearch(s)
	}
}

func (s *ShortestPathSearchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitShortestPathSearch(s)
	}
}

func (p *GQLParser) ShortestPathSearch() (localctx IShortestPathSearchContext) {
	localctx = NewShortestPathSearchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, GQLParserRULE_shortestPathSearch)
	p.SetState(2249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2245)
			p.AllShortestPathSearch()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2246)
			p.AnyShortestPathSearch()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2247)
			p.CountedShortestPathSearch()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2248)
			p.CountedShortestGroupSearch()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAllShortestPathSearchContext is an interface to support dynamic dispatch.
type IAllShortestPathSearchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	SHORTEST() antlr.TerminalNode
	PathMode() IPathModeContext
	PathOrPaths() IPathOrPathsContext

	// IsAllShortestPathSearchContext differentiates from other interfaces.
	IsAllShortestPathSearchContext()
}

type AllShortestPathSearchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllShortestPathSearchContext() *AllShortestPathSearchContext {
	var p = new(AllShortestPathSearchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_allShortestPathSearch
	return p
}

func InitEmptyAllShortestPathSearchContext(p *AllShortestPathSearchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_allShortestPathSearch
}

func (*AllShortestPathSearchContext) IsAllShortestPathSearchContext() {}

func NewAllShortestPathSearchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllShortestPathSearchContext {
	var p = new(AllShortestPathSearchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_allShortestPathSearch

	return p
}

func (s *AllShortestPathSearchContext) GetParser() antlr.Parser { return s.parser }

func (s *AllShortestPathSearchContext) ALL() antlr.TerminalNode {
	return s.GetToken(GQLParserALL, 0)
}

func (s *AllShortestPathSearchContext) SHORTEST() antlr.TerminalNode {
	return s.GetToken(GQLParserSHORTEST, 0)
}

func (s *AllShortestPathSearchContext) PathMode() IPathModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathModeContext)
}

func (s *AllShortestPathSearchContext) PathOrPaths() IPathOrPathsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathOrPathsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathOrPathsContext)
}

func (s *AllShortestPathSearchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllShortestPathSearchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AllShortestPathSearchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAllShortestPathSearch(s)
	}
}

func (s *AllShortestPathSearchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAllShortestPathSearch(s)
	}
}

func (p *GQLParser) AllShortestPathSearch() (localctx IAllShortestPathSearchContext) {
	localctx = NewAllShortestPathSearchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, GQLParserRULE_allShortestPathSearch)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2251)
		p.Match(GQLParserALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2252)
		p.Match(GQLParserSHORTEST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2254)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2253)
			p.PathMode()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2257)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2256)
			p.PathOrPaths()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnyShortestPathSearchContext is an interface to support dynamic dispatch.
type IAnyShortestPathSearchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANY() antlr.TerminalNode
	SHORTEST() antlr.TerminalNode
	PathMode() IPathModeContext
	PathOrPaths() IPathOrPathsContext

	// IsAnyShortestPathSearchContext differentiates from other interfaces.
	IsAnyShortestPathSearchContext()
}

type AnyShortestPathSearchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyShortestPathSearchContext() *AnyShortestPathSearchContext {
	var p = new(AnyShortestPathSearchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_anyShortestPathSearch
	return p
}

func InitEmptyAnyShortestPathSearchContext(p *AnyShortestPathSearchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_anyShortestPathSearch
}

func (*AnyShortestPathSearchContext) IsAnyShortestPathSearchContext() {}

func NewAnyShortestPathSearchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyShortestPathSearchContext {
	var p = new(AnyShortestPathSearchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_anyShortestPathSearch

	return p
}

func (s *AnyShortestPathSearchContext) GetParser() antlr.Parser { return s.parser }

func (s *AnyShortestPathSearchContext) ANY() antlr.TerminalNode {
	return s.GetToken(GQLParserANY, 0)
}

func (s *AnyShortestPathSearchContext) SHORTEST() antlr.TerminalNode {
	return s.GetToken(GQLParserSHORTEST, 0)
}

func (s *AnyShortestPathSearchContext) PathMode() IPathModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathModeContext)
}

func (s *AnyShortestPathSearchContext) PathOrPaths() IPathOrPathsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathOrPathsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathOrPathsContext)
}

func (s *AnyShortestPathSearchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyShortestPathSearchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnyShortestPathSearchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAnyShortestPathSearch(s)
	}
}

func (s *AnyShortestPathSearchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAnyShortestPathSearch(s)
	}
}

func (p *GQLParser) AnyShortestPathSearch() (localctx IAnyShortestPathSearchContext) {
	localctx = NewAnyShortestPathSearchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, GQLParserRULE_anyShortestPathSearch)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2259)
		p.Match(GQLParserANY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2260)
		p.Match(GQLParserSHORTEST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2262)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2261)
			p.PathMode()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2265)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2264)
			p.PathOrPaths()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICountedShortestPathSearchContext is an interface to support dynamic dispatch.
type ICountedShortestPathSearchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHORTEST() antlr.TerminalNode
	NumberOfPaths() INumberOfPathsContext
	PathMode() IPathModeContext
	PathOrPaths() IPathOrPathsContext

	// IsCountedShortestPathSearchContext differentiates from other interfaces.
	IsCountedShortestPathSearchContext()
}

type CountedShortestPathSearchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCountedShortestPathSearchContext() *CountedShortestPathSearchContext {
	var p = new(CountedShortestPathSearchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_countedShortestPathSearch
	return p
}

func InitEmptyCountedShortestPathSearchContext(p *CountedShortestPathSearchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_countedShortestPathSearch
}

func (*CountedShortestPathSearchContext) IsCountedShortestPathSearchContext() {}

func NewCountedShortestPathSearchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CountedShortestPathSearchContext {
	var p = new(CountedShortestPathSearchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_countedShortestPathSearch

	return p
}

func (s *CountedShortestPathSearchContext) GetParser() antlr.Parser { return s.parser }

func (s *CountedShortestPathSearchContext) SHORTEST() antlr.TerminalNode {
	return s.GetToken(GQLParserSHORTEST, 0)
}

func (s *CountedShortestPathSearchContext) NumberOfPaths() INumberOfPathsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberOfPathsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberOfPathsContext)
}

func (s *CountedShortestPathSearchContext) PathMode() IPathModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathModeContext)
}

func (s *CountedShortestPathSearchContext) PathOrPaths() IPathOrPathsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathOrPathsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathOrPathsContext)
}

func (s *CountedShortestPathSearchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CountedShortestPathSearchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CountedShortestPathSearchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCountedShortestPathSearch(s)
	}
}

func (s *CountedShortestPathSearchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCountedShortestPathSearch(s)
	}
}

func (p *GQLParser) CountedShortestPathSearch() (localctx ICountedShortestPathSearchContext) {
	localctx = NewCountedShortestPathSearchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, GQLParserRULE_countedShortestPathSearch)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2267)
		p.Match(GQLParserSHORTEST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2268)
		p.NumberOfPaths()
	}
	p.SetState(2270)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2269)
			p.PathMode()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2273)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2272)
			p.PathOrPaths()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICountedShortestGroupSearchContext is an interface to support dynamic dispatch.
type ICountedShortestGroupSearchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHORTEST() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	NumberOfGroups() INumberOfGroupsContext
	PathMode() IPathModeContext
	PathOrPaths() IPathOrPathsContext

	// IsCountedShortestGroupSearchContext differentiates from other interfaces.
	IsCountedShortestGroupSearchContext()
}

type CountedShortestGroupSearchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCountedShortestGroupSearchContext() *CountedShortestGroupSearchContext {
	var p = new(CountedShortestGroupSearchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_countedShortestGroupSearch
	return p
}

func InitEmptyCountedShortestGroupSearchContext(p *CountedShortestGroupSearchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_countedShortestGroupSearch
}

func (*CountedShortestGroupSearchContext) IsCountedShortestGroupSearchContext() {}

func NewCountedShortestGroupSearchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CountedShortestGroupSearchContext {
	var p = new(CountedShortestGroupSearchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_countedShortestGroupSearch

	return p
}

func (s *CountedShortestGroupSearchContext) GetParser() antlr.Parser { return s.parser }

func (s *CountedShortestGroupSearchContext) SHORTEST() antlr.TerminalNode {
	return s.GetToken(GQLParserSHORTEST, 0)
}

func (s *CountedShortestGroupSearchContext) GROUP() antlr.TerminalNode {
	return s.GetToken(GQLParserGROUP, 0)
}

func (s *CountedShortestGroupSearchContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(GQLParserGROUPS, 0)
}

func (s *CountedShortestGroupSearchContext) NumberOfGroups() INumberOfGroupsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberOfGroupsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberOfGroupsContext)
}

func (s *CountedShortestGroupSearchContext) PathMode() IPathModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathModeContext)
}

func (s *CountedShortestGroupSearchContext) PathOrPaths() IPathOrPathsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathOrPathsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathOrPathsContext)
}

func (s *CountedShortestGroupSearchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CountedShortestGroupSearchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CountedShortestGroupSearchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCountedShortestGroupSearch(s)
	}
}

func (s *CountedShortestGroupSearchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCountedShortestGroupSearch(s)
	}
}

func (p *GQLParser) CountedShortestGroupSearch() (localctx ICountedShortestGroupSearchContext) {
	localctx = NewCountedShortestGroupSearchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, GQLParserRULE_countedShortestGroupSearch)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2275)
		p.Match(GQLParserSHORTEST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2277)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7864320) != 0) || _la == GQLParserGENERAL_PARAMETER_REFERENCE {
		{
			p.SetState(2276)
			p.NumberOfGroups()
		}

	}
	p.SetState(2280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&9088150798337) != 0 {
		{
			p.SetState(2279)
			p.PathMode()
		}

	}
	p.SetState(2283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserPATH || _la == GQLParserPATHS {
		{
			p.SetState(2282)
			p.PathOrPaths()
		}

	}
	{
		p.SetState(2285)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserGROUP || _la == GQLParserGROUPS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberOfGroupsContext is an interface to support dynamic dispatch.
type INumberOfGroupsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NonNegativeIntegerSpecification() INonNegativeIntegerSpecificationContext

	// IsNumberOfGroupsContext differentiates from other interfaces.
	IsNumberOfGroupsContext()
}

type NumberOfGroupsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberOfGroupsContext() *NumberOfGroupsContext {
	var p = new(NumberOfGroupsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numberOfGroups
	return p
}

func InitEmptyNumberOfGroupsContext(p *NumberOfGroupsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numberOfGroups
}

func (*NumberOfGroupsContext) IsNumberOfGroupsContext() {}

func NewNumberOfGroupsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberOfGroupsContext {
	var p = new(NumberOfGroupsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_numberOfGroups

	return p
}

func (s *NumberOfGroupsContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberOfGroupsContext) NonNegativeIntegerSpecification() INonNegativeIntegerSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonNegativeIntegerSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonNegativeIntegerSpecificationContext)
}

func (s *NumberOfGroupsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberOfGroupsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberOfGroupsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNumberOfGroups(s)
	}
}

func (s *NumberOfGroupsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNumberOfGroups(s)
	}
}

func (p *GQLParser) NumberOfGroups() (localctx INumberOfGroupsContext) {
	localctx = NewNumberOfGroupsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, GQLParserRULE_numberOfGroups)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2287)
		p.NonNegativeIntegerSpecification()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathPatternExpressionContext is an interface to support dynamic dispatch.
type IPathPatternExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPathPatternExpressionContext differentiates from other interfaces.
	IsPathPatternExpressionContext()
}

type PathPatternExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathPatternExpressionContext() *PathPatternExpressionContext {
	var p = new(PathPatternExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathPatternExpression
	return p
}

func InitEmptyPathPatternExpressionContext(p *PathPatternExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathPatternExpression
}

func (*PathPatternExpressionContext) IsPathPatternExpressionContext() {}

func NewPathPatternExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathPatternExpressionContext {
	var p = new(PathPatternExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathPatternExpression

	return p
}

func (s *PathPatternExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PathPatternExpressionContext) CopyAll(ctx *PathPatternExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PathPatternExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathPatternExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PpePatternUnionContext struct {
	PathPatternExpressionContext
}

func NewPpePatternUnionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PpePatternUnionContext {
	var p = new(PpePatternUnionContext)

	InitEmptyPathPatternExpressionContext(&p.PathPatternExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PathPatternExpressionContext))

	return p
}

func (s *PpePatternUnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PpePatternUnionContext) AllPathTerm() []IPathTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPathTermContext); ok {
			len++
		}
	}

	tst := make([]IPathTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPathTermContext); ok {
			tst[i] = t.(IPathTermContext)
			i++
		}
	}

	return tst
}

func (s *PpePatternUnionContext) PathTerm(i int) IPathTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathTermContext)
}

func (s *PpePatternUnionContext) AllVERTICAL_BAR() []antlr.TerminalNode {
	return s.GetTokens(GQLParserVERTICAL_BAR)
}

func (s *PpePatternUnionContext) VERTICAL_BAR(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserVERTICAL_BAR, i)
}

func (s *PpePatternUnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPpePatternUnion(s)
	}
}

func (s *PpePatternUnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPpePatternUnion(s)
	}
}

type PpePathTermContext struct {
	PathPatternExpressionContext
}

func NewPpePathTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PpePathTermContext {
	var p = new(PpePathTermContext)

	InitEmptyPathPatternExpressionContext(&p.PathPatternExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PathPatternExpressionContext))

	return p
}

func (s *PpePathTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PpePathTermContext) PathTerm() IPathTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathTermContext)
}

func (s *PpePathTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPpePathTerm(s)
	}
}

func (s *PpePathTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPpePathTerm(s)
	}
}

type PpeMultisetAlternationContext struct {
	PathPatternExpressionContext
}

func NewPpeMultisetAlternationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PpeMultisetAlternationContext {
	var p = new(PpeMultisetAlternationContext)

	InitEmptyPathPatternExpressionContext(&p.PathPatternExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PathPatternExpressionContext))

	return p
}

func (s *PpeMultisetAlternationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PpeMultisetAlternationContext) AllPathTerm() []IPathTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPathTermContext); ok {
			len++
		}
	}

	tst := make([]IPathTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPathTermContext); ok {
			tst[i] = t.(IPathTermContext)
			i++
		}
	}

	return tst
}

func (s *PpeMultisetAlternationContext) PathTerm(i int) IPathTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathTermContext)
}

func (s *PpeMultisetAlternationContext) AllMULTISET_ALTERNATION_OPERATOR() []antlr.TerminalNode {
	return s.GetTokens(GQLParserMULTISET_ALTERNATION_OPERATOR)
}

func (s *PpeMultisetAlternationContext) MULTISET_ALTERNATION_OPERATOR(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserMULTISET_ALTERNATION_OPERATOR, i)
}

func (s *PpeMultisetAlternationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPpeMultisetAlternation(s)
	}
}

func (s *PpeMultisetAlternationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPpeMultisetAlternation(s)
	}
}

func (p *GQLParser) PathPatternExpression() (localctx IPathPatternExpressionContext) {
	localctx = NewPathPatternExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, GQLParserRULE_pathPatternExpression)
	var _alt int

	p.SetState(2304)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPpePathTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2289)
			p.PathTerm()
		}

	case 2:
		localctx = NewPpeMultisetAlternationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2290)
			p.PathTerm()
		}
		p.SetState(2293)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(2291)
					p.Match(GQLParserMULTISET_ALTERNATION_OPERATOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2292)
					p.PathTerm()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(2295)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 3:
		localctx = NewPpePatternUnionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2297)
			p.PathTerm()
		}
		p.SetState(2300)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(2298)
					p.Match(GQLParserVERTICAL_BAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2299)
					p.PathTerm()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(2302)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathTermContext is an interface to support dynamic dispatch.
type IPathTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPathFactor() []IPathFactorContext
	PathFactor(i int) IPathFactorContext

	// IsPathTermContext differentiates from other interfaces.
	IsPathTermContext()
}

type PathTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathTermContext() *PathTermContext {
	var p = new(PathTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathTerm
	return p
}

func InitEmptyPathTermContext(p *PathTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathTerm
}

func (*PathTermContext) IsPathTermContext() {}

func NewPathTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathTermContext {
	var p = new(PathTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathTerm

	return p
}

func (s *PathTermContext) GetParser() antlr.Parser { return s.parser }

func (s *PathTermContext) AllPathFactor() []IPathFactorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPathFactorContext); ok {
			len++
		}
	}

	tst := make([]IPathFactorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPathFactorContext); ok {
			tst[i] = t.(IPathFactorContext)
			i++
		}
	}

	return tst
}

func (s *PathTermContext) PathFactor(i int) IPathFactorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathFactorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathFactorContext)
}

func (s *PathTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathTerm(s)
	}
}

func (s *PathTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathTerm(s)
	}
}

func (p *GQLParser) PathTerm() (localctx IPathTermContext) {
	localctx = NewPathTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, GQLParserRULE_pathTerm)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(2306)
				p.PathFactor()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(2309)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathFactorContext is an interface to support dynamic dispatch.
type IPathFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPathFactorContext differentiates from other interfaces.
	IsPathFactorContext()
}

type PathFactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathFactorContext() *PathFactorContext {
	var p = new(PathFactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathFactor
	return p
}

func InitEmptyPathFactorContext(p *PathFactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathFactor
}

func (*PathFactorContext) IsPathFactorContext() {}

func NewPathFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathFactorContext {
	var p = new(PathFactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathFactor

	return p
}

func (s *PathFactorContext) GetParser() antlr.Parser { return s.parser }

func (s *PathFactorContext) CopyAll(ctx *PathFactorContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PathFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathFactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PfQuantifiedPathPrimaryContext struct {
	PathFactorContext
}

func NewPfQuantifiedPathPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PfQuantifiedPathPrimaryContext {
	var p = new(PfQuantifiedPathPrimaryContext)

	InitEmptyPathFactorContext(&p.PathFactorContext)
	p.parser = parser
	p.CopyAll(ctx.(*PathFactorContext))

	return p
}

func (s *PfQuantifiedPathPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PfQuantifiedPathPrimaryContext) PathPrimary() IPathPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathPrimaryContext)
}

func (s *PfQuantifiedPathPrimaryContext) GraphPatternQuantifier() IGraphPatternQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphPatternQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphPatternQuantifierContext)
}

func (s *PfQuantifiedPathPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPfQuantifiedPathPrimary(s)
	}
}

func (s *PfQuantifiedPathPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPfQuantifiedPathPrimary(s)
	}
}

type PfQuestionedPathPrimaryContext struct {
	PathFactorContext
}

func NewPfQuestionedPathPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PfQuestionedPathPrimaryContext {
	var p = new(PfQuestionedPathPrimaryContext)

	InitEmptyPathFactorContext(&p.PathFactorContext)
	p.parser = parser
	p.CopyAll(ctx.(*PathFactorContext))

	return p
}

func (s *PfQuestionedPathPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PfQuestionedPathPrimaryContext) PathPrimary() IPathPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathPrimaryContext)
}

func (s *PfQuestionedPathPrimaryContext) QUESTION_MARK() antlr.TerminalNode {
	return s.GetToken(GQLParserQUESTION_MARK, 0)
}

func (s *PfQuestionedPathPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPfQuestionedPathPrimary(s)
	}
}

func (s *PfQuestionedPathPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPfQuestionedPathPrimary(s)
	}
}

type PfPathPrimaryContext struct {
	PathFactorContext
}

func NewPfPathPrimaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PfPathPrimaryContext {
	var p = new(PfPathPrimaryContext)

	InitEmptyPathFactorContext(&p.PathFactorContext)
	p.parser = parser
	p.CopyAll(ctx.(*PathFactorContext))

	return p
}

func (s *PfPathPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PfPathPrimaryContext) PathPrimary() IPathPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathPrimaryContext)
}

func (s *PfPathPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPfPathPrimary(s)
	}
}

func (s *PfPathPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPfPathPrimary(s)
	}
}

func (p *GQLParser) PathFactor() (localctx IPathFactorContext) {
	localctx = NewPathFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, GQLParserRULE_pathFactor)
	p.SetState(2318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPfPathPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2311)
			p.PathPrimary()
		}

	case 2:
		localctx = NewPfQuantifiedPathPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2312)
			p.PathPrimary()
		}
		{
			p.SetState(2313)
			p.GraphPatternQuantifier()
		}

	case 3:
		localctx = NewPfQuestionedPathPrimaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2315)
			p.PathPrimary()
		}
		{
			p.SetState(2316)
			p.Match(GQLParserQUESTION_MARK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathPrimaryContext is an interface to support dynamic dispatch.
type IPathPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPathPrimaryContext differentiates from other interfaces.
	IsPathPrimaryContext()
}

type PathPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathPrimaryContext() *PathPrimaryContext {
	var p = new(PathPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathPrimary
	return p
}

func InitEmptyPathPrimaryContext(p *PathPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathPrimary
}

func (*PathPrimaryContext) IsPathPrimaryContext() {}

func NewPathPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathPrimaryContext {
	var p = new(PathPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathPrimary

	return p
}

func (s *PathPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PathPrimaryContext) CopyAll(ctx *PathPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PathPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PpParenthesizedPathPatternExpressionContext struct {
	PathPrimaryContext
}

func NewPpParenthesizedPathPatternExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PpParenthesizedPathPatternExpressionContext {
	var p = new(PpParenthesizedPathPatternExpressionContext)

	InitEmptyPathPrimaryContext(&p.PathPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PathPrimaryContext))

	return p
}

func (s *PpParenthesizedPathPatternExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PpParenthesizedPathPatternExpressionContext) ParenthesizedPathPatternExpression() IParenthesizedPathPatternExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedPathPatternExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedPathPatternExpressionContext)
}

func (s *PpParenthesizedPathPatternExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPpParenthesizedPathPatternExpression(s)
	}
}

func (s *PpParenthesizedPathPatternExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPpParenthesizedPathPatternExpression(s)
	}
}

type PpElementPatternContext struct {
	PathPrimaryContext
}

func NewPpElementPatternContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PpElementPatternContext {
	var p = new(PpElementPatternContext)

	InitEmptyPathPrimaryContext(&p.PathPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PathPrimaryContext))

	return p
}

func (s *PpElementPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PpElementPatternContext) ElementPattern() IElementPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementPatternContext)
}

func (s *PpElementPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPpElementPattern(s)
	}
}

func (s *PpElementPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPpElementPattern(s)
	}
}

type PpSimplifiedPathPatternExpressionContext struct {
	PathPrimaryContext
}

func NewPpSimplifiedPathPatternExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PpSimplifiedPathPatternExpressionContext {
	var p = new(PpSimplifiedPathPatternExpressionContext)

	InitEmptyPathPrimaryContext(&p.PathPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*PathPrimaryContext))

	return p
}

func (s *PpSimplifiedPathPatternExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PpSimplifiedPathPatternExpressionContext) SimplifiedPathPatternExpression() ISimplifiedPathPatternExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedPathPatternExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedPathPatternExpressionContext)
}

func (s *PpSimplifiedPathPatternExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPpSimplifiedPathPatternExpression(s)
	}
}

func (s *PpSimplifiedPathPatternExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPpSimplifiedPathPatternExpression(s)
	}
}

func (p *GQLParser) PathPrimary() (localctx IPathPrimaryContext) {
	localctx = NewPathPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, GQLParserRULE_pathPrimary)
	p.SetState(2323)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPpElementPatternContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2320)
			p.ElementPattern()
		}

	case 2:
		localctx = NewPpParenthesizedPathPatternExpressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2321)
			p.ParenthesizedPathPatternExpression()
		}

	case 3:
		localctx = NewPpSimplifiedPathPatternExpressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2322)
			p.SimplifiedPathPatternExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementPatternContext is an interface to support dynamic dispatch.
type IElementPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NodePattern() INodePatternContext
	EdgePattern() IEdgePatternContext

	// IsElementPatternContext differentiates from other interfaces.
	IsElementPatternContext()
}

type ElementPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementPatternContext() *ElementPatternContext {
	var p = new(ElementPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementPattern
	return p
}

func InitEmptyElementPatternContext(p *ElementPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementPattern
}

func (*ElementPatternContext) IsElementPatternContext() {}

func NewElementPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementPatternContext {
	var p = new(ElementPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_elementPattern

	return p
}

func (s *ElementPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementPatternContext) NodePattern() INodePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodePatternContext)
}

func (s *ElementPatternContext) EdgePattern() IEdgePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgePatternContext)
}

func (s *ElementPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterElementPattern(s)
	}
}

func (s *ElementPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitElementPattern(s)
	}
}

func (p *GQLParser) ElementPattern() (localctx IElementPatternContext) {
	localctx = NewElementPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, GQLParserRULE_elementPattern)
	p.SetState(2327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2325)
			p.NodePattern()
		}

	case GQLParserLEFT_ARROW, GQLParserLEFT_ARROW_TILDE, GQLParserLEFT_ARROW_BRACKET, GQLParserLEFT_ARROW_TILDE_BRACKET, GQLParserLEFT_MINUS_RIGHT, GQLParserMINUS_LEFT_BRACKET, GQLParserRIGHT_ARROW, GQLParserTILDE_LEFT_BRACKET, GQLParserTILDE_RIGHT_ARROW, GQLParserMINUS_SIGN, GQLParserTILDE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2326)
			p.EdgePattern()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodePatternContext is an interface to support dynamic dispatch.
type INodePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	ElementPatternFiller() IElementPatternFillerContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsNodePatternContext differentiates from other interfaces.
	IsNodePatternContext()
}

type NodePatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodePatternContext() *NodePatternContext {
	var p = new(NodePatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodePattern
	return p
}

func InitEmptyNodePatternContext(p *NodePatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodePattern
}

func (*NodePatternContext) IsNodePatternContext() {}

func NewNodePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodePatternContext {
	var p = new(NodePatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nodePattern

	return p
}

func (s *NodePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *NodePatternContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *NodePatternContext) ElementPatternFiller() IElementPatternFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementPatternFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementPatternFillerContext)
}

func (s *NodePatternContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *NodePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNodePattern(s)
	}
}

func (s *NodePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNodePattern(s)
	}
}

func (p *GQLParser) NodePattern() (localctx INodePatternContext) {
	localctx = NewNodePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, GQLParserRULE_nodePattern)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2329)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2330)
		p.ElementPatternFiller()
	}
	{
		p.SetState(2331)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementPatternFillerContext is an interface to support dynamic dispatch.
type IElementPatternFillerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementVariableDeclaration() IElementVariableDeclarationContext
	IsLabelExpression() IIsLabelExpressionContext
	ElementPatternPredicate() IElementPatternPredicateContext

	// IsElementPatternFillerContext differentiates from other interfaces.
	IsElementPatternFillerContext()
}

type ElementPatternFillerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementPatternFillerContext() *ElementPatternFillerContext {
	var p = new(ElementPatternFillerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementPatternFiller
	return p
}

func InitEmptyElementPatternFillerContext(p *ElementPatternFillerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementPatternFiller
}

func (*ElementPatternFillerContext) IsElementPatternFillerContext() {}

func NewElementPatternFillerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementPatternFillerContext {
	var p = new(ElementPatternFillerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_elementPatternFiller

	return p
}

func (s *ElementPatternFillerContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementPatternFillerContext) ElementVariableDeclaration() IElementVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementVariableDeclarationContext)
}

func (s *ElementPatternFillerContext) IsLabelExpression() IIsLabelExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsLabelExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsLabelExpressionContext)
}

func (s *ElementPatternFillerContext) ElementPatternPredicate() IElementPatternPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementPatternPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementPatternPredicateContext)
}

func (s *ElementPatternFillerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementPatternFillerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementPatternFillerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterElementPatternFiller(s)
	}
}

func (s *ElementPatternFillerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitElementPatternFiller(s)
	}
}

func (p *GQLParser) ElementPatternFiller() (localctx IElementPatternFillerContext) {
	localctx = NewElementPatternFillerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, GQLParserRULE_elementPatternFiller)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&281474976710655) != 0 {
		{
			p.SetState(2333)
			p.ElementVariableDeclaration()
		}

	}
	p.SetState(2337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserIS || _la == GQLParserCOLON {
		{
			p.SetState(2336)
			p.IsLabelExpression()
		}

	}
	p.SetState(2340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserWHERE || _la == GQLParserLEFT_BRACE {
		{
			p.SetState(2339)
			p.ElementPatternPredicate()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementVariableDeclarationContext is an interface to support dynamic dispatch.
type IElementVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementVariable() IElementVariableContext

	// IsElementVariableDeclarationContext differentiates from other interfaces.
	IsElementVariableDeclarationContext()
}

type ElementVariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementVariableDeclarationContext() *ElementVariableDeclarationContext {
	var p = new(ElementVariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementVariableDeclaration
	return p
}

func InitEmptyElementVariableDeclarationContext(p *ElementVariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementVariableDeclaration
}

func (*ElementVariableDeclarationContext) IsElementVariableDeclarationContext() {}

func NewElementVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementVariableDeclarationContext {
	var p = new(ElementVariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_elementVariableDeclaration

	return p
}

func (s *ElementVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementVariableDeclarationContext) ElementVariable() IElementVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementVariableContext)
}

func (s *ElementVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterElementVariableDeclaration(s)
	}
}

func (s *ElementVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitElementVariableDeclaration(s)
	}
}

func (p *GQLParser) ElementVariableDeclaration() (localctx IElementVariableDeclarationContext) {
	localctx = NewElementVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, GQLParserRULE_elementVariableDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2342)
		p.ElementVariable()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsLabelExpressionContext is an interface to support dynamic dispatch.
type IIsLabelExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IsOrColon() IIsOrColonContext
	LabelExpression() ILabelExpressionContext

	// IsIsLabelExpressionContext differentiates from other interfaces.
	IsIsLabelExpressionContext()
}

type IsLabelExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsLabelExpressionContext() *IsLabelExpressionContext {
	var p = new(IsLabelExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_isLabelExpression
	return p
}

func InitEmptyIsLabelExpressionContext(p *IsLabelExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_isLabelExpression
}

func (*IsLabelExpressionContext) IsIsLabelExpressionContext() {}

func NewIsLabelExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsLabelExpressionContext {
	var p = new(IsLabelExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_isLabelExpression

	return p
}

func (s *IsLabelExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IsLabelExpressionContext) IsOrColon() IIsOrColonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsOrColonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsOrColonContext)
}

func (s *IsLabelExpressionContext) LabelExpression() ILabelExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelExpressionContext)
}

func (s *IsLabelExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsLabelExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IsLabelExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterIsLabelExpression(s)
	}
}

func (s *IsLabelExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitIsLabelExpression(s)
	}
}

func (p *GQLParser) IsLabelExpression() (localctx IIsLabelExpressionContext) {
	localctx = NewIsLabelExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, GQLParserRULE_isLabelExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2344)
		p.IsOrColon()
	}
	{
		p.SetState(2345)
		p.labelExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsOrColonContext is an interface to support dynamic dispatch.
type IIsOrColonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IS() antlr.TerminalNode
	COLON() antlr.TerminalNode

	// IsIsOrColonContext differentiates from other interfaces.
	IsIsOrColonContext()
}

type IsOrColonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsOrColonContext() *IsOrColonContext {
	var p = new(IsOrColonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_isOrColon
	return p
}

func InitEmptyIsOrColonContext(p *IsOrColonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_isOrColon
}

func (*IsOrColonContext) IsIsOrColonContext() {}

func NewIsOrColonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsOrColonContext {
	var p = new(IsOrColonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_isOrColon

	return p
}

func (s *IsOrColonContext) GetParser() antlr.Parser { return s.parser }

func (s *IsOrColonContext) IS() antlr.TerminalNode {
	return s.GetToken(GQLParserIS, 0)
}

func (s *IsOrColonContext) COLON() antlr.TerminalNode {
	return s.GetToken(GQLParserCOLON, 0)
}

func (s *IsOrColonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsOrColonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IsOrColonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterIsOrColon(s)
	}
}

func (s *IsOrColonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitIsOrColon(s)
	}
}

func (p *GQLParser) IsOrColon() (localctx IIsOrColonContext) {
	localctx = NewIsOrColonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, GQLParserRULE_isOrColon)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2347)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserIS || _la == GQLParserCOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementPatternPredicateContext is an interface to support dynamic dispatch.
type IElementPatternPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementPatternWhereClause() IElementPatternWhereClauseContext
	ElementPropertySpecification() IElementPropertySpecificationContext

	// IsElementPatternPredicateContext differentiates from other interfaces.
	IsElementPatternPredicateContext()
}

type ElementPatternPredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementPatternPredicateContext() *ElementPatternPredicateContext {
	var p = new(ElementPatternPredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementPatternPredicate
	return p
}

func InitEmptyElementPatternPredicateContext(p *ElementPatternPredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementPatternPredicate
}

func (*ElementPatternPredicateContext) IsElementPatternPredicateContext() {}

func NewElementPatternPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementPatternPredicateContext {
	var p = new(ElementPatternPredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_elementPatternPredicate

	return p
}

func (s *ElementPatternPredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementPatternPredicateContext) ElementPatternWhereClause() IElementPatternWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementPatternWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementPatternWhereClauseContext)
}

func (s *ElementPatternPredicateContext) ElementPropertySpecification() IElementPropertySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementPropertySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementPropertySpecificationContext)
}

func (s *ElementPatternPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementPatternPredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementPatternPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterElementPatternPredicate(s)
	}
}

func (s *ElementPatternPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitElementPatternPredicate(s)
	}
}

func (p *GQLParser) ElementPatternPredicate() (localctx IElementPatternPredicateContext) {
	localctx = NewElementPatternPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, GQLParserRULE_elementPatternPredicate)
	p.SetState(2351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserWHERE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2349)
			p.ElementPatternWhereClause()
		}

	case GQLParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2350)
			p.ElementPropertySpecification()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementPatternWhereClauseContext is an interface to support dynamic dispatch.
type IElementPatternWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	SearchCondition() ISearchConditionContext

	// IsElementPatternWhereClauseContext differentiates from other interfaces.
	IsElementPatternWhereClauseContext()
}

type ElementPatternWhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementPatternWhereClauseContext() *ElementPatternWhereClauseContext {
	var p = new(ElementPatternWhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementPatternWhereClause
	return p
}

func InitEmptyElementPatternWhereClauseContext(p *ElementPatternWhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementPatternWhereClause
}

func (*ElementPatternWhereClauseContext) IsElementPatternWhereClauseContext() {}

func NewElementPatternWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementPatternWhereClauseContext {
	var p = new(ElementPatternWhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_elementPatternWhereClause

	return p
}

func (s *ElementPatternWhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementPatternWhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(GQLParserWHERE, 0)
}

func (s *ElementPatternWhereClauseContext) SearchCondition() ISearchConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchConditionContext)
}

func (s *ElementPatternWhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementPatternWhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementPatternWhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterElementPatternWhereClause(s)
	}
}

func (s *ElementPatternWhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitElementPatternWhereClause(s)
	}
}

func (p *GQLParser) ElementPatternWhereClause() (localctx IElementPatternWhereClauseContext) {
	localctx = NewElementPatternWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, GQLParserRULE_elementPatternWhereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2353)
		p.Match(GQLParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2354)
		p.SearchCondition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementPropertySpecificationContext is an interface to support dynamic dispatch.
type IElementPropertySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_BRACE() antlr.TerminalNode
	PropertyKeyValuePairList() IPropertyKeyValuePairListContext
	RIGHT_BRACE() antlr.TerminalNode

	// IsElementPropertySpecificationContext differentiates from other interfaces.
	IsElementPropertySpecificationContext()
}

type ElementPropertySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementPropertySpecificationContext() *ElementPropertySpecificationContext {
	var p = new(ElementPropertySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementPropertySpecification
	return p
}

func InitEmptyElementPropertySpecificationContext(p *ElementPropertySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementPropertySpecification
}

func (*ElementPropertySpecificationContext) IsElementPropertySpecificationContext() {}

func NewElementPropertySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementPropertySpecificationContext {
	var p = new(ElementPropertySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_elementPropertySpecification

	return p
}

func (s *ElementPropertySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementPropertySpecificationContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACE, 0)
}

func (s *ElementPropertySpecificationContext) PropertyKeyValuePairList() IPropertyKeyValuePairListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeyValuePairListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyValuePairListContext)
}

func (s *ElementPropertySpecificationContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACE, 0)
}

func (s *ElementPropertySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementPropertySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementPropertySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterElementPropertySpecification(s)
	}
}

func (s *ElementPropertySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitElementPropertySpecification(s)
	}
}

func (p *GQLParser) ElementPropertySpecification() (localctx IElementPropertySpecificationContext) {
	localctx = NewElementPropertySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, GQLParserRULE_elementPropertySpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2356)
		p.Match(GQLParserLEFT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2357)
		p.PropertyKeyValuePairList()
	}
	{
		p.SetState(2358)
		p.Match(GQLParserRIGHT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyKeyValuePairListContext is an interface to support dynamic dispatch.
type IPropertyKeyValuePairListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPropertyKeyValuePair() []IPropertyKeyValuePairContext
	PropertyKeyValuePair(i int) IPropertyKeyValuePairContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyKeyValuePairListContext differentiates from other interfaces.
	IsPropertyKeyValuePairListContext()
}

type PropertyKeyValuePairListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyKeyValuePairListContext() *PropertyKeyValuePairListContext {
	var p = new(PropertyKeyValuePairListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_propertyKeyValuePairList
	return p
}

func InitEmptyPropertyKeyValuePairListContext(p *PropertyKeyValuePairListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_propertyKeyValuePairList
}

func (*PropertyKeyValuePairListContext) IsPropertyKeyValuePairListContext() {}

func NewPropertyKeyValuePairListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyKeyValuePairListContext {
	var p = new(PropertyKeyValuePairListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_propertyKeyValuePairList

	return p
}

func (s *PropertyKeyValuePairListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyKeyValuePairListContext) AllPropertyKeyValuePair() []IPropertyKeyValuePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyKeyValuePairContext); ok {
			len++
		}
	}

	tst := make([]IPropertyKeyValuePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyKeyValuePairContext); ok {
			tst[i] = t.(IPropertyKeyValuePairContext)
			i++
		}
	}

	return tst
}

func (s *PropertyKeyValuePairListContext) PropertyKeyValuePair(i int) IPropertyKeyValuePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeyValuePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyValuePairContext)
}

func (s *PropertyKeyValuePairListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *PropertyKeyValuePairListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *PropertyKeyValuePairListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyKeyValuePairListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyKeyValuePairListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPropertyKeyValuePairList(s)
	}
}

func (s *PropertyKeyValuePairListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPropertyKeyValuePairList(s)
	}
}

func (p *GQLParser) PropertyKeyValuePairList() (localctx IPropertyKeyValuePairListContext) {
	localctx = NewPropertyKeyValuePairListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, GQLParserRULE_propertyKeyValuePairList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2360)
		p.PropertyKeyValuePair()
	}
	p.SetState(2365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(2361)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2362)
			p.PropertyKeyValuePair()
		}

		p.SetState(2367)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyKeyValuePairContext is an interface to support dynamic dispatch.
type IPropertyKeyValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyName() IPropertyNameContext
	COLON() antlr.TerminalNode
	ValueExpression() IValueExpressionContext

	// IsPropertyKeyValuePairContext differentiates from other interfaces.
	IsPropertyKeyValuePairContext()
}

type PropertyKeyValuePairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyKeyValuePairContext() *PropertyKeyValuePairContext {
	var p = new(PropertyKeyValuePairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_propertyKeyValuePair
	return p
}

func InitEmptyPropertyKeyValuePairContext(p *PropertyKeyValuePairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_propertyKeyValuePair
}

func (*PropertyKeyValuePairContext) IsPropertyKeyValuePairContext() {}

func NewPropertyKeyValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyKeyValuePairContext {
	var p = new(PropertyKeyValuePairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_propertyKeyValuePair

	return p
}

func (s *PropertyKeyValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyKeyValuePairContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *PropertyKeyValuePairContext) COLON() antlr.TerminalNode {
	return s.GetToken(GQLParserCOLON, 0)
}

func (s *PropertyKeyValuePairContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PropertyKeyValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyKeyValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyKeyValuePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPropertyKeyValuePair(s)
	}
}

func (s *PropertyKeyValuePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPropertyKeyValuePair(s)
	}
}

func (p *GQLParser) PropertyKeyValuePair() (localctx IPropertyKeyValuePairContext) {
	localctx = NewPropertyKeyValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, GQLParserRULE_propertyKeyValuePair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2368)
		p.PropertyName()
	}
	{
		p.SetState(2369)
		p.Match(GQLParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2370)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgePatternContext is an interface to support dynamic dispatch.
type IEdgePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FullEdgePattern() IFullEdgePatternContext
	AbbreviatedEdgePattern() IAbbreviatedEdgePatternContext

	// IsEdgePatternContext differentiates from other interfaces.
	IsEdgePatternContext()
}

type EdgePatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgePatternContext() *EdgePatternContext {
	var p = new(EdgePatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgePattern
	return p
}

func InitEmptyEdgePatternContext(p *EdgePatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgePattern
}

func (*EdgePatternContext) IsEdgePatternContext() {}

func NewEdgePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgePatternContext {
	var p = new(EdgePatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgePattern

	return p
}

func (s *EdgePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgePatternContext) FullEdgePattern() IFullEdgePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullEdgePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullEdgePatternContext)
}

func (s *EdgePatternContext) AbbreviatedEdgePattern() IAbbreviatedEdgePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbbreviatedEdgePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbbreviatedEdgePatternContext)
}

func (s *EdgePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgePattern(s)
	}
}

func (s *EdgePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgePattern(s)
	}
}

func (p *GQLParser) EdgePattern() (localctx IEdgePatternContext) {
	localctx = NewEdgePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, GQLParserRULE_edgePattern)
	p.SetState(2374)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserLEFT_ARROW_BRACKET, GQLParserLEFT_ARROW_TILDE_BRACKET, GQLParserMINUS_LEFT_BRACKET, GQLParserTILDE_LEFT_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2372)
			p.FullEdgePattern()
		}

	case GQLParserLEFT_ARROW, GQLParserLEFT_ARROW_TILDE, GQLParserLEFT_MINUS_RIGHT, GQLParserRIGHT_ARROW, GQLParserTILDE_RIGHT_ARROW, GQLParserMINUS_SIGN, GQLParserTILDE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2373)
			p.AbbreviatedEdgePattern()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullEdgePatternContext is an interface to support dynamic dispatch.
type IFullEdgePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FullEdgePointingLeft() IFullEdgePointingLeftContext
	FullEdgeUndirected() IFullEdgeUndirectedContext
	FullEdgePointingRight() IFullEdgePointingRightContext
	FullEdgeLeftOrUndirected() IFullEdgeLeftOrUndirectedContext
	FullEdgeUndirectedOrRight() IFullEdgeUndirectedOrRightContext
	FullEdgeLeftOrRight() IFullEdgeLeftOrRightContext
	FullEdgeAnyDirection() IFullEdgeAnyDirectionContext

	// IsFullEdgePatternContext differentiates from other interfaces.
	IsFullEdgePatternContext()
}

type FullEdgePatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullEdgePatternContext() *FullEdgePatternContext {
	var p = new(FullEdgePatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgePattern
	return p
}

func InitEmptyFullEdgePatternContext(p *FullEdgePatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgePattern
}

func (*FullEdgePatternContext) IsFullEdgePatternContext() {}

func NewFullEdgePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullEdgePatternContext {
	var p = new(FullEdgePatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fullEdgePattern

	return p
}

func (s *FullEdgePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *FullEdgePatternContext) FullEdgePointingLeft() IFullEdgePointingLeftContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullEdgePointingLeftContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullEdgePointingLeftContext)
}

func (s *FullEdgePatternContext) FullEdgeUndirected() IFullEdgeUndirectedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullEdgeUndirectedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullEdgeUndirectedContext)
}

func (s *FullEdgePatternContext) FullEdgePointingRight() IFullEdgePointingRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullEdgePointingRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullEdgePointingRightContext)
}

func (s *FullEdgePatternContext) FullEdgeLeftOrUndirected() IFullEdgeLeftOrUndirectedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullEdgeLeftOrUndirectedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullEdgeLeftOrUndirectedContext)
}

func (s *FullEdgePatternContext) FullEdgeUndirectedOrRight() IFullEdgeUndirectedOrRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullEdgeUndirectedOrRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullEdgeUndirectedOrRightContext)
}

func (s *FullEdgePatternContext) FullEdgeLeftOrRight() IFullEdgeLeftOrRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullEdgeLeftOrRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullEdgeLeftOrRightContext)
}

func (s *FullEdgePatternContext) FullEdgeAnyDirection() IFullEdgeAnyDirectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullEdgeAnyDirectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullEdgeAnyDirectionContext)
}

func (s *FullEdgePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullEdgePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullEdgePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFullEdgePattern(s)
	}
}

func (s *FullEdgePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFullEdgePattern(s)
	}
}

func (p *GQLParser) FullEdgePattern() (localctx IFullEdgePatternContext) {
	localctx = NewFullEdgePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, GQLParserRULE_fullEdgePattern)
	p.SetState(2383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2376)
			p.FullEdgePointingLeft()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2377)
			p.FullEdgeUndirected()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2378)
			p.FullEdgePointingRight()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2379)
			p.FullEdgeLeftOrUndirected()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2380)
			p.FullEdgeUndirectedOrRight()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2381)
			p.FullEdgeLeftOrRight()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2382)
			p.FullEdgeAnyDirection()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullEdgePointingLeftContext is an interface to support dynamic dispatch.
type IFullEdgePointingLeftContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_ARROW_BRACKET() antlr.TerminalNode
	ElementPatternFiller() IElementPatternFillerContext
	RIGHT_BRACKET_MINUS() antlr.TerminalNode

	// IsFullEdgePointingLeftContext differentiates from other interfaces.
	IsFullEdgePointingLeftContext()
}

type FullEdgePointingLeftContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullEdgePointingLeftContext() *FullEdgePointingLeftContext {
	var p = new(FullEdgePointingLeftContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgePointingLeft
	return p
}

func InitEmptyFullEdgePointingLeftContext(p *FullEdgePointingLeftContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgePointingLeft
}

func (*FullEdgePointingLeftContext) IsFullEdgePointingLeftContext() {}

func NewFullEdgePointingLeftContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullEdgePointingLeftContext {
	var p = new(FullEdgePointingLeftContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fullEdgePointingLeft

	return p
}

func (s *FullEdgePointingLeftContext) GetParser() antlr.Parser { return s.parser }

func (s *FullEdgePointingLeftContext) LEFT_ARROW_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_ARROW_BRACKET, 0)
}

func (s *FullEdgePointingLeftContext) ElementPatternFiller() IElementPatternFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementPatternFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementPatternFillerContext)
}

func (s *FullEdgePointingLeftContext) RIGHT_BRACKET_MINUS() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET_MINUS, 0)
}

func (s *FullEdgePointingLeftContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullEdgePointingLeftContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullEdgePointingLeftContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFullEdgePointingLeft(s)
	}
}

func (s *FullEdgePointingLeftContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFullEdgePointingLeft(s)
	}
}

func (p *GQLParser) FullEdgePointingLeft() (localctx IFullEdgePointingLeftContext) {
	localctx = NewFullEdgePointingLeftContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, GQLParserRULE_fullEdgePointingLeft)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2385)
		p.Match(GQLParserLEFT_ARROW_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2386)
		p.ElementPatternFiller()
	}
	{
		p.SetState(2387)
		p.Match(GQLParserRIGHT_BRACKET_MINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullEdgeUndirectedContext is an interface to support dynamic dispatch.
type IFullEdgeUndirectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TILDE_LEFT_BRACKET() antlr.TerminalNode
	ElementPatternFiller() IElementPatternFillerContext
	RIGHT_BRACKET_TILDE() antlr.TerminalNode

	// IsFullEdgeUndirectedContext differentiates from other interfaces.
	IsFullEdgeUndirectedContext()
}

type FullEdgeUndirectedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullEdgeUndirectedContext() *FullEdgeUndirectedContext {
	var p = new(FullEdgeUndirectedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgeUndirected
	return p
}

func InitEmptyFullEdgeUndirectedContext(p *FullEdgeUndirectedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgeUndirected
}

func (*FullEdgeUndirectedContext) IsFullEdgeUndirectedContext() {}

func NewFullEdgeUndirectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullEdgeUndirectedContext {
	var p = new(FullEdgeUndirectedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fullEdgeUndirected

	return p
}

func (s *FullEdgeUndirectedContext) GetParser() antlr.Parser { return s.parser }

func (s *FullEdgeUndirectedContext) TILDE_LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserTILDE_LEFT_BRACKET, 0)
}

func (s *FullEdgeUndirectedContext) ElementPatternFiller() IElementPatternFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementPatternFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementPatternFillerContext)
}

func (s *FullEdgeUndirectedContext) RIGHT_BRACKET_TILDE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET_TILDE, 0)
}

func (s *FullEdgeUndirectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullEdgeUndirectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullEdgeUndirectedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFullEdgeUndirected(s)
	}
}

func (s *FullEdgeUndirectedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFullEdgeUndirected(s)
	}
}

func (p *GQLParser) FullEdgeUndirected() (localctx IFullEdgeUndirectedContext) {
	localctx = NewFullEdgeUndirectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, GQLParserRULE_fullEdgeUndirected)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2389)
		p.Match(GQLParserTILDE_LEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2390)
		p.ElementPatternFiller()
	}
	{
		p.SetState(2391)
		p.Match(GQLParserRIGHT_BRACKET_TILDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullEdgePointingRightContext is an interface to support dynamic dispatch.
type IFullEdgePointingRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS_LEFT_BRACKET() antlr.TerminalNode
	ElementPatternFiller() IElementPatternFillerContext
	BRACKET_RIGHT_ARROW() antlr.TerminalNode

	// IsFullEdgePointingRightContext differentiates from other interfaces.
	IsFullEdgePointingRightContext()
}

type FullEdgePointingRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullEdgePointingRightContext() *FullEdgePointingRightContext {
	var p = new(FullEdgePointingRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgePointingRight
	return p
}

func InitEmptyFullEdgePointingRightContext(p *FullEdgePointingRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgePointingRight
}

func (*FullEdgePointingRightContext) IsFullEdgePointingRightContext() {}

func NewFullEdgePointingRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullEdgePointingRightContext {
	var p = new(FullEdgePointingRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fullEdgePointingRight

	return p
}

func (s *FullEdgePointingRightContext) GetParser() antlr.Parser { return s.parser }

func (s *FullEdgePointingRightContext) MINUS_LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserMINUS_LEFT_BRACKET, 0)
}

func (s *FullEdgePointingRightContext) ElementPatternFiller() IElementPatternFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementPatternFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementPatternFillerContext)
}

func (s *FullEdgePointingRightContext) BRACKET_RIGHT_ARROW() antlr.TerminalNode {
	return s.GetToken(GQLParserBRACKET_RIGHT_ARROW, 0)
}

func (s *FullEdgePointingRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullEdgePointingRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullEdgePointingRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFullEdgePointingRight(s)
	}
}

func (s *FullEdgePointingRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFullEdgePointingRight(s)
	}
}

func (p *GQLParser) FullEdgePointingRight() (localctx IFullEdgePointingRightContext) {
	localctx = NewFullEdgePointingRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, GQLParserRULE_fullEdgePointingRight)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2393)
		p.Match(GQLParserMINUS_LEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2394)
		p.ElementPatternFiller()
	}
	{
		p.SetState(2395)
		p.Match(GQLParserBRACKET_RIGHT_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullEdgeLeftOrUndirectedContext is an interface to support dynamic dispatch.
type IFullEdgeLeftOrUndirectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_ARROW_TILDE_BRACKET() antlr.TerminalNode
	ElementPatternFiller() IElementPatternFillerContext
	RIGHT_BRACKET_TILDE() antlr.TerminalNode

	// IsFullEdgeLeftOrUndirectedContext differentiates from other interfaces.
	IsFullEdgeLeftOrUndirectedContext()
}

type FullEdgeLeftOrUndirectedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullEdgeLeftOrUndirectedContext() *FullEdgeLeftOrUndirectedContext {
	var p = new(FullEdgeLeftOrUndirectedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgeLeftOrUndirected
	return p
}

func InitEmptyFullEdgeLeftOrUndirectedContext(p *FullEdgeLeftOrUndirectedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgeLeftOrUndirected
}

func (*FullEdgeLeftOrUndirectedContext) IsFullEdgeLeftOrUndirectedContext() {}

func NewFullEdgeLeftOrUndirectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullEdgeLeftOrUndirectedContext {
	var p = new(FullEdgeLeftOrUndirectedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fullEdgeLeftOrUndirected

	return p
}

func (s *FullEdgeLeftOrUndirectedContext) GetParser() antlr.Parser { return s.parser }

func (s *FullEdgeLeftOrUndirectedContext) LEFT_ARROW_TILDE_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_ARROW_TILDE_BRACKET, 0)
}

func (s *FullEdgeLeftOrUndirectedContext) ElementPatternFiller() IElementPatternFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementPatternFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementPatternFillerContext)
}

func (s *FullEdgeLeftOrUndirectedContext) RIGHT_BRACKET_TILDE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET_TILDE, 0)
}

func (s *FullEdgeLeftOrUndirectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullEdgeLeftOrUndirectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullEdgeLeftOrUndirectedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFullEdgeLeftOrUndirected(s)
	}
}

func (s *FullEdgeLeftOrUndirectedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFullEdgeLeftOrUndirected(s)
	}
}

func (p *GQLParser) FullEdgeLeftOrUndirected() (localctx IFullEdgeLeftOrUndirectedContext) {
	localctx = NewFullEdgeLeftOrUndirectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, GQLParserRULE_fullEdgeLeftOrUndirected)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2397)
		p.Match(GQLParserLEFT_ARROW_TILDE_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2398)
		p.ElementPatternFiller()
	}
	{
		p.SetState(2399)
		p.Match(GQLParserRIGHT_BRACKET_TILDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullEdgeUndirectedOrRightContext is an interface to support dynamic dispatch.
type IFullEdgeUndirectedOrRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TILDE_LEFT_BRACKET() antlr.TerminalNode
	ElementPatternFiller() IElementPatternFillerContext
	BRACKET_TILDE_RIGHT_ARROW() antlr.TerminalNode

	// IsFullEdgeUndirectedOrRightContext differentiates from other interfaces.
	IsFullEdgeUndirectedOrRightContext()
}

type FullEdgeUndirectedOrRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullEdgeUndirectedOrRightContext() *FullEdgeUndirectedOrRightContext {
	var p = new(FullEdgeUndirectedOrRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgeUndirectedOrRight
	return p
}

func InitEmptyFullEdgeUndirectedOrRightContext(p *FullEdgeUndirectedOrRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgeUndirectedOrRight
}

func (*FullEdgeUndirectedOrRightContext) IsFullEdgeUndirectedOrRightContext() {}

func NewFullEdgeUndirectedOrRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullEdgeUndirectedOrRightContext {
	var p = new(FullEdgeUndirectedOrRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fullEdgeUndirectedOrRight

	return p
}

func (s *FullEdgeUndirectedOrRightContext) GetParser() antlr.Parser { return s.parser }

func (s *FullEdgeUndirectedOrRightContext) TILDE_LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserTILDE_LEFT_BRACKET, 0)
}

func (s *FullEdgeUndirectedOrRightContext) ElementPatternFiller() IElementPatternFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementPatternFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementPatternFillerContext)
}

func (s *FullEdgeUndirectedOrRightContext) BRACKET_TILDE_RIGHT_ARROW() antlr.TerminalNode {
	return s.GetToken(GQLParserBRACKET_TILDE_RIGHT_ARROW, 0)
}

func (s *FullEdgeUndirectedOrRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullEdgeUndirectedOrRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullEdgeUndirectedOrRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFullEdgeUndirectedOrRight(s)
	}
}

func (s *FullEdgeUndirectedOrRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFullEdgeUndirectedOrRight(s)
	}
}

func (p *GQLParser) FullEdgeUndirectedOrRight() (localctx IFullEdgeUndirectedOrRightContext) {
	localctx = NewFullEdgeUndirectedOrRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, GQLParserRULE_fullEdgeUndirectedOrRight)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2401)
		p.Match(GQLParserTILDE_LEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2402)
		p.ElementPatternFiller()
	}
	{
		p.SetState(2403)
		p.Match(GQLParserBRACKET_TILDE_RIGHT_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullEdgeLeftOrRightContext is an interface to support dynamic dispatch.
type IFullEdgeLeftOrRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_ARROW_BRACKET() antlr.TerminalNode
	ElementPatternFiller() IElementPatternFillerContext
	BRACKET_RIGHT_ARROW() antlr.TerminalNode

	// IsFullEdgeLeftOrRightContext differentiates from other interfaces.
	IsFullEdgeLeftOrRightContext()
}

type FullEdgeLeftOrRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullEdgeLeftOrRightContext() *FullEdgeLeftOrRightContext {
	var p = new(FullEdgeLeftOrRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgeLeftOrRight
	return p
}

func InitEmptyFullEdgeLeftOrRightContext(p *FullEdgeLeftOrRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgeLeftOrRight
}

func (*FullEdgeLeftOrRightContext) IsFullEdgeLeftOrRightContext() {}

func NewFullEdgeLeftOrRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullEdgeLeftOrRightContext {
	var p = new(FullEdgeLeftOrRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fullEdgeLeftOrRight

	return p
}

func (s *FullEdgeLeftOrRightContext) GetParser() antlr.Parser { return s.parser }

func (s *FullEdgeLeftOrRightContext) LEFT_ARROW_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_ARROW_BRACKET, 0)
}

func (s *FullEdgeLeftOrRightContext) ElementPatternFiller() IElementPatternFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementPatternFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementPatternFillerContext)
}

func (s *FullEdgeLeftOrRightContext) BRACKET_RIGHT_ARROW() antlr.TerminalNode {
	return s.GetToken(GQLParserBRACKET_RIGHT_ARROW, 0)
}

func (s *FullEdgeLeftOrRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullEdgeLeftOrRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullEdgeLeftOrRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFullEdgeLeftOrRight(s)
	}
}

func (s *FullEdgeLeftOrRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFullEdgeLeftOrRight(s)
	}
}

func (p *GQLParser) FullEdgeLeftOrRight() (localctx IFullEdgeLeftOrRightContext) {
	localctx = NewFullEdgeLeftOrRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, GQLParserRULE_fullEdgeLeftOrRight)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2405)
		p.Match(GQLParserLEFT_ARROW_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2406)
		p.ElementPatternFiller()
	}
	{
		p.SetState(2407)
		p.Match(GQLParserBRACKET_RIGHT_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullEdgeAnyDirectionContext is an interface to support dynamic dispatch.
type IFullEdgeAnyDirectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS_LEFT_BRACKET() antlr.TerminalNode
	ElementPatternFiller() IElementPatternFillerContext
	RIGHT_BRACKET_MINUS() antlr.TerminalNode

	// IsFullEdgeAnyDirectionContext differentiates from other interfaces.
	IsFullEdgeAnyDirectionContext()
}

type FullEdgeAnyDirectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullEdgeAnyDirectionContext() *FullEdgeAnyDirectionContext {
	var p = new(FullEdgeAnyDirectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgeAnyDirection
	return p
}

func InitEmptyFullEdgeAnyDirectionContext(p *FullEdgeAnyDirectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fullEdgeAnyDirection
}

func (*FullEdgeAnyDirectionContext) IsFullEdgeAnyDirectionContext() {}

func NewFullEdgeAnyDirectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullEdgeAnyDirectionContext {
	var p = new(FullEdgeAnyDirectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fullEdgeAnyDirection

	return p
}

func (s *FullEdgeAnyDirectionContext) GetParser() antlr.Parser { return s.parser }

func (s *FullEdgeAnyDirectionContext) MINUS_LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserMINUS_LEFT_BRACKET, 0)
}

func (s *FullEdgeAnyDirectionContext) ElementPatternFiller() IElementPatternFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementPatternFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementPatternFillerContext)
}

func (s *FullEdgeAnyDirectionContext) RIGHT_BRACKET_MINUS() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET_MINUS, 0)
}

func (s *FullEdgeAnyDirectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullEdgeAnyDirectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullEdgeAnyDirectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFullEdgeAnyDirection(s)
	}
}

func (s *FullEdgeAnyDirectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFullEdgeAnyDirection(s)
	}
}

func (p *GQLParser) FullEdgeAnyDirection() (localctx IFullEdgeAnyDirectionContext) {
	localctx = NewFullEdgeAnyDirectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, GQLParserRULE_fullEdgeAnyDirection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2409)
		p.Match(GQLParserMINUS_LEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2410)
		p.ElementPatternFiller()
	}
	{
		p.SetState(2411)
		p.Match(GQLParserRIGHT_BRACKET_MINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbbreviatedEdgePatternContext is an interface to support dynamic dispatch.
type IAbbreviatedEdgePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_ARROW() antlr.TerminalNode
	TILDE() antlr.TerminalNode
	RIGHT_ARROW() antlr.TerminalNode
	LEFT_ARROW_TILDE() antlr.TerminalNode
	TILDE_RIGHT_ARROW() antlr.TerminalNode
	LEFT_MINUS_RIGHT() antlr.TerminalNode
	MINUS_SIGN() antlr.TerminalNode

	// IsAbbreviatedEdgePatternContext differentiates from other interfaces.
	IsAbbreviatedEdgePatternContext()
}

type AbbreviatedEdgePatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbbreviatedEdgePatternContext() *AbbreviatedEdgePatternContext {
	var p = new(AbbreviatedEdgePatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_abbreviatedEdgePattern
	return p
}

func InitEmptyAbbreviatedEdgePatternContext(p *AbbreviatedEdgePatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_abbreviatedEdgePattern
}

func (*AbbreviatedEdgePatternContext) IsAbbreviatedEdgePatternContext() {}

func NewAbbreviatedEdgePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbbreviatedEdgePatternContext {
	var p = new(AbbreviatedEdgePatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_abbreviatedEdgePattern

	return p
}

func (s *AbbreviatedEdgePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *AbbreviatedEdgePatternContext) LEFT_ARROW() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_ARROW, 0)
}

func (s *AbbreviatedEdgePatternContext) TILDE() antlr.TerminalNode {
	return s.GetToken(GQLParserTILDE, 0)
}

func (s *AbbreviatedEdgePatternContext) RIGHT_ARROW() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_ARROW, 0)
}

func (s *AbbreviatedEdgePatternContext) LEFT_ARROW_TILDE() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_ARROW_TILDE, 0)
}

func (s *AbbreviatedEdgePatternContext) TILDE_RIGHT_ARROW() antlr.TerminalNode {
	return s.GetToken(GQLParserTILDE_RIGHT_ARROW, 0)
}

func (s *AbbreviatedEdgePatternContext) LEFT_MINUS_RIGHT() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_MINUS_RIGHT, 0)
}

func (s *AbbreviatedEdgePatternContext) MINUS_SIGN() antlr.TerminalNode {
	return s.GetToken(GQLParserMINUS_SIGN, 0)
}

func (s *AbbreviatedEdgePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbbreviatedEdgePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbbreviatedEdgePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAbbreviatedEdgePattern(s)
	}
}

func (s *AbbreviatedEdgePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAbbreviatedEdgePattern(s)
	}
}

func (p *GQLParser) AbbreviatedEdgePattern() (localctx IAbbreviatedEdgePatternContext) {
	localctx = NewAbbreviatedEdgePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, GQLParserRULE_abbreviatedEdgePattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2413)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-338)) & ^0x3f) == 0 && ((int64(1)<<(_la-338))&281612416714771) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedPathPatternExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedPathPatternExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	PathPatternExpression() IPathPatternExpressionContext
	RIGHT_PAREN() antlr.TerminalNode
	SubpathVariableDeclaration() ISubpathVariableDeclarationContext
	PathModePrefix() IPathModePrefixContext
	ParenthesizedPathPatternWhereClause() IParenthesizedPathPatternWhereClauseContext

	// IsParenthesizedPathPatternExpressionContext differentiates from other interfaces.
	IsParenthesizedPathPatternExpressionContext()
}

type ParenthesizedPathPatternExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedPathPatternExpressionContext() *ParenthesizedPathPatternExpressionContext {
	var p = new(ParenthesizedPathPatternExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_parenthesizedPathPatternExpression
	return p
}

func InitEmptyParenthesizedPathPatternExpressionContext(p *ParenthesizedPathPatternExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_parenthesizedPathPatternExpression
}

func (*ParenthesizedPathPatternExpressionContext) IsParenthesizedPathPatternExpressionContext() {}

func NewParenthesizedPathPatternExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedPathPatternExpressionContext {
	var p = new(ParenthesizedPathPatternExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_parenthesizedPathPatternExpression

	return p
}

func (s *ParenthesizedPathPatternExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedPathPatternExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *ParenthesizedPathPatternExpressionContext) PathPatternExpression() IPathPatternExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathPatternExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathPatternExpressionContext)
}

func (s *ParenthesizedPathPatternExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *ParenthesizedPathPatternExpressionContext) SubpathVariableDeclaration() ISubpathVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpathVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpathVariableDeclarationContext)
}

func (s *ParenthesizedPathPatternExpressionContext) PathModePrefix() IPathModePrefixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathModePrefixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathModePrefixContext)
}

func (s *ParenthesizedPathPatternExpressionContext) ParenthesizedPathPatternWhereClause() IParenthesizedPathPatternWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedPathPatternWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedPathPatternWhereClauseContext)
}

func (s *ParenthesizedPathPatternExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedPathPatternExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedPathPatternExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterParenthesizedPathPatternExpression(s)
	}
}

func (s *ParenthesizedPathPatternExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitParenthesizedPathPatternExpression(s)
	}
}

func (p *GQLParser) ParenthesizedPathPatternExpression() (localctx IParenthesizedPathPatternExpressionContext) {
	localctx = NewParenthesizedPathPatternExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, GQLParserRULE_parenthesizedPathPatternExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2415)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2417)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 202, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2416)
			p.SubpathVariableDeclaration()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&9088150798337) != 0 {
		{
			p.SetState(2419)
			p.PathModePrefix()
		}

	}
	{
		p.SetState(2422)
		p.PathPatternExpression()
	}
	p.SetState(2424)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserWHERE {
		{
			p.SetState(2423)
			p.ParenthesizedPathPatternWhereClause()
		}

	}
	{
		p.SetState(2426)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubpathVariableDeclarationContext is an interface to support dynamic dispatch.
type ISubpathVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SubpathVariable() ISubpathVariableContext
	EQUALS_OPERATOR() antlr.TerminalNode

	// IsSubpathVariableDeclarationContext differentiates from other interfaces.
	IsSubpathVariableDeclarationContext()
}

type SubpathVariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpathVariableDeclarationContext() *SubpathVariableDeclarationContext {
	var p = new(SubpathVariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_subpathVariableDeclaration
	return p
}

func InitEmptySubpathVariableDeclarationContext(p *SubpathVariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_subpathVariableDeclaration
}

func (*SubpathVariableDeclarationContext) IsSubpathVariableDeclarationContext() {}

func NewSubpathVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpathVariableDeclarationContext {
	var p = new(SubpathVariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_subpathVariableDeclaration

	return p
}

func (s *SubpathVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpathVariableDeclarationContext) SubpathVariable() ISubpathVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpathVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpathVariableContext)
}

func (s *SubpathVariableDeclarationContext) EQUALS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(GQLParserEQUALS_OPERATOR, 0)
}

func (s *SubpathVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpathVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubpathVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSubpathVariableDeclaration(s)
	}
}

func (s *SubpathVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSubpathVariableDeclaration(s)
	}
}

func (p *GQLParser) SubpathVariableDeclaration() (localctx ISubpathVariableDeclarationContext) {
	localctx = NewSubpathVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, GQLParserRULE_subpathVariableDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2428)
		p.SubpathVariable()
	}
	{
		p.SetState(2429)
		p.Match(GQLParserEQUALS_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedPathPatternWhereClauseContext is an interface to support dynamic dispatch.
type IParenthesizedPathPatternWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	SearchCondition() ISearchConditionContext

	// IsParenthesizedPathPatternWhereClauseContext differentiates from other interfaces.
	IsParenthesizedPathPatternWhereClauseContext()
}

type ParenthesizedPathPatternWhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedPathPatternWhereClauseContext() *ParenthesizedPathPatternWhereClauseContext {
	var p = new(ParenthesizedPathPatternWhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_parenthesizedPathPatternWhereClause
	return p
}

func InitEmptyParenthesizedPathPatternWhereClauseContext(p *ParenthesizedPathPatternWhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_parenthesizedPathPatternWhereClause
}

func (*ParenthesizedPathPatternWhereClauseContext) IsParenthesizedPathPatternWhereClauseContext() {}

func NewParenthesizedPathPatternWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedPathPatternWhereClauseContext {
	var p = new(ParenthesizedPathPatternWhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_parenthesizedPathPatternWhereClause

	return p
}

func (s *ParenthesizedPathPatternWhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedPathPatternWhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(GQLParserWHERE, 0)
}

func (s *ParenthesizedPathPatternWhereClauseContext) SearchCondition() ISearchConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchConditionContext)
}

func (s *ParenthesizedPathPatternWhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedPathPatternWhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedPathPatternWhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterParenthesizedPathPatternWhereClause(s)
	}
}

func (s *ParenthesizedPathPatternWhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitParenthesizedPathPatternWhereClause(s)
	}
}

func (p *GQLParser) ParenthesizedPathPatternWhereClause() (localctx IParenthesizedPathPatternWhereClauseContext) {
	localctx = NewParenthesizedPathPatternWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, GQLParserRULE_parenthesizedPathPatternWhereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2431)
		p.Match(GQLParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2432)
		p.SearchCondition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelExpressionContext is an interface to support dynamic dispatch.
type ILabelExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLabelExpressionContext differentiates from other interfaces.
	IsLabelExpressionContext()
}

type LabelExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelExpressionContext() *LabelExpressionContext {
	var p = new(LabelExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_labelExpression
	return p
}

func InitEmptyLabelExpressionContext(p *LabelExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_labelExpression
}

func (*LabelExpressionContext) IsLabelExpressionContext() {}

func NewLabelExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelExpressionContext {
	var p = new(LabelExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_labelExpression

	return p
}

func (s *LabelExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelExpressionContext) CopyAll(ctx *LabelExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LabelExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelExpressionNegationContext struct {
	LabelExpressionContext
}

func NewLabelExpressionNegationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelExpressionNegationContext {
	var p = new(LabelExpressionNegationContext)

	InitEmptyLabelExpressionContext(&p.LabelExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LabelExpressionContext))

	return p
}

func (s *LabelExpressionNegationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelExpressionNegationContext) EXCLAMATION_MARK() antlr.TerminalNode {
	return s.GetToken(GQLParserEXCLAMATION_MARK, 0)
}

func (s *LabelExpressionNegationContext) LabelExpression() ILabelExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelExpressionContext)
}

func (s *LabelExpressionNegationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLabelExpressionNegation(s)
	}
}

func (s *LabelExpressionNegationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLabelExpressionNegation(s)
	}
}

type LabelExpressionDisjunctionContext struct {
	LabelExpressionContext
}

func NewLabelExpressionDisjunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelExpressionDisjunctionContext {
	var p = new(LabelExpressionDisjunctionContext)

	InitEmptyLabelExpressionContext(&p.LabelExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LabelExpressionContext))

	return p
}

func (s *LabelExpressionDisjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelExpressionDisjunctionContext) AllLabelExpression() []ILabelExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelExpressionContext); ok {
			len++
		}
	}

	tst := make([]ILabelExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelExpressionContext); ok {
			tst[i] = t.(ILabelExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LabelExpressionDisjunctionContext) LabelExpression(i int) ILabelExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelExpressionContext)
}

func (s *LabelExpressionDisjunctionContext) VERTICAL_BAR() antlr.TerminalNode {
	return s.GetToken(GQLParserVERTICAL_BAR, 0)
}

func (s *LabelExpressionDisjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLabelExpressionDisjunction(s)
	}
}

func (s *LabelExpressionDisjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLabelExpressionDisjunction(s)
	}
}

type LabelExpressionParenthesizedContext struct {
	LabelExpressionContext
}

func NewLabelExpressionParenthesizedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelExpressionParenthesizedContext {
	var p = new(LabelExpressionParenthesizedContext)

	InitEmptyLabelExpressionContext(&p.LabelExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LabelExpressionContext))

	return p
}

func (s *LabelExpressionParenthesizedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelExpressionParenthesizedContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *LabelExpressionParenthesizedContext) LabelExpression() ILabelExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelExpressionContext)
}

func (s *LabelExpressionParenthesizedContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *LabelExpressionParenthesizedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLabelExpressionParenthesized(s)
	}
}

func (s *LabelExpressionParenthesizedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLabelExpressionParenthesized(s)
	}
}

type LabelExpressionWildcardContext struct {
	LabelExpressionContext
}

func NewLabelExpressionWildcardContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelExpressionWildcardContext {
	var p = new(LabelExpressionWildcardContext)

	InitEmptyLabelExpressionContext(&p.LabelExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LabelExpressionContext))

	return p
}

func (s *LabelExpressionWildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelExpressionWildcardContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(GQLParserPERCENT, 0)
}

func (s *LabelExpressionWildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLabelExpressionWildcard(s)
	}
}

func (s *LabelExpressionWildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLabelExpressionWildcard(s)
	}
}

type LabelExpressionConjunctionContext struct {
	LabelExpressionContext
}

func NewLabelExpressionConjunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelExpressionConjunctionContext {
	var p = new(LabelExpressionConjunctionContext)

	InitEmptyLabelExpressionContext(&p.LabelExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LabelExpressionContext))

	return p
}

func (s *LabelExpressionConjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelExpressionConjunctionContext) AllLabelExpression() []ILabelExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelExpressionContext); ok {
			len++
		}
	}

	tst := make([]ILabelExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelExpressionContext); ok {
			tst[i] = t.(ILabelExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LabelExpressionConjunctionContext) LabelExpression(i int) ILabelExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelExpressionContext)
}

func (s *LabelExpressionConjunctionContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(GQLParserAMPERSAND, 0)
}

func (s *LabelExpressionConjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLabelExpressionConjunction(s)
	}
}

func (s *LabelExpressionConjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLabelExpressionConjunction(s)
	}
}

type LabelExpressionNameContext struct {
	LabelExpressionContext
}

func NewLabelExpressionNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelExpressionNameContext {
	var p = new(LabelExpressionNameContext)

	InitEmptyLabelExpressionContext(&p.LabelExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LabelExpressionContext))

	return p
}

func (s *LabelExpressionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelExpressionNameContext) LabelName() ILabelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelNameContext)
}

func (s *LabelExpressionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLabelExpressionName(s)
	}
}

func (s *LabelExpressionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLabelExpressionName(s)
	}
}

func (p *GQLParser) LabelExpression() (localctx ILabelExpressionContext) {
	return p.labelExpression(0)
}

func (p *GQLParser) labelExpression(_p int) (localctx ILabelExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewLabelExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILabelExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 428
	p.EnterRecursionRule(localctx, 428, GQLParserRULE_labelExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserEXCLAMATION_MARK:
		localctx = NewLabelExpressionNegationContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(2435)
			p.Match(GQLParserEXCLAMATION_MARK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2436)
			p.labelExpression(6)
		}

	case GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE, GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE, GQLParserREGULAR_IDENTIFIER:
		localctx = NewLabelExpressionNameContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2437)
			p.LabelName()
		}

	case GQLParserPERCENT:
		localctx = NewLabelExpressionWildcardContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2438)
			p.Match(GQLParserPERCENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserLEFT_PAREN:
		localctx = NewLabelExpressionParenthesizedContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2439)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2440)
			p.labelExpression(0)
		}
		{
			p.SetState(2441)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2451)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLabelExpressionConjunctionContext(p, NewLabelExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_labelExpression)
				p.SetState(2445)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(2446)
					p.Match(GQLParserAMPERSAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2447)
					p.labelExpression(6)
				}

			case 2:
				localctx = NewLabelExpressionDisjunctionContext(p, NewLabelExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_labelExpression)
				p.SetState(2448)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(2449)
					p.Match(GQLParserVERTICAL_BAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2450)
					p.labelExpression(5)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2455)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathVariableReferenceContext is an interface to support dynamic dispatch.
type IPathVariableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingVariableReference() IBindingVariableReferenceContext

	// IsPathVariableReferenceContext differentiates from other interfaces.
	IsPathVariableReferenceContext()
}

type PathVariableReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathVariableReferenceContext() *PathVariableReferenceContext {
	var p = new(PathVariableReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathVariableReference
	return p
}

func InitEmptyPathVariableReferenceContext(p *PathVariableReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathVariableReference
}

func (*PathVariableReferenceContext) IsPathVariableReferenceContext() {}

func NewPathVariableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathVariableReferenceContext {
	var p = new(PathVariableReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathVariableReference

	return p
}

func (s *PathVariableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *PathVariableReferenceContext) BindingVariableReference() IBindingVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableReferenceContext)
}

func (s *PathVariableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathVariableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathVariableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathVariableReference(s)
	}
}

func (s *PathVariableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathVariableReference(s)
	}
}

func (p *GQLParser) PathVariableReference() (localctx IPathVariableReferenceContext) {
	localctx = NewPathVariableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, GQLParserRULE_pathVariableReference)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2456)
		p.BindingVariableReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementVariableReferenceContext is an interface to support dynamic dispatch.
type IElementVariableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingVariableReference() IBindingVariableReferenceContext

	// IsElementVariableReferenceContext differentiates from other interfaces.
	IsElementVariableReferenceContext()
}

type ElementVariableReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementVariableReferenceContext() *ElementVariableReferenceContext {
	var p = new(ElementVariableReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementVariableReference
	return p
}

func InitEmptyElementVariableReferenceContext(p *ElementVariableReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementVariableReference
}

func (*ElementVariableReferenceContext) IsElementVariableReferenceContext() {}

func NewElementVariableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementVariableReferenceContext {
	var p = new(ElementVariableReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_elementVariableReference

	return p
}

func (s *ElementVariableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementVariableReferenceContext) BindingVariableReference() IBindingVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableReferenceContext)
}

func (s *ElementVariableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementVariableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementVariableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterElementVariableReference(s)
	}
}

func (s *ElementVariableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitElementVariableReference(s)
	}
}

func (p *GQLParser) ElementVariableReference() (localctx IElementVariableReferenceContext) {
	localctx = NewElementVariableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, GQLParserRULE_elementVariableReference)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2458)
		p.BindingVariableReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphPatternQuantifierContext is an interface to support dynamic dispatch.
type IGraphPatternQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASTERISK() antlr.TerminalNode
	PLUS_SIGN() antlr.TerminalNode
	FixedQuantifier() IFixedQuantifierContext
	GeneralQuantifier() IGeneralQuantifierContext

	// IsGraphPatternQuantifierContext differentiates from other interfaces.
	IsGraphPatternQuantifierContext()
}

type GraphPatternQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphPatternQuantifierContext() *GraphPatternQuantifierContext {
	var p = new(GraphPatternQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphPatternQuantifier
	return p
}

func InitEmptyGraphPatternQuantifierContext(p *GraphPatternQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphPatternQuantifier
}

func (*GraphPatternQuantifierContext) IsGraphPatternQuantifierContext() {}

func NewGraphPatternQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphPatternQuantifierContext {
	var p = new(GraphPatternQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphPatternQuantifier

	return p
}

func (s *GraphPatternQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphPatternQuantifierContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(GQLParserASTERISK, 0)
}

func (s *GraphPatternQuantifierContext) PLUS_SIGN() antlr.TerminalNode {
	return s.GetToken(GQLParserPLUS_SIGN, 0)
}

func (s *GraphPatternQuantifierContext) FixedQuantifier() IFixedQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFixedQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFixedQuantifierContext)
}

func (s *GraphPatternQuantifierContext) GeneralQuantifier() IGeneralQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralQuantifierContext)
}

func (s *GraphPatternQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphPatternQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphPatternQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphPatternQuantifier(s)
	}
}

func (s *GraphPatternQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphPatternQuantifier(s)
	}
}

func (p *GQLParser) GraphPatternQuantifier() (localctx IGraphPatternQuantifierContext) {
	localctx = NewGraphPatternQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, GQLParserRULE_graphPatternQuantifier)
	p.SetState(2464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2460)
			p.Match(GQLParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2461)
			p.Match(GQLParserPLUS_SIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2462)
			p.FixedQuantifier()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2463)
			p.GeneralQuantifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFixedQuantifierContext is an interface to support dynamic dispatch.
type IFixedQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_BRACE() antlr.TerminalNode
	UnsignedInteger() IUnsignedIntegerContext
	RIGHT_BRACE() antlr.TerminalNode

	// IsFixedQuantifierContext differentiates from other interfaces.
	IsFixedQuantifierContext()
}

type FixedQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixedQuantifierContext() *FixedQuantifierContext {
	var p = new(FixedQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fixedQuantifier
	return p
}

func InitEmptyFixedQuantifierContext(p *FixedQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fixedQuantifier
}

func (*FixedQuantifierContext) IsFixedQuantifierContext() {}

func NewFixedQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FixedQuantifierContext {
	var p = new(FixedQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fixedQuantifier

	return p
}

func (s *FixedQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FixedQuantifierContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACE, 0)
}

func (s *FixedQuantifierContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *FixedQuantifierContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACE, 0)
}

func (s *FixedQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FixedQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FixedQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFixedQuantifier(s)
	}
}

func (s *FixedQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFixedQuantifier(s)
	}
}

func (p *GQLParser) FixedQuantifier() (localctx IFixedQuantifierContext) {
	localctx = NewFixedQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, GQLParserRULE_fixedQuantifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2466)
		p.Match(GQLParserLEFT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2467)
		p.UnsignedInteger()
	}
	{
		p.SetState(2468)
		p.Match(GQLParserRIGHT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneralQuantifierContext is an interface to support dynamic dispatch.
type IGeneralQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_BRACE() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	RIGHT_BRACE() antlr.TerminalNode
	LowerBound() ILowerBoundContext
	UpperBound() IUpperBoundContext

	// IsGeneralQuantifierContext differentiates from other interfaces.
	IsGeneralQuantifierContext()
}

type GeneralQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralQuantifierContext() *GeneralQuantifierContext {
	var p = new(GeneralQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalQuantifier
	return p
}

func InitEmptyGeneralQuantifierContext(p *GeneralQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalQuantifier
}

func (*GeneralQuantifierContext) IsGeneralQuantifierContext() {}

func NewGeneralQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralQuantifierContext {
	var p = new(GeneralQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_generalQuantifier

	return p
}

func (s *GeneralQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralQuantifierContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACE, 0)
}

func (s *GeneralQuantifierContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *GeneralQuantifierContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACE, 0)
}

func (s *GeneralQuantifierContext) LowerBound() ILowerBoundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILowerBoundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILowerBoundContext)
}

func (s *GeneralQuantifierContext) UpperBound() IUpperBoundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpperBoundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpperBoundContext)
}

func (s *GeneralQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGeneralQuantifier(s)
	}
}

func (s *GeneralQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGeneralQuantifier(s)
	}
}

func (p *GQLParser) GeneralQuantifier() (localctx IGeneralQuantifierContext) {
	localctx = NewGeneralQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, GQLParserRULE_generalQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2470)
		p.Match(GQLParserLEFT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7864320) != 0 {
		{
			p.SetState(2471)
			p.LowerBound()
		}

	}
	{
		p.SetState(2474)
		p.Match(GQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7864320) != 0 {
		{
			p.SetState(2475)
			p.UpperBound()
		}

	}
	{
		p.SetState(2478)
		p.Match(GQLParserRIGHT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILowerBoundContext is an interface to support dynamic dispatch.
type ILowerBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext

	// IsLowerBoundContext differentiates from other interfaces.
	IsLowerBoundContext()
}

type LowerBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLowerBoundContext() *LowerBoundContext {
	var p = new(LowerBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_lowerBound
	return p
}

func InitEmptyLowerBoundContext(p *LowerBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_lowerBound
}

func (*LowerBoundContext) IsLowerBoundContext() {}

func NewLowerBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LowerBoundContext {
	var p = new(LowerBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_lowerBound

	return p
}

func (s *LowerBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *LowerBoundContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *LowerBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LowerBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LowerBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLowerBound(s)
	}
}

func (s *LowerBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLowerBound(s)
	}
}

func (p *GQLParser) LowerBound() (localctx ILowerBoundContext) {
	localctx = NewLowerBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, GQLParserRULE_lowerBound)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2480)
		p.UnsignedInteger()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpperBoundContext is an interface to support dynamic dispatch.
type IUpperBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext

	// IsUpperBoundContext differentiates from other interfaces.
	IsUpperBoundContext()
}

type UpperBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpperBoundContext() *UpperBoundContext {
	var p = new(UpperBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_upperBound
	return p
}

func InitEmptyUpperBoundContext(p *UpperBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_upperBound
}

func (*UpperBoundContext) IsUpperBoundContext() {}

func NewUpperBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpperBoundContext {
	var p = new(UpperBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_upperBound

	return p
}

func (s *UpperBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *UpperBoundContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *UpperBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpperBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpperBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterUpperBound(s)
	}
}

func (s *UpperBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitUpperBound(s)
	}
}

func (p *GQLParser) UpperBound() (localctx IUpperBoundContext) {
	localctx = NewUpperBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, GQLParserRULE_upperBound)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2482)
		p.UnsignedInteger()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedPathPatternExpressionContext is an interface to support dynamic dispatch.
type ISimplifiedPathPatternExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimplifiedDefaultingLeft() ISimplifiedDefaultingLeftContext
	SimplifiedDefaultingUndirected() ISimplifiedDefaultingUndirectedContext
	SimplifiedDefaultingRight() ISimplifiedDefaultingRightContext
	SimplifiedDefaultingLeftOrUndirected() ISimplifiedDefaultingLeftOrUndirectedContext
	SimplifiedDefaultingUndirectedOrRight() ISimplifiedDefaultingUndirectedOrRightContext
	SimplifiedDefaultingLeftOrRight() ISimplifiedDefaultingLeftOrRightContext
	SimplifiedDefaultingAnyDirection() ISimplifiedDefaultingAnyDirectionContext

	// IsSimplifiedPathPatternExpressionContext differentiates from other interfaces.
	IsSimplifiedPathPatternExpressionContext()
}

type SimplifiedPathPatternExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedPathPatternExpressionContext() *SimplifiedPathPatternExpressionContext {
	var p = new(SimplifiedPathPatternExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedPathPatternExpression
	return p
}

func InitEmptySimplifiedPathPatternExpressionContext(p *SimplifiedPathPatternExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedPathPatternExpression
}

func (*SimplifiedPathPatternExpressionContext) IsSimplifiedPathPatternExpressionContext() {}

func NewSimplifiedPathPatternExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedPathPatternExpressionContext {
	var p = new(SimplifiedPathPatternExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedPathPatternExpression

	return p
}

func (s *SimplifiedPathPatternExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedPathPatternExpressionContext) SimplifiedDefaultingLeft() ISimplifiedDefaultingLeftContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedDefaultingLeftContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedDefaultingLeftContext)
}

func (s *SimplifiedPathPatternExpressionContext) SimplifiedDefaultingUndirected() ISimplifiedDefaultingUndirectedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedDefaultingUndirectedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedDefaultingUndirectedContext)
}

func (s *SimplifiedPathPatternExpressionContext) SimplifiedDefaultingRight() ISimplifiedDefaultingRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedDefaultingRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedDefaultingRightContext)
}

func (s *SimplifiedPathPatternExpressionContext) SimplifiedDefaultingLeftOrUndirected() ISimplifiedDefaultingLeftOrUndirectedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedDefaultingLeftOrUndirectedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedDefaultingLeftOrUndirectedContext)
}

func (s *SimplifiedPathPatternExpressionContext) SimplifiedDefaultingUndirectedOrRight() ISimplifiedDefaultingUndirectedOrRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedDefaultingUndirectedOrRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedDefaultingUndirectedOrRightContext)
}

func (s *SimplifiedPathPatternExpressionContext) SimplifiedDefaultingLeftOrRight() ISimplifiedDefaultingLeftOrRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedDefaultingLeftOrRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedDefaultingLeftOrRightContext)
}

func (s *SimplifiedPathPatternExpressionContext) SimplifiedDefaultingAnyDirection() ISimplifiedDefaultingAnyDirectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedDefaultingAnyDirectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedDefaultingAnyDirectionContext)
}

func (s *SimplifiedPathPatternExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedPathPatternExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedPathPatternExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedPathPatternExpression(s)
	}
}

func (s *SimplifiedPathPatternExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedPathPatternExpression(s)
	}
}

func (p *GQLParser) SimplifiedPathPatternExpression() (localctx ISimplifiedPathPatternExpressionContext) {
	localctx = NewSimplifiedPathPatternExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, GQLParserRULE_simplifiedPathPatternExpression)
	p.SetState(2491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 211, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2484)
			p.SimplifiedDefaultingLeft()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2485)
			p.SimplifiedDefaultingUndirected()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2486)
			p.SimplifiedDefaultingRight()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2487)
			p.SimplifiedDefaultingLeftOrUndirected()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2488)
			p.SimplifiedDefaultingUndirectedOrRight()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2489)
			p.SimplifiedDefaultingLeftOrRight()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2490)
			p.SimplifiedDefaultingAnyDirection()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedDefaultingLeftContext is an interface to support dynamic dispatch.
type ISimplifiedDefaultingLeftContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_MINUS_SLASH() antlr.TerminalNode
	SimplifiedContents() ISimplifiedContentsContext
	SLASH_MINUS() antlr.TerminalNode

	// IsSimplifiedDefaultingLeftContext differentiates from other interfaces.
	IsSimplifiedDefaultingLeftContext()
}

type SimplifiedDefaultingLeftContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedDefaultingLeftContext() *SimplifiedDefaultingLeftContext {
	var p = new(SimplifiedDefaultingLeftContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingLeft
	return p
}

func InitEmptySimplifiedDefaultingLeftContext(p *SimplifiedDefaultingLeftContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingLeft
}

func (*SimplifiedDefaultingLeftContext) IsSimplifiedDefaultingLeftContext() {}

func NewSimplifiedDefaultingLeftContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedDefaultingLeftContext {
	var p = new(SimplifiedDefaultingLeftContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingLeft

	return p
}

func (s *SimplifiedDefaultingLeftContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedDefaultingLeftContext) LEFT_MINUS_SLASH() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_MINUS_SLASH, 0)
}

func (s *SimplifiedDefaultingLeftContext) SimplifiedContents() ISimplifiedContentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedContentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedContentsContext)
}

func (s *SimplifiedDefaultingLeftContext) SLASH_MINUS() antlr.TerminalNode {
	return s.GetToken(GQLParserSLASH_MINUS, 0)
}

func (s *SimplifiedDefaultingLeftContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedDefaultingLeftContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedDefaultingLeftContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedDefaultingLeft(s)
	}
}

func (s *SimplifiedDefaultingLeftContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedDefaultingLeft(s)
	}
}

func (p *GQLParser) SimplifiedDefaultingLeft() (localctx ISimplifiedDefaultingLeftContext) {
	localctx = NewSimplifiedDefaultingLeftContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, GQLParserRULE_simplifiedDefaultingLeft)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2493)
		p.Match(GQLParserLEFT_MINUS_SLASH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2494)
		p.SimplifiedContents()
	}
	{
		p.SetState(2495)
		p.Match(GQLParserSLASH_MINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedDefaultingUndirectedContext is an interface to support dynamic dispatch.
type ISimplifiedDefaultingUndirectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TILDE_SLASH() antlr.TerminalNode
	SimplifiedContents() ISimplifiedContentsContext
	SLASH_TILDE() antlr.TerminalNode

	// IsSimplifiedDefaultingUndirectedContext differentiates from other interfaces.
	IsSimplifiedDefaultingUndirectedContext()
}

type SimplifiedDefaultingUndirectedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedDefaultingUndirectedContext() *SimplifiedDefaultingUndirectedContext {
	var p = new(SimplifiedDefaultingUndirectedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingUndirected
	return p
}

func InitEmptySimplifiedDefaultingUndirectedContext(p *SimplifiedDefaultingUndirectedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingUndirected
}

func (*SimplifiedDefaultingUndirectedContext) IsSimplifiedDefaultingUndirectedContext() {}

func NewSimplifiedDefaultingUndirectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedDefaultingUndirectedContext {
	var p = new(SimplifiedDefaultingUndirectedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingUndirected

	return p
}

func (s *SimplifiedDefaultingUndirectedContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedDefaultingUndirectedContext) TILDE_SLASH() antlr.TerminalNode {
	return s.GetToken(GQLParserTILDE_SLASH, 0)
}

func (s *SimplifiedDefaultingUndirectedContext) SimplifiedContents() ISimplifiedContentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedContentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedContentsContext)
}

func (s *SimplifiedDefaultingUndirectedContext) SLASH_TILDE() antlr.TerminalNode {
	return s.GetToken(GQLParserSLASH_TILDE, 0)
}

func (s *SimplifiedDefaultingUndirectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedDefaultingUndirectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedDefaultingUndirectedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedDefaultingUndirected(s)
	}
}

func (s *SimplifiedDefaultingUndirectedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedDefaultingUndirected(s)
	}
}

func (p *GQLParser) SimplifiedDefaultingUndirected() (localctx ISimplifiedDefaultingUndirectedContext) {
	localctx = NewSimplifiedDefaultingUndirectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, GQLParserRULE_simplifiedDefaultingUndirected)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2497)
		p.Match(GQLParserTILDE_SLASH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2498)
		p.SimplifiedContents()
	}
	{
		p.SetState(2499)
		p.Match(GQLParserSLASH_TILDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedDefaultingRightContext is an interface to support dynamic dispatch.
type ISimplifiedDefaultingRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS_SLASH() antlr.TerminalNode
	SimplifiedContents() ISimplifiedContentsContext
	SLASH_MINUS_RIGHT() antlr.TerminalNode

	// IsSimplifiedDefaultingRightContext differentiates from other interfaces.
	IsSimplifiedDefaultingRightContext()
}

type SimplifiedDefaultingRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedDefaultingRightContext() *SimplifiedDefaultingRightContext {
	var p = new(SimplifiedDefaultingRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingRight
	return p
}

func InitEmptySimplifiedDefaultingRightContext(p *SimplifiedDefaultingRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingRight
}

func (*SimplifiedDefaultingRightContext) IsSimplifiedDefaultingRightContext() {}

func NewSimplifiedDefaultingRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedDefaultingRightContext {
	var p = new(SimplifiedDefaultingRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingRight

	return p
}

func (s *SimplifiedDefaultingRightContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedDefaultingRightContext) MINUS_SLASH() antlr.TerminalNode {
	return s.GetToken(GQLParserMINUS_SLASH, 0)
}

func (s *SimplifiedDefaultingRightContext) SimplifiedContents() ISimplifiedContentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedContentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedContentsContext)
}

func (s *SimplifiedDefaultingRightContext) SLASH_MINUS_RIGHT() antlr.TerminalNode {
	return s.GetToken(GQLParserSLASH_MINUS_RIGHT, 0)
}

func (s *SimplifiedDefaultingRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedDefaultingRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedDefaultingRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedDefaultingRight(s)
	}
}

func (s *SimplifiedDefaultingRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedDefaultingRight(s)
	}
}

func (p *GQLParser) SimplifiedDefaultingRight() (localctx ISimplifiedDefaultingRightContext) {
	localctx = NewSimplifiedDefaultingRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, GQLParserRULE_simplifiedDefaultingRight)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2501)
		p.Match(GQLParserMINUS_SLASH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2502)
		p.SimplifiedContents()
	}
	{
		p.SetState(2503)
		p.Match(GQLParserSLASH_MINUS_RIGHT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedDefaultingLeftOrUndirectedContext is an interface to support dynamic dispatch.
type ISimplifiedDefaultingLeftOrUndirectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_TILDE_SLASH() antlr.TerminalNode
	SimplifiedContents() ISimplifiedContentsContext
	SLASH_TILDE() antlr.TerminalNode

	// IsSimplifiedDefaultingLeftOrUndirectedContext differentiates from other interfaces.
	IsSimplifiedDefaultingLeftOrUndirectedContext()
}

type SimplifiedDefaultingLeftOrUndirectedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedDefaultingLeftOrUndirectedContext() *SimplifiedDefaultingLeftOrUndirectedContext {
	var p = new(SimplifiedDefaultingLeftOrUndirectedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingLeftOrUndirected
	return p
}

func InitEmptySimplifiedDefaultingLeftOrUndirectedContext(p *SimplifiedDefaultingLeftOrUndirectedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingLeftOrUndirected
}

func (*SimplifiedDefaultingLeftOrUndirectedContext) IsSimplifiedDefaultingLeftOrUndirectedContext() {}

func NewSimplifiedDefaultingLeftOrUndirectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedDefaultingLeftOrUndirectedContext {
	var p = new(SimplifiedDefaultingLeftOrUndirectedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingLeftOrUndirected

	return p
}

func (s *SimplifiedDefaultingLeftOrUndirectedContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedDefaultingLeftOrUndirectedContext) LEFT_TILDE_SLASH() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_TILDE_SLASH, 0)
}

func (s *SimplifiedDefaultingLeftOrUndirectedContext) SimplifiedContents() ISimplifiedContentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedContentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedContentsContext)
}

func (s *SimplifiedDefaultingLeftOrUndirectedContext) SLASH_TILDE() antlr.TerminalNode {
	return s.GetToken(GQLParserSLASH_TILDE, 0)
}

func (s *SimplifiedDefaultingLeftOrUndirectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedDefaultingLeftOrUndirectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedDefaultingLeftOrUndirectedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedDefaultingLeftOrUndirected(s)
	}
}

func (s *SimplifiedDefaultingLeftOrUndirectedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedDefaultingLeftOrUndirected(s)
	}
}

func (p *GQLParser) SimplifiedDefaultingLeftOrUndirected() (localctx ISimplifiedDefaultingLeftOrUndirectedContext) {
	localctx = NewSimplifiedDefaultingLeftOrUndirectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, GQLParserRULE_simplifiedDefaultingLeftOrUndirected)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2505)
		p.Match(GQLParserLEFT_TILDE_SLASH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2506)
		p.SimplifiedContents()
	}
	{
		p.SetState(2507)
		p.Match(GQLParserSLASH_TILDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedDefaultingUndirectedOrRightContext is an interface to support dynamic dispatch.
type ISimplifiedDefaultingUndirectedOrRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TILDE_SLASH() antlr.TerminalNode
	SimplifiedContents() ISimplifiedContentsContext
	SLASH_TILDE_RIGHT() antlr.TerminalNode

	// IsSimplifiedDefaultingUndirectedOrRightContext differentiates from other interfaces.
	IsSimplifiedDefaultingUndirectedOrRightContext()
}

type SimplifiedDefaultingUndirectedOrRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedDefaultingUndirectedOrRightContext() *SimplifiedDefaultingUndirectedOrRightContext {
	var p = new(SimplifiedDefaultingUndirectedOrRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingUndirectedOrRight
	return p
}

func InitEmptySimplifiedDefaultingUndirectedOrRightContext(p *SimplifiedDefaultingUndirectedOrRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingUndirectedOrRight
}

func (*SimplifiedDefaultingUndirectedOrRightContext) IsSimplifiedDefaultingUndirectedOrRightContext() {
}

func NewSimplifiedDefaultingUndirectedOrRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedDefaultingUndirectedOrRightContext {
	var p = new(SimplifiedDefaultingUndirectedOrRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingUndirectedOrRight

	return p
}

func (s *SimplifiedDefaultingUndirectedOrRightContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedDefaultingUndirectedOrRightContext) TILDE_SLASH() antlr.TerminalNode {
	return s.GetToken(GQLParserTILDE_SLASH, 0)
}

func (s *SimplifiedDefaultingUndirectedOrRightContext) SimplifiedContents() ISimplifiedContentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedContentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedContentsContext)
}

func (s *SimplifiedDefaultingUndirectedOrRightContext) SLASH_TILDE_RIGHT() antlr.TerminalNode {
	return s.GetToken(GQLParserSLASH_TILDE_RIGHT, 0)
}

func (s *SimplifiedDefaultingUndirectedOrRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedDefaultingUndirectedOrRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedDefaultingUndirectedOrRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedDefaultingUndirectedOrRight(s)
	}
}

func (s *SimplifiedDefaultingUndirectedOrRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedDefaultingUndirectedOrRight(s)
	}
}

func (p *GQLParser) SimplifiedDefaultingUndirectedOrRight() (localctx ISimplifiedDefaultingUndirectedOrRightContext) {
	localctx = NewSimplifiedDefaultingUndirectedOrRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, GQLParserRULE_simplifiedDefaultingUndirectedOrRight)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2509)
		p.Match(GQLParserTILDE_SLASH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2510)
		p.SimplifiedContents()
	}
	{
		p.SetState(2511)
		p.Match(GQLParserSLASH_TILDE_RIGHT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedDefaultingLeftOrRightContext is an interface to support dynamic dispatch.
type ISimplifiedDefaultingLeftOrRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_MINUS_SLASH() antlr.TerminalNode
	SimplifiedContents() ISimplifiedContentsContext
	SLASH_MINUS_RIGHT() antlr.TerminalNode

	// IsSimplifiedDefaultingLeftOrRightContext differentiates from other interfaces.
	IsSimplifiedDefaultingLeftOrRightContext()
}

type SimplifiedDefaultingLeftOrRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedDefaultingLeftOrRightContext() *SimplifiedDefaultingLeftOrRightContext {
	var p = new(SimplifiedDefaultingLeftOrRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingLeftOrRight
	return p
}

func InitEmptySimplifiedDefaultingLeftOrRightContext(p *SimplifiedDefaultingLeftOrRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingLeftOrRight
}

func (*SimplifiedDefaultingLeftOrRightContext) IsSimplifiedDefaultingLeftOrRightContext() {}

func NewSimplifiedDefaultingLeftOrRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedDefaultingLeftOrRightContext {
	var p = new(SimplifiedDefaultingLeftOrRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingLeftOrRight

	return p
}

func (s *SimplifiedDefaultingLeftOrRightContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedDefaultingLeftOrRightContext) LEFT_MINUS_SLASH() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_MINUS_SLASH, 0)
}

func (s *SimplifiedDefaultingLeftOrRightContext) SimplifiedContents() ISimplifiedContentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedContentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedContentsContext)
}

func (s *SimplifiedDefaultingLeftOrRightContext) SLASH_MINUS_RIGHT() antlr.TerminalNode {
	return s.GetToken(GQLParserSLASH_MINUS_RIGHT, 0)
}

func (s *SimplifiedDefaultingLeftOrRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedDefaultingLeftOrRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedDefaultingLeftOrRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedDefaultingLeftOrRight(s)
	}
}

func (s *SimplifiedDefaultingLeftOrRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedDefaultingLeftOrRight(s)
	}
}

func (p *GQLParser) SimplifiedDefaultingLeftOrRight() (localctx ISimplifiedDefaultingLeftOrRightContext) {
	localctx = NewSimplifiedDefaultingLeftOrRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, GQLParserRULE_simplifiedDefaultingLeftOrRight)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2513)
		p.Match(GQLParserLEFT_MINUS_SLASH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2514)
		p.SimplifiedContents()
	}
	{
		p.SetState(2515)
		p.Match(GQLParserSLASH_MINUS_RIGHT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedDefaultingAnyDirectionContext is an interface to support dynamic dispatch.
type ISimplifiedDefaultingAnyDirectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS_SLASH() antlr.TerminalNode
	SimplifiedContents() ISimplifiedContentsContext
	SLASH_MINUS() antlr.TerminalNode

	// IsSimplifiedDefaultingAnyDirectionContext differentiates from other interfaces.
	IsSimplifiedDefaultingAnyDirectionContext()
}

type SimplifiedDefaultingAnyDirectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedDefaultingAnyDirectionContext() *SimplifiedDefaultingAnyDirectionContext {
	var p = new(SimplifiedDefaultingAnyDirectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingAnyDirection
	return p
}

func InitEmptySimplifiedDefaultingAnyDirectionContext(p *SimplifiedDefaultingAnyDirectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingAnyDirection
}

func (*SimplifiedDefaultingAnyDirectionContext) IsSimplifiedDefaultingAnyDirectionContext() {}

func NewSimplifiedDefaultingAnyDirectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedDefaultingAnyDirectionContext {
	var p = new(SimplifiedDefaultingAnyDirectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedDefaultingAnyDirection

	return p
}

func (s *SimplifiedDefaultingAnyDirectionContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedDefaultingAnyDirectionContext) MINUS_SLASH() antlr.TerminalNode {
	return s.GetToken(GQLParserMINUS_SLASH, 0)
}

func (s *SimplifiedDefaultingAnyDirectionContext) SimplifiedContents() ISimplifiedContentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedContentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedContentsContext)
}

func (s *SimplifiedDefaultingAnyDirectionContext) SLASH_MINUS() antlr.TerminalNode {
	return s.GetToken(GQLParserSLASH_MINUS, 0)
}

func (s *SimplifiedDefaultingAnyDirectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedDefaultingAnyDirectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedDefaultingAnyDirectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedDefaultingAnyDirection(s)
	}
}

func (s *SimplifiedDefaultingAnyDirectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedDefaultingAnyDirection(s)
	}
}

func (p *GQLParser) SimplifiedDefaultingAnyDirection() (localctx ISimplifiedDefaultingAnyDirectionContext) {
	localctx = NewSimplifiedDefaultingAnyDirectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, GQLParserRULE_simplifiedDefaultingAnyDirection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2517)
		p.Match(GQLParserMINUS_SLASH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2518)
		p.SimplifiedContents()
	}
	{
		p.SetState(2519)
		p.Match(GQLParserSLASH_MINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedContentsContext is an interface to support dynamic dispatch.
type ISimplifiedContentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimplifiedTerm() ISimplifiedTermContext
	SimplifiedPathUnion() ISimplifiedPathUnionContext
	SimplifiedMultisetAlternation() ISimplifiedMultisetAlternationContext

	// IsSimplifiedContentsContext differentiates from other interfaces.
	IsSimplifiedContentsContext()
}

type SimplifiedContentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedContentsContext() *SimplifiedContentsContext {
	var p = new(SimplifiedContentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedContents
	return p
}

func InitEmptySimplifiedContentsContext(p *SimplifiedContentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedContents
}

func (*SimplifiedContentsContext) IsSimplifiedContentsContext() {}

func NewSimplifiedContentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedContentsContext {
	var p = new(SimplifiedContentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedContents

	return p
}

func (s *SimplifiedContentsContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedContentsContext) SimplifiedTerm() ISimplifiedTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedTermContext)
}

func (s *SimplifiedContentsContext) SimplifiedPathUnion() ISimplifiedPathUnionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedPathUnionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedPathUnionContext)
}

func (s *SimplifiedContentsContext) SimplifiedMultisetAlternation() ISimplifiedMultisetAlternationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedMultisetAlternationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedMultisetAlternationContext)
}

func (s *SimplifiedContentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedContentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedContentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedContents(s)
	}
}

func (s *SimplifiedContentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedContents(s)
	}
}

func (p *GQLParser) SimplifiedContents() (localctx ISimplifiedContentsContext) {
	localctx = NewSimplifiedContentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, GQLParserRULE_simplifiedContents)
	p.SetState(2524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2521)
			p.simplifiedTerm(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2522)
			p.SimplifiedPathUnion()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2523)
			p.SimplifiedMultisetAlternation()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedPathUnionContext is an interface to support dynamic dispatch.
type ISimplifiedPathUnionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimplifiedTerm() []ISimplifiedTermContext
	SimplifiedTerm(i int) ISimplifiedTermContext
	AllVERTICAL_BAR() []antlr.TerminalNode
	VERTICAL_BAR(i int) antlr.TerminalNode

	// IsSimplifiedPathUnionContext differentiates from other interfaces.
	IsSimplifiedPathUnionContext()
}

type SimplifiedPathUnionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedPathUnionContext() *SimplifiedPathUnionContext {
	var p = new(SimplifiedPathUnionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedPathUnion
	return p
}

func InitEmptySimplifiedPathUnionContext(p *SimplifiedPathUnionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedPathUnion
}

func (*SimplifiedPathUnionContext) IsSimplifiedPathUnionContext() {}

func NewSimplifiedPathUnionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedPathUnionContext {
	var p = new(SimplifiedPathUnionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedPathUnion

	return p
}

func (s *SimplifiedPathUnionContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedPathUnionContext) AllSimplifiedTerm() []ISimplifiedTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimplifiedTermContext); ok {
			len++
		}
	}

	tst := make([]ISimplifiedTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimplifiedTermContext); ok {
			tst[i] = t.(ISimplifiedTermContext)
			i++
		}
	}

	return tst
}

func (s *SimplifiedPathUnionContext) SimplifiedTerm(i int) ISimplifiedTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedTermContext)
}

func (s *SimplifiedPathUnionContext) AllVERTICAL_BAR() []antlr.TerminalNode {
	return s.GetTokens(GQLParserVERTICAL_BAR)
}

func (s *SimplifiedPathUnionContext) VERTICAL_BAR(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserVERTICAL_BAR, i)
}

func (s *SimplifiedPathUnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedPathUnionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedPathUnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedPathUnion(s)
	}
}

func (s *SimplifiedPathUnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedPathUnion(s)
	}
}

func (p *GQLParser) SimplifiedPathUnion() (localctx ISimplifiedPathUnionContext) {
	localctx = NewSimplifiedPathUnionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, GQLParserRULE_simplifiedPathUnion)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2526)
		p.simplifiedTerm(0)
	}
	{
		p.SetState(2527)
		p.Match(GQLParserVERTICAL_BAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2528)
		p.simplifiedTerm(0)
	}
	p.SetState(2533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserVERTICAL_BAR {
		{
			p.SetState(2529)
			p.Match(GQLParserVERTICAL_BAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2530)
			p.simplifiedTerm(0)
		}

		p.SetState(2535)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedMultisetAlternationContext is an interface to support dynamic dispatch.
type ISimplifiedMultisetAlternationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimplifiedTerm() []ISimplifiedTermContext
	SimplifiedTerm(i int) ISimplifiedTermContext
	AllMULTISET_ALTERNATION_OPERATOR() []antlr.TerminalNode
	MULTISET_ALTERNATION_OPERATOR(i int) antlr.TerminalNode

	// IsSimplifiedMultisetAlternationContext differentiates from other interfaces.
	IsSimplifiedMultisetAlternationContext()
}

type SimplifiedMultisetAlternationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedMultisetAlternationContext() *SimplifiedMultisetAlternationContext {
	var p = new(SimplifiedMultisetAlternationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedMultisetAlternation
	return p
}

func InitEmptySimplifiedMultisetAlternationContext(p *SimplifiedMultisetAlternationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedMultisetAlternation
}

func (*SimplifiedMultisetAlternationContext) IsSimplifiedMultisetAlternationContext() {}

func NewSimplifiedMultisetAlternationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedMultisetAlternationContext {
	var p = new(SimplifiedMultisetAlternationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedMultisetAlternation

	return p
}

func (s *SimplifiedMultisetAlternationContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedMultisetAlternationContext) AllSimplifiedTerm() []ISimplifiedTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimplifiedTermContext); ok {
			len++
		}
	}

	tst := make([]ISimplifiedTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimplifiedTermContext); ok {
			tst[i] = t.(ISimplifiedTermContext)
			i++
		}
	}

	return tst
}

func (s *SimplifiedMultisetAlternationContext) SimplifiedTerm(i int) ISimplifiedTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedTermContext)
}

func (s *SimplifiedMultisetAlternationContext) AllMULTISET_ALTERNATION_OPERATOR() []antlr.TerminalNode {
	return s.GetTokens(GQLParserMULTISET_ALTERNATION_OPERATOR)
}

func (s *SimplifiedMultisetAlternationContext) MULTISET_ALTERNATION_OPERATOR(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserMULTISET_ALTERNATION_OPERATOR, i)
}

func (s *SimplifiedMultisetAlternationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedMultisetAlternationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedMultisetAlternationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedMultisetAlternation(s)
	}
}

func (s *SimplifiedMultisetAlternationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedMultisetAlternation(s)
	}
}

func (p *GQLParser) SimplifiedMultisetAlternation() (localctx ISimplifiedMultisetAlternationContext) {
	localctx = NewSimplifiedMultisetAlternationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, GQLParserRULE_simplifiedMultisetAlternation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2536)
		p.simplifiedTerm(0)
	}
	{
		p.SetState(2537)
		p.Match(GQLParserMULTISET_ALTERNATION_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2538)
		p.simplifiedTerm(0)
	}
	p.SetState(2543)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserMULTISET_ALTERNATION_OPERATOR {
		{
			p.SetState(2539)
			p.Match(GQLParserMULTISET_ALTERNATION_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2540)
			p.simplifiedTerm(0)
		}

		p.SetState(2545)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedTermContext is an interface to support dynamic dispatch.
type ISimplifiedTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSimplifiedTermContext differentiates from other interfaces.
	IsSimplifiedTermContext()
}

type SimplifiedTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedTermContext() *SimplifiedTermContext {
	var p = new(SimplifiedTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedTerm
	return p
}

func InitEmptySimplifiedTermContext(p *SimplifiedTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedTerm
}

func (*SimplifiedTermContext) IsSimplifiedTermContext() {}

func NewSimplifiedTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedTermContext {
	var p = new(SimplifiedTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedTerm

	return p
}

func (s *SimplifiedTermContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedTermContext) CopyAll(ctx *SimplifiedTermContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SimplifiedTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SimplifiedFactorLowLabelContext struct {
	SimplifiedTermContext
}

func NewSimplifiedFactorLowLabelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimplifiedFactorLowLabelContext {
	var p = new(SimplifiedFactorLowLabelContext)

	InitEmptySimplifiedTermContext(&p.SimplifiedTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimplifiedTermContext))

	return p
}

func (s *SimplifiedFactorLowLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedFactorLowLabelContext) SimplifiedFactorLow() ISimplifiedFactorLowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedFactorLowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedFactorLowContext)
}

func (s *SimplifiedFactorLowLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedFactorLowLabel(s)
	}
}

func (s *SimplifiedFactorLowLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedFactorLowLabel(s)
	}
}

type SimplifiedConcatenationLabelContext struct {
	SimplifiedTermContext
}

func NewSimplifiedConcatenationLabelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimplifiedConcatenationLabelContext {
	var p = new(SimplifiedConcatenationLabelContext)

	InitEmptySimplifiedTermContext(&p.SimplifiedTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimplifiedTermContext))

	return p
}

func (s *SimplifiedConcatenationLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedConcatenationLabelContext) SimplifiedTerm() ISimplifiedTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedTermContext)
}

func (s *SimplifiedConcatenationLabelContext) SimplifiedFactorLow() ISimplifiedFactorLowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedFactorLowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedFactorLowContext)
}

func (s *SimplifiedConcatenationLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedConcatenationLabel(s)
	}
}

func (s *SimplifiedConcatenationLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedConcatenationLabel(s)
	}
}

func (p *GQLParser) SimplifiedTerm() (localctx ISimplifiedTermContext) {
	return p.simplifiedTerm(0)
}

func (p *GQLParser) simplifiedTerm(_p int) (localctx ISimplifiedTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewSimplifiedTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISimplifiedTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 466
	p.EnterRecursionRule(localctx, 466, GQLParserRULE_simplifiedTerm, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewSimplifiedFactorLowLabelContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(2547)
		p.simplifiedFactorLow(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2553)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 215, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewSimplifiedConcatenationLabelContext(p, NewSimplifiedTermContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_simplifiedTerm)
			p.SetState(2549)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(2550)
				p.simplifiedFactorLow(0)
			}

		}
		p.SetState(2555)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 215, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedFactorLowContext is an interface to support dynamic dispatch.
type ISimplifiedFactorLowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSimplifiedFactorLowContext differentiates from other interfaces.
	IsSimplifiedFactorLowContext()
}

type SimplifiedFactorLowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedFactorLowContext() *SimplifiedFactorLowContext {
	var p = new(SimplifiedFactorLowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedFactorLow
	return p
}

func InitEmptySimplifiedFactorLowContext(p *SimplifiedFactorLowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedFactorLow
}

func (*SimplifiedFactorLowContext) IsSimplifiedFactorLowContext() {}

func NewSimplifiedFactorLowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedFactorLowContext {
	var p = new(SimplifiedFactorLowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedFactorLow

	return p
}

func (s *SimplifiedFactorLowContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedFactorLowContext) CopyAll(ctx *SimplifiedFactorLowContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SimplifiedFactorLowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedFactorLowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SimplifiedConjunctionLabelContext struct {
	SimplifiedFactorLowContext
}

func NewSimplifiedConjunctionLabelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimplifiedConjunctionLabelContext {
	var p = new(SimplifiedConjunctionLabelContext)

	InitEmptySimplifiedFactorLowContext(&p.SimplifiedFactorLowContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimplifiedFactorLowContext))

	return p
}

func (s *SimplifiedConjunctionLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedConjunctionLabelContext) SimplifiedFactorLow() ISimplifiedFactorLowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedFactorLowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedFactorLowContext)
}

func (s *SimplifiedConjunctionLabelContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(GQLParserAMPERSAND, 0)
}

func (s *SimplifiedConjunctionLabelContext) SimplifiedFactorHigh() ISimplifiedFactorHighContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedFactorHighContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedFactorHighContext)
}

func (s *SimplifiedConjunctionLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedConjunctionLabel(s)
	}
}

func (s *SimplifiedConjunctionLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedConjunctionLabel(s)
	}
}

type SimplifiedFactorHighLabelContext struct {
	SimplifiedFactorLowContext
}

func NewSimplifiedFactorHighLabelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimplifiedFactorHighLabelContext {
	var p = new(SimplifiedFactorHighLabelContext)

	InitEmptySimplifiedFactorLowContext(&p.SimplifiedFactorLowContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimplifiedFactorLowContext))

	return p
}

func (s *SimplifiedFactorHighLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedFactorHighLabelContext) SimplifiedFactorHigh() ISimplifiedFactorHighContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedFactorHighContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedFactorHighContext)
}

func (s *SimplifiedFactorHighLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedFactorHighLabel(s)
	}
}

func (s *SimplifiedFactorHighLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedFactorHighLabel(s)
	}
}

func (p *GQLParser) SimplifiedFactorLow() (localctx ISimplifiedFactorLowContext) {
	return p.simplifiedFactorLow(0)
}

func (p *GQLParser) simplifiedFactorLow(_p int) (localctx ISimplifiedFactorLowContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewSimplifiedFactorLowContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISimplifiedFactorLowContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 468
	p.EnterRecursionRule(localctx, 468, GQLParserRULE_simplifiedFactorLow, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewSimplifiedFactorHighLabelContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(2557)
		p.SimplifiedFactorHigh()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2564)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewSimplifiedConjunctionLabelContext(p, NewSimplifiedFactorLowContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_simplifiedFactorLow)
			p.SetState(2559)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(2560)
				p.Match(GQLParserAMPERSAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2561)
				p.SimplifiedFactorHigh()
			}

		}
		p.SetState(2566)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedFactorHighContext is an interface to support dynamic dispatch.
type ISimplifiedFactorHighContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimplifiedTertiary() ISimplifiedTertiaryContext
	SimplifiedQuantified() ISimplifiedQuantifiedContext
	SimplifiedQuestioned() ISimplifiedQuestionedContext

	// IsSimplifiedFactorHighContext differentiates from other interfaces.
	IsSimplifiedFactorHighContext()
}

type SimplifiedFactorHighContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedFactorHighContext() *SimplifiedFactorHighContext {
	var p = new(SimplifiedFactorHighContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedFactorHigh
	return p
}

func InitEmptySimplifiedFactorHighContext(p *SimplifiedFactorHighContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedFactorHigh
}

func (*SimplifiedFactorHighContext) IsSimplifiedFactorHighContext() {}

func NewSimplifiedFactorHighContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedFactorHighContext {
	var p = new(SimplifiedFactorHighContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedFactorHigh

	return p
}

func (s *SimplifiedFactorHighContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedFactorHighContext) SimplifiedTertiary() ISimplifiedTertiaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedTertiaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedTertiaryContext)
}

func (s *SimplifiedFactorHighContext) SimplifiedQuantified() ISimplifiedQuantifiedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedQuantifiedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedQuantifiedContext)
}

func (s *SimplifiedFactorHighContext) SimplifiedQuestioned() ISimplifiedQuestionedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedQuestionedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedQuestionedContext)
}

func (s *SimplifiedFactorHighContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedFactorHighContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedFactorHighContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedFactorHigh(s)
	}
}

func (s *SimplifiedFactorHighContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedFactorHigh(s)
	}
}

func (p *GQLParser) SimplifiedFactorHigh() (localctx ISimplifiedFactorHighContext) {
	localctx = NewSimplifiedFactorHighContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, GQLParserRULE_simplifiedFactorHigh)
	p.SetState(2570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2567)
			p.SimplifiedTertiary()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2568)
			p.SimplifiedQuantified()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2569)
			p.SimplifiedQuestioned()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedQuantifiedContext is an interface to support dynamic dispatch.
type ISimplifiedQuantifiedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimplifiedTertiary() ISimplifiedTertiaryContext
	GraphPatternQuantifier() IGraphPatternQuantifierContext

	// IsSimplifiedQuantifiedContext differentiates from other interfaces.
	IsSimplifiedQuantifiedContext()
}

type SimplifiedQuantifiedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedQuantifiedContext() *SimplifiedQuantifiedContext {
	var p = new(SimplifiedQuantifiedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedQuantified
	return p
}

func InitEmptySimplifiedQuantifiedContext(p *SimplifiedQuantifiedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedQuantified
}

func (*SimplifiedQuantifiedContext) IsSimplifiedQuantifiedContext() {}

func NewSimplifiedQuantifiedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedQuantifiedContext {
	var p = new(SimplifiedQuantifiedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedQuantified

	return p
}

func (s *SimplifiedQuantifiedContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedQuantifiedContext) SimplifiedTertiary() ISimplifiedTertiaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedTertiaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedTertiaryContext)
}

func (s *SimplifiedQuantifiedContext) GraphPatternQuantifier() IGraphPatternQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphPatternQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphPatternQuantifierContext)
}

func (s *SimplifiedQuantifiedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedQuantifiedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedQuantifiedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedQuantified(s)
	}
}

func (s *SimplifiedQuantifiedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedQuantified(s)
	}
}

func (p *GQLParser) SimplifiedQuantified() (localctx ISimplifiedQuantifiedContext) {
	localctx = NewSimplifiedQuantifiedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, GQLParserRULE_simplifiedQuantified)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2572)
		p.SimplifiedTertiary()
	}
	{
		p.SetState(2573)
		p.GraphPatternQuantifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedQuestionedContext is an interface to support dynamic dispatch.
type ISimplifiedQuestionedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimplifiedTertiary() ISimplifiedTertiaryContext
	QUESTION_MARK() antlr.TerminalNode

	// IsSimplifiedQuestionedContext differentiates from other interfaces.
	IsSimplifiedQuestionedContext()
}

type SimplifiedQuestionedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedQuestionedContext() *SimplifiedQuestionedContext {
	var p = new(SimplifiedQuestionedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedQuestioned
	return p
}

func InitEmptySimplifiedQuestionedContext(p *SimplifiedQuestionedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedQuestioned
}

func (*SimplifiedQuestionedContext) IsSimplifiedQuestionedContext() {}

func NewSimplifiedQuestionedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedQuestionedContext {
	var p = new(SimplifiedQuestionedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedQuestioned

	return p
}

func (s *SimplifiedQuestionedContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedQuestionedContext) SimplifiedTertiary() ISimplifiedTertiaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedTertiaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedTertiaryContext)
}

func (s *SimplifiedQuestionedContext) QUESTION_MARK() antlr.TerminalNode {
	return s.GetToken(GQLParserQUESTION_MARK, 0)
}

func (s *SimplifiedQuestionedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedQuestionedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedQuestionedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedQuestioned(s)
	}
}

func (s *SimplifiedQuestionedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedQuestioned(s)
	}
}

func (p *GQLParser) SimplifiedQuestioned() (localctx ISimplifiedQuestionedContext) {
	localctx = NewSimplifiedQuestionedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, GQLParserRULE_simplifiedQuestioned)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2575)
		p.SimplifiedTertiary()
	}
	{
		p.SetState(2576)
		p.Match(GQLParserQUESTION_MARK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedTertiaryContext is an interface to support dynamic dispatch.
type ISimplifiedTertiaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimplifiedDirectionOverride() ISimplifiedDirectionOverrideContext
	SimplifiedSecondary() ISimplifiedSecondaryContext

	// IsSimplifiedTertiaryContext differentiates from other interfaces.
	IsSimplifiedTertiaryContext()
}

type SimplifiedTertiaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedTertiaryContext() *SimplifiedTertiaryContext {
	var p = new(SimplifiedTertiaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedTertiary
	return p
}

func InitEmptySimplifiedTertiaryContext(p *SimplifiedTertiaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedTertiary
}

func (*SimplifiedTertiaryContext) IsSimplifiedTertiaryContext() {}

func NewSimplifiedTertiaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedTertiaryContext {
	var p = new(SimplifiedTertiaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedTertiary

	return p
}

func (s *SimplifiedTertiaryContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedTertiaryContext) SimplifiedDirectionOverride() ISimplifiedDirectionOverrideContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedDirectionOverrideContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedDirectionOverrideContext)
}

func (s *SimplifiedTertiaryContext) SimplifiedSecondary() ISimplifiedSecondaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedSecondaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedSecondaryContext)
}

func (s *SimplifiedTertiaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedTertiaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedTertiaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedTertiary(s)
	}
}

func (s *SimplifiedTertiaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedTertiary(s)
	}
}

func (p *GQLParser) SimplifiedTertiary() (localctx ISimplifiedTertiaryContext) {
	localctx = NewSimplifiedTertiaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, GQLParserRULE_simplifiedTertiary)
	p.SetState(2580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 218, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2578)
			p.SimplifiedDirectionOverride()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2579)
			p.SimplifiedSecondary()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedDirectionOverrideContext is an interface to support dynamic dispatch.
type ISimplifiedDirectionOverrideContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimplifiedOverrideLeft() ISimplifiedOverrideLeftContext
	SimplifiedOverrideUndirected() ISimplifiedOverrideUndirectedContext
	SimplifiedOverrideRight() ISimplifiedOverrideRightContext
	SimplifiedOverrideLeftOrUndirected() ISimplifiedOverrideLeftOrUndirectedContext
	SimplifiedOverrideUndirectedOrRight() ISimplifiedOverrideUndirectedOrRightContext
	SimplifiedOverrideLeftOrRight() ISimplifiedOverrideLeftOrRightContext
	SimplifiedOverrideAnyDirection() ISimplifiedOverrideAnyDirectionContext

	// IsSimplifiedDirectionOverrideContext differentiates from other interfaces.
	IsSimplifiedDirectionOverrideContext()
}

type SimplifiedDirectionOverrideContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedDirectionOverrideContext() *SimplifiedDirectionOverrideContext {
	var p = new(SimplifiedDirectionOverrideContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDirectionOverride
	return p
}

func InitEmptySimplifiedDirectionOverrideContext(p *SimplifiedDirectionOverrideContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedDirectionOverride
}

func (*SimplifiedDirectionOverrideContext) IsSimplifiedDirectionOverrideContext() {}

func NewSimplifiedDirectionOverrideContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedDirectionOverrideContext {
	var p = new(SimplifiedDirectionOverrideContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedDirectionOverride

	return p
}

func (s *SimplifiedDirectionOverrideContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedDirectionOverrideContext) SimplifiedOverrideLeft() ISimplifiedOverrideLeftContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedOverrideLeftContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedOverrideLeftContext)
}

func (s *SimplifiedDirectionOverrideContext) SimplifiedOverrideUndirected() ISimplifiedOverrideUndirectedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedOverrideUndirectedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedOverrideUndirectedContext)
}

func (s *SimplifiedDirectionOverrideContext) SimplifiedOverrideRight() ISimplifiedOverrideRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedOverrideRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedOverrideRightContext)
}

func (s *SimplifiedDirectionOverrideContext) SimplifiedOverrideLeftOrUndirected() ISimplifiedOverrideLeftOrUndirectedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedOverrideLeftOrUndirectedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedOverrideLeftOrUndirectedContext)
}

func (s *SimplifiedDirectionOverrideContext) SimplifiedOverrideUndirectedOrRight() ISimplifiedOverrideUndirectedOrRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedOverrideUndirectedOrRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedOverrideUndirectedOrRightContext)
}

func (s *SimplifiedDirectionOverrideContext) SimplifiedOverrideLeftOrRight() ISimplifiedOverrideLeftOrRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedOverrideLeftOrRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedOverrideLeftOrRightContext)
}

func (s *SimplifiedDirectionOverrideContext) SimplifiedOverrideAnyDirection() ISimplifiedOverrideAnyDirectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedOverrideAnyDirectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedOverrideAnyDirectionContext)
}

func (s *SimplifiedDirectionOverrideContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedDirectionOverrideContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedDirectionOverrideContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedDirectionOverride(s)
	}
}

func (s *SimplifiedDirectionOverrideContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedDirectionOverride(s)
	}
}

func (p *GQLParser) SimplifiedDirectionOverride() (localctx ISimplifiedDirectionOverrideContext) {
	localctx = NewSimplifiedDirectionOverrideContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, GQLParserRULE_simplifiedDirectionOverride)
	p.SetState(2589)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 219, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2582)
			p.SimplifiedOverrideLeft()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2583)
			p.SimplifiedOverrideUndirected()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2584)
			p.SimplifiedOverrideRight()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2585)
			p.SimplifiedOverrideLeftOrUndirected()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2586)
			p.SimplifiedOverrideUndirectedOrRight()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2587)
			p.SimplifiedOverrideLeftOrRight()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2588)
			p.SimplifiedOverrideAnyDirection()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedOverrideLeftContext is an interface to support dynamic dispatch.
type ISimplifiedOverrideLeftContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_ANGLE_BRACKET() antlr.TerminalNode
	SimplifiedSecondary() ISimplifiedSecondaryContext

	// IsSimplifiedOverrideLeftContext differentiates from other interfaces.
	IsSimplifiedOverrideLeftContext()
}

type SimplifiedOverrideLeftContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedOverrideLeftContext() *SimplifiedOverrideLeftContext {
	var p = new(SimplifiedOverrideLeftContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedOverrideLeft
	return p
}

func InitEmptySimplifiedOverrideLeftContext(p *SimplifiedOverrideLeftContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedOverrideLeft
}

func (*SimplifiedOverrideLeftContext) IsSimplifiedOverrideLeftContext() {}

func NewSimplifiedOverrideLeftContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedOverrideLeftContext {
	var p = new(SimplifiedOverrideLeftContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedOverrideLeft

	return p
}

func (s *SimplifiedOverrideLeftContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedOverrideLeftContext) LEFT_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_ANGLE_BRACKET, 0)
}

func (s *SimplifiedOverrideLeftContext) SimplifiedSecondary() ISimplifiedSecondaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedSecondaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedSecondaryContext)
}

func (s *SimplifiedOverrideLeftContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedOverrideLeftContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedOverrideLeftContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedOverrideLeft(s)
	}
}

func (s *SimplifiedOverrideLeftContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedOverrideLeft(s)
	}
}

func (p *GQLParser) SimplifiedOverrideLeft() (localctx ISimplifiedOverrideLeftContext) {
	localctx = NewSimplifiedOverrideLeftContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, GQLParserRULE_simplifiedOverrideLeft)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2591)
		p.Match(GQLParserLEFT_ANGLE_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2592)
		p.SimplifiedSecondary()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedOverrideUndirectedContext is an interface to support dynamic dispatch.
type ISimplifiedOverrideUndirectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TILDE() antlr.TerminalNode
	SimplifiedSecondary() ISimplifiedSecondaryContext

	// IsSimplifiedOverrideUndirectedContext differentiates from other interfaces.
	IsSimplifiedOverrideUndirectedContext()
}

type SimplifiedOverrideUndirectedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedOverrideUndirectedContext() *SimplifiedOverrideUndirectedContext {
	var p = new(SimplifiedOverrideUndirectedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedOverrideUndirected
	return p
}

func InitEmptySimplifiedOverrideUndirectedContext(p *SimplifiedOverrideUndirectedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedOverrideUndirected
}

func (*SimplifiedOverrideUndirectedContext) IsSimplifiedOverrideUndirectedContext() {}

func NewSimplifiedOverrideUndirectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedOverrideUndirectedContext {
	var p = new(SimplifiedOverrideUndirectedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedOverrideUndirected

	return p
}

func (s *SimplifiedOverrideUndirectedContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedOverrideUndirectedContext) TILDE() antlr.TerminalNode {
	return s.GetToken(GQLParserTILDE, 0)
}

func (s *SimplifiedOverrideUndirectedContext) SimplifiedSecondary() ISimplifiedSecondaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedSecondaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedSecondaryContext)
}

func (s *SimplifiedOverrideUndirectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedOverrideUndirectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedOverrideUndirectedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedOverrideUndirected(s)
	}
}

func (s *SimplifiedOverrideUndirectedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedOverrideUndirected(s)
	}
}

func (p *GQLParser) SimplifiedOverrideUndirected() (localctx ISimplifiedOverrideUndirectedContext) {
	localctx = NewSimplifiedOverrideUndirectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, GQLParserRULE_simplifiedOverrideUndirected)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2594)
		p.Match(GQLParserTILDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2595)
		p.SimplifiedSecondary()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedOverrideRightContext is an interface to support dynamic dispatch.
type ISimplifiedOverrideRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimplifiedSecondary() ISimplifiedSecondaryContext
	RIGHT_ANGLE_BRACKET() antlr.TerminalNode

	// IsSimplifiedOverrideRightContext differentiates from other interfaces.
	IsSimplifiedOverrideRightContext()
}

type SimplifiedOverrideRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedOverrideRightContext() *SimplifiedOverrideRightContext {
	var p = new(SimplifiedOverrideRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedOverrideRight
	return p
}

func InitEmptySimplifiedOverrideRightContext(p *SimplifiedOverrideRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedOverrideRight
}

func (*SimplifiedOverrideRightContext) IsSimplifiedOverrideRightContext() {}

func NewSimplifiedOverrideRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedOverrideRightContext {
	var p = new(SimplifiedOverrideRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedOverrideRight

	return p
}

func (s *SimplifiedOverrideRightContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedOverrideRightContext) SimplifiedSecondary() ISimplifiedSecondaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedSecondaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedSecondaryContext)
}

func (s *SimplifiedOverrideRightContext) RIGHT_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_ANGLE_BRACKET, 0)
}

func (s *SimplifiedOverrideRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedOverrideRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedOverrideRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedOverrideRight(s)
	}
}

func (s *SimplifiedOverrideRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedOverrideRight(s)
	}
}

func (p *GQLParser) SimplifiedOverrideRight() (localctx ISimplifiedOverrideRightContext) {
	localctx = NewSimplifiedOverrideRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, GQLParserRULE_simplifiedOverrideRight)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2597)
		p.SimplifiedSecondary()
	}
	{
		p.SetState(2598)
		p.Match(GQLParserRIGHT_ANGLE_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedOverrideLeftOrUndirectedContext is an interface to support dynamic dispatch.
type ISimplifiedOverrideLeftOrUndirectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_ARROW_TILDE() antlr.TerminalNode
	SimplifiedSecondary() ISimplifiedSecondaryContext

	// IsSimplifiedOverrideLeftOrUndirectedContext differentiates from other interfaces.
	IsSimplifiedOverrideLeftOrUndirectedContext()
}

type SimplifiedOverrideLeftOrUndirectedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedOverrideLeftOrUndirectedContext() *SimplifiedOverrideLeftOrUndirectedContext {
	var p = new(SimplifiedOverrideLeftOrUndirectedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedOverrideLeftOrUndirected
	return p
}

func InitEmptySimplifiedOverrideLeftOrUndirectedContext(p *SimplifiedOverrideLeftOrUndirectedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedOverrideLeftOrUndirected
}

func (*SimplifiedOverrideLeftOrUndirectedContext) IsSimplifiedOverrideLeftOrUndirectedContext() {}

func NewSimplifiedOverrideLeftOrUndirectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedOverrideLeftOrUndirectedContext {
	var p = new(SimplifiedOverrideLeftOrUndirectedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedOverrideLeftOrUndirected

	return p
}

func (s *SimplifiedOverrideLeftOrUndirectedContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedOverrideLeftOrUndirectedContext) LEFT_ARROW_TILDE() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_ARROW_TILDE, 0)
}

func (s *SimplifiedOverrideLeftOrUndirectedContext) SimplifiedSecondary() ISimplifiedSecondaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedSecondaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedSecondaryContext)
}

func (s *SimplifiedOverrideLeftOrUndirectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedOverrideLeftOrUndirectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedOverrideLeftOrUndirectedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedOverrideLeftOrUndirected(s)
	}
}

func (s *SimplifiedOverrideLeftOrUndirectedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedOverrideLeftOrUndirected(s)
	}
}

func (p *GQLParser) SimplifiedOverrideLeftOrUndirected() (localctx ISimplifiedOverrideLeftOrUndirectedContext) {
	localctx = NewSimplifiedOverrideLeftOrUndirectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, GQLParserRULE_simplifiedOverrideLeftOrUndirected)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2600)
		p.Match(GQLParserLEFT_ARROW_TILDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2601)
		p.SimplifiedSecondary()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedOverrideUndirectedOrRightContext is an interface to support dynamic dispatch.
type ISimplifiedOverrideUndirectedOrRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TILDE() antlr.TerminalNode
	SimplifiedSecondary() ISimplifiedSecondaryContext
	RIGHT_ANGLE_BRACKET() antlr.TerminalNode

	// IsSimplifiedOverrideUndirectedOrRightContext differentiates from other interfaces.
	IsSimplifiedOverrideUndirectedOrRightContext()
}

type SimplifiedOverrideUndirectedOrRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedOverrideUndirectedOrRightContext() *SimplifiedOverrideUndirectedOrRightContext {
	var p = new(SimplifiedOverrideUndirectedOrRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedOverrideUndirectedOrRight
	return p
}

func InitEmptySimplifiedOverrideUndirectedOrRightContext(p *SimplifiedOverrideUndirectedOrRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedOverrideUndirectedOrRight
}

func (*SimplifiedOverrideUndirectedOrRightContext) IsSimplifiedOverrideUndirectedOrRightContext() {}

func NewSimplifiedOverrideUndirectedOrRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedOverrideUndirectedOrRightContext {
	var p = new(SimplifiedOverrideUndirectedOrRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedOverrideUndirectedOrRight

	return p
}

func (s *SimplifiedOverrideUndirectedOrRightContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedOverrideUndirectedOrRightContext) TILDE() antlr.TerminalNode {
	return s.GetToken(GQLParserTILDE, 0)
}

func (s *SimplifiedOverrideUndirectedOrRightContext) SimplifiedSecondary() ISimplifiedSecondaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedSecondaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedSecondaryContext)
}

func (s *SimplifiedOverrideUndirectedOrRightContext) RIGHT_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_ANGLE_BRACKET, 0)
}

func (s *SimplifiedOverrideUndirectedOrRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedOverrideUndirectedOrRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedOverrideUndirectedOrRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedOverrideUndirectedOrRight(s)
	}
}

func (s *SimplifiedOverrideUndirectedOrRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedOverrideUndirectedOrRight(s)
	}
}

func (p *GQLParser) SimplifiedOverrideUndirectedOrRight() (localctx ISimplifiedOverrideUndirectedOrRightContext) {
	localctx = NewSimplifiedOverrideUndirectedOrRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, GQLParserRULE_simplifiedOverrideUndirectedOrRight)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2603)
		p.Match(GQLParserTILDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2604)
		p.SimplifiedSecondary()
	}
	{
		p.SetState(2605)
		p.Match(GQLParserRIGHT_ANGLE_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedOverrideLeftOrRightContext is an interface to support dynamic dispatch.
type ISimplifiedOverrideLeftOrRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_ANGLE_BRACKET() antlr.TerminalNode
	SimplifiedSecondary() ISimplifiedSecondaryContext
	RIGHT_ANGLE_BRACKET() antlr.TerminalNode

	// IsSimplifiedOverrideLeftOrRightContext differentiates from other interfaces.
	IsSimplifiedOverrideLeftOrRightContext()
}

type SimplifiedOverrideLeftOrRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedOverrideLeftOrRightContext() *SimplifiedOverrideLeftOrRightContext {
	var p = new(SimplifiedOverrideLeftOrRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedOverrideLeftOrRight
	return p
}

func InitEmptySimplifiedOverrideLeftOrRightContext(p *SimplifiedOverrideLeftOrRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedOverrideLeftOrRight
}

func (*SimplifiedOverrideLeftOrRightContext) IsSimplifiedOverrideLeftOrRightContext() {}

func NewSimplifiedOverrideLeftOrRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedOverrideLeftOrRightContext {
	var p = new(SimplifiedOverrideLeftOrRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedOverrideLeftOrRight

	return p
}

func (s *SimplifiedOverrideLeftOrRightContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedOverrideLeftOrRightContext) LEFT_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_ANGLE_BRACKET, 0)
}

func (s *SimplifiedOverrideLeftOrRightContext) SimplifiedSecondary() ISimplifiedSecondaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedSecondaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedSecondaryContext)
}

func (s *SimplifiedOverrideLeftOrRightContext) RIGHT_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_ANGLE_BRACKET, 0)
}

func (s *SimplifiedOverrideLeftOrRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedOverrideLeftOrRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedOverrideLeftOrRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedOverrideLeftOrRight(s)
	}
}

func (s *SimplifiedOverrideLeftOrRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedOverrideLeftOrRight(s)
	}
}

func (p *GQLParser) SimplifiedOverrideLeftOrRight() (localctx ISimplifiedOverrideLeftOrRightContext) {
	localctx = NewSimplifiedOverrideLeftOrRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, GQLParserRULE_simplifiedOverrideLeftOrRight)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2607)
		p.Match(GQLParserLEFT_ANGLE_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2608)
		p.SimplifiedSecondary()
	}
	{
		p.SetState(2609)
		p.Match(GQLParserRIGHT_ANGLE_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedOverrideAnyDirectionContext is an interface to support dynamic dispatch.
type ISimplifiedOverrideAnyDirectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS_SIGN() antlr.TerminalNode
	SimplifiedSecondary() ISimplifiedSecondaryContext

	// IsSimplifiedOverrideAnyDirectionContext differentiates from other interfaces.
	IsSimplifiedOverrideAnyDirectionContext()
}

type SimplifiedOverrideAnyDirectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedOverrideAnyDirectionContext() *SimplifiedOverrideAnyDirectionContext {
	var p = new(SimplifiedOverrideAnyDirectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedOverrideAnyDirection
	return p
}

func InitEmptySimplifiedOverrideAnyDirectionContext(p *SimplifiedOverrideAnyDirectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedOverrideAnyDirection
}

func (*SimplifiedOverrideAnyDirectionContext) IsSimplifiedOverrideAnyDirectionContext() {}

func NewSimplifiedOverrideAnyDirectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedOverrideAnyDirectionContext {
	var p = new(SimplifiedOverrideAnyDirectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedOverrideAnyDirection

	return p
}

func (s *SimplifiedOverrideAnyDirectionContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedOverrideAnyDirectionContext) MINUS_SIGN() antlr.TerminalNode {
	return s.GetToken(GQLParserMINUS_SIGN, 0)
}

func (s *SimplifiedOverrideAnyDirectionContext) SimplifiedSecondary() ISimplifiedSecondaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedSecondaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedSecondaryContext)
}

func (s *SimplifiedOverrideAnyDirectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedOverrideAnyDirectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedOverrideAnyDirectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedOverrideAnyDirection(s)
	}
}

func (s *SimplifiedOverrideAnyDirectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedOverrideAnyDirection(s)
	}
}

func (p *GQLParser) SimplifiedOverrideAnyDirection() (localctx ISimplifiedOverrideAnyDirectionContext) {
	localctx = NewSimplifiedOverrideAnyDirectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, GQLParserRULE_simplifiedOverrideAnyDirection)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2611)
		p.Match(GQLParserMINUS_SIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2612)
		p.SimplifiedSecondary()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedSecondaryContext is an interface to support dynamic dispatch.
type ISimplifiedSecondaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimplifiedPrimary() ISimplifiedPrimaryContext
	SimplifiedNegation() ISimplifiedNegationContext

	// IsSimplifiedSecondaryContext differentiates from other interfaces.
	IsSimplifiedSecondaryContext()
}

type SimplifiedSecondaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedSecondaryContext() *SimplifiedSecondaryContext {
	var p = new(SimplifiedSecondaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedSecondary
	return p
}

func InitEmptySimplifiedSecondaryContext(p *SimplifiedSecondaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedSecondary
}

func (*SimplifiedSecondaryContext) IsSimplifiedSecondaryContext() {}

func NewSimplifiedSecondaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedSecondaryContext {
	var p = new(SimplifiedSecondaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedSecondary

	return p
}

func (s *SimplifiedSecondaryContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedSecondaryContext) SimplifiedPrimary() ISimplifiedPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedPrimaryContext)
}

func (s *SimplifiedSecondaryContext) SimplifiedNegation() ISimplifiedNegationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedNegationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedNegationContext)
}

func (s *SimplifiedSecondaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedSecondaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedSecondaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedSecondary(s)
	}
}

func (s *SimplifiedSecondaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedSecondary(s)
	}
}

func (p *GQLParser) SimplifiedSecondary() (localctx ISimplifiedSecondaryContext) {
	localctx = NewSimplifiedSecondaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, GQLParserRULE_simplifiedSecondary)
	p.SetState(2616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE, GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE, GQLParserREGULAR_IDENTIFIER, GQLParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2614)
			p.SimplifiedPrimary()
		}

	case GQLParserEXCLAMATION_MARK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2615)
			p.SimplifiedNegation()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedNegationContext is an interface to support dynamic dispatch.
type ISimplifiedNegationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCLAMATION_MARK() antlr.TerminalNode
	SimplifiedPrimary() ISimplifiedPrimaryContext

	// IsSimplifiedNegationContext differentiates from other interfaces.
	IsSimplifiedNegationContext()
}

type SimplifiedNegationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedNegationContext() *SimplifiedNegationContext {
	var p = new(SimplifiedNegationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedNegation
	return p
}

func InitEmptySimplifiedNegationContext(p *SimplifiedNegationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedNegation
}

func (*SimplifiedNegationContext) IsSimplifiedNegationContext() {}

func NewSimplifiedNegationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedNegationContext {
	var p = new(SimplifiedNegationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedNegation

	return p
}

func (s *SimplifiedNegationContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedNegationContext) EXCLAMATION_MARK() antlr.TerminalNode {
	return s.GetToken(GQLParserEXCLAMATION_MARK, 0)
}

func (s *SimplifiedNegationContext) SimplifiedPrimary() ISimplifiedPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedPrimaryContext)
}

func (s *SimplifiedNegationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedNegationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedNegationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedNegation(s)
	}
}

func (s *SimplifiedNegationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedNegation(s)
	}
}

func (p *GQLParser) SimplifiedNegation() (localctx ISimplifiedNegationContext) {
	localctx = NewSimplifiedNegationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, GQLParserRULE_simplifiedNegation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2618)
		p.Match(GQLParserEXCLAMATION_MARK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2619)
		p.SimplifiedPrimary()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplifiedPrimaryContext is an interface to support dynamic dispatch.
type ISimplifiedPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LabelName() ILabelNameContext
	LEFT_PAREN() antlr.TerminalNode
	SimplifiedContents() ISimplifiedContentsContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsSimplifiedPrimaryContext differentiates from other interfaces.
	IsSimplifiedPrimaryContext()
}

type SimplifiedPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplifiedPrimaryContext() *SimplifiedPrimaryContext {
	var p = new(SimplifiedPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedPrimary
	return p
}

func InitEmptySimplifiedPrimaryContext(p *SimplifiedPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simplifiedPrimary
}

func (*SimplifiedPrimaryContext) IsSimplifiedPrimaryContext() {}

func NewSimplifiedPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplifiedPrimaryContext {
	var p = new(SimplifiedPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simplifiedPrimary

	return p
}

func (s *SimplifiedPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplifiedPrimaryContext) LabelName() ILabelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelNameContext)
}

func (s *SimplifiedPrimaryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *SimplifiedPrimaryContext) SimplifiedContents() ISimplifiedContentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplifiedContentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplifiedContentsContext)
}

func (s *SimplifiedPrimaryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *SimplifiedPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplifiedPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplifiedPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimplifiedPrimary(s)
	}
}

func (s *SimplifiedPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimplifiedPrimary(s)
	}
}

func (p *GQLParser) SimplifiedPrimary() (localctx ISimplifiedPrimaryContext) {
	localctx = NewSimplifiedPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, GQLParserRULE_simplifiedPrimary)
	p.SetState(2626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE, GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE, GQLParserREGULAR_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2621)
			p.LabelName()
		}

	case GQLParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2622)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2623)
			p.SimplifiedContents()
		}
		{
			p.SetState(2624)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	SearchCondition() ISearchConditionContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(GQLParserWHERE, 0)
}

func (s *WhereClauseContext) SearchCondition() ISearchConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchConditionContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (p *GQLParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, GQLParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2628)
		p.Match(GQLParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2629)
		p.SearchCondition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldClauseContext is an interface to support dynamic dispatch.
type IYieldClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YIELD() antlr.TerminalNode
	YieldItemList() IYieldItemListContext

	// IsYieldClauseContext differentiates from other interfaces.
	IsYieldClauseContext()
}

type YieldClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldClauseContext() *YieldClauseContext {
	var p = new(YieldClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_yieldClause
	return p
}

func InitEmptyYieldClauseContext(p *YieldClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_yieldClause
}

func (*YieldClauseContext) IsYieldClauseContext() {}

func NewYieldClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldClauseContext {
	var p = new(YieldClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_yieldClause

	return p
}

func (s *YieldClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldClauseContext) YIELD() antlr.TerminalNode {
	return s.GetToken(GQLParserYIELD, 0)
}

func (s *YieldClauseContext) YieldItemList() IYieldItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldItemListContext)
}

func (s *YieldClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterYieldClause(s)
	}
}

func (s *YieldClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitYieldClause(s)
	}
}

func (p *GQLParser) YieldClause() (localctx IYieldClauseContext) {
	localctx = NewYieldClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, GQLParserRULE_yieldClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2631)
		p.Match(GQLParserYIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2632)
		p.YieldItemList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldItemListContext is an interface to support dynamic dispatch.
type IYieldItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllYieldItem() []IYieldItemContext
	YieldItem(i int) IYieldItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsYieldItemListContext differentiates from other interfaces.
	IsYieldItemListContext()
}

type YieldItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldItemListContext() *YieldItemListContext {
	var p = new(YieldItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_yieldItemList
	return p
}

func InitEmptyYieldItemListContext(p *YieldItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_yieldItemList
}

func (*YieldItemListContext) IsYieldItemListContext() {}

func NewYieldItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldItemListContext {
	var p = new(YieldItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_yieldItemList

	return p
}

func (s *YieldItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldItemListContext) AllYieldItem() []IYieldItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IYieldItemContext); ok {
			len++
		}
	}

	tst := make([]IYieldItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IYieldItemContext); ok {
			tst[i] = t.(IYieldItemContext)
			i++
		}
	}

	return tst
}

func (s *YieldItemListContext) YieldItem(i int) IYieldItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldItemContext)
}

func (s *YieldItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *YieldItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *YieldItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterYieldItemList(s)
	}
}

func (s *YieldItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitYieldItemList(s)
	}
}

func (p *GQLParser) YieldItemList() (localctx IYieldItemListContext) {
	localctx = NewYieldItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, GQLParserRULE_yieldItemList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2634)
		p.YieldItem()
	}
	p.SetState(2639)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(2635)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2636)
			p.YieldItem()
		}

		p.SetState(2641)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldItemContext is an interface to support dynamic dispatch.
type IYieldItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YieldItemName() IYieldItemNameContext
	YieldItemAlias() IYieldItemAliasContext

	// IsYieldItemContext differentiates from other interfaces.
	IsYieldItemContext()
}

type YieldItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldItemContext() *YieldItemContext {
	var p = new(YieldItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_yieldItem
	return p
}

func InitEmptyYieldItemContext(p *YieldItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_yieldItem
}

func (*YieldItemContext) IsYieldItemContext() {}

func NewYieldItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldItemContext {
	var p = new(YieldItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_yieldItem

	return p
}

func (s *YieldItemContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldItemContext) YieldItemName() IYieldItemNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldItemNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldItemNameContext)
}

func (s *YieldItemContext) YieldItemAlias() IYieldItemAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldItemAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldItemAliasContext)
}

func (s *YieldItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterYieldItem(s)
	}
}

func (s *YieldItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitYieldItem(s)
	}
}

func (p *GQLParser) YieldItem() (localctx IYieldItemContext) {
	localctx = NewYieldItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, GQLParserRULE_yieldItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2642)
		p.YieldItemName()
	}
	p.SetState(2644)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserAS {
		{
			p.SetState(2643)
			p.YieldItemAlias()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldItemNameContext is an interface to support dynamic dispatch.
type IYieldItemNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext

	// IsYieldItemNameContext differentiates from other interfaces.
	IsYieldItemNameContext()
}

type YieldItemNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldItemNameContext() *YieldItemNameContext {
	var p = new(YieldItemNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_yieldItemName
	return p
}

func InitEmptyYieldItemNameContext(p *YieldItemNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_yieldItemName
}

func (*YieldItemNameContext) IsYieldItemNameContext() {}

func NewYieldItemNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldItemNameContext {
	var p = new(YieldItemNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_yieldItemName

	return p
}

func (s *YieldItemNameContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldItemNameContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *YieldItemNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldItemNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldItemNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterYieldItemName(s)
	}
}

func (s *YieldItemNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitYieldItemName(s)
	}
}

func (p *GQLParser) YieldItemName() (localctx IYieldItemNameContext) {
	localctx = NewYieldItemNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, GQLParserRULE_yieldItemName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2646)
		p.FieldName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldItemAliasContext is an interface to support dynamic dispatch.
type IYieldItemAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	BindingVariable() IBindingVariableContext

	// IsYieldItemAliasContext differentiates from other interfaces.
	IsYieldItemAliasContext()
}

type YieldItemAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldItemAliasContext() *YieldItemAliasContext {
	var p = new(YieldItemAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_yieldItemAlias
	return p
}

func InitEmptyYieldItemAliasContext(p *YieldItemAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_yieldItemAlias
}

func (*YieldItemAliasContext) IsYieldItemAliasContext() {}

func NewYieldItemAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldItemAliasContext {
	var p = new(YieldItemAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_yieldItemAlias

	return p
}

func (s *YieldItemAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldItemAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(GQLParserAS, 0)
}

func (s *YieldItemAliasContext) BindingVariable() IBindingVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableContext)
}

func (s *YieldItemAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldItemAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldItemAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterYieldItemAlias(s)
	}
}

func (s *YieldItemAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitYieldItemAlias(s)
	}
}

func (p *GQLParser) YieldItemAlias() (localctx IYieldItemAliasContext) {
	localctx = NewYieldItemAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, GQLParserRULE_yieldItemAlias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2648)
		p.Match(GQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2649)
		p.BindingVariable()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	GroupingElementList() IGroupingElementListContext

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(GQLParserGROUP, 0)
}

func (s *GroupByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(GQLParserBY, 0)
}

func (s *GroupByClauseContext) GroupingElementList() IGroupingElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingElementListContext)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (p *GQLParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, GQLParserRULE_groupByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2651)
		p.Match(GQLParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2652)
		p.Match(GQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2653)
		p.GroupingElementList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingElementListContext is an interface to support dynamic dispatch.
type IGroupingElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGroupingElement() []IGroupingElementContext
	GroupingElement(i int) IGroupingElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	EmptyGroupingSet() IEmptyGroupingSetContext

	// IsGroupingElementListContext differentiates from other interfaces.
	IsGroupingElementListContext()
}

type GroupingElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementListContext() *GroupingElementListContext {
	var p = new(GroupingElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_groupingElementList
	return p
}

func InitEmptyGroupingElementListContext(p *GroupingElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_groupingElementList
}

func (*GroupingElementListContext) IsGroupingElementListContext() {}

func NewGroupingElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementListContext {
	var p = new(GroupingElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_groupingElementList

	return p
}

func (s *GroupingElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementListContext) AllGroupingElement() []IGroupingElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingElementContext); ok {
			len++
		}
	}

	tst := make([]IGroupingElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingElementContext); ok {
			tst[i] = t.(IGroupingElementContext)
			i++
		}
	}

	return tst
}

func (s *GroupingElementListContext) GroupingElement(i int) IGroupingElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *GroupingElementListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *GroupingElementListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *GroupingElementListContext) EmptyGroupingSet() IEmptyGroupingSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyGroupingSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyGroupingSetContext)
}

func (s *GroupingElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGroupingElementList(s)
	}
}

func (s *GroupingElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGroupingElementList(s)
	}
}

func (p *GQLParser) GroupingElementList() (localctx IGroupingElementListContext) {
	localctx = NewGroupingElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, GQLParserRULE_groupingElementList)
	var _alt int

	p.SetState(2664)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE, GQLParserREGULAR_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2655)
			p.GroupingElement()
		}
		p.SetState(2660)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2656)
					p.Match(GQLParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2657)
					p.GroupingElement()
				}

			}
			p.SetState(2662)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case GQLParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2663)
			p.EmptyGroupingSet()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingVariableReference() IBindingVariableReferenceContext

	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_groupingElement
	return p
}

func InitEmptyGroupingElementContext(p *GroupingElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_groupingElement
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) BindingVariableReference() IBindingVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableReferenceContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGroupingElement(s)
	}
}

func (s *GroupingElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGroupingElement(s)
	}
}

func (p *GQLParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, GQLParserRULE_groupingElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2666)
		p.BindingVariableReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyGroupingSetContext is an interface to support dynamic dispatch.
type IEmptyGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsEmptyGroupingSetContext differentiates from other interfaces.
	IsEmptyGroupingSetContext()
}

type EmptyGroupingSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyGroupingSetContext() *EmptyGroupingSetContext {
	var p = new(EmptyGroupingSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_emptyGroupingSet
	return p
}

func InitEmptyEmptyGroupingSetContext(p *EmptyGroupingSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_emptyGroupingSet
}

func (*EmptyGroupingSetContext) IsEmptyGroupingSetContext() {}

func NewEmptyGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyGroupingSetContext {
	var p = new(EmptyGroupingSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_emptyGroupingSet

	return p
}

func (s *EmptyGroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *EmptyGroupingSetContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *EmptyGroupingSetContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *EmptyGroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyGroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyGroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEmptyGroupingSet(s)
	}
}

func (s *EmptyGroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEmptyGroupingSet(s)
	}
}

func (p *GQLParser) EmptyGroupingSet() (localctx IEmptyGroupingSetContext) {
	localctx = NewEmptyGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, GQLParserRULE_emptyGroupingSet)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2668)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2669)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	SortSpecificationList() ISortSpecificationListContext

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_orderByClause
	return p
}

func InitEmptyOrderByClauseContext(p *OrderByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_orderByClause
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(GQLParserORDER, 0)
}

func (s *OrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(GQLParserBY, 0)
}

func (s *OrderByClauseContext) SortSpecificationList() ISortSpecificationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortSpecificationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortSpecificationListContext)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}

func (p *GQLParser) OrderByClause() (localctx IOrderByClauseContext) {
	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, GQLParserRULE_orderByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2671)
		p.Match(GQLParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2672)
		p.Match(GQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2673)
		p.SortSpecificationList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortSpecificationListContext is an interface to support dynamic dispatch.
type ISortSpecificationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSortSpecification() []ISortSpecificationContext
	SortSpecification(i int) ISortSpecificationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSortSpecificationListContext differentiates from other interfaces.
	IsSortSpecificationListContext()
}

type SortSpecificationListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortSpecificationListContext() *SortSpecificationListContext {
	var p = new(SortSpecificationListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sortSpecificationList
	return p
}

func InitEmptySortSpecificationListContext(p *SortSpecificationListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sortSpecificationList
}

func (*SortSpecificationListContext) IsSortSpecificationListContext() {}

func NewSortSpecificationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortSpecificationListContext {
	var p = new(SortSpecificationListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sortSpecificationList

	return p
}

func (s *SortSpecificationListContext) GetParser() antlr.Parser { return s.parser }

func (s *SortSpecificationListContext) AllSortSpecification() []ISortSpecificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortSpecificationContext); ok {
			len++
		}
	}

	tst := make([]ISortSpecificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortSpecificationContext); ok {
			tst[i] = t.(ISortSpecificationContext)
			i++
		}
	}

	return tst
}

func (s *SortSpecificationListContext) SortSpecification(i int) ISortSpecificationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortSpecificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortSpecificationContext)
}

func (s *SortSpecificationListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *SortSpecificationListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *SortSpecificationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortSpecificationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortSpecificationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSortSpecificationList(s)
	}
}

func (s *SortSpecificationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSortSpecificationList(s)
	}
}

func (p *GQLParser) SortSpecificationList() (localctx ISortSpecificationListContext) {
	localctx = NewSortSpecificationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, GQLParserRULE_sortSpecificationList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2675)
		p.SortSpecification()
	}
	p.SetState(2680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 226, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2676)
				p.Match(GQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2677)
				p.SortSpecification()
			}

		}
		p.SetState(2682)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 226, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortSpecificationContext is an interface to support dynamic dispatch.
type ISortSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SortKey() ISortKeyContext
	OrderingSpecification() IOrderingSpecificationContext
	NullOrdering() INullOrderingContext

	// IsSortSpecificationContext differentiates from other interfaces.
	IsSortSpecificationContext()
}

type SortSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortSpecificationContext() *SortSpecificationContext {
	var p = new(SortSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sortSpecification
	return p
}

func InitEmptySortSpecificationContext(p *SortSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sortSpecification
}

func (*SortSpecificationContext) IsSortSpecificationContext() {}

func NewSortSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortSpecificationContext {
	var p = new(SortSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sortSpecification

	return p
}

func (s *SortSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *SortSpecificationContext) SortKey() ISortKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortKeyContext)
}

func (s *SortSpecificationContext) OrderingSpecification() IOrderingSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderingSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderingSpecificationContext)
}

func (s *SortSpecificationContext) NullOrdering() INullOrderingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullOrderingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullOrderingContext)
}

func (s *SortSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSortSpecification(s)
	}
}

func (s *SortSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSortSpecification(s)
	}
}

func (p *GQLParser) SortSpecification() (localctx ISortSpecificationContext) {
	localctx = NewSortSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, GQLParserRULE_sortSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2683)
		p.SortKey()
	}
	p.SetState(2685)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 227, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2684)
			p.OrderingSpecification()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2688)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 228, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2687)
			p.NullOrdering()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortKeyContext is an interface to support dynamic dispatch.
type ISortKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AggregatingValueExpression() IAggregatingValueExpressionContext

	// IsSortKeyContext differentiates from other interfaces.
	IsSortKeyContext()
}

type SortKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortKeyContext() *SortKeyContext {
	var p = new(SortKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sortKey
	return p
}

func InitEmptySortKeyContext(p *SortKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sortKey
}

func (*SortKeyContext) IsSortKeyContext() {}

func NewSortKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortKeyContext {
	var p = new(SortKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sortKey

	return p
}

func (s *SortKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *SortKeyContext) AggregatingValueExpression() IAggregatingValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregatingValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregatingValueExpressionContext)
}

func (s *SortKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSortKey(s)
	}
}

func (s *SortKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSortKey(s)
	}
}

func (p *GQLParser) SortKey() (localctx ISortKeyContext) {
	localctx = NewSortKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, GQLParserRULE_sortKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2690)
		p.AggregatingValueExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderingSpecificationContext is an interface to support dynamic dispatch.
type IOrderingSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASC() antlr.TerminalNode
	ASCENDING() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DESCENDING() antlr.TerminalNode

	// IsOrderingSpecificationContext differentiates from other interfaces.
	IsOrderingSpecificationContext()
}

type OrderingSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderingSpecificationContext() *OrderingSpecificationContext {
	var p = new(OrderingSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_orderingSpecification
	return p
}

func InitEmptyOrderingSpecificationContext(p *OrderingSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_orderingSpecification
}

func (*OrderingSpecificationContext) IsOrderingSpecificationContext() {}

func NewOrderingSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderingSpecificationContext {
	var p = new(OrderingSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_orderingSpecification

	return p
}

func (s *OrderingSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderingSpecificationContext) ASC() antlr.TerminalNode {
	return s.GetToken(GQLParserASC, 0)
}

func (s *OrderingSpecificationContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(GQLParserASCENDING, 0)
}

func (s *OrderingSpecificationContext) DESC() antlr.TerminalNode {
	return s.GetToken(GQLParserDESC, 0)
}

func (s *OrderingSpecificationContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(GQLParserDESCENDING, 0)
}

func (s *OrderingSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderingSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderingSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOrderingSpecification(s)
	}
}

func (s *OrderingSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOrderingSpecification(s)
	}
}

func (p *GQLParser) OrderingSpecification() (localctx IOrderingSpecificationContext) {
	localctx = NewOrderingSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, GQLParserRULE_orderingSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2692)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-31)) & ^0x3f) == 0 && ((int64(1)<<(_la-31))&1688849860263939) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullOrderingContext is an interface to support dynamic dispatch.
type INullOrderingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULLS() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsNullOrderingContext differentiates from other interfaces.
	IsNullOrderingContext()
}

type NullOrderingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullOrderingContext() *NullOrderingContext {
	var p = new(NullOrderingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nullOrdering
	return p
}

func InitEmptyNullOrderingContext(p *NullOrderingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nullOrdering
}

func (*NullOrderingContext) IsNullOrderingContext() {}

func NewNullOrderingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullOrderingContext {
	var p = new(NullOrderingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nullOrdering

	return p
}

func (s *NullOrderingContext) GetParser() antlr.Parser { return s.parser }

func (s *NullOrderingContext) NULLS() antlr.TerminalNode {
	return s.GetToken(GQLParserNULLS, 0)
}

func (s *NullOrderingContext) FIRST() antlr.TerminalNode {
	return s.GetToken(GQLParserFIRST, 0)
}

func (s *NullOrderingContext) LAST() antlr.TerminalNode {
	return s.GetToken(GQLParserLAST, 0)
}

func (s *NullOrderingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullOrderingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullOrderingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNullOrdering(s)
	}
}

func (s *NullOrderingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNullOrdering(s)
	}
}

func (p *GQLParser) NullOrdering() (localctx INullOrderingContext) {
	localctx = NewNullOrderingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, GQLParserRULE_nullOrdering)
	p.SetState(2698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 229, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2694)
			p.Match(GQLParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2695)
			p.Match(GQLParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2696)
			p.Match(GQLParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2697)
			p.Match(GQLParserLAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT() antlr.TerminalNode
	NonNegativeIntegerSpecification() INonNegativeIntegerSpecificationContext

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(GQLParserLIMIT, 0)
}

func (s *LimitClauseContext) NonNegativeIntegerSpecification() INonNegativeIntegerSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonNegativeIntegerSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonNegativeIntegerSpecificationContext)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (p *GQLParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, GQLParserRULE_limitClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2700)
		p.Match(GQLParserLIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2701)
		p.NonNegativeIntegerSpecification()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOffsetClauseContext is an interface to support dynamic dispatch.
type IOffsetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OffsetSynonym() IOffsetSynonymContext
	NonNegativeIntegerSpecification() INonNegativeIntegerSpecificationContext

	// IsOffsetClauseContext differentiates from other interfaces.
	IsOffsetClauseContext()
}

type OffsetClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOffsetClauseContext() *OffsetClauseContext {
	var p = new(OffsetClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_offsetClause
	return p
}

func InitEmptyOffsetClauseContext(p *OffsetClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_offsetClause
}

func (*OffsetClauseContext) IsOffsetClauseContext() {}

func NewOffsetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OffsetClauseContext {
	var p = new(OffsetClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_offsetClause

	return p
}

func (s *OffsetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OffsetClauseContext) OffsetSynonym() IOffsetSynonymContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOffsetSynonymContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOffsetSynonymContext)
}

func (s *OffsetClauseContext) NonNegativeIntegerSpecification() INonNegativeIntegerSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonNegativeIntegerSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonNegativeIntegerSpecificationContext)
}

func (s *OffsetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OffsetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OffsetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOffsetClause(s)
	}
}

func (s *OffsetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOffsetClause(s)
	}
}

func (p *GQLParser) OffsetClause() (localctx IOffsetClauseContext) {
	localctx = NewOffsetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, GQLParserRULE_offsetClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2703)
		p.OffsetSynonym()
	}
	{
		p.SetState(2704)
		p.NonNegativeIntegerSpecification()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOffsetSynonymContext is an interface to support dynamic dispatch.
type IOffsetSynonymContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OFFSET() antlr.TerminalNode
	SKIP_RESERVED_WORD() antlr.TerminalNode

	// IsOffsetSynonymContext differentiates from other interfaces.
	IsOffsetSynonymContext()
}

type OffsetSynonymContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOffsetSynonymContext() *OffsetSynonymContext {
	var p = new(OffsetSynonymContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_offsetSynonym
	return p
}

func InitEmptyOffsetSynonymContext(p *OffsetSynonymContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_offsetSynonym
}

func (*OffsetSynonymContext) IsOffsetSynonymContext() {}

func NewOffsetSynonymContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OffsetSynonymContext {
	var p = new(OffsetSynonymContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_offsetSynonym

	return p
}

func (s *OffsetSynonymContext) GetParser() antlr.Parser { return s.parser }

func (s *OffsetSynonymContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(GQLParserOFFSET, 0)
}

func (s *OffsetSynonymContext) SKIP_RESERVED_WORD() antlr.TerminalNode {
	return s.GetToken(GQLParserSKIP_RESERVED_WORD, 0)
}

func (s *OffsetSynonymContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OffsetSynonymContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OffsetSynonymContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOffsetSynonym(s)
	}
}

func (s *OffsetSynonymContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOffsetSynonym(s)
	}
}

func (p *GQLParser) OffsetSynonym() (localctx IOffsetSynonymContext) {
	localctx = NewOffsetSynonymContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, GQLParserRULE_offsetSynonym)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2706)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserOFFSET || _la == GQLParserSKIP_RESERVED_WORD) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaReferenceContext is an interface to support dynamic dispatch.
type ISchemaReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AbsoluteCatalogSchemaReference() IAbsoluteCatalogSchemaReferenceContext
	RelativeCatalogSchemaReference() IRelativeCatalogSchemaReferenceContext
	ReferenceParameterSpecification() IReferenceParameterSpecificationContext

	// IsSchemaReferenceContext differentiates from other interfaces.
	IsSchemaReferenceContext()
}

type SchemaReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaReferenceContext() *SchemaReferenceContext {
	var p = new(SchemaReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_schemaReference
	return p
}

func InitEmptySchemaReferenceContext(p *SchemaReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_schemaReference
}

func (*SchemaReferenceContext) IsSchemaReferenceContext() {}

func NewSchemaReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaReferenceContext {
	var p = new(SchemaReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_schemaReference

	return p
}

func (s *SchemaReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaReferenceContext) AbsoluteCatalogSchemaReference() IAbsoluteCatalogSchemaReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbsoluteCatalogSchemaReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbsoluteCatalogSchemaReferenceContext)
}

func (s *SchemaReferenceContext) RelativeCatalogSchemaReference() IRelativeCatalogSchemaReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelativeCatalogSchemaReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelativeCatalogSchemaReferenceContext)
}

func (s *SchemaReferenceContext) ReferenceParameterSpecification() IReferenceParameterSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceParameterSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceParameterSpecificationContext)
}

func (s *SchemaReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSchemaReference(s)
	}
}

func (s *SchemaReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSchemaReference(s)
	}
}

func (p *GQLParser) SchemaReference() (localctx ISchemaReferenceContext) {
	localctx = NewSchemaReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, GQLParserRULE_schemaReference)
	p.SetState(2711)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserSOLIDUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2708)
			p.AbsoluteCatalogSchemaReference()
		}

	case GQLParserCURRENT_SCHEMA, GQLParserHOME_SCHEMA, GQLParserDOUBLE_PERIOD, GQLParserPERIOD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2709)
			p.RelativeCatalogSchemaReference()
		}

	case GQLParserSUBSTITUTED_PARAMETER_REFERENCE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2710)
			p.ReferenceParameterSpecification()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbsoluteCatalogSchemaReferenceContext is an interface to support dynamic dispatch.
type IAbsoluteCatalogSchemaReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SOLIDUS() antlr.TerminalNode
	AbsoluteDirectoryPath() IAbsoluteDirectoryPathContext
	SchemaName() ISchemaNameContext

	// IsAbsoluteCatalogSchemaReferenceContext differentiates from other interfaces.
	IsAbsoluteCatalogSchemaReferenceContext()
}

type AbsoluteCatalogSchemaReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbsoluteCatalogSchemaReferenceContext() *AbsoluteCatalogSchemaReferenceContext {
	var p = new(AbsoluteCatalogSchemaReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_absoluteCatalogSchemaReference
	return p
}

func InitEmptyAbsoluteCatalogSchemaReferenceContext(p *AbsoluteCatalogSchemaReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_absoluteCatalogSchemaReference
}

func (*AbsoluteCatalogSchemaReferenceContext) IsAbsoluteCatalogSchemaReferenceContext() {}

func NewAbsoluteCatalogSchemaReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbsoluteCatalogSchemaReferenceContext {
	var p = new(AbsoluteCatalogSchemaReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_absoluteCatalogSchemaReference

	return p
}

func (s *AbsoluteCatalogSchemaReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *AbsoluteCatalogSchemaReferenceContext) SOLIDUS() antlr.TerminalNode {
	return s.GetToken(GQLParserSOLIDUS, 0)
}

func (s *AbsoluteCatalogSchemaReferenceContext) AbsoluteDirectoryPath() IAbsoluteDirectoryPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbsoluteDirectoryPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbsoluteDirectoryPathContext)
}

func (s *AbsoluteCatalogSchemaReferenceContext) SchemaName() ISchemaNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *AbsoluteCatalogSchemaReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbsoluteCatalogSchemaReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbsoluteCatalogSchemaReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAbsoluteCatalogSchemaReference(s)
	}
}

func (s *AbsoluteCatalogSchemaReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAbsoluteCatalogSchemaReference(s)
	}
}

func (p *GQLParser) AbsoluteCatalogSchemaReference() (localctx IAbsoluteCatalogSchemaReferenceContext) {
	localctx = NewAbsoluteCatalogSchemaReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, GQLParserRULE_absoluteCatalogSchemaReference)
	p.SetState(2717)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 231, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2713)
			p.Match(GQLParserSOLIDUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2714)
			p.AbsoluteDirectoryPath()
		}
		{
			p.SetState(2715)
			p.SchemaName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatalogSchemaParentAndNameContext is an interface to support dynamic dispatch.
type ICatalogSchemaParentAndNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AbsoluteDirectoryPath() IAbsoluteDirectoryPathContext
	SchemaName() ISchemaNameContext

	// IsCatalogSchemaParentAndNameContext differentiates from other interfaces.
	IsCatalogSchemaParentAndNameContext()
}

type CatalogSchemaParentAndNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatalogSchemaParentAndNameContext() *CatalogSchemaParentAndNameContext {
	var p = new(CatalogSchemaParentAndNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_catalogSchemaParentAndName
	return p
}

func InitEmptyCatalogSchemaParentAndNameContext(p *CatalogSchemaParentAndNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_catalogSchemaParentAndName
}

func (*CatalogSchemaParentAndNameContext) IsCatalogSchemaParentAndNameContext() {}

func NewCatalogSchemaParentAndNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatalogSchemaParentAndNameContext {
	var p = new(CatalogSchemaParentAndNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_catalogSchemaParentAndName

	return p
}

func (s *CatalogSchemaParentAndNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CatalogSchemaParentAndNameContext) AbsoluteDirectoryPath() IAbsoluteDirectoryPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbsoluteDirectoryPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbsoluteDirectoryPathContext)
}

func (s *CatalogSchemaParentAndNameContext) SchemaName() ISchemaNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *CatalogSchemaParentAndNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatalogSchemaParentAndNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatalogSchemaParentAndNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCatalogSchemaParentAndName(s)
	}
}

func (s *CatalogSchemaParentAndNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCatalogSchemaParentAndName(s)
	}
}

func (p *GQLParser) CatalogSchemaParentAndName() (localctx ICatalogSchemaParentAndNameContext) {
	localctx = NewCatalogSchemaParentAndNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, GQLParserRULE_catalogSchemaParentAndName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2719)
		p.AbsoluteDirectoryPath()
	}
	{
		p.SetState(2720)
		p.SchemaName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelativeCatalogSchemaReferenceContext is an interface to support dynamic dispatch.
type IRelativeCatalogSchemaReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PredefinedSchemaReference() IPredefinedSchemaReferenceContext
	RelativeDirectoryPath() IRelativeDirectoryPathContext
	SchemaName() ISchemaNameContext

	// IsRelativeCatalogSchemaReferenceContext differentiates from other interfaces.
	IsRelativeCatalogSchemaReferenceContext()
}

type RelativeCatalogSchemaReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelativeCatalogSchemaReferenceContext() *RelativeCatalogSchemaReferenceContext {
	var p = new(RelativeCatalogSchemaReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_relativeCatalogSchemaReference
	return p
}

func InitEmptyRelativeCatalogSchemaReferenceContext(p *RelativeCatalogSchemaReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_relativeCatalogSchemaReference
}

func (*RelativeCatalogSchemaReferenceContext) IsRelativeCatalogSchemaReferenceContext() {}

func NewRelativeCatalogSchemaReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelativeCatalogSchemaReferenceContext {
	var p = new(RelativeCatalogSchemaReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_relativeCatalogSchemaReference

	return p
}

func (s *RelativeCatalogSchemaReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RelativeCatalogSchemaReferenceContext) PredefinedSchemaReference() IPredefinedSchemaReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredefinedSchemaReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredefinedSchemaReferenceContext)
}

func (s *RelativeCatalogSchemaReferenceContext) RelativeDirectoryPath() IRelativeDirectoryPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelativeDirectoryPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelativeDirectoryPathContext)
}

func (s *RelativeCatalogSchemaReferenceContext) SchemaName() ISchemaNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *RelativeCatalogSchemaReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelativeCatalogSchemaReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelativeCatalogSchemaReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterRelativeCatalogSchemaReference(s)
	}
}

func (s *RelativeCatalogSchemaReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitRelativeCatalogSchemaReference(s)
	}
}

func (p *GQLParser) RelativeCatalogSchemaReference() (localctx IRelativeCatalogSchemaReferenceContext) {
	localctx = NewRelativeCatalogSchemaReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, GQLParserRULE_relativeCatalogSchemaReference)
	p.SetState(2726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserCURRENT_SCHEMA, GQLParserHOME_SCHEMA, GQLParserPERIOD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2722)
			p.PredefinedSchemaReference()
		}

	case GQLParserDOUBLE_PERIOD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2723)
			p.RelativeDirectoryPath()
		}
		{
			p.SetState(2724)
			p.SchemaName()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredefinedSchemaReferenceContext is an interface to support dynamic dispatch.
type IPredefinedSchemaReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HOME_SCHEMA() antlr.TerminalNode
	CURRENT_SCHEMA() antlr.TerminalNode
	PERIOD() antlr.TerminalNode

	// IsPredefinedSchemaReferenceContext differentiates from other interfaces.
	IsPredefinedSchemaReferenceContext()
}

type PredefinedSchemaReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredefinedSchemaReferenceContext() *PredefinedSchemaReferenceContext {
	var p = new(PredefinedSchemaReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_predefinedSchemaReference
	return p
}

func InitEmptyPredefinedSchemaReferenceContext(p *PredefinedSchemaReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_predefinedSchemaReference
}

func (*PredefinedSchemaReferenceContext) IsPredefinedSchemaReferenceContext() {}

func NewPredefinedSchemaReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredefinedSchemaReferenceContext {
	var p = new(PredefinedSchemaReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_predefinedSchemaReference

	return p
}

func (s *PredefinedSchemaReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *PredefinedSchemaReferenceContext) HOME_SCHEMA() antlr.TerminalNode {
	return s.GetToken(GQLParserHOME_SCHEMA, 0)
}

func (s *PredefinedSchemaReferenceContext) CURRENT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCURRENT_SCHEMA, 0)
}

func (s *PredefinedSchemaReferenceContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(GQLParserPERIOD, 0)
}

func (s *PredefinedSchemaReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredefinedSchemaReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredefinedSchemaReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPredefinedSchemaReference(s)
	}
}

func (s *PredefinedSchemaReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPredefinedSchemaReference(s)
	}
}

func (p *GQLParser) PredefinedSchemaReference() (localctx IPredefinedSchemaReferenceContext) {
	localctx = NewPredefinedSchemaReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, GQLParserRULE_predefinedSchemaReference)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2728)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserCURRENT_SCHEMA || _la == GQLParserHOME_SCHEMA || _la == GQLParserPERIOD) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbsoluteDirectoryPathContext is an interface to support dynamic dispatch.
type IAbsoluteDirectoryPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SOLIDUS() antlr.TerminalNode
	SimpleDirectoryPath() ISimpleDirectoryPathContext

	// IsAbsoluteDirectoryPathContext differentiates from other interfaces.
	IsAbsoluteDirectoryPathContext()
}

type AbsoluteDirectoryPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbsoluteDirectoryPathContext() *AbsoluteDirectoryPathContext {
	var p = new(AbsoluteDirectoryPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_absoluteDirectoryPath
	return p
}

func InitEmptyAbsoluteDirectoryPathContext(p *AbsoluteDirectoryPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_absoluteDirectoryPath
}

func (*AbsoluteDirectoryPathContext) IsAbsoluteDirectoryPathContext() {}

func NewAbsoluteDirectoryPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbsoluteDirectoryPathContext {
	var p = new(AbsoluteDirectoryPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_absoluteDirectoryPath

	return p
}

func (s *AbsoluteDirectoryPathContext) GetParser() antlr.Parser { return s.parser }

func (s *AbsoluteDirectoryPathContext) SOLIDUS() antlr.TerminalNode {
	return s.GetToken(GQLParserSOLIDUS, 0)
}

func (s *AbsoluteDirectoryPathContext) SimpleDirectoryPath() ISimpleDirectoryPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleDirectoryPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleDirectoryPathContext)
}

func (s *AbsoluteDirectoryPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbsoluteDirectoryPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbsoluteDirectoryPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAbsoluteDirectoryPath(s)
	}
}

func (s *AbsoluteDirectoryPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAbsoluteDirectoryPath(s)
	}
}

func (p *GQLParser) AbsoluteDirectoryPath() (localctx IAbsoluteDirectoryPathContext) {
	localctx = NewAbsoluteDirectoryPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, GQLParserRULE_absoluteDirectoryPath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2730)
		p.Match(GQLParserSOLIDUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2732)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 233, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2731)
			p.SimpleDirectoryPath()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelativeDirectoryPathContext is an interface to support dynamic dispatch.
type IRelativeDirectoryPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDOUBLE_PERIOD() []antlr.TerminalNode
	DOUBLE_PERIOD(i int) antlr.TerminalNode
	AllSOLIDUS() []antlr.TerminalNode
	SOLIDUS(i int) antlr.TerminalNode
	SimpleDirectoryPath() ISimpleDirectoryPathContext

	// IsRelativeDirectoryPathContext differentiates from other interfaces.
	IsRelativeDirectoryPathContext()
}

type RelativeDirectoryPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelativeDirectoryPathContext() *RelativeDirectoryPathContext {
	var p = new(RelativeDirectoryPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_relativeDirectoryPath
	return p
}

func InitEmptyRelativeDirectoryPathContext(p *RelativeDirectoryPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_relativeDirectoryPath
}

func (*RelativeDirectoryPathContext) IsRelativeDirectoryPathContext() {}

func NewRelativeDirectoryPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelativeDirectoryPathContext {
	var p = new(RelativeDirectoryPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_relativeDirectoryPath

	return p
}

func (s *RelativeDirectoryPathContext) GetParser() antlr.Parser { return s.parser }

func (s *RelativeDirectoryPathContext) AllDOUBLE_PERIOD() []antlr.TerminalNode {
	return s.GetTokens(GQLParserDOUBLE_PERIOD)
}

func (s *RelativeDirectoryPathContext) DOUBLE_PERIOD(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserDOUBLE_PERIOD, i)
}

func (s *RelativeDirectoryPathContext) AllSOLIDUS() []antlr.TerminalNode {
	return s.GetTokens(GQLParserSOLIDUS)
}

func (s *RelativeDirectoryPathContext) SOLIDUS(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserSOLIDUS, i)
}

func (s *RelativeDirectoryPathContext) SimpleDirectoryPath() ISimpleDirectoryPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleDirectoryPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleDirectoryPathContext)
}

func (s *RelativeDirectoryPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelativeDirectoryPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelativeDirectoryPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterRelativeDirectoryPath(s)
	}
}

func (s *RelativeDirectoryPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitRelativeDirectoryPath(s)
	}
}

func (p *GQLParser) RelativeDirectoryPath() (localctx IRelativeDirectoryPathContext) {
	localctx = NewRelativeDirectoryPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, GQLParserRULE_relativeDirectoryPath)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2734)
		p.Match(GQLParserDOUBLE_PERIOD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 234, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2735)
				p.Match(GQLParserSOLIDUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2736)
				p.Match(GQLParserDOUBLE_PERIOD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 234, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(2742)
		p.Match(GQLParserSOLIDUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2744)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 235, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2743)
			p.SimpleDirectoryPath()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleDirectoryPathContext is an interface to support dynamic dispatch.
type ISimpleDirectoryPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDirectoryName() []IDirectoryNameContext
	DirectoryName(i int) IDirectoryNameContext
	AllSOLIDUS() []antlr.TerminalNode
	SOLIDUS(i int) antlr.TerminalNode

	// IsSimpleDirectoryPathContext differentiates from other interfaces.
	IsSimpleDirectoryPathContext()
}

type SimpleDirectoryPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleDirectoryPathContext() *SimpleDirectoryPathContext {
	var p = new(SimpleDirectoryPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleDirectoryPath
	return p
}

func InitEmptySimpleDirectoryPathContext(p *SimpleDirectoryPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleDirectoryPath
}

func (*SimpleDirectoryPathContext) IsSimpleDirectoryPathContext() {}

func NewSimpleDirectoryPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleDirectoryPathContext {
	var p = new(SimpleDirectoryPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simpleDirectoryPath

	return p
}

func (s *SimpleDirectoryPathContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleDirectoryPathContext) AllDirectoryName() []IDirectoryNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDirectoryNameContext); ok {
			len++
		}
	}

	tst := make([]IDirectoryNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDirectoryNameContext); ok {
			tst[i] = t.(IDirectoryNameContext)
			i++
		}
	}

	return tst
}

func (s *SimpleDirectoryPathContext) DirectoryName(i int) IDirectoryNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectoryNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectoryNameContext)
}

func (s *SimpleDirectoryPathContext) AllSOLIDUS() []antlr.TerminalNode {
	return s.GetTokens(GQLParserSOLIDUS)
}

func (s *SimpleDirectoryPathContext) SOLIDUS(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserSOLIDUS, i)
}

func (s *SimpleDirectoryPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDirectoryPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleDirectoryPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimpleDirectoryPath(s)
	}
}

func (s *SimpleDirectoryPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimpleDirectoryPath(s)
	}
}

func (p *GQLParser) SimpleDirectoryPath() (localctx ISimpleDirectoryPathContext) {
	localctx = NewSimpleDirectoryPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, GQLParserRULE_simpleDirectoryPath)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2749)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(2746)
				p.DirectoryName()
			}
			{
				p.SetState(2747)
				p.Match(GQLParserSOLIDUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(2751)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 236, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphReferenceContext is an interface to support dynamic dispatch.
type IGraphReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CatalogObjectParentReference() ICatalogObjectParentReferenceContext
	GraphName() IGraphNameContext
	DelimitedGraphName() IDelimitedGraphNameContext
	HomeGraph() IHomeGraphContext
	ReferenceParameterSpecification() IReferenceParameterSpecificationContext

	// IsGraphReferenceContext differentiates from other interfaces.
	IsGraphReferenceContext()
}

type GraphReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphReferenceContext() *GraphReferenceContext {
	var p = new(GraphReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphReference
	return p
}

func InitEmptyGraphReferenceContext(p *GraphReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphReference
}

func (*GraphReferenceContext) IsGraphReferenceContext() {}

func NewGraphReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphReferenceContext {
	var p = new(GraphReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphReference

	return p
}

func (s *GraphReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphReferenceContext) CatalogObjectParentReference() ICatalogObjectParentReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogObjectParentReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogObjectParentReferenceContext)
}

func (s *GraphReferenceContext) GraphName() IGraphNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphNameContext)
}

func (s *GraphReferenceContext) DelimitedGraphName() IDelimitedGraphNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelimitedGraphNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelimitedGraphNameContext)
}

func (s *GraphReferenceContext) HomeGraph() IHomeGraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHomeGraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHomeGraphContext)
}

func (s *GraphReferenceContext) ReferenceParameterSpecification() IReferenceParameterSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceParameterSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceParameterSpecificationContext)
}

func (s *GraphReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphReference(s)
	}
}

func (s *GraphReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphReference(s)
	}
}

func (p *GQLParser) GraphReference() (localctx IGraphReferenceContext) {
	localctx = NewGraphReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, GQLParserRULE_graphReference)
	p.SetState(2759)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 237, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2753)
			p.CatalogObjectParentReference()
		}
		{
			p.SetState(2754)
			p.GraphName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2756)
			p.DelimitedGraphName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2757)
			p.HomeGraph()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2758)
			p.ReferenceParameterSpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatalogGraphParentAndNameContext is an interface to support dynamic dispatch.
type ICatalogGraphParentAndNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GraphName() IGraphNameContext
	CatalogObjectParentReference() ICatalogObjectParentReferenceContext

	// IsCatalogGraphParentAndNameContext differentiates from other interfaces.
	IsCatalogGraphParentAndNameContext()
}

type CatalogGraphParentAndNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatalogGraphParentAndNameContext() *CatalogGraphParentAndNameContext {
	var p = new(CatalogGraphParentAndNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_catalogGraphParentAndName
	return p
}

func InitEmptyCatalogGraphParentAndNameContext(p *CatalogGraphParentAndNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_catalogGraphParentAndName
}

func (*CatalogGraphParentAndNameContext) IsCatalogGraphParentAndNameContext() {}

func NewCatalogGraphParentAndNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatalogGraphParentAndNameContext {
	var p = new(CatalogGraphParentAndNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_catalogGraphParentAndName

	return p
}

func (s *CatalogGraphParentAndNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CatalogGraphParentAndNameContext) GraphName() IGraphNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphNameContext)
}

func (s *CatalogGraphParentAndNameContext) CatalogObjectParentReference() ICatalogObjectParentReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogObjectParentReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogObjectParentReferenceContext)
}

func (s *CatalogGraphParentAndNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatalogGraphParentAndNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatalogGraphParentAndNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCatalogGraphParentAndName(s)
	}
}

func (s *CatalogGraphParentAndNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCatalogGraphParentAndName(s)
	}
}

func (p *GQLParser) CatalogGraphParentAndName() (localctx ICatalogGraphParentAndNameContext) {
	localctx = NewCatalogGraphParentAndNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, GQLParserRULE_catalogGraphParentAndName)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2762)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 238, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2761)
			p.CatalogObjectParentReference()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2764)
		p.GraphName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHomeGraphContext is an interface to support dynamic dispatch.
type IHomeGraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HOME_PROPERTY_GRAPH() antlr.TerminalNode
	HOME_GRAPH() antlr.TerminalNode

	// IsHomeGraphContext differentiates from other interfaces.
	IsHomeGraphContext()
}

type HomeGraphContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHomeGraphContext() *HomeGraphContext {
	var p = new(HomeGraphContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_homeGraph
	return p
}

func InitEmptyHomeGraphContext(p *HomeGraphContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_homeGraph
}

func (*HomeGraphContext) IsHomeGraphContext() {}

func NewHomeGraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HomeGraphContext {
	var p = new(HomeGraphContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_homeGraph

	return p
}

func (s *HomeGraphContext) GetParser() antlr.Parser { return s.parser }

func (s *HomeGraphContext) HOME_PROPERTY_GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserHOME_PROPERTY_GRAPH, 0)
}

func (s *HomeGraphContext) HOME_GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserHOME_GRAPH, 0)
}

func (s *HomeGraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HomeGraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HomeGraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterHomeGraph(s)
	}
}

func (s *HomeGraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitHomeGraph(s)
	}
}

func (p *GQLParser) HomeGraph() (localctx IHomeGraphContext) {
	localctx = NewHomeGraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, GQLParserRULE_homeGraph)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2766)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserHOME_GRAPH || _la == GQLParserHOME_PROPERTY_GRAPH) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphTypeReferenceContext is an interface to support dynamic dispatch.
type IGraphTypeReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CatalogGraphTypeParentAndName() ICatalogGraphTypeParentAndNameContext
	ReferenceParameterSpecification() IReferenceParameterSpecificationContext

	// IsGraphTypeReferenceContext differentiates from other interfaces.
	IsGraphTypeReferenceContext()
}

type GraphTypeReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphTypeReferenceContext() *GraphTypeReferenceContext {
	var p = new(GraphTypeReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphTypeReference
	return p
}

func InitEmptyGraphTypeReferenceContext(p *GraphTypeReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphTypeReference
}

func (*GraphTypeReferenceContext) IsGraphTypeReferenceContext() {}

func NewGraphTypeReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphTypeReferenceContext {
	var p = new(GraphTypeReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphTypeReference

	return p
}

func (s *GraphTypeReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphTypeReferenceContext) CatalogGraphTypeParentAndName() ICatalogGraphTypeParentAndNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogGraphTypeParentAndNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogGraphTypeParentAndNameContext)
}

func (s *GraphTypeReferenceContext) ReferenceParameterSpecification() IReferenceParameterSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceParameterSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceParameterSpecificationContext)
}

func (s *GraphTypeReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphTypeReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphTypeReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphTypeReference(s)
	}
}

func (s *GraphTypeReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphTypeReference(s)
	}
}

func (p *GQLParser) GraphTypeReference() (localctx IGraphTypeReferenceContext) {
	localctx = NewGraphTypeReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, GQLParserRULE_graphTypeReference)
	p.SetState(2770)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 239, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2768)
			p.CatalogGraphTypeParentAndName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2769)
			p.ReferenceParameterSpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatalogGraphTypeParentAndNameContext is an interface to support dynamic dispatch.
type ICatalogGraphTypeParentAndNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GraphTypeName() IGraphTypeNameContext
	CatalogObjectParentReference() ICatalogObjectParentReferenceContext

	// IsCatalogGraphTypeParentAndNameContext differentiates from other interfaces.
	IsCatalogGraphTypeParentAndNameContext()
}

type CatalogGraphTypeParentAndNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatalogGraphTypeParentAndNameContext() *CatalogGraphTypeParentAndNameContext {
	var p = new(CatalogGraphTypeParentAndNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_catalogGraphTypeParentAndName
	return p
}

func InitEmptyCatalogGraphTypeParentAndNameContext(p *CatalogGraphTypeParentAndNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_catalogGraphTypeParentAndName
}

func (*CatalogGraphTypeParentAndNameContext) IsCatalogGraphTypeParentAndNameContext() {}

func NewCatalogGraphTypeParentAndNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatalogGraphTypeParentAndNameContext {
	var p = new(CatalogGraphTypeParentAndNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_catalogGraphTypeParentAndName

	return p
}

func (s *CatalogGraphTypeParentAndNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CatalogGraphTypeParentAndNameContext) GraphTypeName() IGraphTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphTypeNameContext)
}

func (s *CatalogGraphTypeParentAndNameContext) CatalogObjectParentReference() ICatalogObjectParentReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogObjectParentReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogObjectParentReferenceContext)
}

func (s *CatalogGraphTypeParentAndNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatalogGraphTypeParentAndNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatalogGraphTypeParentAndNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCatalogGraphTypeParentAndName(s)
	}
}

func (s *CatalogGraphTypeParentAndNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCatalogGraphTypeParentAndName(s)
	}
}

func (p *GQLParser) CatalogGraphTypeParentAndName() (localctx ICatalogGraphTypeParentAndNameContext) {
	localctx = NewCatalogGraphTypeParentAndNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, GQLParserRULE_catalogGraphTypeParentAndName)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2773)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2772)
			p.CatalogObjectParentReference()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2775)
		p.GraphTypeName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindingTableReferenceContext is an interface to support dynamic dispatch.
type IBindingTableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CatalogObjectParentReference() ICatalogObjectParentReferenceContext
	BindingTableName() IBindingTableNameContext
	DelimitedBindingTableName() IDelimitedBindingTableNameContext
	ReferenceParameterSpecification() IReferenceParameterSpecificationContext

	// IsBindingTableReferenceContext differentiates from other interfaces.
	IsBindingTableReferenceContext()
}

type BindingTableReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingTableReferenceContext() *BindingTableReferenceContext {
	var p = new(BindingTableReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingTableReference
	return p
}

func InitEmptyBindingTableReferenceContext(p *BindingTableReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingTableReference
}

func (*BindingTableReferenceContext) IsBindingTableReferenceContext() {}

func NewBindingTableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingTableReferenceContext {
	var p = new(BindingTableReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_bindingTableReference

	return p
}

func (s *BindingTableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingTableReferenceContext) CatalogObjectParentReference() ICatalogObjectParentReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogObjectParentReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogObjectParentReferenceContext)
}

func (s *BindingTableReferenceContext) BindingTableName() IBindingTableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingTableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingTableNameContext)
}

func (s *BindingTableReferenceContext) DelimitedBindingTableName() IDelimitedBindingTableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelimitedBindingTableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelimitedBindingTableNameContext)
}

func (s *BindingTableReferenceContext) ReferenceParameterSpecification() IReferenceParameterSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceParameterSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceParameterSpecificationContext)
}

func (s *BindingTableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingTableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingTableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBindingTableReference(s)
	}
}

func (s *BindingTableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBindingTableReference(s)
	}
}

func (p *GQLParser) BindingTableReference() (localctx IBindingTableReferenceContext) {
	localctx = NewBindingTableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, GQLParserRULE_bindingTableReference)
	p.SetState(2782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 241, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2777)
			p.CatalogObjectParentReference()
		}
		{
			p.SetState(2778)
			p.BindingTableName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2780)
			p.DelimitedBindingTableName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2781)
			p.ReferenceParameterSpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureReferenceContext is an interface to support dynamic dispatch.
type IProcedureReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CatalogProcedureParentAndName() ICatalogProcedureParentAndNameContext
	ReferenceParameterSpecification() IReferenceParameterSpecificationContext

	// IsProcedureReferenceContext differentiates from other interfaces.
	IsProcedureReferenceContext()
}

type ProcedureReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureReferenceContext() *ProcedureReferenceContext {
	var p = new(ProcedureReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_procedureReference
	return p
}

func InitEmptyProcedureReferenceContext(p *ProcedureReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_procedureReference
}

func (*ProcedureReferenceContext) IsProcedureReferenceContext() {}

func NewProcedureReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureReferenceContext {
	var p = new(ProcedureReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_procedureReference

	return p
}

func (s *ProcedureReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureReferenceContext) CatalogProcedureParentAndName() ICatalogProcedureParentAndNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogProcedureParentAndNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogProcedureParentAndNameContext)
}

func (s *ProcedureReferenceContext) ReferenceParameterSpecification() IReferenceParameterSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceParameterSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceParameterSpecificationContext)
}

func (s *ProcedureReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterProcedureReference(s)
	}
}

func (s *ProcedureReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitProcedureReference(s)
	}
}

func (p *GQLParser) ProcedureReference() (localctx IProcedureReferenceContext) {
	localctx = NewProcedureReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, GQLParserRULE_procedureReference)
	p.SetState(2786)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 242, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2784)
			p.CatalogProcedureParentAndName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2785)
			p.ReferenceParameterSpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatalogProcedureParentAndNameContext is an interface to support dynamic dispatch.
type ICatalogProcedureParentAndNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ProcedureName() IProcedureNameContext
	CatalogObjectParentReference() ICatalogObjectParentReferenceContext

	// IsCatalogProcedureParentAndNameContext differentiates from other interfaces.
	IsCatalogProcedureParentAndNameContext()
}

type CatalogProcedureParentAndNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatalogProcedureParentAndNameContext() *CatalogProcedureParentAndNameContext {
	var p = new(CatalogProcedureParentAndNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_catalogProcedureParentAndName
	return p
}

func InitEmptyCatalogProcedureParentAndNameContext(p *CatalogProcedureParentAndNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_catalogProcedureParentAndName
}

func (*CatalogProcedureParentAndNameContext) IsCatalogProcedureParentAndNameContext() {}

func NewCatalogProcedureParentAndNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatalogProcedureParentAndNameContext {
	var p = new(CatalogProcedureParentAndNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_catalogProcedureParentAndName

	return p
}

func (s *CatalogProcedureParentAndNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CatalogProcedureParentAndNameContext) ProcedureName() IProcedureNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *CatalogProcedureParentAndNameContext) CatalogObjectParentReference() ICatalogObjectParentReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatalogObjectParentReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatalogObjectParentReferenceContext)
}

func (s *CatalogProcedureParentAndNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatalogProcedureParentAndNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatalogProcedureParentAndNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCatalogProcedureParentAndName(s)
	}
}

func (s *CatalogProcedureParentAndNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCatalogProcedureParentAndName(s)
	}
}

func (p *GQLParser) CatalogProcedureParentAndName() (localctx ICatalogProcedureParentAndNameContext) {
	localctx = NewCatalogProcedureParentAndNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, GQLParserRULE_catalogProcedureParentAndName)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2789)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 243, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2788)
			p.CatalogObjectParentReference()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2791)
		p.ProcedureName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatalogObjectParentReferenceContext is an interface to support dynamic dispatch.
type ICatalogObjectParentReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SchemaReference() ISchemaReferenceContext
	SOLIDUS() antlr.TerminalNode
	AllObjectName() []IObjectNameContext
	ObjectName(i int) IObjectNameContext
	AllPERIOD() []antlr.TerminalNode
	PERIOD(i int) antlr.TerminalNode

	// IsCatalogObjectParentReferenceContext differentiates from other interfaces.
	IsCatalogObjectParentReferenceContext()
}

type CatalogObjectParentReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatalogObjectParentReferenceContext() *CatalogObjectParentReferenceContext {
	var p = new(CatalogObjectParentReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_catalogObjectParentReference
	return p
}

func InitEmptyCatalogObjectParentReferenceContext(p *CatalogObjectParentReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_catalogObjectParentReference
}

func (*CatalogObjectParentReferenceContext) IsCatalogObjectParentReferenceContext() {}

func NewCatalogObjectParentReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatalogObjectParentReferenceContext {
	var p = new(CatalogObjectParentReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_catalogObjectParentReference

	return p
}

func (s *CatalogObjectParentReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *CatalogObjectParentReferenceContext) SchemaReference() ISchemaReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaReferenceContext)
}

func (s *CatalogObjectParentReferenceContext) SOLIDUS() antlr.TerminalNode {
	return s.GetToken(GQLParserSOLIDUS, 0)
}

func (s *CatalogObjectParentReferenceContext) AllObjectName() []IObjectNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectNameContext); ok {
			len++
		}
	}

	tst := make([]IObjectNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectNameContext); ok {
			tst[i] = t.(IObjectNameContext)
			i++
		}
	}

	return tst
}

func (s *CatalogObjectParentReferenceContext) ObjectName(i int) IObjectNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectNameContext)
}

func (s *CatalogObjectParentReferenceContext) AllPERIOD() []antlr.TerminalNode {
	return s.GetTokens(GQLParserPERIOD)
}

func (s *CatalogObjectParentReferenceContext) PERIOD(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserPERIOD, i)
}

func (s *CatalogObjectParentReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatalogObjectParentReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatalogObjectParentReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCatalogObjectParentReference(s)
	}
}

func (s *CatalogObjectParentReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCatalogObjectParentReference(s)
	}
}

func (p *GQLParser) CatalogObjectParentReference() (localctx ICatalogObjectParentReferenceContext) {
	localctx = NewCatalogObjectParentReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, GQLParserRULE_catalogObjectParentReference)
	var _la int

	var _alt int

	p.SetState(2812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserCURRENT_SCHEMA, GQLParserHOME_SCHEMA, GQLParserSUBSTITUTED_PARAMETER_REFERENCE, GQLParserDOUBLE_PERIOD, GQLParserPERIOD, GQLParserSOLIDUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2793)
			p.SchemaReference()
		}
		p.SetState(2795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserSOLIDUS {
			{
				p.SetState(2794)
				p.Match(GQLParserSOLIDUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2802)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 245, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2797)
					p.ObjectName()
				}
				{
					p.SetState(2798)
					p.Match(GQLParserPERIOD)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(2804)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 245, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE, GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE, GQLParserREGULAR_IDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2808)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(2805)
					p.ObjectName()
				}
				{
					p.SetState(2806)
					p.Match(GQLParserPERIOD)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(2810)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 246, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferenceParameterSpecificationContext is an interface to support dynamic dispatch.
type IReferenceParameterSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBSTITUTED_PARAMETER_REFERENCE() antlr.TerminalNode

	// IsReferenceParameterSpecificationContext differentiates from other interfaces.
	IsReferenceParameterSpecificationContext()
}

type ReferenceParameterSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceParameterSpecificationContext() *ReferenceParameterSpecificationContext {
	var p = new(ReferenceParameterSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_referenceParameterSpecification
	return p
}

func InitEmptyReferenceParameterSpecificationContext(p *ReferenceParameterSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_referenceParameterSpecification
}

func (*ReferenceParameterSpecificationContext) IsReferenceParameterSpecificationContext() {}

func NewReferenceParameterSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceParameterSpecificationContext {
	var p = new(ReferenceParameterSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_referenceParameterSpecification

	return p
}

func (s *ReferenceParameterSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceParameterSpecificationContext) SUBSTITUTED_PARAMETER_REFERENCE() antlr.TerminalNode {
	return s.GetToken(GQLParserSUBSTITUTED_PARAMETER_REFERENCE, 0)
}

func (s *ReferenceParameterSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceParameterSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceParameterSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterReferenceParameterSpecification(s)
	}
}

func (s *ReferenceParameterSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitReferenceParameterSpecification(s)
	}
}

func (p *GQLParser) ReferenceParameterSpecification() (localctx IReferenceParameterSpecificationContext) {
	localctx = NewReferenceParameterSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, GQLParserRULE_referenceParameterSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2814)
		p.Match(GQLParserSUBSTITUTED_PARAMETER_REFERENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INestedGraphTypeSpecificationContext is an interface to support dynamic dispatch.
type INestedGraphTypeSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_BRACE() antlr.TerminalNode
	GraphTypeSpecificationBody() IGraphTypeSpecificationBodyContext
	RIGHT_BRACE() antlr.TerminalNode

	// IsNestedGraphTypeSpecificationContext differentiates from other interfaces.
	IsNestedGraphTypeSpecificationContext()
}

type NestedGraphTypeSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedGraphTypeSpecificationContext() *NestedGraphTypeSpecificationContext {
	var p = new(NestedGraphTypeSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nestedGraphTypeSpecification
	return p
}

func InitEmptyNestedGraphTypeSpecificationContext(p *NestedGraphTypeSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nestedGraphTypeSpecification
}

func (*NestedGraphTypeSpecificationContext) IsNestedGraphTypeSpecificationContext() {}

func NewNestedGraphTypeSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedGraphTypeSpecificationContext {
	var p = new(NestedGraphTypeSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nestedGraphTypeSpecification

	return p
}

func (s *NestedGraphTypeSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedGraphTypeSpecificationContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACE, 0)
}

func (s *NestedGraphTypeSpecificationContext) GraphTypeSpecificationBody() IGraphTypeSpecificationBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphTypeSpecificationBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphTypeSpecificationBodyContext)
}

func (s *NestedGraphTypeSpecificationContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACE, 0)
}

func (s *NestedGraphTypeSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedGraphTypeSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedGraphTypeSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNestedGraphTypeSpecification(s)
	}
}

func (s *NestedGraphTypeSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNestedGraphTypeSpecification(s)
	}
}

func (p *GQLParser) NestedGraphTypeSpecification() (localctx INestedGraphTypeSpecificationContext) {
	localctx = NewNestedGraphTypeSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, GQLParserRULE_nestedGraphTypeSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2816)
		p.Match(GQLParserLEFT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2817)
		p.GraphTypeSpecificationBody()
	}
	{
		p.SetState(2818)
		p.Match(GQLParserRIGHT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphTypeSpecificationBodyContext is an interface to support dynamic dispatch.
type IGraphTypeSpecificationBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementTypeList() IElementTypeListContext

	// IsGraphTypeSpecificationBodyContext differentiates from other interfaces.
	IsGraphTypeSpecificationBodyContext()
}

type GraphTypeSpecificationBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphTypeSpecificationBodyContext() *GraphTypeSpecificationBodyContext {
	var p = new(GraphTypeSpecificationBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphTypeSpecificationBody
	return p
}

func InitEmptyGraphTypeSpecificationBodyContext(p *GraphTypeSpecificationBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphTypeSpecificationBody
}

func (*GraphTypeSpecificationBodyContext) IsGraphTypeSpecificationBodyContext() {}

func NewGraphTypeSpecificationBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphTypeSpecificationBodyContext {
	var p = new(GraphTypeSpecificationBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphTypeSpecificationBody

	return p
}

func (s *GraphTypeSpecificationBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphTypeSpecificationBodyContext) ElementTypeList() IElementTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTypeListContext)
}

func (s *GraphTypeSpecificationBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphTypeSpecificationBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphTypeSpecificationBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphTypeSpecificationBody(s)
	}
}

func (s *GraphTypeSpecificationBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphTypeSpecificationBody(s)
	}
}

func (p *GQLParser) GraphTypeSpecificationBody() (localctx IGraphTypeSpecificationBodyContext) {
	localctx = NewGraphTypeSpecificationBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, GQLParserRULE_graphTypeSpecificationBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2820)
		p.ElementTypeList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementTypeListContext is an interface to support dynamic dispatch.
type IElementTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllElementTypeSpecification() []IElementTypeSpecificationContext
	ElementTypeSpecification(i int) IElementTypeSpecificationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsElementTypeListContext differentiates from other interfaces.
	IsElementTypeListContext()
}

type ElementTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementTypeListContext() *ElementTypeListContext {
	var p = new(ElementTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementTypeList
	return p
}

func InitEmptyElementTypeListContext(p *ElementTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementTypeList
}

func (*ElementTypeListContext) IsElementTypeListContext() {}

func NewElementTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementTypeListContext {
	var p = new(ElementTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_elementTypeList

	return p
}

func (s *ElementTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementTypeListContext) AllElementTypeSpecification() []IElementTypeSpecificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementTypeSpecificationContext); ok {
			len++
		}
	}

	tst := make([]IElementTypeSpecificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementTypeSpecificationContext); ok {
			tst[i] = t.(IElementTypeSpecificationContext)
			i++
		}
	}

	return tst
}

func (s *ElementTypeListContext) ElementTypeSpecification(i int) IElementTypeSpecificationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementTypeSpecificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementTypeSpecificationContext)
}

func (s *ElementTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *ElementTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *ElementTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterElementTypeList(s)
	}
}

func (s *ElementTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitElementTypeList(s)
	}
}

func (p *GQLParser) ElementTypeList() (localctx IElementTypeListContext) {
	localctx = NewElementTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, GQLParserRULE_elementTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2822)
		p.ElementTypeSpecification()
	}
	p.SetState(2827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(2823)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2824)
			p.ElementTypeSpecification()
		}

		p.SetState(2829)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementTypeSpecificationContext is an interface to support dynamic dispatch.
type IElementTypeSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NodeTypeSpecification() INodeTypeSpecificationContext
	EdgeTypeSpecification() IEdgeTypeSpecificationContext
	CompositePrimaryKey() ICompositePrimaryKeyContext
	CompositeUniqueConstraint() ICompositeUniqueConstraintContext

	// IsElementTypeSpecificationContext differentiates from other interfaces.
	IsElementTypeSpecificationContext()
}

type ElementTypeSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementTypeSpecificationContext() *ElementTypeSpecificationContext {
	var p = new(ElementTypeSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementTypeSpecification
	return p
}

func InitEmptyElementTypeSpecificationContext(p *ElementTypeSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementTypeSpecification
}

func (*ElementTypeSpecificationContext) IsElementTypeSpecificationContext() {}

func NewElementTypeSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementTypeSpecificationContext {
	var p = new(ElementTypeSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_elementTypeSpecification

	return p
}

func (s *ElementTypeSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementTypeSpecificationContext) NodeTypeSpecification() INodeTypeSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTypeSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTypeSpecificationContext)
}

func (s *ElementTypeSpecificationContext) EdgeTypeSpecification() IEdgeTypeSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypeSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypeSpecificationContext)
}

func (s *ElementTypeSpecificationContext) CompositePrimaryKey() ICompositePrimaryKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompositePrimaryKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompositePrimaryKeyContext)
}

func (s *ElementTypeSpecificationContext) CompositeUniqueConstraint() ICompositeUniqueConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompositeUniqueConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompositeUniqueConstraintContext)
}

func (s *ElementTypeSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementTypeSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementTypeSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterElementTypeSpecification(s)
	}
}

func (s *ElementTypeSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitElementTypeSpecification(s)
	}
}

func (p *GQLParser) ElementTypeSpecification() (localctx IElementTypeSpecificationContext) {
	localctx = NewElementTypeSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, GQLParserRULE_elementTypeSpecification)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 249, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2830)
			p.NodeTypeSpecification()
		}

	case 2:
		{
			p.SetState(2831)
			p.EdgeTypeSpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case GQLParserPRIMARY:
		{
			p.SetState(2834)
			p.CompositePrimaryKey()
		}

	case GQLParserUNIQUE:
		{
			p.SetState(2835)
			p.CompositeUniqueConstraint()
		}

	case GQLParserCOMMA, GQLParserRIGHT_BRACE:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompositePrimaryKeyContext is an interface to support dynamic dispatch.
type ICompositePrimaryKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryKey() IPrimaryKeyContext
	LEFT_PAREN() antlr.TerminalNode
	FieldNameList() IFieldNameListContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsCompositePrimaryKeyContext differentiates from other interfaces.
	IsCompositePrimaryKeyContext()
}

type CompositePrimaryKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompositePrimaryKeyContext() *CompositePrimaryKeyContext {
	var p = new(CompositePrimaryKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_compositePrimaryKey
	return p
}

func InitEmptyCompositePrimaryKeyContext(p *CompositePrimaryKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_compositePrimaryKey
}

func (*CompositePrimaryKeyContext) IsCompositePrimaryKeyContext() {}

func NewCompositePrimaryKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompositePrimaryKeyContext {
	var p = new(CompositePrimaryKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_compositePrimaryKey

	return p
}

func (s *CompositePrimaryKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *CompositePrimaryKeyContext) PrimaryKey() IPrimaryKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyContext)
}

func (s *CompositePrimaryKeyContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *CompositePrimaryKeyContext) FieldNameList() IFieldNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameListContext)
}

func (s *CompositePrimaryKeyContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *CompositePrimaryKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompositePrimaryKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompositePrimaryKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCompositePrimaryKey(s)
	}
}

func (s *CompositePrimaryKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCompositePrimaryKey(s)
	}
}

func (p *GQLParser) CompositePrimaryKey() (localctx ICompositePrimaryKeyContext) {
	localctx = NewCompositePrimaryKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, GQLParserRULE_compositePrimaryKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2838)
		p.PrimaryKey()
	}
	{
		p.SetState(2839)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2840)
		p.FieldNameList()
	}
	{
		p.SetState(2841)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompositeUniqueConstraintContext is an interface to support dynamic dispatch.
type ICompositeUniqueConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNIQUE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	FieldNameList() IFieldNameListContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsCompositeUniqueConstraintContext differentiates from other interfaces.
	IsCompositeUniqueConstraintContext()
}

type CompositeUniqueConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompositeUniqueConstraintContext() *CompositeUniqueConstraintContext {
	var p = new(CompositeUniqueConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_compositeUniqueConstraint
	return p
}

func InitEmptyCompositeUniqueConstraintContext(p *CompositeUniqueConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_compositeUniqueConstraint
}

func (*CompositeUniqueConstraintContext) IsCompositeUniqueConstraintContext() {}

func NewCompositeUniqueConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompositeUniqueConstraintContext {
	var p = new(CompositeUniqueConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_compositeUniqueConstraint

	return p
}

func (s *CompositeUniqueConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *CompositeUniqueConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(GQLParserUNIQUE, 0)
}

func (s *CompositeUniqueConstraintContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *CompositeUniqueConstraintContext) FieldNameList() IFieldNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameListContext)
}

func (s *CompositeUniqueConstraintContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *CompositeUniqueConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompositeUniqueConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompositeUniqueConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCompositeUniqueConstraint(s)
	}
}

func (s *CompositeUniqueConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCompositeUniqueConstraint(s)
	}
}

func (p *GQLParser) CompositeUniqueConstraint() (localctx ICompositeUniqueConstraintContext) {
	localctx = NewCompositeUniqueConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, GQLParserRULE_compositeUniqueConstraint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2843)
		p.Match(GQLParserUNIQUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2844)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2845)
		p.FieldNameList()
	}
	{
		p.SetState(2846)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldNameListContext is an interface to support dynamic dispatch.
type IFieldNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldName() []IFieldNameContext
	FieldName(i int) IFieldNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFieldNameListContext differentiates from other interfaces.
	IsFieldNameListContext()
}

type FieldNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldNameListContext() *FieldNameListContext {
	var p = new(FieldNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fieldNameList
	return p
}

func InitEmptyFieldNameListContext(p *FieldNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fieldNameList
}

func (*FieldNameListContext) IsFieldNameListContext() {}

func NewFieldNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldNameListContext {
	var p = new(FieldNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fieldNameList

	return p
}

func (s *FieldNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldNameListContext) AllFieldName() []IFieldNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldNameContext); ok {
			len++
		}
	}

	tst := make([]IFieldNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldNameContext); ok {
			tst[i] = t.(IFieldNameContext)
			i++
		}
	}

	return tst
}

func (s *FieldNameListContext) FieldName(i int) IFieldNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *FieldNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *FieldNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *FieldNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFieldNameList(s)
	}
}

func (s *FieldNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFieldNameList(s)
	}
}

func (p *GQLParser) FieldNameList() (localctx IFieldNameListContext) {
	localctx = NewFieldNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, GQLParserRULE_fieldNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2848)
		p.FieldName()
	}
	p.SetState(2853)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(2849)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2850)
			p.FieldName()
		}

		p.SetState(2855)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeTypeSpecificationContext is an interface to support dynamic dispatch.
type INodeTypeSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NodeTypePattern() INodeTypePatternContext
	NodeTypePhrase() INodeTypePhraseContext

	// IsNodeTypeSpecificationContext differentiates from other interfaces.
	IsNodeTypeSpecificationContext()
}

type NodeTypeSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeTypeSpecificationContext() *NodeTypeSpecificationContext {
	var p = new(NodeTypeSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypeSpecification
	return p
}

func InitEmptyNodeTypeSpecificationContext(p *NodeTypeSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypeSpecification
}

func (*NodeTypeSpecificationContext) IsNodeTypeSpecificationContext() {}

func NewNodeTypeSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeTypeSpecificationContext {
	var p = new(NodeTypeSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nodeTypeSpecification

	return p
}

func (s *NodeTypeSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeTypeSpecificationContext) NodeTypePattern() INodeTypePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTypePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTypePatternContext)
}

func (s *NodeTypeSpecificationContext) NodeTypePhrase() INodeTypePhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTypePhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTypePhraseContext)
}

func (s *NodeTypeSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeTypeSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeTypeSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNodeTypeSpecification(s)
	}
}

func (s *NodeTypeSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNodeTypeSpecification(s)
	}
}

func (p *GQLParser) NodeTypeSpecification() (localctx INodeTypeSpecificationContext) {
	localctx = NewNodeTypeSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, GQLParserRULE_nodeTypeSpecification)
	p.SetState(2858)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2856)
			p.NodeTypePattern()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2857)
			p.NodeTypePhrase()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeTypePatternContext is an interface to support dynamic dispatch.
type INodeTypePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	NodeSynonym() INodeSynonymContext
	NodeTypeName() INodeTypeNameContext
	LocalNodeTypeAlias() ILocalNodeTypeAliasContext
	NodeTypeFiller() INodeTypeFillerContext
	TYPE() antlr.TerminalNode

	// IsNodeTypePatternContext differentiates from other interfaces.
	IsNodeTypePatternContext()
}

type NodeTypePatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeTypePatternContext() *NodeTypePatternContext {
	var p = new(NodeTypePatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypePattern
	return p
}

func InitEmptyNodeTypePatternContext(p *NodeTypePatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypePattern
}

func (*NodeTypePatternContext) IsNodeTypePatternContext() {}

func NewNodeTypePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeTypePatternContext {
	var p = new(NodeTypePatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nodeTypePattern

	return p
}

func (s *NodeTypePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeTypePatternContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *NodeTypePatternContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *NodeTypePatternContext) NodeSynonym() INodeSynonymContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeSynonymContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeSynonymContext)
}

func (s *NodeTypePatternContext) NodeTypeName() INodeTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTypeNameContext)
}

func (s *NodeTypePatternContext) LocalNodeTypeAlias() ILocalNodeTypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalNodeTypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalNodeTypeAliasContext)
}

func (s *NodeTypePatternContext) NodeTypeFiller() INodeTypeFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTypeFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTypeFillerContext)
}

func (s *NodeTypePatternContext) TYPE() antlr.TerminalNode {
	return s.GetToken(GQLParserTYPE, 0)
}

func (s *NodeTypePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeTypePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeTypePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNodeTypePattern(s)
	}
}

func (s *NodeTypePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNodeTypePattern(s)
	}
}

func (p *GQLParser) NodeTypePattern() (localctx INodeTypePatternContext) {
	localctx = NewNodeTypePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, GQLParserRULE_nodeTypePattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2866)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserNODE || _la == GQLParserVERTEX {
		{
			p.SetState(2860)
			p.NodeSynonym()
		}
		p.SetState(2862)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 253, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2861)
				p.Match(GQLParserTYPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2864)
			p.NodeTypeName()
		}

	}
	{
		p.SetState(2868)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2870)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 255, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2869)
			p.LocalNodeTypeAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserIMPLIES || _la == GQLParserIS || _la == GQLParserLABEL || _la == GQLParserLABELS || _la == GQLParserCOLON || _la == GQLParserLEFT_BRACE {
		{
			p.SetState(2872)
			p.NodeTypeFiller()
		}

	}
	{
		p.SetState(2875)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeTypePhraseContext is an interface to support dynamic dispatch.
type INodeTypePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NodeSynonym() INodeSynonymContext
	NodeTypePhraseFiller() INodeTypePhraseFillerContext
	TYPE() antlr.TerminalNode
	AS() antlr.TerminalNode
	LocalNodeTypeAlias() ILocalNodeTypeAliasContext

	// IsNodeTypePhraseContext differentiates from other interfaces.
	IsNodeTypePhraseContext()
}

type NodeTypePhraseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeTypePhraseContext() *NodeTypePhraseContext {
	var p = new(NodeTypePhraseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypePhrase
	return p
}

func InitEmptyNodeTypePhraseContext(p *NodeTypePhraseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypePhrase
}

func (*NodeTypePhraseContext) IsNodeTypePhraseContext() {}

func NewNodeTypePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeTypePhraseContext {
	var p = new(NodeTypePhraseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nodeTypePhrase

	return p
}

func (s *NodeTypePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeTypePhraseContext) NodeSynonym() INodeSynonymContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeSynonymContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeSynonymContext)
}

func (s *NodeTypePhraseContext) NodeTypePhraseFiller() INodeTypePhraseFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTypePhraseFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTypePhraseFillerContext)
}

func (s *NodeTypePhraseContext) TYPE() antlr.TerminalNode {
	return s.GetToken(GQLParserTYPE, 0)
}

func (s *NodeTypePhraseContext) AS() antlr.TerminalNode {
	return s.GetToken(GQLParserAS, 0)
}

func (s *NodeTypePhraseContext) LocalNodeTypeAlias() ILocalNodeTypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalNodeTypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalNodeTypeAliasContext)
}

func (s *NodeTypePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeTypePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeTypePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNodeTypePhrase(s)
	}
}

func (s *NodeTypePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNodeTypePhrase(s)
	}
}

func (p *GQLParser) NodeTypePhrase() (localctx INodeTypePhraseContext) {
	localctx = NewNodeTypePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, GQLParserRULE_nodeTypePhrase)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2877)
		p.NodeSynonym()
	}
	p.SetState(2879)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 257, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2878)
			p.Match(GQLParserTYPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2881)
		p.NodeTypePhraseFiller()
	}
	p.SetState(2884)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 258, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2882)
			p.Match(GQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2883)
			p.LocalNodeTypeAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeTypePhraseFillerContext is an interface to support dynamic dispatch.
type INodeTypePhraseFillerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NodeTypeName() INodeTypeNameContext
	NodeTypeFiller() INodeTypeFillerContext

	// IsNodeTypePhraseFillerContext differentiates from other interfaces.
	IsNodeTypePhraseFillerContext()
}

type NodeTypePhraseFillerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeTypePhraseFillerContext() *NodeTypePhraseFillerContext {
	var p = new(NodeTypePhraseFillerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypePhraseFiller
	return p
}

func InitEmptyNodeTypePhraseFillerContext(p *NodeTypePhraseFillerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypePhraseFiller
}

func (*NodeTypePhraseFillerContext) IsNodeTypePhraseFillerContext() {}

func NewNodeTypePhraseFillerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeTypePhraseFillerContext {
	var p = new(NodeTypePhraseFillerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nodeTypePhraseFiller

	return p
}

func (s *NodeTypePhraseFillerContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeTypePhraseFillerContext) NodeTypeName() INodeTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTypeNameContext)
}

func (s *NodeTypePhraseFillerContext) NodeTypeFiller() INodeTypeFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTypeFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTypeFillerContext)
}

func (s *NodeTypePhraseFillerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeTypePhraseFillerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeTypePhraseFillerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNodeTypePhraseFiller(s)
	}
}

func (s *NodeTypePhraseFillerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNodeTypePhraseFiller(s)
	}
}

func (p *GQLParser) NodeTypePhraseFiller() (localctx INodeTypePhraseFillerContext) {
	localctx = NewNodeTypePhraseFillerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, GQLParserRULE_nodeTypePhraseFiller)
	p.SetState(2891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 260, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2886)
			p.NodeTypeName()
		}
		p.SetState(2888)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 259, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2887)
				p.NodeTypeFiller()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2890)
			p.NodeTypeFiller()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeTypeFillerContext is an interface to support dynamic dispatch.
type INodeTypeFillerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NodeTypeKeyLabelSet() INodeTypeKeyLabelSetContext
	NodeTypeImpliedContent() INodeTypeImpliedContentContext

	// IsNodeTypeFillerContext differentiates from other interfaces.
	IsNodeTypeFillerContext()
}

type NodeTypeFillerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeTypeFillerContext() *NodeTypeFillerContext {
	var p = new(NodeTypeFillerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypeFiller
	return p
}

func InitEmptyNodeTypeFillerContext(p *NodeTypeFillerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypeFiller
}

func (*NodeTypeFillerContext) IsNodeTypeFillerContext() {}

func NewNodeTypeFillerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeTypeFillerContext {
	var p = new(NodeTypeFillerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nodeTypeFiller

	return p
}

func (s *NodeTypeFillerContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeTypeFillerContext) NodeTypeKeyLabelSet() INodeTypeKeyLabelSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTypeKeyLabelSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTypeKeyLabelSetContext)
}

func (s *NodeTypeFillerContext) NodeTypeImpliedContent() INodeTypeImpliedContentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTypeImpliedContentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTypeImpliedContentContext)
}

func (s *NodeTypeFillerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeTypeFillerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeTypeFillerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNodeTypeFiller(s)
	}
}

func (s *NodeTypeFillerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNodeTypeFiller(s)
	}
}

func (p *GQLParser) NodeTypeFiller() (localctx INodeTypeFillerContext) {
	localctx = NewNodeTypeFillerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, GQLParserRULE_nodeTypeFiller)
	p.SetState(2898)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2893)
			p.NodeTypeKeyLabelSet()
		}
		p.SetState(2895)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 261, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2894)
				p.NodeTypeImpliedContent()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2897)
			p.NodeTypeImpliedContent()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocalNodeTypeAliasContext is an interface to support dynamic dispatch.
type ILocalNodeTypeAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RegularIdentifier() IRegularIdentifierContext

	// IsLocalNodeTypeAliasContext differentiates from other interfaces.
	IsLocalNodeTypeAliasContext()
}

type LocalNodeTypeAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalNodeTypeAliasContext() *LocalNodeTypeAliasContext {
	var p = new(LocalNodeTypeAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_localNodeTypeAlias
	return p
}

func InitEmptyLocalNodeTypeAliasContext(p *LocalNodeTypeAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_localNodeTypeAlias
}

func (*LocalNodeTypeAliasContext) IsLocalNodeTypeAliasContext() {}

func NewLocalNodeTypeAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalNodeTypeAliasContext {
	var p = new(LocalNodeTypeAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_localNodeTypeAlias

	return p
}

func (s *LocalNodeTypeAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalNodeTypeAliasContext) RegularIdentifier() IRegularIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegularIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegularIdentifierContext)
}

func (s *LocalNodeTypeAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalNodeTypeAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalNodeTypeAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLocalNodeTypeAlias(s)
	}
}

func (s *LocalNodeTypeAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLocalNodeTypeAlias(s)
	}
}

func (p *GQLParser) LocalNodeTypeAlias() (localctx ILocalNodeTypeAliasContext) {
	localctx = NewLocalNodeTypeAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, GQLParserRULE_localNodeTypeAlias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2900)
		p.RegularIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeTypeImpliedContentContext is an interface to support dynamic dispatch.
type INodeTypeImpliedContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NodeTypeLabelSet() INodeTypeLabelSetContext
	NodeTypePropertyTypes() INodeTypePropertyTypesContext

	// IsNodeTypeImpliedContentContext differentiates from other interfaces.
	IsNodeTypeImpliedContentContext()
}

type NodeTypeImpliedContentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeTypeImpliedContentContext() *NodeTypeImpliedContentContext {
	var p = new(NodeTypeImpliedContentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypeImpliedContent
	return p
}

func InitEmptyNodeTypeImpliedContentContext(p *NodeTypeImpliedContentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypeImpliedContent
}

func (*NodeTypeImpliedContentContext) IsNodeTypeImpliedContentContext() {}

func NewNodeTypeImpliedContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeTypeImpliedContentContext {
	var p = new(NodeTypeImpliedContentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nodeTypeImpliedContent

	return p
}

func (s *NodeTypeImpliedContentContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeTypeImpliedContentContext) NodeTypeLabelSet() INodeTypeLabelSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTypeLabelSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTypeLabelSetContext)
}

func (s *NodeTypeImpliedContentContext) NodeTypePropertyTypes() INodeTypePropertyTypesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTypePropertyTypesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTypePropertyTypesContext)
}

func (s *NodeTypeImpliedContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeTypeImpliedContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeTypeImpliedContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNodeTypeImpliedContent(s)
	}
}

func (s *NodeTypeImpliedContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNodeTypeImpliedContent(s)
	}
}

func (p *GQLParser) NodeTypeImpliedContent() (localctx INodeTypeImpliedContentContext) {
	localctx = NewNodeTypeImpliedContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, GQLParserRULE_nodeTypeImpliedContent)
	p.SetState(2907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2902)
			p.NodeTypeLabelSet()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2903)
			p.NodeTypePropertyTypes()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2904)
			p.NodeTypeLabelSet()
		}
		{
			p.SetState(2905)
			p.NodeTypePropertyTypes()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeTypeKeyLabelSetContext is an interface to support dynamic dispatch.
type INodeTypeKeyLabelSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPLIES() antlr.TerminalNode
	LabelSetPhrase() ILabelSetPhraseContext

	// IsNodeTypeKeyLabelSetContext differentiates from other interfaces.
	IsNodeTypeKeyLabelSetContext()
}

type NodeTypeKeyLabelSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeTypeKeyLabelSetContext() *NodeTypeKeyLabelSetContext {
	var p = new(NodeTypeKeyLabelSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypeKeyLabelSet
	return p
}

func InitEmptyNodeTypeKeyLabelSetContext(p *NodeTypeKeyLabelSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypeKeyLabelSet
}

func (*NodeTypeKeyLabelSetContext) IsNodeTypeKeyLabelSetContext() {}

func NewNodeTypeKeyLabelSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeTypeKeyLabelSetContext {
	var p = new(NodeTypeKeyLabelSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nodeTypeKeyLabelSet

	return p
}

func (s *NodeTypeKeyLabelSetContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeTypeKeyLabelSetContext) IMPLIES() antlr.TerminalNode {
	return s.GetToken(GQLParserIMPLIES, 0)
}

func (s *NodeTypeKeyLabelSetContext) LabelSetPhrase() ILabelSetPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelSetPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelSetPhraseContext)
}

func (s *NodeTypeKeyLabelSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeTypeKeyLabelSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeTypeKeyLabelSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNodeTypeKeyLabelSet(s)
	}
}

func (s *NodeTypeKeyLabelSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNodeTypeKeyLabelSet(s)
	}
}

func (p *GQLParser) NodeTypeKeyLabelSet() (localctx INodeTypeKeyLabelSetContext) {
	localctx = NewNodeTypeKeyLabelSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, GQLParserRULE_nodeTypeKeyLabelSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserIS || _la == GQLParserLABEL || _la == GQLParserLABELS || _la == GQLParserCOLON {
		{
			p.SetState(2909)
			p.LabelSetPhrase()
		}

	}
	{
		p.SetState(2912)
		p.Match(GQLParserIMPLIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeTypeLabelSetContext is an interface to support dynamic dispatch.
type INodeTypeLabelSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LabelSetPhrase() ILabelSetPhraseContext

	// IsNodeTypeLabelSetContext differentiates from other interfaces.
	IsNodeTypeLabelSetContext()
}

type NodeTypeLabelSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeTypeLabelSetContext() *NodeTypeLabelSetContext {
	var p = new(NodeTypeLabelSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypeLabelSet
	return p
}

func InitEmptyNodeTypeLabelSetContext(p *NodeTypeLabelSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypeLabelSet
}

func (*NodeTypeLabelSetContext) IsNodeTypeLabelSetContext() {}

func NewNodeTypeLabelSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeTypeLabelSetContext {
	var p = new(NodeTypeLabelSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nodeTypeLabelSet

	return p
}

func (s *NodeTypeLabelSetContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeTypeLabelSetContext) LabelSetPhrase() ILabelSetPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelSetPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelSetPhraseContext)
}

func (s *NodeTypeLabelSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeTypeLabelSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeTypeLabelSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNodeTypeLabelSet(s)
	}
}

func (s *NodeTypeLabelSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNodeTypeLabelSet(s)
	}
}

func (p *GQLParser) NodeTypeLabelSet() (localctx INodeTypeLabelSetContext) {
	localctx = NewNodeTypeLabelSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, GQLParserRULE_nodeTypeLabelSet)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2914)
		p.LabelSetPhrase()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeTypePropertyTypesContext is an interface to support dynamic dispatch.
type INodeTypePropertyTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyTypesSpecification() IPropertyTypesSpecificationContext

	// IsNodeTypePropertyTypesContext differentiates from other interfaces.
	IsNodeTypePropertyTypesContext()
}

type NodeTypePropertyTypesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeTypePropertyTypesContext() *NodeTypePropertyTypesContext {
	var p = new(NodeTypePropertyTypesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypePropertyTypes
	return p
}

func InitEmptyNodeTypePropertyTypesContext(p *NodeTypePropertyTypesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypePropertyTypes
}

func (*NodeTypePropertyTypesContext) IsNodeTypePropertyTypesContext() {}

func NewNodeTypePropertyTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeTypePropertyTypesContext {
	var p = new(NodeTypePropertyTypesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nodeTypePropertyTypes

	return p
}

func (s *NodeTypePropertyTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeTypePropertyTypesContext) PropertyTypesSpecification() IPropertyTypesSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyTypesSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyTypesSpecificationContext)
}

func (s *NodeTypePropertyTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeTypePropertyTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeTypePropertyTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNodeTypePropertyTypes(s)
	}
}

func (s *NodeTypePropertyTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNodeTypePropertyTypes(s)
	}
}

func (p *GQLParser) NodeTypePropertyTypes() (localctx INodeTypePropertyTypesContext) {
	localctx = NewNodeTypePropertyTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, GQLParserRULE_nodeTypePropertyTypes)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2916)
		p.PropertyTypesSpecification()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeTypeSpecificationContext is an interface to support dynamic dispatch.
type IEdgeTypeSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EdgeTypePattern() IEdgeTypePatternContext
	EdgeTypePhrase() IEdgeTypePhraseContext

	// IsEdgeTypeSpecificationContext differentiates from other interfaces.
	IsEdgeTypeSpecificationContext()
}

type EdgeTypeSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeTypeSpecificationContext() *EdgeTypeSpecificationContext {
	var p = new(EdgeTypeSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypeSpecification
	return p
}

func InitEmptyEdgeTypeSpecificationContext(p *EdgeTypeSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypeSpecification
}

func (*EdgeTypeSpecificationContext) IsEdgeTypeSpecificationContext() {}

func NewEdgeTypeSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeTypeSpecificationContext {
	var p = new(EdgeTypeSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeTypeSpecification

	return p
}

func (s *EdgeTypeSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeTypeSpecificationContext) EdgeTypePattern() IEdgeTypePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypePatternContext)
}

func (s *EdgeTypeSpecificationContext) EdgeTypePhrase() IEdgeTypePhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypePhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypePhraseContext)
}

func (s *EdgeTypeSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeTypeSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeTypeSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeTypeSpecification(s)
	}
}

func (s *EdgeTypeSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeTypeSpecification(s)
	}
}

func (p *GQLParser) EdgeTypeSpecification() (localctx IEdgeTypeSpecificationContext) {
	localctx = NewEdgeTypeSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, GQLParserRULE_edgeTypeSpecification)
	p.SetState(2920)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 265, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2918)
			p.EdgeTypePattern()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2919)
			p.EdgeTypePhrase()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeTypePatternContext is an interface to support dynamic dispatch.
type IEdgeTypePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EdgeTypePatternDirected() IEdgeTypePatternDirectedContext
	EdgeTypePatternUndirected() IEdgeTypePatternUndirectedContext
	EdgeSynonym() IEdgeSynonymContext
	EdgeTypeName() IEdgeTypeNameContext
	EdgeKind() IEdgeKindContext
	TYPE() antlr.TerminalNode

	// IsEdgeTypePatternContext differentiates from other interfaces.
	IsEdgeTypePatternContext()
}

type EdgeTypePatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeTypePatternContext() *EdgeTypePatternContext {
	var p = new(EdgeTypePatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePattern
	return p
}

func InitEmptyEdgeTypePatternContext(p *EdgeTypePatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePattern
}

func (*EdgeTypePatternContext) IsEdgeTypePatternContext() {}

func NewEdgeTypePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeTypePatternContext {
	var p = new(EdgeTypePatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeTypePattern

	return p
}

func (s *EdgeTypePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeTypePatternContext) EdgeTypePatternDirected() IEdgeTypePatternDirectedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypePatternDirectedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypePatternDirectedContext)
}

func (s *EdgeTypePatternContext) EdgeTypePatternUndirected() IEdgeTypePatternUndirectedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypePatternUndirectedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypePatternUndirectedContext)
}

func (s *EdgeTypePatternContext) EdgeSynonym() IEdgeSynonymContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeSynonymContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeSynonymContext)
}

func (s *EdgeTypePatternContext) EdgeTypeName() IEdgeTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypeNameContext)
}

func (s *EdgeTypePatternContext) EdgeKind() IEdgeKindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeKindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeKindContext)
}

func (s *EdgeTypePatternContext) TYPE() antlr.TerminalNode {
	return s.GetToken(GQLParserTYPE, 0)
}

func (s *EdgeTypePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeTypePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeTypePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeTypePattern(s)
	}
}

func (s *EdgeTypePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeTypePattern(s)
	}
}

func (p *GQLParser) EdgeTypePattern() (localctx IEdgeTypePatternContext) {
	localctx = NewEdgeTypePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, GQLParserRULE_edgeTypePattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2931)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-286)) & ^0x3f) == 0 && ((int64(1)<<(_la-286))&34376515587) != 0 {
		p.SetState(2923)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserDIRECTED || _la == GQLParserUNDIRECTED {
			{
				p.SetState(2922)
				p.EdgeKind()
			}

		}
		{
			p.SetState(2925)
			p.EdgeSynonym()
		}
		p.SetState(2927)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 267, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2926)
				p.Match(GQLParserTYPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2929)
			p.EdgeTypeName()
		}

	}
	p.SetState(2935)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 269, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2933)
			p.EdgeTypePatternDirected()
		}

	case 2:
		{
			p.SetState(2934)
			p.EdgeTypePatternUndirected()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeTypePhraseContext is an interface to support dynamic dispatch.
type IEdgeTypePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EdgeKind() IEdgeKindContext
	EdgeSynonym() IEdgeSynonymContext
	EdgeTypePhraseFiller() IEdgeTypePhraseFillerContext
	EndpointPairPhrase() IEndpointPairPhraseContext
	TYPE() antlr.TerminalNode

	// IsEdgeTypePhraseContext differentiates from other interfaces.
	IsEdgeTypePhraseContext()
}

type EdgeTypePhraseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeTypePhraseContext() *EdgeTypePhraseContext {
	var p = new(EdgeTypePhraseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePhrase
	return p
}

func InitEmptyEdgeTypePhraseContext(p *EdgeTypePhraseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePhrase
}

func (*EdgeTypePhraseContext) IsEdgeTypePhraseContext() {}

func NewEdgeTypePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeTypePhraseContext {
	var p = new(EdgeTypePhraseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeTypePhrase

	return p
}

func (s *EdgeTypePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeTypePhraseContext) EdgeKind() IEdgeKindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeKindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeKindContext)
}

func (s *EdgeTypePhraseContext) EdgeSynonym() IEdgeSynonymContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeSynonymContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeSynonymContext)
}

func (s *EdgeTypePhraseContext) EdgeTypePhraseFiller() IEdgeTypePhraseFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypePhraseFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypePhraseFillerContext)
}

func (s *EdgeTypePhraseContext) EndpointPairPhrase() IEndpointPairPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndpointPairPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndpointPairPhraseContext)
}

func (s *EdgeTypePhraseContext) TYPE() antlr.TerminalNode {
	return s.GetToken(GQLParserTYPE, 0)
}

func (s *EdgeTypePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeTypePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeTypePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeTypePhrase(s)
	}
}

func (s *EdgeTypePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeTypePhrase(s)
	}
}

func (p *GQLParser) EdgeTypePhrase() (localctx IEdgeTypePhraseContext) {
	localctx = NewEdgeTypePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, GQLParserRULE_edgeTypePhrase)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2937)
		p.EdgeKind()
	}
	{
		p.SetState(2938)
		p.EdgeSynonym()
	}
	p.SetState(2940)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 270, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2939)
			p.Match(GQLParserTYPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2942)
		p.EdgeTypePhraseFiller()
	}
	{
		p.SetState(2943)
		p.EndpointPairPhrase()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeTypePhraseFillerContext is an interface to support dynamic dispatch.
type IEdgeTypePhraseFillerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EdgeTypeName() IEdgeTypeNameContext
	EdgeTypeFiller() IEdgeTypeFillerContext

	// IsEdgeTypePhraseFillerContext differentiates from other interfaces.
	IsEdgeTypePhraseFillerContext()
}

type EdgeTypePhraseFillerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeTypePhraseFillerContext() *EdgeTypePhraseFillerContext {
	var p = new(EdgeTypePhraseFillerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePhraseFiller
	return p
}

func InitEmptyEdgeTypePhraseFillerContext(p *EdgeTypePhraseFillerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePhraseFiller
}

func (*EdgeTypePhraseFillerContext) IsEdgeTypePhraseFillerContext() {}

func NewEdgeTypePhraseFillerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeTypePhraseFillerContext {
	var p = new(EdgeTypePhraseFillerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeTypePhraseFiller

	return p
}

func (s *EdgeTypePhraseFillerContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeTypePhraseFillerContext) EdgeTypeName() IEdgeTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypeNameContext)
}

func (s *EdgeTypePhraseFillerContext) EdgeTypeFiller() IEdgeTypeFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypeFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypeFillerContext)
}

func (s *EdgeTypePhraseFillerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeTypePhraseFillerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeTypePhraseFillerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeTypePhraseFiller(s)
	}
}

func (s *EdgeTypePhraseFillerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeTypePhraseFiller(s)
	}
}

func (p *GQLParser) EdgeTypePhraseFiller() (localctx IEdgeTypePhraseFillerContext) {
	localctx = NewEdgeTypePhraseFillerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, GQLParserRULE_edgeTypePhraseFiller)
	var _la int

	p.SetState(2950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 272, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2945)
			p.EdgeTypeName()
		}
		p.SetState(2947)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserIMPLIES || _la == GQLParserIS || _la == GQLParserLABEL || _la == GQLParserLABELS || _la == GQLParserCOLON || _la == GQLParserLEFT_BRACE {
			{
				p.SetState(2946)
				p.EdgeTypeFiller()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2949)
			p.EdgeTypeFiller()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeTypeFillerContext is an interface to support dynamic dispatch.
type IEdgeTypeFillerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EdgeTypeKeyLabelSet() IEdgeTypeKeyLabelSetContext
	EdgeTypeImpliedContent() IEdgeTypeImpliedContentContext

	// IsEdgeTypeFillerContext differentiates from other interfaces.
	IsEdgeTypeFillerContext()
}

type EdgeTypeFillerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeTypeFillerContext() *EdgeTypeFillerContext {
	var p = new(EdgeTypeFillerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypeFiller
	return p
}

func InitEmptyEdgeTypeFillerContext(p *EdgeTypeFillerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypeFiller
}

func (*EdgeTypeFillerContext) IsEdgeTypeFillerContext() {}

func NewEdgeTypeFillerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeTypeFillerContext {
	var p = new(EdgeTypeFillerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeTypeFiller

	return p
}

func (s *EdgeTypeFillerContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeTypeFillerContext) EdgeTypeKeyLabelSet() IEdgeTypeKeyLabelSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypeKeyLabelSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypeKeyLabelSetContext)
}

func (s *EdgeTypeFillerContext) EdgeTypeImpliedContent() IEdgeTypeImpliedContentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypeImpliedContentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypeImpliedContentContext)
}

func (s *EdgeTypeFillerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeTypeFillerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeTypeFillerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeTypeFiller(s)
	}
}

func (s *EdgeTypeFillerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeTypeFiller(s)
	}
}

func (p *GQLParser) EdgeTypeFiller() (localctx IEdgeTypeFillerContext) {
	localctx = NewEdgeTypeFillerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, GQLParserRULE_edgeTypeFiller)
	var _la int

	p.SetState(2957)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 274, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2952)
			p.EdgeTypeKeyLabelSet()
		}
		p.SetState(2954)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserIS || _la == GQLParserLABEL || _la == GQLParserLABELS || _la == GQLParserCOLON || _la == GQLParserLEFT_BRACE {
			{
				p.SetState(2953)
				p.EdgeTypeImpliedContent()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2956)
			p.EdgeTypeImpliedContent()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeTypeImpliedContentContext is an interface to support dynamic dispatch.
type IEdgeTypeImpliedContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EdgeTypeLabelSet() IEdgeTypeLabelSetContext
	EdgeTypePropertyTypes() IEdgeTypePropertyTypesContext

	// IsEdgeTypeImpliedContentContext differentiates from other interfaces.
	IsEdgeTypeImpliedContentContext()
}

type EdgeTypeImpliedContentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeTypeImpliedContentContext() *EdgeTypeImpliedContentContext {
	var p = new(EdgeTypeImpliedContentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypeImpliedContent
	return p
}

func InitEmptyEdgeTypeImpliedContentContext(p *EdgeTypeImpliedContentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypeImpliedContent
}

func (*EdgeTypeImpliedContentContext) IsEdgeTypeImpliedContentContext() {}

func NewEdgeTypeImpliedContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeTypeImpliedContentContext {
	var p = new(EdgeTypeImpliedContentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeTypeImpliedContent

	return p
}

func (s *EdgeTypeImpliedContentContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeTypeImpliedContentContext) EdgeTypeLabelSet() IEdgeTypeLabelSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypeLabelSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypeLabelSetContext)
}

func (s *EdgeTypeImpliedContentContext) EdgeTypePropertyTypes() IEdgeTypePropertyTypesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypePropertyTypesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypePropertyTypesContext)
}

func (s *EdgeTypeImpliedContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeTypeImpliedContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeTypeImpliedContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeTypeImpliedContent(s)
	}
}

func (s *EdgeTypeImpliedContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeTypeImpliedContent(s)
	}
}

func (p *GQLParser) EdgeTypeImpliedContent() (localctx IEdgeTypeImpliedContentContext) {
	localctx = NewEdgeTypeImpliedContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, GQLParserRULE_edgeTypeImpliedContent)
	p.SetState(2964)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 275, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2959)
			p.EdgeTypeLabelSet()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2960)
			p.EdgeTypePropertyTypes()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2961)
			p.EdgeTypeLabelSet()
		}
		{
			p.SetState(2962)
			p.EdgeTypePropertyTypes()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeTypeKeyLabelSetContext is an interface to support dynamic dispatch.
type IEdgeTypeKeyLabelSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPLIES() antlr.TerminalNode
	LabelSetPhrase() ILabelSetPhraseContext

	// IsEdgeTypeKeyLabelSetContext differentiates from other interfaces.
	IsEdgeTypeKeyLabelSetContext()
}

type EdgeTypeKeyLabelSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeTypeKeyLabelSetContext() *EdgeTypeKeyLabelSetContext {
	var p = new(EdgeTypeKeyLabelSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypeKeyLabelSet
	return p
}

func InitEmptyEdgeTypeKeyLabelSetContext(p *EdgeTypeKeyLabelSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypeKeyLabelSet
}

func (*EdgeTypeKeyLabelSetContext) IsEdgeTypeKeyLabelSetContext() {}

func NewEdgeTypeKeyLabelSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeTypeKeyLabelSetContext {
	var p = new(EdgeTypeKeyLabelSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeTypeKeyLabelSet

	return p
}

func (s *EdgeTypeKeyLabelSetContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeTypeKeyLabelSetContext) IMPLIES() antlr.TerminalNode {
	return s.GetToken(GQLParserIMPLIES, 0)
}

func (s *EdgeTypeKeyLabelSetContext) LabelSetPhrase() ILabelSetPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelSetPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelSetPhraseContext)
}

func (s *EdgeTypeKeyLabelSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeTypeKeyLabelSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeTypeKeyLabelSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeTypeKeyLabelSet(s)
	}
}

func (s *EdgeTypeKeyLabelSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeTypeKeyLabelSet(s)
	}
}

func (p *GQLParser) EdgeTypeKeyLabelSet() (localctx IEdgeTypeKeyLabelSetContext) {
	localctx = NewEdgeTypeKeyLabelSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, GQLParserRULE_edgeTypeKeyLabelSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserIS || _la == GQLParserLABEL || _la == GQLParserLABELS || _la == GQLParserCOLON {
		{
			p.SetState(2966)
			p.LabelSetPhrase()
		}

	}
	{
		p.SetState(2969)
		p.Match(GQLParserIMPLIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeTypeLabelSetContext is an interface to support dynamic dispatch.
type IEdgeTypeLabelSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LabelSetPhrase() ILabelSetPhraseContext

	// IsEdgeTypeLabelSetContext differentiates from other interfaces.
	IsEdgeTypeLabelSetContext()
}

type EdgeTypeLabelSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeTypeLabelSetContext() *EdgeTypeLabelSetContext {
	var p = new(EdgeTypeLabelSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypeLabelSet
	return p
}

func InitEmptyEdgeTypeLabelSetContext(p *EdgeTypeLabelSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypeLabelSet
}

func (*EdgeTypeLabelSetContext) IsEdgeTypeLabelSetContext() {}

func NewEdgeTypeLabelSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeTypeLabelSetContext {
	var p = new(EdgeTypeLabelSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeTypeLabelSet

	return p
}

func (s *EdgeTypeLabelSetContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeTypeLabelSetContext) LabelSetPhrase() ILabelSetPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelSetPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelSetPhraseContext)
}

func (s *EdgeTypeLabelSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeTypeLabelSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeTypeLabelSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeTypeLabelSet(s)
	}
}

func (s *EdgeTypeLabelSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeTypeLabelSet(s)
	}
}

func (p *GQLParser) EdgeTypeLabelSet() (localctx IEdgeTypeLabelSetContext) {
	localctx = NewEdgeTypeLabelSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, GQLParserRULE_edgeTypeLabelSet)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2971)
		p.LabelSetPhrase()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeTypePropertyTypesContext is an interface to support dynamic dispatch.
type IEdgeTypePropertyTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyTypesSpecification() IPropertyTypesSpecificationContext

	// IsEdgeTypePropertyTypesContext differentiates from other interfaces.
	IsEdgeTypePropertyTypesContext()
}

type EdgeTypePropertyTypesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeTypePropertyTypesContext() *EdgeTypePropertyTypesContext {
	var p = new(EdgeTypePropertyTypesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePropertyTypes
	return p
}

func InitEmptyEdgeTypePropertyTypesContext(p *EdgeTypePropertyTypesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePropertyTypes
}

func (*EdgeTypePropertyTypesContext) IsEdgeTypePropertyTypesContext() {}

func NewEdgeTypePropertyTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeTypePropertyTypesContext {
	var p = new(EdgeTypePropertyTypesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeTypePropertyTypes

	return p
}

func (s *EdgeTypePropertyTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeTypePropertyTypesContext) PropertyTypesSpecification() IPropertyTypesSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyTypesSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyTypesSpecificationContext)
}

func (s *EdgeTypePropertyTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeTypePropertyTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeTypePropertyTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeTypePropertyTypes(s)
	}
}

func (s *EdgeTypePropertyTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeTypePropertyTypes(s)
	}
}

func (p *GQLParser) EdgeTypePropertyTypes() (localctx IEdgeTypePropertyTypesContext) {
	localctx = NewEdgeTypePropertyTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, GQLParserRULE_edgeTypePropertyTypes)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2973)
		p.PropertyTypesSpecification()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeTypePatternDirectedContext is an interface to support dynamic dispatch.
type IEdgeTypePatternDirectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EdgeTypePatternPointingRight() IEdgeTypePatternPointingRightContext
	EdgeTypePatternPointingLeft() IEdgeTypePatternPointingLeftContext

	// IsEdgeTypePatternDirectedContext differentiates from other interfaces.
	IsEdgeTypePatternDirectedContext()
}

type EdgeTypePatternDirectedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeTypePatternDirectedContext() *EdgeTypePatternDirectedContext {
	var p = new(EdgeTypePatternDirectedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePatternDirected
	return p
}

func InitEmptyEdgeTypePatternDirectedContext(p *EdgeTypePatternDirectedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePatternDirected
}

func (*EdgeTypePatternDirectedContext) IsEdgeTypePatternDirectedContext() {}

func NewEdgeTypePatternDirectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeTypePatternDirectedContext {
	var p = new(EdgeTypePatternDirectedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeTypePatternDirected

	return p
}

func (s *EdgeTypePatternDirectedContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeTypePatternDirectedContext) EdgeTypePatternPointingRight() IEdgeTypePatternPointingRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypePatternPointingRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypePatternPointingRightContext)
}

func (s *EdgeTypePatternDirectedContext) EdgeTypePatternPointingLeft() IEdgeTypePatternPointingLeftContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypePatternPointingLeftContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypePatternPointingLeftContext)
}

func (s *EdgeTypePatternDirectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeTypePatternDirectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeTypePatternDirectedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeTypePatternDirected(s)
	}
}

func (s *EdgeTypePatternDirectedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeTypePatternDirected(s)
	}
}

func (p *GQLParser) EdgeTypePatternDirected() (localctx IEdgeTypePatternDirectedContext) {
	localctx = NewEdgeTypePatternDirectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, GQLParserRULE_edgeTypePatternDirected)
	p.SetState(2977)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2975)
			p.EdgeTypePatternPointingRight()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2976)
			p.EdgeTypePatternPointingLeft()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeTypePatternPointingRightContext is an interface to support dynamic dispatch.
type IEdgeTypePatternPointingRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SourceNodeTypeReference() ISourceNodeTypeReferenceContext
	ArcTypePointingRight() IArcTypePointingRightContext
	DestinationNodeTypeReference() IDestinationNodeTypeReferenceContext

	// IsEdgeTypePatternPointingRightContext differentiates from other interfaces.
	IsEdgeTypePatternPointingRightContext()
}

type EdgeTypePatternPointingRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeTypePatternPointingRightContext() *EdgeTypePatternPointingRightContext {
	var p = new(EdgeTypePatternPointingRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePatternPointingRight
	return p
}

func InitEmptyEdgeTypePatternPointingRightContext(p *EdgeTypePatternPointingRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePatternPointingRight
}

func (*EdgeTypePatternPointingRightContext) IsEdgeTypePatternPointingRightContext() {}

func NewEdgeTypePatternPointingRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeTypePatternPointingRightContext {
	var p = new(EdgeTypePatternPointingRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeTypePatternPointingRight

	return p
}

func (s *EdgeTypePatternPointingRightContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeTypePatternPointingRightContext) SourceNodeTypeReference() ISourceNodeTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNodeTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNodeTypeReferenceContext)
}

func (s *EdgeTypePatternPointingRightContext) ArcTypePointingRight() IArcTypePointingRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArcTypePointingRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArcTypePointingRightContext)
}

func (s *EdgeTypePatternPointingRightContext) DestinationNodeTypeReference() IDestinationNodeTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestinationNodeTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestinationNodeTypeReferenceContext)
}

func (s *EdgeTypePatternPointingRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeTypePatternPointingRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeTypePatternPointingRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeTypePatternPointingRight(s)
	}
}

func (s *EdgeTypePatternPointingRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeTypePatternPointingRight(s)
	}
}

func (p *GQLParser) EdgeTypePatternPointingRight() (localctx IEdgeTypePatternPointingRightContext) {
	localctx = NewEdgeTypePatternPointingRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, GQLParserRULE_edgeTypePatternPointingRight)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2979)
		p.SourceNodeTypeReference()
	}
	{
		p.SetState(2980)
		p.ArcTypePointingRight()
	}
	{
		p.SetState(2981)
		p.DestinationNodeTypeReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeTypePatternPointingLeftContext is an interface to support dynamic dispatch.
type IEdgeTypePatternPointingLeftContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DestinationNodeTypeReference() IDestinationNodeTypeReferenceContext
	ArcTypePointingLeft() IArcTypePointingLeftContext
	SourceNodeTypeReference() ISourceNodeTypeReferenceContext

	// IsEdgeTypePatternPointingLeftContext differentiates from other interfaces.
	IsEdgeTypePatternPointingLeftContext()
}

type EdgeTypePatternPointingLeftContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeTypePatternPointingLeftContext() *EdgeTypePatternPointingLeftContext {
	var p = new(EdgeTypePatternPointingLeftContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePatternPointingLeft
	return p
}

func InitEmptyEdgeTypePatternPointingLeftContext(p *EdgeTypePatternPointingLeftContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePatternPointingLeft
}

func (*EdgeTypePatternPointingLeftContext) IsEdgeTypePatternPointingLeftContext() {}

func NewEdgeTypePatternPointingLeftContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeTypePatternPointingLeftContext {
	var p = new(EdgeTypePatternPointingLeftContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeTypePatternPointingLeft

	return p
}

func (s *EdgeTypePatternPointingLeftContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeTypePatternPointingLeftContext) DestinationNodeTypeReference() IDestinationNodeTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestinationNodeTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestinationNodeTypeReferenceContext)
}

func (s *EdgeTypePatternPointingLeftContext) ArcTypePointingLeft() IArcTypePointingLeftContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArcTypePointingLeftContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArcTypePointingLeftContext)
}

func (s *EdgeTypePatternPointingLeftContext) SourceNodeTypeReference() ISourceNodeTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNodeTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNodeTypeReferenceContext)
}

func (s *EdgeTypePatternPointingLeftContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeTypePatternPointingLeftContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeTypePatternPointingLeftContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeTypePatternPointingLeft(s)
	}
}

func (s *EdgeTypePatternPointingLeftContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeTypePatternPointingLeft(s)
	}
}

func (p *GQLParser) EdgeTypePatternPointingLeft() (localctx IEdgeTypePatternPointingLeftContext) {
	localctx = NewEdgeTypePatternPointingLeftContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, GQLParserRULE_edgeTypePatternPointingLeft)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2983)
		p.DestinationNodeTypeReference()
	}
	{
		p.SetState(2984)
		p.ArcTypePointingLeft()
	}
	{
		p.SetState(2985)
		p.SourceNodeTypeReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeTypePatternUndirectedContext is an interface to support dynamic dispatch.
type IEdgeTypePatternUndirectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SourceNodeTypeReference() ISourceNodeTypeReferenceContext
	ArcTypeUndirected() IArcTypeUndirectedContext
	DestinationNodeTypeReference() IDestinationNodeTypeReferenceContext

	// IsEdgeTypePatternUndirectedContext differentiates from other interfaces.
	IsEdgeTypePatternUndirectedContext()
}

type EdgeTypePatternUndirectedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeTypePatternUndirectedContext() *EdgeTypePatternUndirectedContext {
	var p = new(EdgeTypePatternUndirectedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePatternUndirected
	return p
}

func InitEmptyEdgeTypePatternUndirectedContext(p *EdgeTypePatternUndirectedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypePatternUndirected
}

func (*EdgeTypePatternUndirectedContext) IsEdgeTypePatternUndirectedContext() {}

func NewEdgeTypePatternUndirectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeTypePatternUndirectedContext {
	var p = new(EdgeTypePatternUndirectedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeTypePatternUndirected

	return p
}

func (s *EdgeTypePatternUndirectedContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeTypePatternUndirectedContext) SourceNodeTypeReference() ISourceNodeTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNodeTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNodeTypeReferenceContext)
}

func (s *EdgeTypePatternUndirectedContext) ArcTypeUndirected() IArcTypeUndirectedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArcTypeUndirectedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArcTypeUndirectedContext)
}

func (s *EdgeTypePatternUndirectedContext) DestinationNodeTypeReference() IDestinationNodeTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestinationNodeTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestinationNodeTypeReferenceContext)
}

func (s *EdgeTypePatternUndirectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeTypePatternUndirectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeTypePatternUndirectedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeTypePatternUndirected(s)
	}
}

func (s *EdgeTypePatternUndirectedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeTypePatternUndirected(s)
	}
}

func (p *GQLParser) EdgeTypePatternUndirected() (localctx IEdgeTypePatternUndirectedContext) {
	localctx = NewEdgeTypePatternUndirectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, GQLParserRULE_edgeTypePatternUndirected)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2987)
		p.SourceNodeTypeReference()
	}
	{
		p.SetState(2988)
		p.ArcTypeUndirected()
	}
	{
		p.SetState(2989)
		p.DestinationNodeTypeReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArcTypePointingRightContext is an interface to support dynamic dispatch.
type IArcTypePointingRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleArcTypePointingRight() ISimpleArcTypePointingRightContext
	ArcWithCardinalityPointingRight() IArcWithCardinalityPointingRightContext

	// IsArcTypePointingRightContext differentiates from other interfaces.
	IsArcTypePointingRightContext()
}

type ArcTypePointingRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArcTypePointingRightContext() *ArcTypePointingRightContext {
	var p = new(ArcTypePointingRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_arcTypePointingRight
	return p
}

func InitEmptyArcTypePointingRightContext(p *ArcTypePointingRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_arcTypePointingRight
}

func (*ArcTypePointingRightContext) IsArcTypePointingRightContext() {}

func NewArcTypePointingRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArcTypePointingRightContext {
	var p = new(ArcTypePointingRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_arcTypePointingRight

	return p
}

func (s *ArcTypePointingRightContext) GetParser() antlr.Parser { return s.parser }

func (s *ArcTypePointingRightContext) SimpleArcTypePointingRight() ISimpleArcTypePointingRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleArcTypePointingRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleArcTypePointingRightContext)
}

func (s *ArcTypePointingRightContext) ArcWithCardinalityPointingRight() IArcWithCardinalityPointingRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArcWithCardinalityPointingRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArcWithCardinalityPointingRightContext)
}

func (s *ArcTypePointingRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArcTypePointingRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArcTypePointingRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterArcTypePointingRight(s)
	}
}

func (s *ArcTypePointingRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitArcTypePointingRight(s)
	}
}

func (p *GQLParser) ArcTypePointingRight() (localctx IArcTypePointingRightContext) {
	localctx = NewArcTypePointingRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, GQLParserRULE_arcTypePointingRight)
	p.SetState(2993)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserMINUS_LEFT_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2991)
			p.SimpleArcTypePointingRight()
		}

	case GQLParserMINUS_SIGN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2992)
			p.ArcWithCardinalityPointingRight()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleArcTypePointingRightContext is an interface to support dynamic dispatch.
type ISimpleArcTypePointingRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS_LEFT_BRACKET() antlr.TerminalNode
	EdgeTypeFiller() IEdgeTypeFillerContext
	BRACKET_RIGHT_ARROW() antlr.TerminalNode

	// IsSimpleArcTypePointingRightContext differentiates from other interfaces.
	IsSimpleArcTypePointingRightContext()
}

type SimpleArcTypePointingRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleArcTypePointingRightContext() *SimpleArcTypePointingRightContext {
	var p = new(SimpleArcTypePointingRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleArcTypePointingRight
	return p
}

func InitEmptySimpleArcTypePointingRightContext(p *SimpleArcTypePointingRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleArcTypePointingRight
}

func (*SimpleArcTypePointingRightContext) IsSimpleArcTypePointingRightContext() {}

func NewSimpleArcTypePointingRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleArcTypePointingRightContext {
	var p = new(SimpleArcTypePointingRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simpleArcTypePointingRight

	return p
}

func (s *SimpleArcTypePointingRightContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleArcTypePointingRightContext) MINUS_LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserMINUS_LEFT_BRACKET, 0)
}

func (s *SimpleArcTypePointingRightContext) EdgeTypeFiller() IEdgeTypeFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypeFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypeFillerContext)
}

func (s *SimpleArcTypePointingRightContext) BRACKET_RIGHT_ARROW() antlr.TerminalNode {
	return s.GetToken(GQLParserBRACKET_RIGHT_ARROW, 0)
}

func (s *SimpleArcTypePointingRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleArcTypePointingRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleArcTypePointingRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimpleArcTypePointingRight(s)
	}
}

func (s *SimpleArcTypePointingRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimpleArcTypePointingRight(s)
	}
}

func (p *GQLParser) SimpleArcTypePointingRight() (localctx ISimpleArcTypePointingRightContext) {
	localctx = NewSimpleArcTypePointingRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, GQLParserRULE_simpleArcTypePointingRight)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2995)
		p.Match(GQLParserMINUS_LEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2996)
		p.EdgeTypeFiller()
	}
	{
		p.SetState(2997)
		p.Match(GQLParserBRACKET_RIGHT_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArcWithCardinalityPointingRightContext is an interface to support dynamic dispatch.
type IArcWithCardinalityPointingRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS_SIGN() antlr.TerminalNode
	AllCardinality() []ICardinalityContext
	Cardinality(i int) ICardinalityContext
	MINUS_LEFT_BRACKET() antlr.TerminalNode
	EdgeTypeFiller() IEdgeTypeFillerContext
	RIGHT_BRACKET_MINUS() antlr.TerminalNode
	RIGHT_ARROW() antlr.TerminalNode

	// IsArcWithCardinalityPointingRightContext differentiates from other interfaces.
	IsArcWithCardinalityPointingRightContext()
}

type ArcWithCardinalityPointingRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArcWithCardinalityPointingRightContext() *ArcWithCardinalityPointingRightContext {
	var p = new(ArcWithCardinalityPointingRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_arcWithCardinalityPointingRight
	return p
}

func InitEmptyArcWithCardinalityPointingRightContext(p *ArcWithCardinalityPointingRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_arcWithCardinalityPointingRight
}

func (*ArcWithCardinalityPointingRightContext) IsArcWithCardinalityPointingRightContext() {}

func NewArcWithCardinalityPointingRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArcWithCardinalityPointingRightContext {
	var p = new(ArcWithCardinalityPointingRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_arcWithCardinalityPointingRight

	return p
}

func (s *ArcWithCardinalityPointingRightContext) GetParser() antlr.Parser { return s.parser }

func (s *ArcWithCardinalityPointingRightContext) MINUS_SIGN() antlr.TerminalNode {
	return s.GetToken(GQLParserMINUS_SIGN, 0)
}

func (s *ArcWithCardinalityPointingRightContext) AllCardinality() []ICardinalityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICardinalityContext); ok {
			len++
		}
	}

	tst := make([]ICardinalityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICardinalityContext); ok {
			tst[i] = t.(ICardinalityContext)
			i++
		}
	}

	return tst
}

func (s *ArcWithCardinalityPointingRightContext) Cardinality(i int) ICardinalityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICardinalityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICardinalityContext)
}

func (s *ArcWithCardinalityPointingRightContext) MINUS_LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserMINUS_LEFT_BRACKET, 0)
}

func (s *ArcWithCardinalityPointingRightContext) EdgeTypeFiller() IEdgeTypeFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypeFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypeFillerContext)
}

func (s *ArcWithCardinalityPointingRightContext) RIGHT_BRACKET_MINUS() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET_MINUS, 0)
}

func (s *ArcWithCardinalityPointingRightContext) RIGHT_ARROW() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_ARROW, 0)
}

func (s *ArcWithCardinalityPointingRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArcWithCardinalityPointingRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArcWithCardinalityPointingRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterArcWithCardinalityPointingRight(s)
	}
}

func (s *ArcWithCardinalityPointingRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitArcWithCardinalityPointingRight(s)
	}
}

func (p *GQLParser) ArcWithCardinalityPointingRight() (localctx IArcWithCardinalityPointingRightContext) {
	localctx = NewArcWithCardinalityPointingRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, GQLParserRULE_arcWithCardinalityPointingRight)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2999)
		p.Match(GQLParserMINUS_SIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3000)
		p.Cardinality()
	}
	{
		p.SetState(3001)
		p.Match(GQLParserMINUS_LEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3002)
		p.EdgeTypeFiller()
	}
	{
		p.SetState(3003)
		p.Match(GQLParserRIGHT_BRACKET_MINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3004)
		p.Cardinality()
	}
	{
		p.SetState(3005)
		p.Match(GQLParserRIGHT_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArcTypePointingLeftContext is an interface to support dynamic dispatch.
type IArcTypePointingLeftContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleArcTypePointingLeft() ISimpleArcTypePointingLeftContext
	ArcWithCardinalityPointingLeft() IArcWithCardinalityPointingLeftContext

	// IsArcTypePointingLeftContext differentiates from other interfaces.
	IsArcTypePointingLeftContext()
}

type ArcTypePointingLeftContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArcTypePointingLeftContext() *ArcTypePointingLeftContext {
	var p = new(ArcTypePointingLeftContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_arcTypePointingLeft
	return p
}

func InitEmptyArcTypePointingLeftContext(p *ArcTypePointingLeftContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_arcTypePointingLeft
}

func (*ArcTypePointingLeftContext) IsArcTypePointingLeftContext() {}

func NewArcTypePointingLeftContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArcTypePointingLeftContext {
	var p = new(ArcTypePointingLeftContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_arcTypePointingLeft

	return p
}

func (s *ArcTypePointingLeftContext) GetParser() antlr.Parser { return s.parser }

func (s *ArcTypePointingLeftContext) SimpleArcTypePointingLeft() ISimpleArcTypePointingLeftContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleArcTypePointingLeftContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleArcTypePointingLeftContext)
}

func (s *ArcTypePointingLeftContext) ArcWithCardinalityPointingLeft() IArcWithCardinalityPointingLeftContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArcWithCardinalityPointingLeftContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArcWithCardinalityPointingLeftContext)
}

func (s *ArcTypePointingLeftContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArcTypePointingLeftContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArcTypePointingLeftContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterArcTypePointingLeft(s)
	}
}

func (s *ArcTypePointingLeftContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitArcTypePointingLeft(s)
	}
}

func (p *GQLParser) ArcTypePointingLeft() (localctx IArcTypePointingLeftContext) {
	localctx = NewArcTypePointingLeftContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, GQLParserRULE_arcTypePointingLeft)
	p.SetState(3009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserLEFT_ARROW_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3007)
			p.SimpleArcTypePointingLeft()
		}

	case GQLParserLEFT_ARROW:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3008)
			p.ArcWithCardinalityPointingLeft()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleArcTypePointingLeftContext is an interface to support dynamic dispatch.
type ISimpleArcTypePointingLeftContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_ARROW_BRACKET() antlr.TerminalNode
	EdgeTypeFiller() IEdgeTypeFillerContext
	RIGHT_BRACKET_MINUS() antlr.TerminalNode

	// IsSimpleArcTypePointingLeftContext differentiates from other interfaces.
	IsSimpleArcTypePointingLeftContext()
}

type SimpleArcTypePointingLeftContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleArcTypePointingLeftContext() *SimpleArcTypePointingLeftContext {
	var p = new(SimpleArcTypePointingLeftContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleArcTypePointingLeft
	return p
}

func InitEmptySimpleArcTypePointingLeftContext(p *SimpleArcTypePointingLeftContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleArcTypePointingLeft
}

func (*SimpleArcTypePointingLeftContext) IsSimpleArcTypePointingLeftContext() {}

func NewSimpleArcTypePointingLeftContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleArcTypePointingLeftContext {
	var p = new(SimpleArcTypePointingLeftContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simpleArcTypePointingLeft

	return p
}

func (s *SimpleArcTypePointingLeftContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleArcTypePointingLeftContext) LEFT_ARROW_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_ARROW_BRACKET, 0)
}

func (s *SimpleArcTypePointingLeftContext) EdgeTypeFiller() IEdgeTypeFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypeFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypeFillerContext)
}

func (s *SimpleArcTypePointingLeftContext) RIGHT_BRACKET_MINUS() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET_MINUS, 0)
}

func (s *SimpleArcTypePointingLeftContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleArcTypePointingLeftContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleArcTypePointingLeftContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimpleArcTypePointingLeft(s)
	}
}

func (s *SimpleArcTypePointingLeftContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimpleArcTypePointingLeft(s)
	}
}

func (p *GQLParser) SimpleArcTypePointingLeft() (localctx ISimpleArcTypePointingLeftContext) {
	localctx = NewSimpleArcTypePointingLeftContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, GQLParserRULE_simpleArcTypePointingLeft)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3011)
		p.Match(GQLParserLEFT_ARROW_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3012)
		p.EdgeTypeFiller()
	}
	{
		p.SetState(3013)
		p.Match(GQLParserRIGHT_BRACKET_MINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArcWithCardinalityPointingLeftContext is an interface to support dynamic dispatch.
type IArcWithCardinalityPointingLeftContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_ARROW() antlr.TerminalNode
	AllCardinality() []ICardinalityContext
	Cardinality(i int) ICardinalityContext
	MINUS_LEFT_BRACKET() antlr.TerminalNode
	EdgeTypeFiller() IEdgeTypeFillerContext
	RIGHT_BRACKET_MINUS() antlr.TerminalNode
	MINUS_SIGN() antlr.TerminalNode

	// IsArcWithCardinalityPointingLeftContext differentiates from other interfaces.
	IsArcWithCardinalityPointingLeftContext()
}

type ArcWithCardinalityPointingLeftContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArcWithCardinalityPointingLeftContext() *ArcWithCardinalityPointingLeftContext {
	var p = new(ArcWithCardinalityPointingLeftContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_arcWithCardinalityPointingLeft
	return p
}

func InitEmptyArcWithCardinalityPointingLeftContext(p *ArcWithCardinalityPointingLeftContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_arcWithCardinalityPointingLeft
}

func (*ArcWithCardinalityPointingLeftContext) IsArcWithCardinalityPointingLeftContext() {}

func NewArcWithCardinalityPointingLeftContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArcWithCardinalityPointingLeftContext {
	var p = new(ArcWithCardinalityPointingLeftContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_arcWithCardinalityPointingLeft

	return p
}

func (s *ArcWithCardinalityPointingLeftContext) GetParser() antlr.Parser { return s.parser }

func (s *ArcWithCardinalityPointingLeftContext) LEFT_ARROW() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_ARROW, 0)
}

func (s *ArcWithCardinalityPointingLeftContext) AllCardinality() []ICardinalityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICardinalityContext); ok {
			len++
		}
	}

	tst := make([]ICardinalityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICardinalityContext); ok {
			tst[i] = t.(ICardinalityContext)
			i++
		}
	}

	return tst
}

func (s *ArcWithCardinalityPointingLeftContext) Cardinality(i int) ICardinalityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICardinalityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICardinalityContext)
}

func (s *ArcWithCardinalityPointingLeftContext) MINUS_LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserMINUS_LEFT_BRACKET, 0)
}

func (s *ArcWithCardinalityPointingLeftContext) EdgeTypeFiller() IEdgeTypeFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypeFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypeFillerContext)
}

func (s *ArcWithCardinalityPointingLeftContext) RIGHT_BRACKET_MINUS() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET_MINUS, 0)
}

func (s *ArcWithCardinalityPointingLeftContext) MINUS_SIGN() antlr.TerminalNode {
	return s.GetToken(GQLParserMINUS_SIGN, 0)
}

func (s *ArcWithCardinalityPointingLeftContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArcWithCardinalityPointingLeftContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArcWithCardinalityPointingLeftContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterArcWithCardinalityPointingLeft(s)
	}
}

func (s *ArcWithCardinalityPointingLeftContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitArcWithCardinalityPointingLeft(s)
	}
}

func (p *GQLParser) ArcWithCardinalityPointingLeft() (localctx IArcWithCardinalityPointingLeftContext) {
	localctx = NewArcWithCardinalityPointingLeftContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, GQLParserRULE_arcWithCardinalityPointingLeft)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3015)
		p.Match(GQLParserLEFT_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3016)
		p.Cardinality()
	}
	{
		p.SetState(3017)
		p.Match(GQLParserMINUS_LEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3018)
		p.EdgeTypeFiller()
	}
	{
		p.SetState(3019)
		p.Match(GQLParserRIGHT_BRACKET_MINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3020)
		p.Cardinality()
	}
	{
		p.SetState(3021)
		p.Match(GQLParserMINUS_SIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArcTypeUndirectedContext is an interface to support dynamic dispatch.
type IArcTypeUndirectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleArcTypeUndirected() ISimpleArcTypeUndirectedContext
	ArcWithCardinalityUndirected() IArcWithCardinalityUndirectedContext

	// IsArcTypeUndirectedContext differentiates from other interfaces.
	IsArcTypeUndirectedContext()
}

type ArcTypeUndirectedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArcTypeUndirectedContext() *ArcTypeUndirectedContext {
	var p = new(ArcTypeUndirectedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_arcTypeUndirected
	return p
}

func InitEmptyArcTypeUndirectedContext(p *ArcTypeUndirectedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_arcTypeUndirected
}

func (*ArcTypeUndirectedContext) IsArcTypeUndirectedContext() {}

func NewArcTypeUndirectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArcTypeUndirectedContext {
	var p = new(ArcTypeUndirectedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_arcTypeUndirected

	return p
}

func (s *ArcTypeUndirectedContext) GetParser() antlr.Parser { return s.parser }

func (s *ArcTypeUndirectedContext) SimpleArcTypeUndirected() ISimpleArcTypeUndirectedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleArcTypeUndirectedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleArcTypeUndirectedContext)
}

func (s *ArcTypeUndirectedContext) ArcWithCardinalityUndirected() IArcWithCardinalityUndirectedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArcWithCardinalityUndirectedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArcWithCardinalityUndirectedContext)
}

func (s *ArcTypeUndirectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArcTypeUndirectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArcTypeUndirectedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterArcTypeUndirected(s)
	}
}

func (s *ArcTypeUndirectedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitArcTypeUndirected(s)
	}
}

func (p *GQLParser) ArcTypeUndirected() (localctx IArcTypeUndirectedContext) {
	localctx = NewArcTypeUndirectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, GQLParserRULE_arcTypeUndirected)
	p.SetState(3025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserTILDE_LEFT_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3023)
			p.SimpleArcTypeUndirected()
		}

	case GQLParserTILDE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3024)
			p.ArcWithCardinalityUndirected()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleArcTypeUndirectedContext is an interface to support dynamic dispatch.
type ISimpleArcTypeUndirectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TILDE_LEFT_BRACKET() antlr.TerminalNode
	EdgeTypeFiller() IEdgeTypeFillerContext
	RIGHT_BRACKET_TILDE() antlr.TerminalNode

	// IsSimpleArcTypeUndirectedContext differentiates from other interfaces.
	IsSimpleArcTypeUndirectedContext()
}

type SimpleArcTypeUndirectedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleArcTypeUndirectedContext() *SimpleArcTypeUndirectedContext {
	var p = new(SimpleArcTypeUndirectedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleArcTypeUndirected
	return p
}

func InitEmptySimpleArcTypeUndirectedContext(p *SimpleArcTypeUndirectedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleArcTypeUndirected
}

func (*SimpleArcTypeUndirectedContext) IsSimpleArcTypeUndirectedContext() {}

func NewSimpleArcTypeUndirectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleArcTypeUndirectedContext {
	var p = new(SimpleArcTypeUndirectedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simpleArcTypeUndirected

	return p
}

func (s *SimpleArcTypeUndirectedContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleArcTypeUndirectedContext) TILDE_LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserTILDE_LEFT_BRACKET, 0)
}

func (s *SimpleArcTypeUndirectedContext) EdgeTypeFiller() IEdgeTypeFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypeFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypeFillerContext)
}

func (s *SimpleArcTypeUndirectedContext) RIGHT_BRACKET_TILDE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET_TILDE, 0)
}

func (s *SimpleArcTypeUndirectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleArcTypeUndirectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleArcTypeUndirectedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimpleArcTypeUndirected(s)
	}
}

func (s *SimpleArcTypeUndirectedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimpleArcTypeUndirected(s)
	}
}

func (p *GQLParser) SimpleArcTypeUndirected() (localctx ISimpleArcTypeUndirectedContext) {
	localctx = NewSimpleArcTypeUndirectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, GQLParserRULE_simpleArcTypeUndirected)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3027)
		p.Match(GQLParserTILDE_LEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3028)
		p.EdgeTypeFiller()
	}
	{
		p.SetState(3029)
		p.Match(GQLParserRIGHT_BRACKET_TILDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArcWithCardinalityUndirectedContext is an interface to support dynamic dispatch.
type IArcWithCardinalityUndirectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTILDE() []antlr.TerminalNode
	TILDE(i int) antlr.TerminalNode
	AllCardinality() []ICardinalityContext
	Cardinality(i int) ICardinalityContext
	TILDE_LEFT_BRACKET() antlr.TerminalNode
	EdgeTypeFiller() IEdgeTypeFillerContext
	RIGHT_BRACKET_TILDE() antlr.TerminalNode

	// IsArcWithCardinalityUndirectedContext differentiates from other interfaces.
	IsArcWithCardinalityUndirectedContext()
}

type ArcWithCardinalityUndirectedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArcWithCardinalityUndirectedContext() *ArcWithCardinalityUndirectedContext {
	var p = new(ArcWithCardinalityUndirectedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_arcWithCardinalityUndirected
	return p
}

func InitEmptyArcWithCardinalityUndirectedContext(p *ArcWithCardinalityUndirectedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_arcWithCardinalityUndirected
}

func (*ArcWithCardinalityUndirectedContext) IsArcWithCardinalityUndirectedContext() {}

func NewArcWithCardinalityUndirectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArcWithCardinalityUndirectedContext {
	var p = new(ArcWithCardinalityUndirectedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_arcWithCardinalityUndirected

	return p
}

func (s *ArcWithCardinalityUndirectedContext) GetParser() antlr.Parser { return s.parser }

func (s *ArcWithCardinalityUndirectedContext) AllTILDE() []antlr.TerminalNode {
	return s.GetTokens(GQLParserTILDE)
}

func (s *ArcWithCardinalityUndirectedContext) TILDE(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserTILDE, i)
}

func (s *ArcWithCardinalityUndirectedContext) AllCardinality() []ICardinalityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICardinalityContext); ok {
			len++
		}
	}

	tst := make([]ICardinalityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICardinalityContext); ok {
			tst[i] = t.(ICardinalityContext)
			i++
		}
	}

	return tst
}

func (s *ArcWithCardinalityUndirectedContext) Cardinality(i int) ICardinalityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICardinalityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICardinalityContext)
}

func (s *ArcWithCardinalityUndirectedContext) TILDE_LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserTILDE_LEFT_BRACKET, 0)
}

func (s *ArcWithCardinalityUndirectedContext) EdgeTypeFiller() IEdgeTypeFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypeFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypeFillerContext)
}

func (s *ArcWithCardinalityUndirectedContext) RIGHT_BRACKET_TILDE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET_TILDE, 0)
}

func (s *ArcWithCardinalityUndirectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArcWithCardinalityUndirectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArcWithCardinalityUndirectedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterArcWithCardinalityUndirected(s)
	}
}

func (s *ArcWithCardinalityUndirectedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitArcWithCardinalityUndirected(s)
	}
}

func (p *GQLParser) ArcWithCardinalityUndirected() (localctx IArcWithCardinalityUndirectedContext) {
	localctx = NewArcWithCardinalityUndirectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, GQLParserRULE_arcWithCardinalityUndirected)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3031)
		p.Match(GQLParserTILDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3032)
		p.Cardinality()
	}
	{
		p.SetState(3033)
		p.Match(GQLParserTILDE_LEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3034)
		p.EdgeTypeFiller()
	}
	{
		p.SetState(3035)
		p.Match(GQLParserRIGHT_BRACKET_TILDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3036)
		p.Cardinality()
	}
	{
		p.SetState(3037)
		p.Match(GQLParserTILDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICardinalityContext is an interface to support dynamic dispatch.
type ICardinalityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	CardinalityFiller() ICardinalityFillerContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsCardinalityContext differentiates from other interfaces.
	IsCardinalityContext()
}

type CardinalityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCardinalityContext() *CardinalityContext {
	var p = new(CardinalityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_cardinality
	return p
}

func InitEmptyCardinalityContext(p *CardinalityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_cardinality
}

func (*CardinalityContext) IsCardinalityContext() {}

func NewCardinalityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CardinalityContext {
	var p = new(CardinalityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_cardinality

	return p
}

func (s *CardinalityContext) GetParser() antlr.Parser { return s.parser }

func (s *CardinalityContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *CardinalityContext) CardinalityFiller() ICardinalityFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICardinalityFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICardinalityFillerContext)
}

func (s *CardinalityContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *CardinalityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CardinalityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CardinalityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCardinality(s)
	}
}

func (s *CardinalityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCardinality(s)
	}
}

func (p *GQLParser) Cardinality() (localctx ICardinalityContext) {
	localctx = NewCardinalityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, GQLParserRULE_cardinality)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3039)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3040)
		p.CardinalityFiller()
	}
	{
		p.SetState(3041)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICardinalityFillerContext is an interface to support dynamic dispatch.
type ICardinalityFillerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CardinalityLowerBound() ICardinalityLowerBoundContext
	COMMA() antlr.TerminalNode
	CardinalityUpperBound() ICardinalityUpperBoundContext

	// IsCardinalityFillerContext differentiates from other interfaces.
	IsCardinalityFillerContext()
}

type CardinalityFillerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCardinalityFillerContext() *CardinalityFillerContext {
	var p = new(CardinalityFillerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_cardinalityFiller
	return p
}

func InitEmptyCardinalityFillerContext(p *CardinalityFillerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_cardinalityFiller
}

func (*CardinalityFillerContext) IsCardinalityFillerContext() {}

func NewCardinalityFillerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CardinalityFillerContext {
	var p = new(CardinalityFillerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_cardinalityFiller

	return p
}

func (s *CardinalityFillerContext) GetParser() antlr.Parser { return s.parser }

func (s *CardinalityFillerContext) CardinalityLowerBound() ICardinalityLowerBoundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICardinalityLowerBoundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICardinalityLowerBoundContext)
}

func (s *CardinalityFillerContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *CardinalityFillerContext) CardinalityUpperBound() ICardinalityUpperBoundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICardinalityUpperBoundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICardinalityUpperBoundContext)
}

func (s *CardinalityFillerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CardinalityFillerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CardinalityFillerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCardinalityFiller(s)
	}
}

func (s *CardinalityFillerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCardinalityFiller(s)
	}
}

func (p *GQLParser) CardinalityFiller() (localctx ICardinalityFillerContext) {
	localctx = NewCardinalityFillerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, GQLParserRULE_cardinalityFiller)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3043)
		p.CardinalityLowerBound()
	}
	{
		p.SetState(3044)
		p.Match(GQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3045)
		p.CardinalityUpperBound()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICardinalityLowerBoundContext is an interface to support dynamic dispatch.
type ICardinalityLowerBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNSIGNED_DECIMAL_INTEGER() antlr.TerminalNode

	// IsCardinalityLowerBoundContext differentiates from other interfaces.
	IsCardinalityLowerBoundContext()
}

type CardinalityLowerBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCardinalityLowerBoundContext() *CardinalityLowerBoundContext {
	var p = new(CardinalityLowerBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_cardinalityLowerBound
	return p
}

func InitEmptyCardinalityLowerBoundContext(p *CardinalityLowerBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_cardinalityLowerBound
}

func (*CardinalityLowerBoundContext) IsCardinalityLowerBoundContext() {}

func NewCardinalityLowerBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CardinalityLowerBoundContext {
	var p = new(CardinalityLowerBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_cardinalityLowerBound

	return p
}

func (s *CardinalityLowerBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *CardinalityLowerBoundContext) UNSIGNED_DECIMAL_INTEGER() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED_DECIMAL_INTEGER, 0)
}

func (s *CardinalityLowerBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CardinalityLowerBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CardinalityLowerBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCardinalityLowerBound(s)
	}
}

func (s *CardinalityLowerBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCardinalityLowerBound(s)
	}
}

func (p *GQLParser) CardinalityLowerBound() (localctx ICardinalityLowerBoundContext) {
	localctx = NewCardinalityLowerBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, GQLParserRULE_cardinalityLowerBound)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3047)
		p.Match(GQLParserUNSIGNED_DECIMAL_INTEGER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICardinalityUpperBoundContext is an interface to support dynamic dispatch.
type ICardinalityUpperBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNSIGNED_DECIMAL_INTEGER() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode

	// IsCardinalityUpperBoundContext differentiates from other interfaces.
	IsCardinalityUpperBoundContext()
}

type CardinalityUpperBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCardinalityUpperBoundContext() *CardinalityUpperBoundContext {
	var p = new(CardinalityUpperBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_cardinalityUpperBound
	return p
}

func InitEmptyCardinalityUpperBoundContext(p *CardinalityUpperBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_cardinalityUpperBound
}

func (*CardinalityUpperBoundContext) IsCardinalityUpperBoundContext() {}

func NewCardinalityUpperBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CardinalityUpperBoundContext {
	var p = new(CardinalityUpperBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_cardinalityUpperBound

	return p
}

func (s *CardinalityUpperBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *CardinalityUpperBoundContext) UNSIGNED_DECIMAL_INTEGER() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED_DECIMAL_INTEGER, 0)
}

func (s *CardinalityUpperBoundContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(GQLParserASTERISK, 0)
}

func (s *CardinalityUpperBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CardinalityUpperBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CardinalityUpperBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCardinalityUpperBound(s)
	}
}

func (s *CardinalityUpperBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCardinalityUpperBound(s)
	}
}

func (p *GQLParser) CardinalityUpperBound() (localctx ICardinalityUpperBoundContext) {
	localctx = NewCardinalityUpperBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, GQLParserRULE_cardinalityUpperBound)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3049)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserUNSIGNED_DECIMAL_INTEGER || _la == GQLParserASTERISK) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISourceNodeTypeReferenceContext is an interface to support dynamic dispatch.
type ISourceNodeTypeReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	SourceNodeTypeAlias() ISourceNodeTypeAliasContext
	RIGHT_PAREN() antlr.TerminalNode
	NodeTypeFiller() INodeTypeFillerContext

	// IsSourceNodeTypeReferenceContext differentiates from other interfaces.
	IsSourceNodeTypeReferenceContext()
}

type SourceNodeTypeReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceNodeTypeReferenceContext() *SourceNodeTypeReferenceContext {
	var p = new(SourceNodeTypeReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sourceNodeTypeReference
	return p
}

func InitEmptySourceNodeTypeReferenceContext(p *SourceNodeTypeReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sourceNodeTypeReference
}

func (*SourceNodeTypeReferenceContext) IsSourceNodeTypeReferenceContext() {}

func NewSourceNodeTypeReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceNodeTypeReferenceContext {
	var p = new(SourceNodeTypeReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sourceNodeTypeReference

	return p
}

func (s *SourceNodeTypeReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceNodeTypeReferenceContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *SourceNodeTypeReferenceContext) SourceNodeTypeAlias() ISourceNodeTypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNodeTypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNodeTypeAliasContext)
}

func (s *SourceNodeTypeReferenceContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *SourceNodeTypeReferenceContext) NodeTypeFiller() INodeTypeFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTypeFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTypeFillerContext)
}

func (s *SourceNodeTypeReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceNodeTypeReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceNodeTypeReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSourceNodeTypeReference(s)
	}
}

func (s *SourceNodeTypeReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSourceNodeTypeReference(s)
	}
}

func (p *GQLParser) SourceNodeTypeReference() (localctx ISourceNodeTypeReferenceContext) {
	localctx = NewSourceNodeTypeReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, GQLParserRULE_sourceNodeTypeReference)
	var _la int

	p.SetState(3060)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3051)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3052)
			p.SourceNodeTypeAlias()
		}
		{
			p.SetState(3053)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3055)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserIMPLIES || _la == GQLParserIS || _la == GQLParserLABEL || _la == GQLParserLABELS || _la == GQLParserCOLON || _la == GQLParserLEFT_BRACE {
			{
				p.SetState(3056)
				p.NodeTypeFiller()
			}

		}
		{
			p.SetState(3059)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDestinationNodeTypeReferenceContext is an interface to support dynamic dispatch.
type IDestinationNodeTypeReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	DestinationNodeTypeAlias() IDestinationNodeTypeAliasContext
	RIGHT_PAREN() antlr.TerminalNode
	NodeTypeFiller() INodeTypeFillerContext

	// IsDestinationNodeTypeReferenceContext differentiates from other interfaces.
	IsDestinationNodeTypeReferenceContext()
}

type DestinationNodeTypeReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestinationNodeTypeReferenceContext() *DestinationNodeTypeReferenceContext {
	var p = new(DestinationNodeTypeReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_destinationNodeTypeReference
	return p
}

func InitEmptyDestinationNodeTypeReferenceContext(p *DestinationNodeTypeReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_destinationNodeTypeReference
}

func (*DestinationNodeTypeReferenceContext) IsDestinationNodeTypeReferenceContext() {}

func NewDestinationNodeTypeReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestinationNodeTypeReferenceContext {
	var p = new(DestinationNodeTypeReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_destinationNodeTypeReference

	return p
}

func (s *DestinationNodeTypeReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *DestinationNodeTypeReferenceContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *DestinationNodeTypeReferenceContext) DestinationNodeTypeAlias() IDestinationNodeTypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestinationNodeTypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestinationNodeTypeAliasContext)
}

func (s *DestinationNodeTypeReferenceContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *DestinationNodeTypeReferenceContext) NodeTypeFiller() INodeTypeFillerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTypeFillerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTypeFillerContext)
}

func (s *DestinationNodeTypeReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestinationNodeTypeReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DestinationNodeTypeReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDestinationNodeTypeReference(s)
	}
}

func (s *DestinationNodeTypeReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDestinationNodeTypeReference(s)
	}
}

func (p *GQLParser) DestinationNodeTypeReference() (localctx IDestinationNodeTypeReferenceContext) {
	localctx = NewDestinationNodeTypeReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, GQLParserRULE_destinationNodeTypeReference)
	var _la int

	p.SetState(3071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 284, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3062)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3063)
			p.DestinationNodeTypeAlias()
		}
		{
			p.SetState(3064)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3066)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3068)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserIMPLIES || _la == GQLParserIS || _la == GQLParserLABEL || _la == GQLParserLABELS || _la == GQLParserCOLON || _la == GQLParserLEFT_BRACE {
			{
				p.SetState(3067)
				p.NodeTypeFiller()
			}

		}
		{
			p.SetState(3070)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeKindContext is an interface to support dynamic dispatch.
type IEdgeKindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DIRECTED() antlr.TerminalNode
	UNDIRECTED() antlr.TerminalNode

	// IsEdgeKindContext differentiates from other interfaces.
	IsEdgeKindContext()
}

type EdgeKindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeKindContext() *EdgeKindContext {
	var p = new(EdgeKindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeKind
	return p
}

func InitEmptyEdgeKindContext(p *EdgeKindContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeKind
}

func (*EdgeKindContext) IsEdgeKindContext() {}

func NewEdgeKindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeKindContext {
	var p = new(EdgeKindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeKind

	return p
}

func (s *EdgeKindContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeKindContext) DIRECTED() antlr.TerminalNode {
	return s.GetToken(GQLParserDIRECTED, 0)
}

func (s *EdgeKindContext) UNDIRECTED() antlr.TerminalNode {
	return s.GetToken(GQLParserUNDIRECTED, 0)
}

func (s *EdgeKindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeKindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeKindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeKind(s)
	}
}

func (s *EdgeKindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeKind(s)
	}
}

func (p *GQLParser) EdgeKind() (localctx IEdgeKindContext) {
	localctx = NewEdgeKindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, GQLParserRULE_edgeKind)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3073)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserDIRECTED || _la == GQLParserUNDIRECTED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEndpointPairPhraseContext is an interface to support dynamic dispatch.
type IEndpointPairPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONNECTING() antlr.TerminalNode
	EndpointPair() IEndpointPairContext

	// IsEndpointPairPhraseContext differentiates from other interfaces.
	IsEndpointPairPhraseContext()
}

type EndpointPairPhraseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndpointPairPhraseContext() *EndpointPairPhraseContext {
	var p = new(EndpointPairPhraseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_endpointPairPhrase
	return p
}

func InitEmptyEndpointPairPhraseContext(p *EndpointPairPhraseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_endpointPairPhrase
}

func (*EndpointPairPhraseContext) IsEndpointPairPhraseContext() {}

func NewEndpointPairPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndpointPairPhraseContext {
	var p = new(EndpointPairPhraseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_endpointPairPhrase

	return p
}

func (s *EndpointPairPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *EndpointPairPhraseContext) CONNECTING() antlr.TerminalNode {
	return s.GetToken(GQLParserCONNECTING, 0)
}

func (s *EndpointPairPhraseContext) EndpointPair() IEndpointPairContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndpointPairContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndpointPairContext)
}

func (s *EndpointPairPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndpointPairPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndpointPairPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEndpointPairPhrase(s)
	}
}

func (s *EndpointPairPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEndpointPairPhrase(s)
	}
}

func (p *GQLParser) EndpointPairPhrase() (localctx IEndpointPairPhraseContext) {
	localctx = NewEndpointPairPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, GQLParserRULE_endpointPairPhrase)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3075)
		p.Match(GQLParserCONNECTING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3076)
		p.EndpointPair()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEndpointPairContext is an interface to support dynamic dispatch.
type IEndpointPairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EndpointPairDirected() IEndpointPairDirectedContext
	EndpointPairUndirected() IEndpointPairUndirectedContext

	// IsEndpointPairContext differentiates from other interfaces.
	IsEndpointPairContext()
}

type EndpointPairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndpointPairContext() *EndpointPairContext {
	var p = new(EndpointPairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_endpointPair
	return p
}

func InitEmptyEndpointPairContext(p *EndpointPairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_endpointPair
}

func (*EndpointPairContext) IsEndpointPairContext() {}

func NewEndpointPairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndpointPairContext {
	var p = new(EndpointPairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_endpointPair

	return p
}

func (s *EndpointPairContext) GetParser() antlr.Parser { return s.parser }

func (s *EndpointPairContext) EndpointPairDirected() IEndpointPairDirectedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndpointPairDirectedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndpointPairDirectedContext)
}

func (s *EndpointPairContext) EndpointPairUndirected() IEndpointPairUndirectedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndpointPairUndirectedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndpointPairUndirectedContext)
}

func (s *EndpointPairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndpointPairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndpointPairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEndpointPair(s)
	}
}

func (s *EndpointPairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEndpointPair(s)
	}
}

func (p *GQLParser) EndpointPair() (localctx IEndpointPairContext) {
	localctx = NewEndpointPairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, GQLParserRULE_endpointPair)
	p.SetState(3080)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 285, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3078)
			p.EndpointPairDirected()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3079)
			p.EndpointPairUndirected()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEndpointPairDirectedContext is an interface to support dynamic dispatch.
type IEndpointPairDirectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EndpointPairPointingRight() IEndpointPairPointingRightContext
	EndpointPairPointingLeft() IEndpointPairPointingLeftContext

	// IsEndpointPairDirectedContext differentiates from other interfaces.
	IsEndpointPairDirectedContext()
}

type EndpointPairDirectedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndpointPairDirectedContext() *EndpointPairDirectedContext {
	var p = new(EndpointPairDirectedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_endpointPairDirected
	return p
}

func InitEmptyEndpointPairDirectedContext(p *EndpointPairDirectedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_endpointPairDirected
}

func (*EndpointPairDirectedContext) IsEndpointPairDirectedContext() {}

func NewEndpointPairDirectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndpointPairDirectedContext {
	var p = new(EndpointPairDirectedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_endpointPairDirected

	return p
}

func (s *EndpointPairDirectedContext) GetParser() antlr.Parser { return s.parser }

func (s *EndpointPairDirectedContext) EndpointPairPointingRight() IEndpointPairPointingRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndpointPairPointingRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndpointPairPointingRightContext)
}

func (s *EndpointPairDirectedContext) EndpointPairPointingLeft() IEndpointPairPointingLeftContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndpointPairPointingLeftContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndpointPairPointingLeftContext)
}

func (s *EndpointPairDirectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndpointPairDirectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndpointPairDirectedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEndpointPairDirected(s)
	}
}

func (s *EndpointPairDirectedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEndpointPairDirected(s)
	}
}

func (p *GQLParser) EndpointPairDirected() (localctx IEndpointPairDirectedContext) {
	localctx = NewEndpointPairDirectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, GQLParserRULE_endpointPairDirected)
	p.SetState(3084)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3082)
			p.EndpointPairPointingRight()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3083)
			p.EndpointPairPointingLeft()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEndpointPairPointingRightContext is an interface to support dynamic dispatch.
type IEndpointPairPointingRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	SourceNodeTypeAlias() ISourceNodeTypeAliasContext
	ConnectorPointingRight() IConnectorPointingRightContext
	DestinationNodeTypeAlias() IDestinationNodeTypeAliasContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsEndpointPairPointingRightContext differentiates from other interfaces.
	IsEndpointPairPointingRightContext()
}

type EndpointPairPointingRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndpointPairPointingRightContext() *EndpointPairPointingRightContext {
	var p = new(EndpointPairPointingRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_endpointPairPointingRight
	return p
}

func InitEmptyEndpointPairPointingRightContext(p *EndpointPairPointingRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_endpointPairPointingRight
}

func (*EndpointPairPointingRightContext) IsEndpointPairPointingRightContext() {}

func NewEndpointPairPointingRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndpointPairPointingRightContext {
	var p = new(EndpointPairPointingRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_endpointPairPointingRight

	return p
}

func (s *EndpointPairPointingRightContext) GetParser() antlr.Parser { return s.parser }

func (s *EndpointPairPointingRightContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *EndpointPairPointingRightContext) SourceNodeTypeAlias() ISourceNodeTypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNodeTypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNodeTypeAliasContext)
}

func (s *EndpointPairPointingRightContext) ConnectorPointingRight() IConnectorPointingRightContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConnectorPointingRightContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConnectorPointingRightContext)
}

func (s *EndpointPairPointingRightContext) DestinationNodeTypeAlias() IDestinationNodeTypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestinationNodeTypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestinationNodeTypeAliasContext)
}

func (s *EndpointPairPointingRightContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *EndpointPairPointingRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndpointPairPointingRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndpointPairPointingRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEndpointPairPointingRight(s)
	}
}

func (s *EndpointPairPointingRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEndpointPairPointingRight(s)
	}
}

func (p *GQLParser) EndpointPairPointingRight() (localctx IEndpointPairPointingRightContext) {
	localctx = NewEndpointPairPointingRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, GQLParserRULE_endpointPairPointingRight)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3086)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3087)
		p.SourceNodeTypeAlias()
	}
	{
		p.SetState(3088)
		p.ConnectorPointingRight()
	}
	{
		p.SetState(3089)
		p.DestinationNodeTypeAlias()
	}
	{
		p.SetState(3090)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEndpointPairPointingLeftContext is an interface to support dynamic dispatch.
type IEndpointPairPointingLeftContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	DestinationNodeTypeAlias() IDestinationNodeTypeAliasContext
	LEFT_ARROW() antlr.TerminalNode
	SourceNodeTypeAlias() ISourceNodeTypeAliasContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsEndpointPairPointingLeftContext differentiates from other interfaces.
	IsEndpointPairPointingLeftContext()
}

type EndpointPairPointingLeftContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndpointPairPointingLeftContext() *EndpointPairPointingLeftContext {
	var p = new(EndpointPairPointingLeftContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_endpointPairPointingLeft
	return p
}

func InitEmptyEndpointPairPointingLeftContext(p *EndpointPairPointingLeftContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_endpointPairPointingLeft
}

func (*EndpointPairPointingLeftContext) IsEndpointPairPointingLeftContext() {}

func NewEndpointPairPointingLeftContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndpointPairPointingLeftContext {
	var p = new(EndpointPairPointingLeftContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_endpointPairPointingLeft

	return p
}

func (s *EndpointPairPointingLeftContext) GetParser() antlr.Parser { return s.parser }

func (s *EndpointPairPointingLeftContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *EndpointPairPointingLeftContext) DestinationNodeTypeAlias() IDestinationNodeTypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestinationNodeTypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestinationNodeTypeAliasContext)
}

func (s *EndpointPairPointingLeftContext) LEFT_ARROW() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_ARROW, 0)
}

func (s *EndpointPairPointingLeftContext) SourceNodeTypeAlias() ISourceNodeTypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNodeTypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNodeTypeAliasContext)
}

func (s *EndpointPairPointingLeftContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *EndpointPairPointingLeftContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndpointPairPointingLeftContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndpointPairPointingLeftContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEndpointPairPointingLeft(s)
	}
}

func (s *EndpointPairPointingLeftContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEndpointPairPointingLeft(s)
	}
}

func (p *GQLParser) EndpointPairPointingLeft() (localctx IEndpointPairPointingLeftContext) {
	localctx = NewEndpointPairPointingLeftContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, GQLParserRULE_endpointPairPointingLeft)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3092)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3093)
		p.DestinationNodeTypeAlias()
	}
	{
		p.SetState(3094)
		p.Match(GQLParserLEFT_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3095)
		p.SourceNodeTypeAlias()
	}
	{
		p.SetState(3096)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEndpointPairUndirectedContext is an interface to support dynamic dispatch.
type IEndpointPairUndirectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	SourceNodeTypeAlias() ISourceNodeTypeAliasContext
	ConnectorUndirected() IConnectorUndirectedContext
	DestinationNodeTypeAlias() IDestinationNodeTypeAliasContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsEndpointPairUndirectedContext differentiates from other interfaces.
	IsEndpointPairUndirectedContext()
}

type EndpointPairUndirectedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndpointPairUndirectedContext() *EndpointPairUndirectedContext {
	var p = new(EndpointPairUndirectedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_endpointPairUndirected
	return p
}

func InitEmptyEndpointPairUndirectedContext(p *EndpointPairUndirectedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_endpointPairUndirected
}

func (*EndpointPairUndirectedContext) IsEndpointPairUndirectedContext() {}

func NewEndpointPairUndirectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndpointPairUndirectedContext {
	var p = new(EndpointPairUndirectedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_endpointPairUndirected

	return p
}

func (s *EndpointPairUndirectedContext) GetParser() antlr.Parser { return s.parser }

func (s *EndpointPairUndirectedContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *EndpointPairUndirectedContext) SourceNodeTypeAlias() ISourceNodeTypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNodeTypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNodeTypeAliasContext)
}

func (s *EndpointPairUndirectedContext) ConnectorUndirected() IConnectorUndirectedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConnectorUndirectedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConnectorUndirectedContext)
}

func (s *EndpointPairUndirectedContext) DestinationNodeTypeAlias() IDestinationNodeTypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestinationNodeTypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestinationNodeTypeAliasContext)
}

func (s *EndpointPairUndirectedContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *EndpointPairUndirectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndpointPairUndirectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndpointPairUndirectedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEndpointPairUndirected(s)
	}
}

func (s *EndpointPairUndirectedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEndpointPairUndirected(s)
	}
}

func (p *GQLParser) EndpointPairUndirected() (localctx IEndpointPairUndirectedContext) {
	localctx = NewEndpointPairUndirectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, GQLParserRULE_endpointPairUndirected)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3098)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3099)
		p.SourceNodeTypeAlias()
	}
	{
		p.SetState(3100)
		p.ConnectorUndirected()
	}
	{
		p.SetState(3101)
		p.DestinationNodeTypeAlias()
	}
	{
		p.SetState(3102)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConnectorPointingRightContext is an interface to support dynamic dispatch.
type IConnectorPointingRightContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TO() antlr.TerminalNode
	RIGHT_ARROW() antlr.TerminalNode

	// IsConnectorPointingRightContext differentiates from other interfaces.
	IsConnectorPointingRightContext()
}

type ConnectorPointingRightContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConnectorPointingRightContext() *ConnectorPointingRightContext {
	var p = new(ConnectorPointingRightContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_connectorPointingRight
	return p
}

func InitEmptyConnectorPointingRightContext(p *ConnectorPointingRightContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_connectorPointingRight
}

func (*ConnectorPointingRightContext) IsConnectorPointingRightContext() {}

func NewConnectorPointingRightContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConnectorPointingRightContext {
	var p = new(ConnectorPointingRightContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_connectorPointingRight

	return p
}

func (s *ConnectorPointingRightContext) GetParser() antlr.Parser { return s.parser }

func (s *ConnectorPointingRightContext) TO() antlr.TerminalNode {
	return s.GetToken(GQLParserTO, 0)
}

func (s *ConnectorPointingRightContext) RIGHT_ARROW() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_ARROW, 0)
}

func (s *ConnectorPointingRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConnectorPointingRightContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConnectorPointingRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterConnectorPointingRight(s)
	}
}

func (s *ConnectorPointingRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitConnectorPointingRight(s)
	}
}

func (p *GQLParser) ConnectorPointingRight() (localctx IConnectorPointingRightContext) {
	localctx = NewConnectorPointingRightContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, GQLParserRULE_connectorPointingRight)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3104)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserTO || _la == GQLParserRIGHT_ARROW) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConnectorUndirectedContext is an interface to support dynamic dispatch.
type IConnectorUndirectedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TO() antlr.TerminalNode
	TILDE() antlr.TerminalNode

	// IsConnectorUndirectedContext differentiates from other interfaces.
	IsConnectorUndirectedContext()
}

type ConnectorUndirectedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConnectorUndirectedContext() *ConnectorUndirectedContext {
	var p = new(ConnectorUndirectedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_connectorUndirected
	return p
}

func InitEmptyConnectorUndirectedContext(p *ConnectorUndirectedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_connectorUndirected
}

func (*ConnectorUndirectedContext) IsConnectorUndirectedContext() {}

func NewConnectorUndirectedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConnectorUndirectedContext {
	var p = new(ConnectorUndirectedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_connectorUndirected

	return p
}

func (s *ConnectorUndirectedContext) GetParser() antlr.Parser { return s.parser }

func (s *ConnectorUndirectedContext) TO() antlr.TerminalNode {
	return s.GetToken(GQLParserTO, 0)
}

func (s *ConnectorUndirectedContext) TILDE() antlr.TerminalNode {
	return s.GetToken(GQLParserTILDE, 0)
}

func (s *ConnectorUndirectedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConnectorUndirectedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConnectorUndirectedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterConnectorUndirected(s)
	}
}

func (s *ConnectorUndirectedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitConnectorUndirected(s)
	}
}

func (p *GQLParser) ConnectorUndirected() (localctx IConnectorUndirectedContext) {
	localctx = NewConnectorUndirectedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, GQLParserRULE_connectorUndirected)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3106)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserTO || _la == GQLParserTILDE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISourceNodeTypeAliasContext is an interface to support dynamic dispatch.
type ISourceNodeTypeAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RegularIdentifier() IRegularIdentifierContext

	// IsSourceNodeTypeAliasContext differentiates from other interfaces.
	IsSourceNodeTypeAliasContext()
}

type SourceNodeTypeAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceNodeTypeAliasContext() *SourceNodeTypeAliasContext {
	var p = new(SourceNodeTypeAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sourceNodeTypeAlias
	return p
}

func InitEmptySourceNodeTypeAliasContext(p *SourceNodeTypeAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sourceNodeTypeAlias
}

func (*SourceNodeTypeAliasContext) IsSourceNodeTypeAliasContext() {}

func NewSourceNodeTypeAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceNodeTypeAliasContext {
	var p = new(SourceNodeTypeAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sourceNodeTypeAlias

	return p
}

func (s *SourceNodeTypeAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceNodeTypeAliasContext) RegularIdentifier() IRegularIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegularIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegularIdentifierContext)
}

func (s *SourceNodeTypeAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceNodeTypeAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceNodeTypeAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSourceNodeTypeAlias(s)
	}
}

func (s *SourceNodeTypeAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSourceNodeTypeAlias(s)
	}
}

func (p *GQLParser) SourceNodeTypeAlias() (localctx ISourceNodeTypeAliasContext) {
	localctx = NewSourceNodeTypeAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, GQLParserRULE_sourceNodeTypeAlias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3108)
		p.RegularIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDestinationNodeTypeAliasContext is an interface to support dynamic dispatch.
type IDestinationNodeTypeAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RegularIdentifier() IRegularIdentifierContext

	// IsDestinationNodeTypeAliasContext differentiates from other interfaces.
	IsDestinationNodeTypeAliasContext()
}

type DestinationNodeTypeAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestinationNodeTypeAliasContext() *DestinationNodeTypeAliasContext {
	var p = new(DestinationNodeTypeAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_destinationNodeTypeAlias
	return p
}

func InitEmptyDestinationNodeTypeAliasContext(p *DestinationNodeTypeAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_destinationNodeTypeAlias
}

func (*DestinationNodeTypeAliasContext) IsDestinationNodeTypeAliasContext() {}

func NewDestinationNodeTypeAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestinationNodeTypeAliasContext {
	var p = new(DestinationNodeTypeAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_destinationNodeTypeAlias

	return p
}

func (s *DestinationNodeTypeAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *DestinationNodeTypeAliasContext) RegularIdentifier() IRegularIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegularIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegularIdentifierContext)
}

func (s *DestinationNodeTypeAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestinationNodeTypeAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DestinationNodeTypeAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDestinationNodeTypeAlias(s)
	}
}

func (s *DestinationNodeTypeAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDestinationNodeTypeAlias(s)
	}
}

func (p *GQLParser) DestinationNodeTypeAlias() (localctx IDestinationNodeTypeAliasContext) {
	localctx = NewDestinationNodeTypeAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, GQLParserRULE_destinationNodeTypeAlias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3110)
		p.RegularIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelSetPhraseContext is an interface to support dynamic dispatch.
type ILabelSetPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LABEL() antlr.TerminalNode
	LabelName() ILabelNameContext
	LABELS() antlr.TerminalNode
	LabelSetSpecification() ILabelSetSpecificationContext
	IsOrColon() IIsOrColonContext

	// IsLabelSetPhraseContext differentiates from other interfaces.
	IsLabelSetPhraseContext()
}

type LabelSetPhraseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelSetPhraseContext() *LabelSetPhraseContext {
	var p = new(LabelSetPhraseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_labelSetPhrase
	return p
}

func InitEmptyLabelSetPhraseContext(p *LabelSetPhraseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_labelSetPhrase
}

func (*LabelSetPhraseContext) IsLabelSetPhraseContext() {}

func NewLabelSetPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelSetPhraseContext {
	var p = new(LabelSetPhraseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_labelSetPhrase

	return p
}

func (s *LabelSetPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelSetPhraseContext) LABEL() antlr.TerminalNode {
	return s.GetToken(GQLParserLABEL, 0)
}

func (s *LabelSetPhraseContext) LabelName() ILabelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelNameContext)
}

func (s *LabelSetPhraseContext) LABELS() antlr.TerminalNode {
	return s.GetToken(GQLParserLABELS, 0)
}

func (s *LabelSetPhraseContext) LabelSetSpecification() ILabelSetSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelSetSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelSetSpecificationContext)
}

func (s *LabelSetPhraseContext) IsOrColon() IIsOrColonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsOrColonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsOrColonContext)
}

func (s *LabelSetPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelSetPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelSetPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLabelSetPhrase(s)
	}
}

func (s *LabelSetPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLabelSetPhrase(s)
	}
}

func (p *GQLParser) LabelSetPhrase() (localctx ILabelSetPhraseContext) {
	localctx = NewLabelSetPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, GQLParserRULE_labelSetPhrase)
	p.SetState(3119)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserLABEL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3112)
			p.Match(GQLParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3113)
			p.LabelName()
		}

	case GQLParserLABELS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3114)
			p.Match(GQLParserLABELS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3115)
			p.LabelSetSpecification()
		}

	case GQLParserIS, GQLParserCOLON:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3116)
			p.IsOrColon()
		}
		{
			p.SetState(3117)
			p.LabelSetSpecification()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelSetSpecificationContext is an interface to support dynamic dispatch.
type ILabelSetSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLabelName() []ILabelNameContext
	LabelName(i int) ILabelNameContext
	AllAMPERSAND() []antlr.TerminalNode
	AMPERSAND(i int) antlr.TerminalNode

	// IsLabelSetSpecificationContext differentiates from other interfaces.
	IsLabelSetSpecificationContext()
}

type LabelSetSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelSetSpecificationContext() *LabelSetSpecificationContext {
	var p = new(LabelSetSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_labelSetSpecification
	return p
}

func InitEmptyLabelSetSpecificationContext(p *LabelSetSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_labelSetSpecification
}

func (*LabelSetSpecificationContext) IsLabelSetSpecificationContext() {}

func NewLabelSetSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelSetSpecificationContext {
	var p = new(LabelSetSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_labelSetSpecification

	return p
}

func (s *LabelSetSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelSetSpecificationContext) AllLabelName() []ILabelNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILabelNameContext); ok {
			len++
		}
	}

	tst := make([]ILabelNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILabelNameContext); ok {
			tst[i] = t.(ILabelNameContext)
			i++
		}
	}

	return tst
}

func (s *LabelSetSpecificationContext) LabelName(i int) ILabelNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelNameContext)
}

func (s *LabelSetSpecificationContext) AllAMPERSAND() []antlr.TerminalNode {
	return s.GetTokens(GQLParserAMPERSAND)
}

func (s *LabelSetSpecificationContext) AMPERSAND(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserAMPERSAND, i)
}

func (s *LabelSetSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelSetSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelSetSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLabelSetSpecification(s)
	}
}

func (s *LabelSetSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLabelSetSpecification(s)
	}
}

func (p *GQLParser) LabelSetSpecification() (localctx ILabelSetSpecificationContext) {
	localctx = NewLabelSetSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, GQLParserRULE_labelSetSpecification)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3121)
		p.LabelName()
	}
	p.SetState(3126)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3122)
				p.Match(GQLParserAMPERSAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3123)
				p.LabelName()
			}

		}
		p.SetState(3128)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyTypesSpecificationContext is an interface to support dynamic dispatch.
type IPropertyTypesSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_BRACE() antlr.TerminalNode
	RIGHT_BRACE() antlr.TerminalNode
	PropertyTypeList() IPropertyTypeListContext

	// IsPropertyTypesSpecificationContext differentiates from other interfaces.
	IsPropertyTypesSpecificationContext()
}

type PropertyTypesSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyTypesSpecificationContext() *PropertyTypesSpecificationContext {
	var p = new(PropertyTypesSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_propertyTypesSpecification
	return p
}

func InitEmptyPropertyTypesSpecificationContext(p *PropertyTypesSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_propertyTypesSpecification
}

func (*PropertyTypesSpecificationContext) IsPropertyTypesSpecificationContext() {}

func NewPropertyTypesSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyTypesSpecificationContext {
	var p = new(PropertyTypesSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_propertyTypesSpecification

	return p
}

func (s *PropertyTypesSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyTypesSpecificationContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACE, 0)
}

func (s *PropertyTypesSpecificationContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACE, 0)
}

func (s *PropertyTypesSpecificationContext) PropertyTypeList() IPropertyTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyTypeListContext)
}

func (s *PropertyTypesSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyTypesSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyTypesSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPropertyTypesSpecification(s)
	}
}

func (s *PropertyTypesSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPropertyTypesSpecification(s)
	}
}

func (p *GQLParser) PropertyTypesSpecification() (localctx IPropertyTypesSpecificationContext) {
	localctx = NewPropertyTypesSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, GQLParserRULE_propertyTypesSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3129)
		p.Match(GQLParserLEFT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&281474976710655) != 0) {
		{
			p.SetState(3130)
			p.PropertyTypeList()
		}

	}
	{
		p.SetState(3133)
		p.Match(GQLParserRIGHT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyTypeListContext is an interface to support dynamic dispatch.
type IPropertyTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPropertyType() []IPropertyTypeContext
	PropertyType(i int) IPropertyTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyTypeListContext differentiates from other interfaces.
	IsPropertyTypeListContext()
}

type PropertyTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyTypeListContext() *PropertyTypeListContext {
	var p = new(PropertyTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_propertyTypeList
	return p
}

func InitEmptyPropertyTypeListContext(p *PropertyTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_propertyTypeList
}

func (*PropertyTypeListContext) IsPropertyTypeListContext() {}

func NewPropertyTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyTypeListContext {
	var p = new(PropertyTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_propertyTypeList

	return p
}

func (s *PropertyTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyTypeListContext) AllPropertyType() []IPropertyTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyTypeContext); ok {
			len++
		}
	}

	tst := make([]IPropertyTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyTypeContext); ok {
			tst[i] = t.(IPropertyTypeContext)
			i++
		}
	}

	return tst
}

func (s *PropertyTypeListContext) PropertyType(i int) IPropertyTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyTypeContext)
}

func (s *PropertyTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *PropertyTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *PropertyTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPropertyTypeList(s)
	}
}

func (s *PropertyTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPropertyTypeList(s)
	}
}

func (p *GQLParser) PropertyTypeList() (localctx IPropertyTypeListContext) {
	localctx = NewPropertyTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, GQLParserRULE_propertyTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3135)
		p.PropertyType()
	}
	p.SetState(3140)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(3136)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3137)
			p.PropertyType()
		}

		p.SetState(3142)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyTypeContext is an interface to support dynamic dispatch.
type IPropertyTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyName() IPropertyNameContext
	PropertyValueType() IPropertyValueTypeContext
	Typed() ITypedContext

	// IsPropertyTypeContext differentiates from other interfaces.
	IsPropertyTypeContext()
}

type PropertyTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyTypeContext() *PropertyTypeContext {
	var p = new(PropertyTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_propertyType
	return p
}

func InitEmptyPropertyTypeContext(p *PropertyTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_propertyType
}

func (*PropertyTypeContext) IsPropertyTypeContext() {}

func NewPropertyTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyTypeContext {
	var p = new(PropertyTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_propertyType

	return p
}

func (s *PropertyTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyTypeContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *PropertyTypeContext) PropertyValueType() IPropertyValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyValueTypeContext)
}

func (s *PropertyTypeContext) Typed() ITypedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedContext)
}

func (s *PropertyTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPropertyType(s)
	}
}

func (s *PropertyTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPropertyType(s)
	}
}

func (p *GQLParser) PropertyType() (localctx IPropertyTypeContext) {
	localctx = NewPropertyTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, GQLParserRULE_propertyType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3143)
		p.PropertyName()
	}
	p.SetState(3145)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserTYPED || _la == GQLParserDOUBLE_COLON {
		{
			p.SetState(3144)
			p.Typed()
		}

	}
	{
		p.SetState(3147)
		p.PropertyValueType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryKeyContext is an interface to support dynamic dispatch.
type IPrimaryKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsPrimaryKeyContext differentiates from other interfaces.
	IsPrimaryKeyContext()
}

type PrimaryKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyContext() *PrimaryKeyContext {
	var p = new(PrimaryKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_primaryKey
	return p
}

func InitEmptyPrimaryKeyContext(p *PrimaryKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_primaryKey
}

func (*PrimaryKeyContext) IsPrimaryKeyContext() {}

func NewPrimaryKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyContext {
	var p = new(PrimaryKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_primaryKey

	return p
}

func (s *PrimaryKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(GQLParserPRIMARY, 0)
}

func (s *PrimaryKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(GQLParserKEY, 0)
}

func (s *PrimaryKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPrimaryKey(s)
	}
}

func (s *PrimaryKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPrimaryKey(s)
	}
}

func (p *GQLParser) PrimaryKey() (localctx IPrimaryKeyContext) {
	localctx = NewPrimaryKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, GQLParserRULE_primaryKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3149)
		p.Match(GQLParserPRIMARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3150)
		p.Match(GQLParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckConstraintContext is an interface to support dynamic dispatch.
type ICheckConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHECK() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	SearchCondition() ISearchConditionContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsCheckConstraintContext differentiates from other interfaces.
	IsCheckConstraintContext()
}

type CheckConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckConstraintContext() *CheckConstraintContext {
	var p = new(CheckConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_checkConstraint
	return p
}

func InitEmptyCheckConstraintContext(p *CheckConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_checkConstraint
}

func (*CheckConstraintContext) IsCheckConstraintContext() {}

func NewCheckConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckConstraintContext {
	var p = new(CheckConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_checkConstraint

	return p
}

func (s *CheckConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(GQLParserCHECK, 0)
}

func (s *CheckConstraintContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *CheckConstraintContext) SearchCondition() ISearchConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchConditionContext)
}

func (s *CheckConstraintContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *CheckConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCheckConstraint(s)
	}
}

func (s *CheckConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCheckConstraint(s)
	}
}

func (p *GQLParser) CheckConstraint() (localctx ICheckConstraintContext) {
	localctx = NewCheckConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, GQLParserRULE_checkConstraint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3152)
		p.Match(GQLParserCHECK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3153)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3154)
		p.SearchCondition()
	}
	{
		p.SetState(3155)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyValueTypeContext is an interface to support dynamic dispatch.
type IPropertyValueTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueType() IValueTypeContext
	AllUNIQUE() []antlr.TerminalNode
	UNIQUE(i int) antlr.TerminalNode
	AllPrimaryKey() []IPrimaryKeyContext
	PrimaryKey(i int) IPrimaryKeyContext
	AllCheckConstraint() []ICheckConstraintContext
	CheckConstraint(i int) ICheckConstraintContext

	// IsPropertyValueTypeContext differentiates from other interfaces.
	IsPropertyValueTypeContext()
}

type PropertyValueTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyValueTypeContext() *PropertyValueTypeContext {
	var p = new(PropertyValueTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_propertyValueType
	return p
}

func InitEmptyPropertyValueTypeContext(p *PropertyValueTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_propertyValueType
}

func (*PropertyValueTypeContext) IsPropertyValueTypeContext() {}

func NewPropertyValueTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyValueTypeContext {
	var p = new(PropertyValueTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_propertyValueType

	return p
}

func (s *PropertyValueTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyValueTypeContext) ValueType() IValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueTypeContext)
}

func (s *PropertyValueTypeContext) AllUNIQUE() []antlr.TerminalNode {
	return s.GetTokens(GQLParserUNIQUE)
}

func (s *PropertyValueTypeContext) UNIQUE(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserUNIQUE, i)
}

func (s *PropertyValueTypeContext) AllPrimaryKey() []IPrimaryKeyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryKeyContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryKeyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryKeyContext); ok {
			tst[i] = t.(IPrimaryKeyContext)
			i++
		}
	}

	return tst
}

func (s *PropertyValueTypeContext) PrimaryKey(i int) IPrimaryKeyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryKeyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyContext)
}

func (s *PropertyValueTypeContext) AllCheckConstraint() []ICheckConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICheckConstraintContext); ok {
			len++
		}
	}

	tst := make([]ICheckConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICheckConstraintContext); ok {
			tst[i] = t.(ICheckConstraintContext)
			i++
		}
	}

	return tst
}

func (s *PropertyValueTypeContext) CheckConstraint(i int) ICheckConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckConstraintContext)
}

func (s *PropertyValueTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyValueTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyValueTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPropertyValueType(s)
	}
}

func (s *PropertyValueTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPropertyValueType(s)
	}
}

func (p *GQLParser) PropertyValueType() (localctx IPropertyValueTypeContext) {
	localctx = NewPropertyValueTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, GQLParserRULE_propertyValueType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3157)
		p.valueType(0)
	}
	p.SetState(3163)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCHECK || _la == GQLParserPRIMARY || _la == GQLParserUNIQUE {
		p.SetState(3161)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case GQLParserUNIQUE:
			{
				p.SetState(3158)
				p.Match(GQLParserUNIQUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case GQLParserPRIMARY:
			{
				p.SetState(3159)
				p.PrimaryKey()
			}

		case GQLParserCHECK:
			{
				p.SetState(3160)
				p.CheckConstraint()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(3165)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindingTableTypeContext is an interface to support dynamic dispatch.
type IBindingTableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE() antlr.TerminalNode
	FieldTypesSpecification() IFieldTypesSpecificationContext
	BINDING() antlr.TerminalNode

	// IsBindingTableTypeContext differentiates from other interfaces.
	IsBindingTableTypeContext()
}

type BindingTableTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingTableTypeContext() *BindingTableTypeContext {
	var p = new(BindingTableTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingTableType
	return p
}

func InitEmptyBindingTableTypeContext(p *BindingTableTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingTableType
}

func (*BindingTableTypeContext) IsBindingTableTypeContext() {}

func NewBindingTableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingTableTypeContext {
	var p = new(BindingTableTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_bindingTableType

	return p
}

func (s *BindingTableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingTableTypeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(GQLParserTABLE, 0)
}

func (s *BindingTableTypeContext) FieldTypesSpecification() IFieldTypesSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldTypesSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldTypesSpecificationContext)
}

func (s *BindingTableTypeContext) BINDING() antlr.TerminalNode {
	return s.GetToken(GQLParserBINDING, 0)
}

func (s *BindingTableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingTableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingTableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBindingTableType(s)
	}
}

func (s *BindingTableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBindingTableType(s)
	}
}

func (p *GQLParser) BindingTableType() (localctx IBindingTableTypeContext) {
	localctx = NewBindingTableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, GQLParserRULE_bindingTableType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3167)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserBINDING {
		{
			p.SetState(3166)
			p.Match(GQLParserBINDING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3169)
		p.Match(GQLParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3170)
		p.FieldTypesSpecification()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueTypeContext is an interface to support dynamic dispatch.
type IValueTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueTypeContext differentiates from other interfaces.
	IsValueTypeContext()
}

type ValueTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueTypeContext() *ValueTypeContext {
	var p = new(ValueTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueType
	return p
}

func InitEmptyValueTypeContext(p *ValueTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueType
}

func (*ValueTypeContext) IsValueTypeContext() {}

func NewValueTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueTypeContext {
	var p = new(ValueTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_valueType

	return p
}

func (s *ValueTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueTypeContext) CopyAll(ctx *ValueTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DynamicPropertyValueTypeLabelContext struct {
	ValueTypeContext
}

func NewDynamicPropertyValueTypeLabelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DynamicPropertyValueTypeLabelContext {
	var p = new(DynamicPropertyValueTypeLabelContext)

	InitEmptyValueTypeContext(&p.ValueTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueTypeContext))

	return p
}

func (s *DynamicPropertyValueTypeLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DynamicPropertyValueTypeLabelContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY, 0)
}

func (s *DynamicPropertyValueTypeLabelContext) VALUE() antlr.TerminalNode {
	return s.GetToken(GQLParserVALUE, 0)
}

func (s *DynamicPropertyValueTypeLabelContext) ANY() antlr.TerminalNode {
	return s.GetToken(GQLParserANY, 0)
}

func (s *DynamicPropertyValueTypeLabelContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *DynamicPropertyValueTypeLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDynamicPropertyValueTypeLabel(s)
	}
}

func (s *DynamicPropertyValueTypeLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDynamicPropertyValueTypeLabel(s)
	}
}

type ClosedDynamicUnionTypeAtl1Context struct {
	ValueTypeContext
}

func NewClosedDynamicUnionTypeAtl1Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ClosedDynamicUnionTypeAtl1Context {
	var p = new(ClosedDynamicUnionTypeAtl1Context)

	InitEmptyValueTypeContext(&p.ValueTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueTypeContext))

	return p
}

func (s *ClosedDynamicUnionTypeAtl1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosedDynamicUnionTypeAtl1Context) ANY() antlr.TerminalNode {
	return s.GetToken(GQLParserANY, 0)
}

func (s *ClosedDynamicUnionTypeAtl1Context) LEFT_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_ANGLE_BRACKET, 0)
}

func (s *ClosedDynamicUnionTypeAtl1Context) AllValueType() []IValueTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueTypeContext); ok {
			len++
		}
	}

	tst := make([]IValueTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueTypeContext); ok {
			tst[i] = t.(IValueTypeContext)
			i++
		}
	}

	return tst
}

func (s *ClosedDynamicUnionTypeAtl1Context) ValueType(i int) IValueTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueTypeContext)
}

func (s *ClosedDynamicUnionTypeAtl1Context) RIGHT_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_ANGLE_BRACKET, 0)
}

func (s *ClosedDynamicUnionTypeAtl1Context) VALUE() antlr.TerminalNode {
	return s.GetToken(GQLParserVALUE, 0)
}

func (s *ClosedDynamicUnionTypeAtl1Context) AllVERTICAL_BAR() []antlr.TerminalNode {
	return s.GetTokens(GQLParserVERTICAL_BAR)
}

func (s *ClosedDynamicUnionTypeAtl1Context) VERTICAL_BAR(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserVERTICAL_BAR, i)
}

func (s *ClosedDynamicUnionTypeAtl1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterClosedDynamicUnionTypeAtl1(s)
	}
}

func (s *ClosedDynamicUnionTypeAtl1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitClosedDynamicUnionTypeAtl1(s)
	}
}

type ClosedDynamicUnionTypeAtl2Context struct {
	ValueTypeContext
}

func NewClosedDynamicUnionTypeAtl2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ClosedDynamicUnionTypeAtl2Context {
	var p = new(ClosedDynamicUnionTypeAtl2Context)

	InitEmptyValueTypeContext(&p.ValueTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueTypeContext))

	return p
}

func (s *ClosedDynamicUnionTypeAtl2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosedDynamicUnionTypeAtl2Context) AllValueType() []IValueTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueTypeContext); ok {
			len++
		}
	}

	tst := make([]IValueTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueTypeContext); ok {
			tst[i] = t.(IValueTypeContext)
			i++
		}
	}

	return tst
}

func (s *ClosedDynamicUnionTypeAtl2Context) ValueType(i int) IValueTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueTypeContext)
}

func (s *ClosedDynamicUnionTypeAtl2Context) VERTICAL_BAR() antlr.TerminalNode {
	return s.GetToken(GQLParserVERTICAL_BAR, 0)
}

func (s *ClosedDynamicUnionTypeAtl2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterClosedDynamicUnionTypeAtl2(s)
	}
}

func (s *ClosedDynamicUnionTypeAtl2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitClosedDynamicUnionTypeAtl2(s)
	}
}

type PathValueTypeLabelContext struct {
	ValueTypeContext
}

func NewPathValueTypeLabelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PathValueTypeLabelContext {
	var p = new(PathValueTypeLabelContext)

	InitEmptyValueTypeContext(&p.ValueTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueTypeContext))

	return p
}

func (s *PathValueTypeLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathValueTypeLabelContext) PathValueType() IPathValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathValueTypeContext)
}

func (s *PathValueTypeLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathValueTypeLabel(s)
	}
}

func (s *PathValueTypeLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathValueTypeLabel(s)
	}
}

type ListValueTypeAlt3Context struct {
	ValueTypeContext
}

func NewListValueTypeAlt3Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListValueTypeAlt3Context {
	var p = new(ListValueTypeAlt3Context)

	InitEmptyValueTypeContext(&p.ValueTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueTypeContext))

	return p
}

func (s *ListValueTypeAlt3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListValueTypeAlt3Context) ListValueTypeName() IListValueTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListValueTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListValueTypeNameContext)
}

func (s *ListValueTypeAlt3Context) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACKET, 0)
}

func (s *ListValueTypeAlt3Context) MaxLength() IMaxLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaxLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaxLengthContext)
}

func (s *ListValueTypeAlt3Context) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET, 0)
}

func (s *ListValueTypeAlt3Context) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *ListValueTypeAlt3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterListValueTypeAlt3(s)
	}
}

func (s *ListValueTypeAlt3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitListValueTypeAlt3(s)
	}
}

type ListValueTypeAlt2Context struct {
	ValueTypeContext
}

func NewListValueTypeAlt2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListValueTypeAlt2Context {
	var p = new(ListValueTypeAlt2Context)

	InitEmptyValueTypeContext(&p.ValueTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueTypeContext))

	return p
}

func (s *ListValueTypeAlt2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListValueTypeAlt2Context) ValueType() IValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueTypeContext)
}

func (s *ListValueTypeAlt2Context) ListValueTypeName() IListValueTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListValueTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListValueTypeNameContext)
}

func (s *ListValueTypeAlt2Context) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACKET, 0)
}

func (s *ListValueTypeAlt2Context) MaxLength() IMaxLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaxLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaxLengthContext)
}

func (s *ListValueTypeAlt2Context) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET, 0)
}

func (s *ListValueTypeAlt2Context) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *ListValueTypeAlt2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterListValueTypeAlt2(s)
	}
}

func (s *ListValueTypeAlt2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitListValueTypeAlt2(s)
	}
}

type ListValueTypeAlt1Context struct {
	ValueTypeContext
}

func NewListValueTypeAlt1Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListValueTypeAlt1Context {
	var p = new(ListValueTypeAlt1Context)

	InitEmptyValueTypeContext(&p.ValueTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueTypeContext))

	return p
}

func (s *ListValueTypeAlt1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListValueTypeAlt1Context) ListValueTypeName() IListValueTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListValueTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListValueTypeNameContext)
}

func (s *ListValueTypeAlt1Context) LEFT_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_ANGLE_BRACKET, 0)
}

func (s *ListValueTypeAlt1Context) ValueType() IValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueTypeContext)
}

func (s *ListValueTypeAlt1Context) RIGHT_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_ANGLE_BRACKET, 0)
}

func (s *ListValueTypeAlt1Context) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACKET, 0)
}

func (s *ListValueTypeAlt1Context) MaxLength() IMaxLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaxLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaxLengthContext)
}

func (s *ListValueTypeAlt1Context) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET, 0)
}

func (s *ListValueTypeAlt1Context) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *ListValueTypeAlt1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterListValueTypeAlt1(s)
	}
}

func (s *ListValueTypeAlt1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitListValueTypeAlt1(s)
	}
}

type PredefinedTypeLabelContext struct {
	ValueTypeContext
}

func NewPredefinedTypeLabelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredefinedTypeLabelContext {
	var p = new(PredefinedTypeLabelContext)

	InitEmptyValueTypeContext(&p.ValueTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueTypeContext))

	return p
}

func (s *PredefinedTypeLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredefinedTypeLabelContext) PredefinedType() IPredefinedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredefinedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredefinedTypeContext)
}

func (s *PredefinedTypeLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPredefinedTypeLabel(s)
	}
}

func (s *PredefinedTypeLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPredefinedTypeLabel(s)
	}
}

type RecordTypeLabelContext struct {
	ValueTypeContext
}

func NewRecordTypeLabelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RecordTypeLabelContext {
	var p = new(RecordTypeLabelContext)

	InitEmptyValueTypeContext(&p.ValueTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueTypeContext))

	return p
}

func (s *RecordTypeLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordTypeLabelContext) RecordType() IRecordTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordTypeContext)
}

func (s *RecordTypeLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterRecordTypeLabel(s)
	}
}

func (s *RecordTypeLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitRecordTypeLabel(s)
	}
}

type OpenDynamicUnionTypeLabelContext struct {
	ValueTypeContext
}

func NewOpenDynamicUnionTypeLabelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OpenDynamicUnionTypeLabelContext {
	var p = new(OpenDynamicUnionTypeLabelContext)

	InitEmptyValueTypeContext(&p.ValueTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueTypeContext))

	return p
}

func (s *OpenDynamicUnionTypeLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenDynamicUnionTypeLabelContext) ANY() antlr.TerminalNode {
	return s.GetToken(GQLParserANY, 0)
}

func (s *OpenDynamicUnionTypeLabelContext) VALUE() antlr.TerminalNode {
	return s.GetToken(GQLParserVALUE, 0)
}

func (s *OpenDynamicUnionTypeLabelContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *OpenDynamicUnionTypeLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOpenDynamicUnionTypeLabel(s)
	}
}

func (s *OpenDynamicUnionTypeLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOpenDynamicUnionTypeLabel(s)
	}
}

func (p *GQLParser) ValueType() (localctx IValueTypeContext) {
	return p.valueType(0)
}

func (p *GQLParser) valueType(_p int) (localctx IValueTypeContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueTypeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueTypeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 704
	p.EnterRecursionRule(localctx, 704, GQLParserRULE_valueType, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3229)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 305, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPredefinedTypeLabelContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(3173)
			p.PredefinedType()
		}

	case 2:
		localctx = NewPathValueTypeLabelContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3174)
			p.PathValueType()
		}

	case 3:
		localctx = NewListValueTypeAlt1Context(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3175)
			p.ListValueTypeName()
		}
		{
			p.SetState(3176)
			p.Match(GQLParserLEFT_ANGLE_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3177)
			p.valueType(0)
		}
		{
			p.SetState(3178)
			p.Match(GQLParserRIGHT_ANGLE_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3183)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3179)
				p.Match(GQLParserLEFT_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3180)
				p.MaxLength()
			}
			{
				p.SetState(3181)
				p.Match(GQLParserRIGHT_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3186)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3185)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewListValueTypeAlt3Context(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3188)
			p.ListValueTypeName()
		}
		p.SetState(3193)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 297, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3189)
				p.Match(GQLParserLEFT_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3190)
				p.MaxLength()
			}
			{
				p.SetState(3191)
				p.Match(GQLParserRIGHT_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3196)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 298, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3195)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewRecordTypeLabelContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3198)
			p.RecordType()
		}

	case 6:
		localctx = NewOpenDynamicUnionTypeLabelContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3199)
			p.Match(GQLParserANY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3201)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 299, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3200)
				p.Match(GQLParserVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3204)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3203)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		localctx = NewDynamicPropertyValueTypeLabelContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(3207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserANY {
			{
				p.SetState(3206)
				p.Match(GQLParserANY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3209)
			p.Match(GQLParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3210)
			p.Match(GQLParserVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3212)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 302, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3211)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		localctx = NewClosedDynamicUnionTypeAtl1Context(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3214)
			p.Match(GQLParserANY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3216)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserVALUE {
			{
				p.SetState(3215)
				p.Match(GQLParserVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3218)
			p.Match(GQLParserLEFT_ANGLE_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3219)
			p.valueType(0)
		}
		p.SetState(3224)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == GQLParserVERTICAL_BAR {
			{
				p.SetState(3220)
				p.Match(GQLParserVERTICAL_BAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3221)
				p.valueType(0)
			}

			p.SetState(3226)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3227)
			p.Match(GQLParserRIGHT_ANGLE_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3247)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 309, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3245)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 308, p.GetParserRuleContext()) {
			case 1:
				localctx = NewClosedDynamicUnionTypeAtl2Context(p, NewValueTypeContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_valueType)
				p.SetState(3231)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(3232)
					p.Match(GQLParserVERTICAL_BAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3233)
					p.valueType(2)
				}

			case 2:
				localctx = NewListValueTypeAlt2Context(p, NewValueTypeContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_valueType)
				p.SetState(3234)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(3235)
					p.ListValueTypeName()
				}
				p.SetState(3240)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 306, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(3236)
						p.Match(GQLParserLEFT_BRACKET)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(3237)
						p.MaxLength()
					}
					{
						p.SetState(3238)
						p.Match(GQLParserRIGHT_BRACKET)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}
				p.SetState(3243)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 307, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(3242)
						p.NotNull()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(3249)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 309, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedContext is an interface to support dynamic dispatch.
type ITypedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOUBLE_COLON() antlr.TerminalNode
	TYPED() antlr.TerminalNode

	// IsTypedContext differentiates from other interfaces.
	IsTypedContext()
}

type TypedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedContext() *TypedContext {
	var p = new(TypedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_typed
	return p
}

func InitEmptyTypedContext(p *TypedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_typed
}

func (*TypedContext) IsTypedContext() {}

func NewTypedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedContext {
	var p = new(TypedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_typed

	return p
}

func (s *TypedContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedContext) DOUBLE_COLON() antlr.TerminalNode {
	return s.GetToken(GQLParserDOUBLE_COLON, 0)
}

func (s *TypedContext) TYPED() antlr.TerminalNode {
	return s.GetToken(GQLParserTYPED, 0)
}

func (s *TypedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTyped(s)
	}
}

func (s *TypedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTyped(s)
	}
}

func (p *GQLParser) Typed() (localctx ITypedContext) {
	localctx = NewTypedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, GQLParserRULE_typed)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3250)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserTYPED || _la == GQLParserDOUBLE_COLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredefinedTypeContext is an interface to support dynamic dispatch.
type IPredefinedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanType() IBooleanTypeContext
	CharacterStringType() ICharacterStringTypeContext
	ByteStringType() IByteStringTypeContext
	NumericType() INumericTypeContext
	TemporalType() ITemporalTypeContext
	ReferenceValueType() IReferenceValueTypeContext
	ImmaterialValueType() IImmaterialValueTypeContext

	// IsPredefinedTypeContext differentiates from other interfaces.
	IsPredefinedTypeContext()
}

type PredefinedTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredefinedTypeContext() *PredefinedTypeContext {
	var p = new(PredefinedTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_predefinedType
	return p
}

func InitEmptyPredefinedTypeContext(p *PredefinedTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_predefinedType
}

func (*PredefinedTypeContext) IsPredefinedTypeContext() {}

func NewPredefinedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredefinedTypeContext {
	var p = new(PredefinedTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_predefinedType

	return p
}

func (s *PredefinedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PredefinedTypeContext) BooleanType() IBooleanTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanTypeContext)
}

func (s *PredefinedTypeContext) CharacterStringType() ICharacterStringTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacterStringTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacterStringTypeContext)
}

func (s *PredefinedTypeContext) ByteStringType() IByteStringTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IByteStringTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IByteStringTypeContext)
}

func (s *PredefinedTypeContext) NumericType() INumericTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericTypeContext)
}

func (s *PredefinedTypeContext) TemporalType() ITemporalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemporalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemporalTypeContext)
}

func (s *PredefinedTypeContext) ReferenceValueType() IReferenceValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceValueTypeContext)
}

func (s *PredefinedTypeContext) ImmaterialValueType() IImmaterialValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImmaterialValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImmaterialValueTypeContext)
}

func (s *PredefinedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredefinedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredefinedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPredefinedType(s)
	}
}

func (s *PredefinedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPredefinedType(s)
	}
}

func (p *GQLParser) PredefinedType() (localctx IPredefinedTypeContext) {
	localctx = NewPredefinedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, GQLParserRULE_predefinedType)
	p.SetState(3259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserBOOL, GQLParserBOOLEAN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3252)
			p.BooleanType()
		}

	case GQLParserCHAR, GQLParserSTRING, GQLParserVARCHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3253)
			p.CharacterStringType()
		}

	case GQLParserBINARY, GQLParserBYTES, GQLParserVARBINARY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3254)
			p.ByteStringType()
		}

	case GQLParserBIG, GQLParserBIGINT, GQLParserDEC, GQLParserDECIMAL, GQLParserDOUBLE, GQLParserFLOAT, GQLParserFLOAT16, GQLParserFLOAT32, GQLParserFLOAT64, GQLParserFLOAT128, GQLParserFLOAT256, GQLParserINT, GQLParserINTEGER, GQLParserINT8, GQLParserINTEGER8, GQLParserINT16, GQLParserINTEGER16, GQLParserINT32, GQLParserINTEGER32, GQLParserINT64, GQLParserINTEGER64, GQLParserINT128, GQLParserINTEGER128, GQLParserINT256, GQLParserINTEGER256, GQLParserREAL, GQLParserSIGNED, GQLParserSMALL, GQLParserSMALLINT, GQLParserUBIGINT, GQLParserUINT, GQLParserUINT8, GQLParserUINT16, GQLParserUINT32, GQLParserUINT64, GQLParserUINT128, GQLParserUINT256, GQLParserUNSIGNED, GQLParserUSMALLINT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3255)
			p.NumericType()
		}

	case GQLParserDATE, GQLParserDURATION, GQLParserLOCAL, GQLParserTIME, GQLParserTIMESTAMP, GQLParserZONED:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3256)
			p.TemporalType()
		}

	case GQLParserANY, GQLParserBINDING, GQLParserDIRECTED, GQLParserEDGE, GQLParserGRAPH, GQLParserNODE, GQLParserPROPERTY, GQLParserRELATIONSHIP, GQLParserTABLE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3257)
			p.ReferenceValueType()
		}

	case GQLParserNOTHING, GQLParserNULL_KW:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3258)
			p.ImmaterialValueType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanTypeContext is an interface to support dynamic dispatch.
type IBooleanTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BOOL() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	NotNull() INotNullContext

	// IsBooleanTypeContext differentiates from other interfaces.
	IsBooleanTypeContext()
}

type BooleanTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanTypeContext() *BooleanTypeContext {
	var p = new(BooleanTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_booleanType
	return p
}

func InitEmptyBooleanTypeContext(p *BooleanTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_booleanType
}

func (*BooleanTypeContext) IsBooleanTypeContext() {}

func NewBooleanTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanTypeContext {
	var p = new(BooleanTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_booleanType

	return p
}

func (s *BooleanTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanTypeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(GQLParserBOOL, 0)
}

func (s *BooleanTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(GQLParserBOOLEAN, 0)
}

func (s *BooleanTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *BooleanTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBooleanType(s)
	}
}

func (s *BooleanTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBooleanType(s)
	}
}

func (p *GQLParser) BooleanType() (localctx IBooleanTypeContext) {
	localctx = NewBooleanTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, GQLParserRULE_booleanType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3261)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserBOOL || _la == GQLParserBOOLEAN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3263)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 311, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3262)
			p.NotNull()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharacterStringTypeContext is an interface to support dynamic dispatch.
type ICharacterStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	MaxLength() IMaxLengthContext
	RIGHT_PAREN() antlr.TerminalNode
	NotNull() INotNullContext
	MinLength() IMinLengthContext
	COMMA() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	FixedLength() IFixedLengthContext
	VARCHAR() antlr.TerminalNode

	// IsCharacterStringTypeContext differentiates from other interfaces.
	IsCharacterStringTypeContext()
}

type CharacterStringTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacterStringTypeContext() *CharacterStringTypeContext {
	var p = new(CharacterStringTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_characterStringType
	return p
}

func InitEmptyCharacterStringTypeContext(p *CharacterStringTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_characterStringType
}

func (*CharacterStringTypeContext) IsCharacterStringTypeContext() {}

func NewCharacterStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharacterStringTypeContext {
	var p = new(CharacterStringTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_characterStringType

	return p
}

func (s *CharacterStringTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CharacterStringTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(GQLParserSTRING, 0)
}

func (s *CharacterStringTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *CharacterStringTypeContext) MaxLength() IMaxLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaxLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaxLengthContext)
}

func (s *CharacterStringTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *CharacterStringTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *CharacterStringTypeContext) MinLength() IMinLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMinLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMinLengthContext)
}

func (s *CharacterStringTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *CharacterStringTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(GQLParserCHAR, 0)
}

func (s *CharacterStringTypeContext) FixedLength() IFixedLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFixedLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFixedLengthContext)
}

func (s *CharacterStringTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(GQLParserVARCHAR, 0)
}

func (s *CharacterStringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharacterStringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharacterStringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCharacterStringType(s)
	}
}

func (s *CharacterStringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCharacterStringType(s)
	}
}

func (p *GQLParser) CharacterStringType() (localctx ICharacterStringTypeContext) {
	localctx = NewCharacterStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, GQLParserRULE_characterStringType)
	p.SetState(3300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserSTRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3265)
			p.Match(GQLParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3275)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 313, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3266)
				p.Match(GQLParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3270)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 312, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3267)
					p.MinLength()
				}
				{
					p.SetState(3268)
					p.Match(GQLParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(3272)
				p.MaxLength()
			}
			{
				p.SetState(3273)
				p.Match(GQLParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3278)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 314, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3277)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserCHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3280)
			p.Match(GQLParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3285)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 315, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3281)
				p.Match(GQLParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3282)
				p.FixedLength()
			}
			{
				p.SetState(3283)
				p.Match(GQLParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3288)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 316, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3287)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserVARCHAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3290)
			p.Match(GQLParserVARCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3295)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 317, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3291)
				p.Match(GQLParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3292)
				p.MaxLength()
			}
			{
				p.SetState(3293)
				p.Match(GQLParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3298)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3297)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IByteStringTypeContext is an interface to support dynamic dispatch.
type IByteStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BYTES() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	MaxLength() IMaxLengthContext
	RIGHT_PAREN() antlr.TerminalNode
	NotNull() INotNullContext
	MinLength() IMinLengthContext
	COMMA() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	FixedLength() IFixedLengthContext
	VARBINARY() antlr.TerminalNode

	// IsByteStringTypeContext differentiates from other interfaces.
	IsByteStringTypeContext()
}

type ByteStringTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyByteStringTypeContext() *ByteStringTypeContext {
	var p = new(ByteStringTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_byteStringType
	return p
}

func InitEmptyByteStringTypeContext(p *ByteStringTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_byteStringType
}

func (*ByteStringTypeContext) IsByteStringTypeContext() {}

func NewByteStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ByteStringTypeContext {
	var p = new(ByteStringTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_byteStringType

	return p
}

func (s *ByteStringTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ByteStringTypeContext) BYTES() antlr.TerminalNode {
	return s.GetToken(GQLParserBYTES, 0)
}

func (s *ByteStringTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *ByteStringTypeContext) MaxLength() IMaxLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaxLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaxLengthContext)
}

func (s *ByteStringTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *ByteStringTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *ByteStringTypeContext) MinLength() IMinLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMinLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMinLengthContext)
}

func (s *ByteStringTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *ByteStringTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(GQLParserBINARY, 0)
}

func (s *ByteStringTypeContext) FixedLength() IFixedLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFixedLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFixedLengthContext)
}

func (s *ByteStringTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(GQLParserVARBINARY, 0)
}

func (s *ByteStringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ByteStringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ByteStringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterByteStringType(s)
	}
}

func (s *ByteStringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitByteStringType(s)
	}
}

func (p *GQLParser) ByteStringType() (localctx IByteStringTypeContext) {
	localctx = NewByteStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, GQLParserRULE_byteStringType)
	p.SetState(3337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserBYTES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3302)
			p.Match(GQLParserBYTES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3312)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 321, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3303)
				p.Match(GQLParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3307)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 320, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3304)
					p.MinLength()
				}
				{
					p.SetState(3305)
					p.Match(GQLParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(3309)
				p.MaxLength()
			}
			{
				p.SetState(3310)
				p.Match(GQLParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3315)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 322, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3314)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserBINARY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3317)
			p.Match(GQLParserBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3322)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3318)
				p.Match(GQLParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3319)
				p.FixedLength()
			}
			{
				p.SetState(3320)
				p.Match(GQLParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3325)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3324)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserVARBINARY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3327)
			p.Match(GQLParserVARBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3332)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 325, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3328)
				p.Match(GQLParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3329)
				p.MaxLength()
			}
			{
				p.SetState(3330)
				p.Match(GQLParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3335)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 326, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3334)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMinLengthContext is an interface to support dynamic dispatch.
type IMinLengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext

	// IsMinLengthContext differentiates from other interfaces.
	IsMinLengthContext()
}

type MinLengthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMinLengthContext() *MinLengthContext {
	var p = new(MinLengthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_minLength
	return p
}

func InitEmptyMinLengthContext(p *MinLengthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_minLength
}

func (*MinLengthContext) IsMinLengthContext() {}

func NewMinLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinLengthContext {
	var p = new(MinLengthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_minLength

	return p
}

func (s *MinLengthContext) GetParser() antlr.Parser { return s.parser }

func (s *MinLengthContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *MinLengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinLengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinLengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterMinLength(s)
	}
}

func (s *MinLengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitMinLength(s)
	}
}

func (p *GQLParser) MinLength() (localctx IMinLengthContext) {
	localctx = NewMinLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, GQLParserRULE_minLength)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3339)
		p.UnsignedInteger()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaxLengthContext is an interface to support dynamic dispatch.
type IMaxLengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext

	// IsMaxLengthContext differentiates from other interfaces.
	IsMaxLengthContext()
}

type MaxLengthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaxLengthContext() *MaxLengthContext {
	var p = new(MaxLengthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_maxLength
	return p
}

func InitEmptyMaxLengthContext(p *MaxLengthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_maxLength
}

func (*MaxLengthContext) IsMaxLengthContext() {}

func NewMaxLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaxLengthContext {
	var p = new(MaxLengthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_maxLength

	return p
}

func (s *MaxLengthContext) GetParser() antlr.Parser { return s.parser }

func (s *MaxLengthContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *MaxLengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaxLengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaxLengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterMaxLength(s)
	}
}

func (s *MaxLengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitMaxLength(s)
	}
}

func (p *GQLParser) MaxLength() (localctx IMaxLengthContext) {
	localctx = NewMaxLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, GQLParserRULE_maxLength)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3341)
		p.UnsignedInteger()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFixedLengthContext is an interface to support dynamic dispatch.
type IFixedLengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext

	// IsFixedLengthContext differentiates from other interfaces.
	IsFixedLengthContext()
}

type FixedLengthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixedLengthContext() *FixedLengthContext {
	var p = new(FixedLengthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fixedLength
	return p
}

func InitEmptyFixedLengthContext(p *FixedLengthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fixedLength
}

func (*FixedLengthContext) IsFixedLengthContext() {}

func NewFixedLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FixedLengthContext {
	var p = new(FixedLengthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fixedLength

	return p
}

func (s *FixedLengthContext) GetParser() antlr.Parser { return s.parser }

func (s *FixedLengthContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *FixedLengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FixedLengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FixedLengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFixedLength(s)
	}
}

func (s *FixedLengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFixedLength(s)
	}
}

func (p *GQLParser) FixedLength() (localctx IFixedLengthContext) {
	localctx = NewFixedLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, GQLParserRULE_fixedLength)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3343)
		p.UnsignedInteger()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumericTypeContext is an interface to support dynamic dispatch.
type INumericTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExactNumericType() IExactNumericTypeContext
	ApproximateNumericType() IApproximateNumericTypeContext

	// IsNumericTypeContext differentiates from other interfaces.
	IsNumericTypeContext()
}

type NumericTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericTypeContext() *NumericTypeContext {
	var p = new(NumericTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numericType
	return p
}

func InitEmptyNumericTypeContext(p *NumericTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numericType
}

func (*NumericTypeContext) IsNumericTypeContext() {}

func NewNumericTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericTypeContext {
	var p = new(NumericTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_numericType

	return p
}

func (s *NumericTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericTypeContext) ExactNumericType() IExactNumericTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExactNumericTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExactNumericTypeContext)
}

func (s *NumericTypeContext) ApproximateNumericType() IApproximateNumericTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IApproximateNumericTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IApproximateNumericTypeContext)
}

func (s *NumericTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNumericType(s)
	}
}

func (s *NumericTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNumericType(s)
	}
}

func (p *GQLParser) NumericType() (localctx INumericTypeContext) {
	localctx = NewNumericTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, GQLParserRULE_numericType)
	p.SetState(3347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserBIG, GQLParserBIGINT, GQLParserDEC, GQLParserDECIMAL, GQLParserINT, GQLParserINTEGER, GQLParserINT8, GQLParserINTEGER8, GQLParserINT16, GQLParserINTEGER16, GQLParserINT32, GQLParserINTEGER32, GQLParserINT64, GQLParserINTEGER64, GQLParserINT128, GQLParserINTEGER128, GQLParserINT256, GQLParserINTEGER256, GQLParserSIGNED, GQLParserSMALL, GQLParserSMALLINT, GQLParserUBIGINT, GQLParserUINT, GQLParserUINT8, GQLParserUINT16, GQLParserUINT32, GQLParserUINT64, GQLParserUINT128, GQLParserUINT256, GQLParserUNSIGNED, GQLParserUSMALLINT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3345)
			p.ExactNumericType()
		}

	case GQLParserDOUBLE, GQLParserFLOAT, GQLParserFLOAT16, GQLParserFLOAT32, GQLParserFLOAT64, GQLParserFLOAT128, GQLParserFLOAT256, GQLParserREAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3346)
			p.ApproximateNumericType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExactNumericTypeContext is an interface to support dynamic dispatch.
type IExactNumericTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BinaryExactNumericType() IBinaryExactNumericTypeContext
	DecimalExactNumericType() IDecimalExactNumericTypeContext

	// IsExactNumericTypeContext differentiates from other interfaces.
	IsExactNumericTypeContext()
}

type ExactNumericTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExactNumericTypeContext() *ExactNumericTypeContext {
	var p = new(ExactNumericTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_exactNumericType
	return p
}

func InitEmptyExactNumericTypeContext(p *ExactNumericTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_exactNumericType
}

func (*ExactNumericTypeContext) IsExactNumericTypeContext() {}

func NewExactNumericTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExactNumericTypeContext {
	var p = new(ExactNumericTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_exactNumericType

	return p
}

func (s *ExactNumericTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ExactNumericTypeContext) BinaryExactNumericType() IBinaryExactNumericTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinaryExactNumericTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinaryExactNumericTypeContext)
}

func (s *ExactNumericTypeContext) DecimalExactNumericType() IDecimalExactNumericTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalExactNumericTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalExactNumericTypeContext)
}

func (s *ExactNumericTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExactNumericTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExactNumericTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterExactNumericType(s)
	}
}

func (s *ExactNumericTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitExactNumericType(s)
	}
}

func (p *GQLParser) ExactNumericType() (localctx IExactNumericTypeContext) {
	localctx = NewExactNumericTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, GQLParserRULE_exactNumericType)
	p.SetState(3351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserBIG, GQLParserBIGINT, GQLParserINT, GQLParserINTEGER, GQLParserINT8, GQLParserINTEGER8, GQLParserINT16, GQLParserINTEGER16, GQLParserINT32, GQLParserINTEGER32, GQLParserINT64, GQLParserINTEGER64, GQLParserINT128, GQLParserINTEGER128, GQLParserINT256, GQLParserINTEGER256, GQLParserSIGNED, GQLParserSMALL, GQLParserSMALLINT, GQLParserUBIGINT, GQLParserUINT, GQLParserUINT8, GQLParserUINT16, GQLParserUINT32, GQLParserUINT64, GQLParserUINT128, GQLParserUINT256, GQLParserUNSIGNED, GQLParserUSMALLINT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3349)
			p.BinaryExactNumericType()
		}

	case GQLParserDEC, GQLParserDECIMAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3350)
			p.DecimalExactNumericType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBinaryExactNumericTypeContext is an interface to support dynamic dispatch.
type IBinaryExactNumericTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SignedBinaryExactNumericType() ISignedBinaryExactNumericTypeContext
	UnsignedBinaryExactNumericType() IUnsignedBinaryExactNumericTypeContext

	// IsBinaryExactNumericTypeContext differentiates from other interfaces.
	IsBinaryExactNumericTypeContext()
}

type BinaryExactNumericTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryExactNumericTypeContext() *BinaryExactNumericTypeContext {
	var p = new(BinaryExactNumericTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_binaryExactNumericType
	return p
}

func InitEmptyBinaryExactNumericTypeContext(p *BinaryExactNumericTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_binaryExactNumericType
}

func (*BinaryExactNumericTypeContext) IsBinaryExactNumericTypeContext() {}

func NewBinaryExactNumericTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryExactNumericTypeContext {
	var p = new(BinaryExactNumericTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_binaryExactNumericType

	return p
}

func (s *BinaryExactNumericTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryExactNumericTypeContext) SignedBinaryExactNumericType() ISignedBinaryExactNumericTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignedBinaryExactNumericTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignedBinaryExactNumericTypeContext)
}

func (s *BinaryExactNumericTypeContext) UnsignedBinaryExactNumericType() IUnsignedBinaryExactNumericTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedBinaryExactNumericTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedBinaryExactNumericTypeContext)
}

func (s *BinaryExactNumericTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryExactNumericTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryExactNumericTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBinaryExactNumericType(s)
	}
}

func (s *BinaryExactNumericTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBinaryExactNumericType(s)
	}
}

func (p *GQLParser) BinaryExactNumericType() (localctx IBinaryExactNumericTypeContext) {
	localctx = NewBinaryExactNumericTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, GQLParserRULE_binaryExactNumericType)
	p.SetState(3355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserBIG, GQLParserBIGINT, GQLParserINT, GQLParserINTEGER, GQLParserINT8, GQLParserINTEGER8, GQLParserINT16, GQLParserINTEGER16, GQLParserINT32, GQLParserINTEGER32, GQLParserINT64, GQLParserINTEGER64, GQLParserINT128, GQLParserINTEGER128, GQLParserINT256, GQLParserINTEGER256, GQLParserSIGNED, GQLParserSMALL, GQLParserSMALLINT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3353)
			p.SignedBinaryExactNumericType()
		}

	case GQLParserUBIGINT, GQLParserUINT, GQLParserUINT8, GQLParserUINT16, GQLParserUINT32, GQLParserUINT64, GQLParserUINT128, GQLParserUINT256, GQLParserUNSIGNED, GQLParserUSMALLINT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3354)
			p.UnsignedBinaryExactNumericType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignedBinaryExactNumericTypeContext is an interface to support dynamic dispatch.
type ISignedBinaryExactNumericTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT8() antlr.TerminalNode
	NotNull() INotNullContext
	INT16() antlr.TerminalNode
	INT32() antlr.TerminalNode
	INT64() antlr.TerminalNode
	INT128() antlr.TerminalNode
	INT256() antlr.TerminalNode
	SMALLINT() antlr.TerminalNode
	INT() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Precision() IPrecisionContext
	RIGHT_PAREN() antlr.TerminalNode
	BIGINT() antlr.TerminalNode
	VerboseBinaryExactNumericType() IVerboseBinaryExactNumericTypeContext
	SIGNED() antlr.TerminalNode

	// IsSignedBinaryExactNumericTypeContext differentiates from other interfaces.
	IsSignedBinaryExactNumericTypeContext()
}

type SignedBinaryExactNumericTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignedBinaryExactNumericTypeContext() *SignedBinaryExactNumericTypeContext {
	var p = new(SignedBinaryExactNumericTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_signedBinaryExactNumericType
	return p
}

func InitEmptySignedBinaryExactNumericTypeContext(p *SignedBinaryExactNumericTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_signedBinaryExactNumericType
}

func (*SignedBinaryExactNumericTypeContext) IsSignedBinaryExactNumericTypeContext() {}

func NewSignedBinaryExactNumericTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignedBinaryExactNumericTypeContext {
	var p = new(SignedBinaryExactNumericTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_signedBinaryExactNumericType

	return p
}

func (s *SignedBinaryExactNumericTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SignedBinaryExactNumericTypeContext) INT8() antlr.TerminalNode {
	return s.GetToken(GQLParserINT8, 0)
}

func (s *SignedBinaryExactNumericTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *SignedBinaryExactNumericTypeContext) INT16() antlr.TerminalNode {
	return s.GetToken(GQLParserINT16, 0)
}

func (s *SignedBinaryExactNumericTypeContext) INT32() antlr.TerminalNode {
	return s.GetToken(GQLParserINT32, 0)
}

func (s *SignedBinaryExactNumericTypeContext) INT64() antlr.TerminalNode {
	return s.GetToken(GQLParserINT64, 0)
}

func (s *SignedBinaryExactNumericTypeContext) INT128() antlr.TerminalNode {
	return s.GetToken(GQLParserINT128, 0)
}

func (s *SignedBinaryExactNumericTypeContext) INT256() antlr.TerminalNode {
	return s.GetToken(GQLParserINT256, 0)
}

func (s *SignedBinaryExactNumericTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(GQLParserSMALLINT, 0)
}

func (s *SignedBinaryExactNumericTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(GQLParserINT, 0)
}

func (s *SignedBinaryExactNumericTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *SignedBinaryExactNumericTypeContext) Precision() IPrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecisionContext)
}

func (s *SignedBinaryExactNumericTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *SignedBinaryExactNumericTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(GQLParserBIGINT, 0)
}

func (s *SignedBinaryExactNumericTypeContext) VerboseBinaryExactNumericType() IVerboseBinaryExactNumericTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVerboseBinaryExactNumericTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVerboseBinaryExactNumericTypeContext)
}

func (s *SignedBinaryExactNumericTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(GQLParserSIGNED, 0)
}

func (s *SignedBinaryExactNumericTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedBinaryExactNumericTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignedBinaryExactNumericTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSignedBinaryExactNumericType(s)
	}
}

func (s *SignedBinaryExactNumericTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSignedBinaryExactNumericType(s)
	}
}

func (p *GQLParser) SignedBinaryExactNumericType() (localctx ISignedBinaryExactNumericTypeContext) {
	localctx = NewSignedBinaryExactNumericTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, GQLParserRULE_signedBinaryExactNumericType)
	var _la int

	p.SetState(3403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserINT8:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3357)
			p.Match(GQLParserINT8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3359)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 331, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3358)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserINT16:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3361)
			p.Match(GQLParserINT16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3363)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3362)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserINT32:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3365)
			p.Match(GQLParserINT32)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3367)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 333, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3366)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserINT64:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3369)
			p.Match(GQLParserINT64)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3371)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 334, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3370)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserINT128:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3373)
			p.Match(GQLParserINT128)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3375)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 335, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3374)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserINT256:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3377)
			p.Match(GQLParserINT256)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3379)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 336, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3378)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserSMALLINT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3381)
			p.Match(GQLParserSMALLINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3383)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 337, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3382)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserINT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3385)
			p.Match(GQLParserINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3390)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 338, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3386)
				p.Match(GQLParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3387)
				p.Precision()
			}
			{
				p.SetState(3388)
				p.Match(GQLParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3393)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 339, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3392)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserBIGINT:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3395)
			p.Match(GQLParserBIGINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3397)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 340, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3396)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserBIG, GQLParserINTEGER, GQLParserINTEGER8, GQLParserINTEGER16, GQLParserINTEGER32, GQLParserINTEGER64, GQLParserINTEGER128, GQLParserINTEGER256, GQLParserSIGNED, GQLParserSMALL:
		p.EnterOuterAlt(localctx, 10)
		p.SetState(3400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserSIGNED {
			{
				p.SetState(3399)
				p.Match(GQLParserSIGNED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3402)
			p.VerboseBinaryExactNumericType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedBinaryExactNumericTypeContext is an interface to support dynamic dispatch.
type IUnsignedBinaryExactNumericTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UINT8() antlr.TerminalNode
	NotNull() INotNullContext
	UINT16() antlr.TerminalNode
	UINT32() antlr.TerminalNode
	UINT64() antlr.TerminalNode
	UINT128() antlr.TerminalNode
	UINT256() antlr.TerminalNode
	USMALLINT() antlr.TerminalNode
	UINT() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Precision() IPrecisionContext
	RIGHT_PAREN() antlr.TerminalNode
	UBIGINT() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	VerboseBinaryExactNumericType() IVerboseBinaryExactNumericTypeContext

	// IsUnsignedBinaryExactNumericTypeContext differentiates from other interfaces.
	IsUnsignedBinaryExactNumericTypeContext()
}

type UnsignedBinaryExactNumericTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedBinaryExactNumericTypeContext() *UnsignedBinaryExactNumericTypeContext {
	var p = new(UnsignedBinaryExactNumericTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_unsignedBinaryExactNumericType
	return p
}

func InitEmptyUnsignedBinaryExactNumericTypeContext(p *UnsignedBinaryExactNumericTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_unsignedBinaryExactNumericType
}

func (*UnsignedBinaryExactNumericTypeContext) IsUnsignedBinaryExactNumericTypeContext() {}

func NewUnsignedBinaryExactNumericTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedBinaryExactNumericTypeContext {
	var p = new(UnsignedBinaryExactNumericTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_unsignedBinaryExactNumericType

	return p
}

func (s *UnsignedBinaryExactNumericTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedBinaryExactNumericTypeContext) UINT8() antlr.TerminalNode {
	return s.GetToken(GQLParserUINT8, 0)
}

func (s *UnsignedBinaryExactNumericTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *UnsignedBinaryExactNumericTypeContext) UINT16() antlr.TerminalNode {
	return s.GetToken(GQLParserUINT16, 0)
}

func (s *UnsignedBinaryExactNumericTypeContext) UINT32() antlr.TerminalNode {
	return s.GetToken(GQLParserUINT32, 0)
}

func (s *UnsignedBinaryExactNumericTypeContext) UINT64() antlr.TerminalNode {
	return s.GetToken(GQLParserUINT64, 0)
}

func (s *UnsignedBinaryExactNumericTypeContext) UINT128() antlr.TerminalNode {
	return s.GetToken(GQLParserUINT128, 0)
}

func (s *UnsignedBinaryExactNumericTypeContext) UINT256() antlr.TerminalNode {
	return s.GetToken(GQLParserUINT256, 0)
}

func (s *UnsignedBinaryExactNumericTypeContext) USMALLINT() antlr.TerminalNode {
	return s.GetToken(GQLParserUSMALLINT, 0)
}

func (s *UnsignedBinaryExactNumericTypeContext) UINT() antlr.TerminalNode {
	return s.GetToken(GQLParserUINT, 0)
}

func (s *UnsignedBinaryExactNumericTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *UnsignedBinaryExactNumericTypeContext) Precision() IPrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecisionContext)
}

func (s *UnsignedBinaryExactNumericTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *UnsignedBinaryExactNumericTypeContext) UBIGINT() antlr.TerminalNode {
	return s.GetToken(GQLParserUBIGINT, 0)
}

func (s *UnsignedBinaryExactNumericTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED, 0)
}

func (s *UnsignedBinaryExactNumericTypeContext) VerboseBinaryExactNumericType() IVerboseBinaryExactNumericTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVerboseBinaryExactNumericTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVerboseBinaryExactNumericTypeContext)
}

func (s *UnsignedBinaryExactNumericTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedBinaryExactNumericTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedBinaryExactNumericTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterUnsignedBinaryExactNumericType(s)
	}
}

func (s *UnsignedBinaryExactNumericTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitUnsignedBinaryExactNumericType(s)
	}
}

func (p *GQLParser) UnsignedBinaryExactNumericType() (localctx IUnsignedBinaryExactNumericTypeContext) {
	localctx = NewUnsignedBinaryExactNumericTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, GQLParserRULE_unsignedBinaryExactNumericType)
	p.SetState(3449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserUINT8:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3405)
			p.Match(GQLParserUINT8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3407)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3406)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserUINT16:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3409)
			p.Match(GQLParserUINT16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3411)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 344, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3410)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserUINT32:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3413)
			p.Match(GQLParserUINT32)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3415)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 345, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3414)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserUINT64:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3417)
			p.Match(GQLParserUINT64)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3419)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 346, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3418)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserUINT128:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3421)
			p.Match(GQLParserUINT128)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3423)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 347, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3422)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserUINT256:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3425)
			p.Match(GQLParserUINT256)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3427)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 348, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3426)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserUSMALLINT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3429)
			p.Match(GQLParserUSMALLINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3431)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 349, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3430)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserUINT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3433)
			p.Match(GQLParserUINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3438)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 350, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3434)
				p.Match(GQLParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3435)
				p.Precision()
			}
			{
				p.SetState(3436)
				p.Match(GQLParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3441)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 351, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3440)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserUBIGINT:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3443)
			p.Match(GQLParserUBIGINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3445)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 352, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3444)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserUNSIGNED:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3447)
			p.Match(GQLParserUNSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3448)
			p.VerboseBinaryExactNumericType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVerboseBinaryExactNumericTypeContext is an interface to support dynamic dispatch.
type IVerboseBinaryExactNumericTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER8() antlr.TerminalNode
	NotNull() INotNullContext
	INTEGER16() antlr.TerminalNode
	INTEGER32() antlr.TerminalNode
	INTEGER64() antlr.TerminalNode
	INTEGER128() antlr.TerminalNode
	INTEGER256() antlr.TerminalNode
	SMALL() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Precision() IPrecisionContext
	RIGHT_PAREN() antlr.TerminalNode
	BIG() antlr.TerminalNode

	// IsVerboseBinaryExactNumericTypeContext differentiates from other interfaces.
	IsVerboseBinaryExactNumericTypeContext()
}

type VerboseBinaryExactNumericTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVerboseBinaryExactNumericTypeContext() *VerboseBinaryExactNumericTypeContext {
	var p = new(VerboseBinaryExactNumericTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_verboseBinaryExactNumericType
	return p
}

func InitEmptyVerboseBinaryExactNumericTypeContext(p *VerboseBinaryExactNumericTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_verboseBinaryExactNumericType
}

func (*VerboseBinaryExactNumericTypeContext) IsVerboseBinaryExactNumericTypeContext() {}

func NewVerboseBinaryExactNumericTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VerboseBinaryExactNumericTypeContext {
	var p = new(VerboseBinaryExactNumericTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_verboseBinaryExactNumericType

	return p
}

func (s *VerboseBinaryExactNumericTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *VerboseBinaryExactNumericTypeContext) INTEGER8() antlr.TerminalNode {
	return s.GetToken(GQLParserINTEGER8, 0)
}

func (s *VerboseBinaryExactNumericTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *VerboseBinaryExactNumericTypeContext) INTEGER16() antlr.TerminalNode {
	return s.GetToken(GQLParserINTEGER16, 0)
}

func (s *VerboseBinaryExactNumericTypeContext) INTEGER32() antlr.TerminalNode {
	return s.GetToken(GQLParserINTEGER32, 0)
}

func (s *VerboseBinaryExactNumericTypeContext) INTEGER64() antlr.TerminalNode {
	return s.GetToken(GQLParserINTEGER64, 0)
}

func (s *VerboseBinaryExactNumericTypeContext) INTEGER128() antlr.TerminalNode {
	return s.GetToken(GQLParserINTEGER128, 0)
}

func (s *VerboseBinaryExactNumericTypeContext) INTEGER256() antlr.TerminalNode {
	return s.GetToken(GQLParserINTEGER256, 0)
}

func (s *VerboseBinaryExactNumericTypeContext) SMALL() antlr.TerminalNode {
	return s.GetToken(GQLParserSMALL, 0)
}

func (s *VerboseBinaryExactNumericTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(GQLParserINTEGER, 0)
}

func (s *VerboseBinaryExactNumericTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *VerboseBinaryExactNumericTypeContext) Precision() IPrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecisionContext)
}

func (s *VerboseBinaryExactNumericTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *VerboseBinaryExactNumericTypeContext) BIG() antlr.TerminalNode {
	return s.GetToken(GQLParserBIG, 0)
}

func (s *VerboseBinaryExactNumericTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VerboseBinaryExactNumericTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VerboseBinaryExactNumericTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterVerboseBinaryExactNumericType(s)
	}
}

func (s *VerboseBinaryExactNumericTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitVerboseBinaryExactNumericType(s)
	}
}

func (p *GQLParser) VerboseBinaryExactNumericType() (localctx IVerboseBinaryExactNumericTypeContext) {
	localctx = NewVerboseBinaryExactNumericTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, GQLParserRULE_verboseBinaryExactNumericType)
	p.SetState(3495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserINTEGER8:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3451)
			p.Match(GQLParserINTEGER8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3453)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 354, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3452)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserINTEGER16:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3455)
			p.Match(GQLParserINTEGER16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3457)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 355, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3456)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserINTEGER32:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3459)
			p.Match(GQLParserINTEGER32)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3461)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 356, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3460)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserINTEGER64:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3463)
			p.Match(GQLParserINTEGER64)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3465)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 357, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3464)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserINTEGER128:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3467)
			p.Match(GQLParserINTEGER128)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3469)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 358, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3468)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserINTEGER256:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3471)
			p.Match(GQLParserINTEGER256)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3473)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 359, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3472)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserSMALL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3475)
			p.Match(GQLParserSMALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3476)
			p.Match(GQLParserINTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3478)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 360, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3477)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserINTEGER:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3480)
			p.Match(GQLParserINTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3485)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 361, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3481)
				p.Match(GQLParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3482)
				p.Precision()
			}
			{
				p.SetState(3483)
				p.Match(GQLParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3488)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 362, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3487)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserBIG:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3490)
			p.Match(GQLParserBIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3491)
			p.Match(GQLParserINTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3493)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 363, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3492)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecimalExactNumericTypeContext is an interface to support dynamic dispatch.
type IDecimalExactNumericTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL() antlr.TerminalNode
	DEC() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Precision() IPrecisionContext
	RIGHT_PAREN() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	Scale() IScaleContext
	NotNull() INotNullContext

	// IsDecimalExactNumericTypeContext differentiates from other interfaces.
	IsDecimalExactNumericTypeContext()
}

type DecimalExactNumericTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalExactNumericTypeContext() *DecimalExactNumericTypeContext {
	var p = new(DecimalExactNumericTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_decimalExactNumericType
	return p
}

func InitEmptyDecimalExactNumericTypeContext(p *DecimalExactNumericTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_decimalExactNumericType
}

func (*DecimalExactNumericTypeContext) IsDecimalExactNumericTypeContext() {}

func NewDecimalExactNumericTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalExactNumericTypeContext {
	var p = new(DecimalExactNumericTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_decimalExactNumericType

	return p
}

func (s *DecimalExactNumericTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalExactNumericTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(GQLParserDECIMAL, 0)
}

func (s *DecimalExactNumericTypeContext) DEC() antlr.TerminalNode {
	return s.GetToken(GQLParserDEC, 0)
}

func (s *DecimalExactNumericTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *DecimalExactNumericTypeContext) Precision() IPrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecisionContext)
}

func (s *DecimalExactNumericTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *DecimalExactNumericTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *DecimalExactNumericTypeContext) Scale() IScaleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScaleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScaleContext)
}

func (s *DecimalExactNumericTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *DecimalExactNumericTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalExactNumericTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalExactNumericTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDecimalExactNumericType(s)
	}
}

func (s *DecimalExactNumericTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDecimalExactNumericType(s)
	}
}

func (p *GQLParser) DecimalExactNumericType() (localctx IDecimalExactNumericTypeContext) {
	localctx = NewDecimalExactNumericTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, GQLParserRULE_decimalExactNumericType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3497)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserDEC || _la == GQLParserDECIMAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3508)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 367, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3498)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3499)
			p.Precision()
		}
		p.SetState(3502)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserCOMMA {
			{
				p.SetState(3500)
				p.Match(GQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3501)
				p.Scale()
			}

		}
		{
			p.SetState(3504)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3506)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 366, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3505)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrecisionContext is an interface to support dynamic dispatch.
type IPrecisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedDecimalInteger() IUnsignedDecimalIntegerContext

	// IsPrecisionContext differentiates from other interfaces.
	IsPrecisionContext()
}

type PrecisionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecisionContext() *PrecisionContext {
	var p = new(PrecisionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_precision
	return p
}

func InitEmptyPrecisionContext(p *PrecisionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_precision
}

func (*PrecisionContext) IsPrecisionContext() {}

func NewPrecisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecisionContext {
	var p = new(PrecisionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_precision

	return p
}

func (s *PrecisionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecisionContext) UnsignedDecimalInteger() IUnsignedDecimalIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedDecimalIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedDecimalIntegerContext)
}

func (s *PrecisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrecisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPrecision(s)
	}
}

func (s *PrecisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPrecision(s)
	}
}

func (p *GQLParser) Precision() (localctx IPrecisionContext) {
	localctx = NewPrecisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, GQLParserRULE_precision)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3510)
		p.UnsignedDecimalInteger()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScaleContext is an interface to support dynamic dispatch.
type IScaleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedDecimalInteger() IUnsignedDecimalIntegerContext

	// IsScaleContext differentiates from other interfaces.
	IsScaleContext()
}

type ScaleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScaleContext() *ScaleContext {
	var p = new(ScaleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_scale
	return p
}

func InitEmptyScaleContext(p *ScaleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_scale
}

func (*ScaleContext) IsScaleContext() {}

func NewScaleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScaleContext {
	var p = new(ScaleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_scale

	return p
}

func (s *ScaleContext) GetParser() antlr.Parser { return s.parser }

func (s *ScaleContext) UnsignedDecimalInteger() IUnsignedDecimalIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedDecimalIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedDecimalIntegerContext)
}

func (s *ScaleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScaleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScaleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterScale(s)
	}
}

func (s *ScaleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitScale(s)
	}
}

func (p *GQLParser) Scale() (localctx IScaleContext) {
	localctx = NewScaleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, GQLParserRULE_scale)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3512)
		p.UnsignedDecimalInteger()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IApproximateNumericTypeContext is an interface to support dynamic dispatch.
type IApproximateNumericTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOAT16() antlr.TerminalNode
	NotNull() INotNullContext
	FLOAT32() antlr.TerminalNode
	FLOAT64() antlr.TerminalNode
	FLOAT128() antlr.TerminalNode
	FLOAT256() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Precision() IPrecisionContext
	RIGHT_PAREN() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	Scale() IScaleContext
	REAL() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	PRECISION() antlr.TerminalNode

	// IsApproximateNumericTypeContext differentiates from other interfaces.
	IsApproximateNumericTypeContext()
}

type ApproximateNumericTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApproximateNumericTypeContext() *ApproximateNumericTypeContext {
	var p = new(ApproximateNumericTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_approximateNumericType
	return p
}

func InitEmptyApproximateNumericTypeContext(p *ApproximateNumericTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_approximateNumericType
}

func (*ApproximateNumericTypeContext) IsApproximateNumericTypeContext() {}

func NewApproximateNumericTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ApproximateNumericTypeContext {
	var p = new(ApproximateNumericTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_approximateNumericType

	return p
}

func (s *ApproximateNumericTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ApproximateNumericTypeContext) FLOAT16() antlr.TerminalNode {
	return s.GetToken(GQLParserFLOAT16, 0)
}

func (s *ApproximateNumericTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *ApproximateNumericTypeContext) FLOAT32() antlr.TerminalNode {
	return s.GetToken(GQLParserFLOAT32, 0)
}

func (s *ApproximateNumericTypeContext) FLOAT64() antlr.TerminalNode {
	return s.GetToken(GQLParserFLOAT64, 0)
}

func (s *ApproximateNumericTypeContext) FLOAT128() antlr.TerminalNode {
	return s.GetToken(GQLParserFLOAT128, 0)
}

func (s *ApproximateNumericTypeContext) FLOAT256() antlr.TerminalNode {
	return s.GetToken(GQLParserFLOAT256, 0)
}

func (s *ApproximateNumericTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(GQLParserFLOAT, 0)
}

func (s *ApproximateNumericTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *ApproximateNumericTypeContext) Precision() IPrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecisionContext)
}

func (s *ApproximateNumericTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *ApproximateNumericTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *ApproximateNumericTypeContext) Scale() IScaleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScaleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScaleContext)
}

func (s *ApproximateNumericTypeContext) REAL() antlr.TerminalNode {
	return s.GetToken(GQLParserREAL, 0)
}

func (s *ApproximateNumericTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(GQLParserDOUBLE, 0)
}

func (s *ApproximateNumericTypeContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(GQLParserPRECISION, 0)
}

func (s *ApproximateNumericTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApproximateNumericTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ApproximateNumericTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterApproximateNumericType(s)
	}
}

func (s *ApproximateNumericTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitApproximateNumericType(s)
	}
}

func (p *GQLParser) ApproximateNumericType() (localctx IApproximateNumericTypeContext) {
	localctx = NewApproximateNumericTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, GQLParserRULE_approximateNumericType)
	var _la int

	p.SetState(3559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserFLOAT16:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3514)
			p.Match(GQLParserFLOAT16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3516)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 368, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3515)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserFLOAT32:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3518)
			p.Match(GQLParserFLOAT32)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3520)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 369, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3519)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserFLOAT64:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3522)
			p.Match(GQLParserFLOAT64)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3524)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 370, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3523)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserFLOAT128:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3526)
			p.Match(GQLParserFLOAT128)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3528)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 371, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3527)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserFLOAT256:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3530)
			p.Match(GQLParserFLOAT256)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3532)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 372, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3531)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserFLOAT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3534)
			p.Match(GQLParserFLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3543)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 374, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3535)
				p.Match(GQLParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3536)
				p.Precision()
			}
			p.SetState(3539)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == GQLParserCOMMA {
				{
					p.SetState(3537)
					p.Match(GQLParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3538)
					p.Scale()
				}

			}
			{
				p.SetState(3541)
				p.Match(GQLParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3546)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 375, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3545)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserREAL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3548)
			p.Match(GQLParserREAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3550)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 376, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3549)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserDOUBLE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3552)
			p.Match(GQLParserDOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3554)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 377, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3553)
				p.Match(GQLParserPRECISION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3557)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 378, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3556)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemporalTypeContext is an interface to support dynamic dispatch.
type ITemporalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TemporalInstantType() ITemporalInstantTypeContext
	TemporalDurationType() ITemporalDurationTypeContext

	// IsTemporalTypeContext differentiates from other interfaces.
	IsTemporalTypeContext()
}

type TemporalTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemporalTypeContext() *TemporalTypeContext {
	var p = new(TemporalTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_temporalType
	return p
}

func InitEmptyTemporalTypeContext(p *TemporalTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_temporalType
}

func (*TemporalTypeContext) IsTemporalTypeContext() {}

func NewTemporalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemporalTypeContext {
	var p = new(TemporalTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_temporalType

	return p
}

func (s *TemporalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TemporalTypeContext) TemporalInstantType() ITemporalInstantTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemporalInstantTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemporalInstantTypeContext)
}

func (s *TemporalTypeContext) TemporalDurationType() ITemporalDurationTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemporalDurationTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemporalDurationTypeContext)
}

func (s *TemporalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemporalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemporalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTemporalType(s)
	}
}

func (s *TemporalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTemporalType(s)
	}
}

func (p *GQLParser) TemporalType() (localctx ITemporalTypeContext) {
	localctx = NewTemporalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, GQLParserRULE_temporalType)
	p.SetState(3563)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserDATE, GQLParserLOCAL, GQLParserTIME, GQLParserTIMESTAMP, GQLParserZONED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3561)
			p.TemporalInstantType()
		}

	case GQLParserDURATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3562)
			p.TemporalDurationType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemporalInstantTypeContext is an interface to support dynamic dispatch.
type ITemporalInstantTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DatetimeType() IDatetimeTypeContext
	LocaldatetimeType() ILocaldatetimeTypeContext
	DateType() IDateTypeContext
	TimeType() ITimeTypeContext
	LocaltimeType() ILocaltimeTypeContext

	// IsTemporalInstantTypeContext differentiates from other interfaces.
	IsTemporalInstantTypeContext()
}

type TemporalInstantTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemporalInstantTypeContext() *TemporalInstantTypeContext {
	var p = new(TemporalInstantTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_temporalInstantType
	return p
}

func InitEmptyTemporalInstantTypeContext(p *TemporalInstantTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_temporalInstantType
}

func (*TemporalInstantTypeContext) IsTemporalInstantTypeContext() {}

func NewTemporalInstantTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemporalInstantTypeContext {
	var p = new(TemporalInstantTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_temporalInstantType

	return p
}

func (s *TemporalInstantTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TemporalInstantTypeContext) DatetimeType() IDatetimeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeTypeContext)
}

func (s *TemporalInstantTypeContext) LocaldatetimeType() ILocaldatetimeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocaldatetimeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocaldatetimeTypeContext)
}

func (s *TemporalInstantTypeContext) DateType() IDateTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTypeContext)
}

func (s *TemporalInstantTypeContext) TimeType() ITimeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeTypeContext)
}

func (s *TemporalInstantTypeContext) LocaltimeType() ILocaltimeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocaltimeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocaltimeTypeContext)
}

func (s *TemporalInstantTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemporalInstantTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemporalInstantTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTemporalInstantType(s)
	}
}

func (s *TemporalInstantTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTemporalInstantType(s)
	}
}

func (p *GQLParser) TemporalInstantType() (localctx ITemporalInstantTypeContext) {
	localctx = NewTemporalInstantTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, GQLParserRULE_temporalInstantType)
	p.SetState(3570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 381, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3565)
			p.DatetimeType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3566)
			p.LocaldatetimeType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3567)
			p.DateType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3568)
			p.TimeType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3569)
			p.LocaltimeType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatetimeTypeContext is an interface to support dynamic dispatch.
type IDatetimeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ZONED() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	NotNull() INotNullContext
	TIMESTAMP() antlr.TerminalNode
	WITH() antlr.TerminalNode
	TIME() antlr.TerminalNode
	ZONE() antlr.TerminalNode

	// IsDatetimeTypeContext differentiates from other interfaces.
	IsDatetimeTypeContext()
}

type DatetimeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetimeTypeContext() *DatetimeTypeContext {
	var p = new(DatetimeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeType
	return p
}

func InitEmptyDatetimeTypeContext(p *DatetimeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeType
}

func (*DatetimeTypeContext) IsDatetimeTypeContext() {}

func NewDatetimeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatetimeTypeContext {
	var p = new(DatetimeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_datetimeType

	return p
}

func (s *DatetimeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DatetimeTypeContext) ZONED() antlr.TerminalNode {
	return s.GetToken(GQLParserZONED, 0)
}

func (s *DatetimeTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(GQLParserDATETIME, 0)
}

func (s *DatetimeTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *DatetimeTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(GQLParserTIMESTAMP, 0)
}

func (s *DatetimeTypeContext) WITH() antlr.TerminalNode {
	return s.GetToken(GQLParserWITH, 0)
}

func (s *DatetimeTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(GQLParserTIME, 0)
}

func (s *DatetimeTypeContext) ZONE() antlr.TerminalNode {
	return s.GetToken(GQLParserZONE, 0)
}

func (s *DatetimeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatetimeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatetimeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDatetimeType(s)
	}
}

func (s *DatetimeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDatetimeType(s)
	}
}

func (p *GQLParser) DatetimeType() (localctx IDatetimeTypeContext) {
	localctx = NewDatetimeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, GQLParserRULE_datetimeType)
	p.SetState(3584)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserZONED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3572)
			p.Match(GQLParserZONED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3573)
			p.Match(GQLParserDATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3575)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 382, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3574)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserTIMESTAMP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3577)
			p.Match(GQLParserTIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3578)
			p.Match(GQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3579)
			p.Match(GQLParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3580)
			p.Match(GQLParserZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3582)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 383, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3581)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocaldatetimeTypeContext is an interface to support dynamic dispatch.
type ILocaldatetimeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	NotNull() INotNullContext
	TIMESTAMP() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	TIME() antlr.TerminalNode
	ZONE() antlr.TerminalNode

	// IsLocaldatetimeTypeContext differentiates from other interfaces.
	IsLocaldatetimeTypeContext()
}

type LocaldatetimeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocaldatetimeTypeContext() *LocaldatetimeTypeContext {
	var p = new(LocaldatetimeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_localdatetimeType
	return p
}

func InitEmptyLocaldatetimeTypeContext(p *LocaldatetimeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_localdatetimeType
}

func (*LocaldatetimeTypeContext) IsLocaldatetimeTypeContext() {}

func NewLocaldatetimeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocaldatetimeTypeContext {
	var p = new(LocaldatetimeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_localdatetimeType

	return p
}

func (s *LocaldatetimeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *LocaldatetimeTypeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(GQLParserLOCAL, 0)
}

func (s *LocaldatetimeTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(GQLParserDATETIME, 0)
}

func (s *LocaldatetimeTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *LocaldatetimeTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(GQLParserTIMESTAMP, 0)
}

func (s *LocaldatetimeTypeContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(GQLParserWITHOUT, 0)
}

func (s *LocaldatetimeTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(GQLParserTIME, 0)
}

func (s *LocaldatetimeTypeContext) ZONE() antlr.TerminalNode {
	return s.GetToken(GQLParserZONE, 0)
}

func (s *LocaldatetimeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocaldatetimeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocaldatetimeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLocaldatetimeType(s)
	}
}

func (s *LocaldatetimeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLocaldatetimeType(s)
	}
}

func (p *GQLParser) LocaldatetimeType() (localctx ILocaldatetimeTypeContext) {
	localctx = NewLocaldatetimeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, GQLParserRULE_localdatetimeType)
	p.SetState(3600)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserLOCAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3586)
			p.Match(GQLParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3587)
			p.Match(GQLParserDATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3589)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 385, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3588)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserTIMESTAMP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3591)
			p.Match(GQLParserTIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3595)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 386, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3592)
				p.Match(GQLParserWITHOUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3593)
				p.Match(GQLParserTIME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3594)
				p.Match(GQLParserZONE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3598)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 387, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3597)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateTypeContext is an interface to support dynamic dispatch.
type IDateTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATE() antlr.TerminalNode
	NotNull() INotNullContext

	// IsDateTypeContext differentiates from other interfaces.
	IsDateTypeContext()
}

type DateTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateTypeContext() *DateTypeContext {
	var p = new(DateTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dateType
	return p
}

func InitEmptyDateTypeContext(p *DateTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dateType
}

func (*DateTypeContext) IsDateTypeContext() {}

func NewDateTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateTypeContext {
	var p = new(DateTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_dateType

	return p
}

func (s *DateTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DateTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(GQLParserDATE, 0)
}

func (s *DateTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *DateTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDateType(s)
	}
}

func (s *DateTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDateType(s)
	}
}

func (p *GQLParser) DateType() (localctx IDateTypeContext) {
	localctx = NewDateTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, GQLParserRULE_dateType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3602)
		p.Match(GQLParserDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3604)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 389, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3603)
			p.NotNull()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeTypeContext is an interface to support dynamic dispatch.
type ITimeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ZONED() antlr.TerminalNode
	AllTIME() []antlr.TerminalNode
	TIME(i int) antlr.TerminalNode
	NotNull() INotNullContext
	WITH() antlr.TerminalNode
	ZONE() antlr.TerminalNode

	// IsTimeTypeContext differentiates from other interfaces.
	IsTimeTypeContext()
}

type TimeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeTypeContext() *TimeTypeContext {
	var p = new(TimeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_timeType
	return p
}

func InitEmptyTimeTypeContext(p *TimeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_timeType
}

func (*TimeTypeContext) IsTimeTypeContext() {}

func NewTimeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeTypeContext {
	var p = new(TimeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_timeType

	return p
}

func (s *TimeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeTypeContext) ZONED() antlr.TerminalNode {
	return s.GetToken(GQLParserZONED, 0)
}

func (s *TimeTypeContext) AllTIME() []antlr.TerminalNode {
	return s.GetTokens(GQLParserTIME)
}

func (s *TimeTypeContext) TIME(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserTIME, i)
}

func (s *TimeTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *TimeTypeContext) WITH() antlr.TerminalNode {
	return s.GetToken(GQLParserWITH, 0)
}

func (s *TimeTypeContext) ZONE() antlr.TerminalNode {
	return s.GetToken(GQLParserZONE, 0)
}

func (s *TimeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTimeType(s)
	}
}

func (s *TimeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTimeType(s)
	}
}

func (p *GQLParser) TimeType() (localctx ITimeTypeContext) {
	localctx = NewTimeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, GQLParserRULE_timeType)
	p.SetState(3618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserZONED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3606)
			p.Match(GQLParserZONED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3607)
			p.Match(GQLParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3609)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 390, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3608)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserTIME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3611)
			p.Match(GQLParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3612)
			p.Match(GQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3613)
			p.Match(GQLParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3614)
			p.Match(GQLParserZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3616)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 391, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3615)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocaltimeTypeContext is an interface to support dynamic dispatch.
type ILocaltimeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL() antlr.TerminalNode
	AllTIME() []antlr.TerminalNode
	TIME(i int) antlr.TerminalNode
	NotNull() INotNullContext
	WITHOUT() antlr.TerminalNode
	ZONE() antlr.TerminalNode

	// IsLocaltimeTypeContext differentiates from other interfaces.
	IsLocaltimeTypeContext()
}

type LocaltimeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocaltimeTypeContext() *LocaltimeTypeContext {
	var p = new(LocaltimeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_localtimeType
	return p
}

func InitEmptyLocaltimeTypeContext(p *LocaltimeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_localtimeType
}

func (*LocaltimeTypeContext) IsLocaltimeTypeContext() {}

func NewLocaltimeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocaltimeTypeContext {
	var p = new(LocaltimeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_localtimeType

	return p
}

func (s *LocaltimeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *LocaltimeTypeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(GQLParserLOCAL, 0)
}

func (s *LocaltimeTypeContext) AllTIME() []antlr.TerminalNode {
	return s.GetTokens(GQLParserTIME)
}

func (s *LocaltimeTypeContext) TIME(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserTIME, i)
}

func (s *LocaltimeTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *LocaltimeTypeContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(GQLParserWITHOUT, 0)
}

func (s *LocaltimeTypeContext) ZONE() antlr.TerminalNode {
	return s.GetToken(GQLParserZONE, 0)
}

func (s *LocaltimeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocaltimeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocaltimeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLocaltimeType(s)
	}
}

func (s *LocaltimeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLocaltimeType(s)
	}
}

func (p *GQLParser) LocaltimeType() (localctx ILocaltimeTypeContext) {
	localctx = NewLocaltimeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, GQLParserRULE_localtimeType)
	p.SetState(3632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserLOCAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3620)
			p.Match(GQLParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3621)
			p.Match(GQLParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3623)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 393, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3622)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case GQLParserTIME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3625)
			p.Match(GQLParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3626)
			p.Match(GQLParserWITHOUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3627)
			p.Match(GQLParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3628)
			p.Match(GQLParserZONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3630)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 394, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3629)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemporalDurationTypeContext is an interface to support dynamic dispatch.
type ITemporalDurationTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DURATION() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	TemporalDurationQualifier() ITemporalDurationQualifierContext
	RIGHT_PAREN() antlr.TerminalNode
	NotNull() INotNullContext

	// IsTemporalDurationTypeContext differentiates from other interfaces.
	IsTemporalDurationTypeContext()
}

type TemporalDurationTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemporalDurationTypeContext() *TemporalDurationTypeContext {
	var p = new(TemporalDurationTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_temporalDurationType
	return p
}

func InitEmptyTemporalDurationTypeContext(p *TemporalDurationTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_temporalDurationType
}

func (*TemporalDurationTypeContext) IsTemporalDurationTypeContext() {}

func NewTemporalDurationTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemporalDurationTypeContext {
	var p = new(TemporalDurationTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_temporalDurationType

	return p
}

func (s *TemporalDurationTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TemporalDurationTypeContext) DURATION() antlr.TerminalNode {
	return s.GetToken(GQLParserDURATION, 0)
}

func (s *TemporalDurationTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *TemporalDurationTypeContext) TemporalDurationQualifier() ITemporalDurationQualifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemporalDurationQualifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemporalDurationQualifierContext)
}

func (s *TemporalDurationTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *TemporalDurationTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *TemporalDurationTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemporalDurationTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemporalDurationTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTemporalDurationType(s)
	}
}

func (s *TemporalDurationTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTemporalDurationType(s)
	}
}

func (p *GQLParser) TemporalDurationType() (localctx ITemporalDurationTypeContext) {
	localctx = NewTemporalDurationTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, GQLParserRULE_temporalDurationType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3634)
		p.Match(GQLParserDURATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3635)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3636)
		p.TemporalDurationQualifier()
	}
	{
		p.SetState(3637)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3639)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 396, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3638)
			p.NotNull()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemporalDurationQualifierContext is an interface to support dynamic dispatch.
type ITemporalDurationQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YEAR() antlr.TerminalNode
	TO() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	DAY() antlr.TerminalNode
	SECOND() antlr.TerminalNode

	// IsTemporalDurationQualifierContext differentiates from other interfaces.
	IsTemporalDurationQualifierContext()
}

type TemporalDurationQualifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemporalDurationQualifierContext() *TemporalDurationQualifierContext {
	var p = new(TemporalDurationQualifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_temporalDurationQualifier
	return p
}

func InitEmptyTemporalDurationQualifierContext(p *TemporalDurationQualifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_temporalDurationQualifier
}

func (*TemporalDurationQualifierContext) IsTemporalDurationQualifierContext() {}

func NewTemporalDurationQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemporalDurationQualifierContext {
	var p = new(TemporalDurationQualifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_temporalDurationQualifier

	return p
}

func (s *TemporalDurationQualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TemporalDurationQualifierContext) YEAR() antlr.TerminalNode {
	return s.GetToken(GQLParserYEAR, 0)
}

func (s *TemporalDurationQualifierContext) TO() antlr.TerminalNode {
	return s.GetToken(GQLParserTO, 0)
}

func (s *TemporalDurationQualifierContext) MONTH() antlr.TerminalNode {
	return s.GetToken(GQLParserMONTH, 0)
}

func (s *TemporalDurationQualifierContext) DAY() antlr.TerminalNode {
	return s.GetToken(GQLParserDAY, 0)
}

func (s *TemporalDurationQualifierContext) SECOND() antlr.TerminalNode {
	return s.GetToken(GQLParserSECOND, 0)
}

func (s *TemporalDurationQualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemporalDurationQualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemporalDurationQualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTemporalDurationQualifier(s)
	}
}

func (s *TemporalDurationQualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTemporalDurationQualifier(s)
	}
}

func (p *GQLParser) TemporalDurationQualifier() (localctx ITemporalDurationQualifierContext) {
	localctx = NewTemporalDurationQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, GQLParserRULE_temporalDurationQualifier)
	p.SetState(3647)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserYEAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3641)
			p.Match(GQLParserYEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3642)
			p.Match(GQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3643)
			p.Match(GQLParserMONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserDAY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3644)
			p.Match(GQLParserDAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3645)
			p.Match(GQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3646)
			p.Match(GQLParserSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferenceValueTypeContext is an interface to support dynamic dispatch.
type IReferenceValueTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GraphReferenceValueType() IGraphReferenceValueTypeContext
	BindingTableReferenceValueType() IBindingTableReferenceValueTypeContext
	NodeReferenceValueType() INodeReferenceValueTypeContext
	EdgeReferenceValueType() IEdgeReferenceValueTypeContext

	// IsReferenceValueTypeContext differentiates from other interfaces.
	IsReferenceValueTypeContext()
}

type ReferenceValueTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceValueTypeContext() *ReferenceValueTypeContext {
	var p = new(ReferenceValueTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_referenceValueType
	return p
}

func InitEmptyReferenceValueTypeContext(p *ReferenceValueTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_referenceValueType
}

func (*ReferenceValueTypeContext) IsReferenceValueTypeContext() {}

func NewReferenceValueTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceValueTypeContext {
	var p = new(ReferenceValueTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_referenceValueType

	return p
}

func (s *ReferenceValueTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceValueTypeContext) GraphReferenceValueType() IGraphReferenceValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphReferenceValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphReferenceValueTypeContext)
}

func (s *ReferenceValueTypeContext) BindingTableReferenceValueType() IBindingTableReferenceValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingTableReferenceValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingTableReferenceValueTypeContext)
}

func (s *ReferenceValueTypeContext) NodeReferenceValueType() INodeReferenceValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeReferenceValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeReferenceValueTypeContext)
}

func (s *ReferenceValueTypeContext) EdgeReferenceValueType() IEdgeReferenceValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeReferenceValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeReferenceValueTypeContext)
}

func (s *ReferenceValueTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceValueTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceValueTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterReferenceValueType(s)
	}
}

func (s *ReferenceValueTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitReferenceValueType(s)
	}
}

func (p *GQLParser) ReferenceValueType() (localctx IReferenceValueTypeContext) {
	localctx = NewReferenceValueTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, GQLParserRULE_referenceValueType)
	p.SetState(3653)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 398, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3649)
			p.GraphReferenceValueType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3650)
			p.BindingTableReferenceValueType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3651)
			p.NodeReferenceValueType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3652)
			p.EdgeReferenceValueType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImmaterialValueTypeContext is an interface to support dynamic dispatch.
type IImmaterialValueTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NullType() INullTypeContext
	EmptyType() IEmptyTypeContext

	// IsImmaterialValueTypeContext differentiates from other interfaces.
	IsImmaterialValueTypeContext()
}

type ImmaterialValueTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImmaterialValueTypeContext() *ImmaterialValueTypeContext {
	var p = new(ImmaterialValueTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_immaterialValueType
	return p
}

func InitEmptyImmaterialValueTypeContext(p *ImmaterialValueTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_immaterialValueType
}

func (*ImmaterialValueTypeContext) IsImmaterialValueTypeContext() {}

func NewImmaterialValueTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImmaterialValueTypeContext {
	var p = new(ImmaterialValueTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_immaterialValueType

	return p
}

func (s *ImmaterialValueTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ImmaterialValueTypeContext) NullType() INullTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullTypeContext)
}

func (s *ImmaterialValueTypeContext) EmptyType() IEmptyTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyTypeContext)
}

func (s *ImmaterialValueTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImmaterialValueTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImmaterialValueTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterImmaterialValueType(s)
	}
}

func (s *ImmaterialValueTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitImmaterialValueType(s)
	}
}

func (p *GQLParser) ImmaterialValueType() (localctx IImmaterialValueTypeContext) {
	localctx = NewImmaterialValueTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, GQLParserRULE_immaterialValueType)
	p.SetState(3657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 399, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3655)
			p.NullType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3656)
			p.EmptyType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullTypeContext is an interface to support dynamic dispatch.
type INullTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_KW() antlr.TerminalNode

	// IsNullTypeContext differentiates from other interfaces.
	IsNullTypeContext()
}

type NullTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullTypeContext() *NullTypeContext {
	var p = new(NullTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nullType
	return p
}

func InitEmptyNullTypeContext(p *NullTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nullType
}

func (*NullTypeContext) IsNullTypeContext() {}

func NewNullTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullTypeContext {
	var p = new(NullTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nullType

	return p
}

func (s *NullTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NullTypeContext) NULL_KW() antlr.TerminalNode {
	return s.GetToken(GQLParserNULL_KW, 0)
}

func (s *NullTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNullType(s)
	}
}

func (s *NullTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNullType(s)
	}
}

func (p *GQLParser) NullType() (localctx INullTypeContext) {
	localctx = NewNullTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, GQLParserRULE_nullType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3659)
		p.Match(GQLParserNULL_KW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyTypeContext is an interface to support dynamic dispatch.
type IEmptyTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_KW() antlr.TerminalNode
	NotNull() INotNullContext
	NOTHING() antlr.TerminalNode

	// IsEmptyTypeContext differentiates from other interfaces.
	IsEmptyTypeContext()
}

type EmptyTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyTypeContext() *EmptyTypeContext {
	var p = new(EmptyTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_emptyType
	return p
}

func InitEmptyEmptyTypeContext(p *EmptyTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_emptyType
}

func (*EmptyTypeContext) IsEmptyTypeContext() {}

func NewEmptyTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyTypeContext {
	var p = new(EmptyTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_emptyType

	return p
}

func (s *EmptyTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *EmptyTypeContext) NULL_KW() antlr.TerminalNode {
	return s.GetToken(GQLParserNULL_KW, 0)
}

func (s *EmptyTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *EmptyTypeContext) NOTHING() antlr.TerminalNode {
	return s.GetToken(GQLParserNOTHING, 0)
}

func (s *EmptyTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEmptyType(s)
	}
}

func (s *EmptyTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEmptyType(s)
	}
}

func (p *GQLParser) EmptyType() (localctx IEmptyTypeContext) {
	localctx = NewEmptyTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, GQLParserRULE_emptyType)
	p.SetState(3664)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserNULL_KW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3661)
			p.Match(GQLParserNULL_KW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3662)
			p.NotNull()
		}

	case GQLParserNOTHING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3663)
			p.Match(GQLParserNOTHING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphReferenceValueTypeContext is an interface to support dynamic dispatch.
type IGraphReferenceValueTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenGraphReferenceValueType() IOpenGraphReferenceValueTypeContext
	ClosedGraphReferenceValueType() IClosedGraphReferenceValueTypeContext

	// IsGraphReferenceValueTypeContext differentiates from other interfaces.
	IsGraphReferenceValueTypeContext()
}

type GraphReferenceValueTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphReferenceValueTypeContext() *GraphReferenceValueTypeContext {
	var p = new(GraphReferenceValueTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphReferenceValueType
	return p
}

func InitEmptyGraphReferenceValueTypeContext(p *GraphReferenceValueTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphReferenceValueType
}

func (*GraphReferenceValueTypeContext) IsGraphReferenceValueTypeContext() {}

func NewGraphReferenceValueTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphReferenceValueTypeContext {
	var p = new(GraphReferenceValueTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphReferenceValueType

	return p
}

func (s *GraphReferenceValueTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphReferenceValueTypeContext) OpenGraphReferenceValueType() IOpenGraphReferenceValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenGraphReferenceValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenGraphReferenceValueTypeContext)
}

func (s *GraphReferenceValueTypeContext) ClosedGraphReferenceValueType() IClosedGraphReferenceValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosedGraphReferenceValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosedGraphReferenceValueTypeContext)
}

func (s *GraphReferenceValueTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphReferenceValueTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphReferenceValueTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphReferenceValueType(s)
	}
}

func (s *GraphReferenceValueTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphReferenceValueType(s)
	}
}

func (p *GQLParser) GraphReferenceValueType() (localctx IGraphReferenceValueTypeContext) {
	localctx = NewGraphReferenceValueTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, GQLParserRULE_graphReferenceValueType)
	p.SetState(3668)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserANY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3666)
			p.OpenGraphReferenceValueType()
		}

	case GQLParserGRAPH, GQLParserPROPERTY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3667)
			p.ClosedGraphReferenceValueType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClosedGraphReferenceValueTypeContext is an interface to support dynamic dispatch.
type IClosedGraphReferenceValueTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GRAPH() antlr.TerminalNode
	NestedGraphTypeSpecification() INestedGraphTypeSpecificationContext
	PROPERTY() antlr.TerminalNode
	NotNull() INotNullContext

	// IsClosedGraphReferenceValueTypeContext differentiates from other interfaces.
	IsClosedGraphReferenceValueTypeContext()
}

type ClosedGraphReferenceValueTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosedGraphReferenceValueTypeContext() *ClosedGraphReferenceValueTypeContext {
	var p = new(ClosedGraphReferenceValueTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_closedGraphReferenceValueType
	return p
}

func InitEmptyClosedGraphReferenceValueTypeContext(p *ClosedGraphReferenceValueTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_closedGraphReferenceValueType
}

func (*ClosedGraphReferenceValueTypeContext) IsClosedGraphReferenceValueTypeContext() {}

func NewClosedGraphReferenceValueTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosedGraphReferenceValueTypeContext {
	var p = new(ClosedGraphReferenceValueTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_closedGraphReferenceValueType

	return p
}

func (s *ClosedGraphReferenceValueTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosedGraphReferenceValueTypeContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserGRAPH, 0)
}

func (s *ClosedGraphReferenceValueTypeContext) NestedGraphTypeSpecification() INestedGraphTypeSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedGraphTypeSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedGraphTypeSpecificationContext)
}

func (s *ClosedGraphReferenceValueTypeContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY, 0)
}

func (s *ClosedGraphReferenceValueTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *ClosedGraphReferenceValueTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosedGraphReferenceValueTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosedGraphReferenceValueTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterClosedGraphReferenceValueType(s)
	}
}

func (s *ClosedGraphReferenceValueTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitClosedGraphReferenceValueType(s)
	}
}

func (p *GQLParser) ClosedGraphReferenceValueType() (localctx IClosedGraphReferenceValueTypeContext) {
	localctx = NewClosedGraphReferenceValueTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, GQLParserRULE_closedGraphReferenceValueType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserPROPERTY {
		{
			p.SetState(3670)
			p.Match(GQLParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3673)
		p.Match(GQLParserGRAPH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3674)
		p.NestedGraphTypeSpecification()
	}
	p.SetState(3676)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 403, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3675)
			p.NotNull()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpenGraphReferenceValueTypeContext is an interface to support dynamic dispatch.
type IOpenGraphReferenceValueTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANY() antlr.TerminalNode
	GRAPH() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	NotNull() INotNullContext

	// IsOpenGraphReferenceValueTypeContext differentiates from other interfaces.
	IsOpenGraphReferenceValueTypeContext()
}

type OpenGraphReferenceValueTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenGraphReferenceValueTypeContext() *OpenGraphReferenceValueTypeContext {
	var p = new(OpenGraphReferenceValueTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_openGraphReferenceValueType
	return p
}

func InitEmptyOpenGraphReferenceValueTypeContext(p *OpenGraphReferenceValueTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_openGraphReferenceValueType
}

func (*OpenGraphReferenceValueTypeContext) IsOpenGraphReferenceValueTypeContext() {}

func NewOpenGraphReferenceValueTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenGraphReferenceValueTypeContext {
	var p = new(OpenGraphReferenceValueTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_openGraphReferenceValueType

	return p
}

func (s *OpenGraphReferenceValueTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenGraphReferenceValueTypeContext) ANY() antlr.TerminalNode {
	return s.GetToken(GQLParserANY, 0)
}

func (s *OpenGraphReferenceValueTypeContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserGRAPH, 0)
}

func (s *OpenGraphReferenceValueTypeContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY, 0)
}

func (s *OpenGraphReferenceValueTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *OpenGraphReferenceValueTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenGraphReferenceValueTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenGraphReferenceValueTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOpenGraphReferenceValueType(s)
	}
}

func (s *OpenGraphReferenceValueTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOpenGraphReferenceValueType(s)
	}
}

func (p *GQLParser) OpenGraphReferenceValueType() (localctx IOpenGraphReferenceValueTypeContext) {
	localctx = NewOpenGraphReferenceValueTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, GQLParserRULE_openGraphReferenceValueType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3678)
		p.Match(GQLParserANY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserPROPERTY {
		{
			p.SetState(3679)
			p.Match(GQLParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3682)
		p.Match(GQLParserGRAPH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3684)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 405, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3683)
			p.NotNull()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindingTableReferenceValueTypeContext is an interface to support dynamic dispatch.
type IBindingTableReferenceValueTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingTableType() IBindingTableTypeContext
	NotNull() INotNullContext

	// IsBindingTableReferenceValueTypeContext differentiates from other interfaces.
	IsBindingTableReferenceValueTypeContext()
}

type BindingTableReferenceValueTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingTableReferenceValueTypeContext() *BindingTableReferenceValueTypeContext {
	var p = new(BindingTableReferenceValueTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingTableReferenceValueType
	return p
}

func InitEmptyBindingTableReferenceValueTypeContext(p *BindingTableReferenceValueTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingTableReferenceValueType
}

func (*BindingTableReferenceValueTypeContext) IsBindingTableReferenceValueTypeContext() {}

func NewBindingTableReferenceValueTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingTableReferenceValueTypeContext {
	var p = new(BindingTableReferenceValueTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_bindingTableReferenceValueType

	return p
}

func (s *BindingTableReferenceValueTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingTableReferenceValueTypeContext) BindingTableType() IBindingTableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingTableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingTableTypeContext)
}

func (s *BindingTableReferenceValueTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *BindingTableReferenceValueTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingTableReferenceValueTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingTableReferenceValueTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBindingTableReferenceValueType(s)
	}
}

func (s *BindingTableReferenceValueTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBindingTableReferenceValueType(s)
	}
}

func (p *GQLParser) BindingTableReferenceValueType() (localctx IBindingTableReferenceValueTypeContext) {
	localctx = NewBindingTableReferenceValueTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, GQLParserRULE_bindingTableReferenceValueType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3686)
		p.BindingTableType()
	}
	p.SetState(3688)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 406, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3687)
			p.NotNull()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeReferenceValueTypeContext is an interface to support dynamic dispatch.
type INodeReferenceValueTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenNodeReferenceValueType() IOpenNodeReferenceValueTypeContext
	ClosedNodeReferenceValueType() IClosedNodeReferenceValueTypeContext

	// IsNodeReferenceValueTypeContext differentiates from other interfaces.
	IsNodeReferenceValueTypeContext()
}

type NodeReferenceValueTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeReferenceValueTypeContext() *NodeReferenceValueTypeContext {
	var p = new(NodeReferenceValueTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeReferenceValueType
	return p
}

func InitEmptyNodeReferenceValueTypeContext(p *NodeReferenceValueTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeReferenceValueType
}

func (*NodeReferenceValueTypeContext) IsNodeReferenceValueTypeContext() {}

func NewNodeReferenceValueTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeReferenceValueTypeContext {
	var p = new(NodeReferenceValueTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nodeReferenceValueType

	return p
}

func (s *NodeReferenceValueTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeReferenceValueTypeContext) OpenNodeReferenceValueType() IOpenNodeReferenceValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenNodeReferenceValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenNodeReferenceValueTypeContext)
}

func (s *NodeReferenceValueTypeContext) ClosedNodeReferenceValueType() IClosedNodeReferenceValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosedNodeReferenceValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosedNodeReferenceValueTypeContext)
}

func (s *NodeReferenceValueTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeReferenceValueTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeReferenceValueTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNodeReferenceValueType(s)
	}
}

func (s *NodeReferenceValueTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNodeReferenceValueType(s)
	}
}

func (p *GQLParser) NodeReferenceValueType() (localctx INodeReferenceValueTypeContext) {
	localctx = NewNodeReferenceValueTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, GQLParserRULE_nodeReferenceValueType)
	p.SetState(3692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 407, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3690)
			p.OpenNodeReferenceValueType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3691)
			p.ClosedNodeReferenceValueType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClosedNodeReferenceValueTypeContext is an interface to support dynamic dispatch.
type IClosedNodeReferenceValueTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NodeTypeSpecification() INodeTypeSpecificationContext
	NotNull() INotNullContext

	// IsClosedNodeReferenceValueTypeContext differentiates from other interfaces.
	IsClosedNodeReferenceValueTypeContext()
}

type ClosedNodeReferenceValueTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosedNodeReferenceValueTypeContext() *ClosedNodeReferenceValueTypeContext {
	var p = new(ClosedNodeReferenceValueTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_closedNodeReferenceValueType
	return p
}

func InitEmptyClosedNodeReferenceValueTypeContext(p *ClosedNodeReferenceValueTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_closedNodeReferenceValueType
}

func (*ClosedNodeReferenceValueTypeContext) IsClosedNodeReferenceValueTypeContext() {}

func NewClosedNodeReferenceValueTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosedNodeReferenceValueTypeContext {
	var p = new(ClosedNodeReferenceValueTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_closedNodeReferenceValueType

	return p
}

func (s *ClosedNodeReferenceValueTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosedNodeReferenceValueTypeContext) NodeTypeSpecification() INodeTypeSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeTypeSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeTypeSpecificationContext)
}

func (s *ClosedNodeReferenceValueTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *ClosedNodeReferenceValueTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosedNodeReferenceValueTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosedNodeReferenceValueTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterClosedNodeReferenceValueType(s)
	}
}

func (s *ClosedNodeReferenceValueTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitClosedNodeReferenceValueType(s)
	}
}

func (p *GQLParser) ClosedNodeReferenceValueType() (localctx IClosedNodeReferenceValueTypeContext) {
	localctx = NewClosedNodeReferenceValueTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, GQLParserRULE_closedNodeReferenceValueType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3694)
		p.NodeTypeSpecification()
	}
	p.SetState(3696)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 408, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3695)
			p.NotNull()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpenNodeReferenceValueTypeContext is an interface to support dynamic dispatch.
type IOpenNodeReferenceValueTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NodeSynonym() INodeSynonymContext
	ANY() antlr.TerminalNode
	NotNull() INotNullContext

	// IsOpenNodeReferenceValueTypeContext differentiates from other interfaces.
	IsOpenNodeReferenceValueTypeContext()
}

type OpenNodeReferenceValueTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenNodeReferenceValueTypeContext() *OpenNodeReferenceValueTypeContext {
	var p = new(OpenNodeReferenceValueTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_openNodeReferenceValueType
	return p
}

func InitEmptyOpenNodeReferenceValueTypeContext(p *OpenNodeReferenceValueTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_openNodeReferenceValueType
}

func (*OpenNodeReferenceValueTypeContext) IsOpenNodeReferenceValueTypeContext() {}

func NewOpenNodeReferenceValueTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenNodeReferenceValueTypeContext {
	var p = new(OpenNodeReferenceValueTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_openNodeReferenceValueType

	return p
}

func (s *OpenNodeReferenceValueTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenNodeReferenceValueTypeContext) NodeSynonym() INodeSynonymContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeSynonymContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeSynonymContext)
}

func (s *OpenNodeReferenceValueTypeContext) ANY() antlr.TerminalNode {
	return s.GetToken(GQLParserANY, 0)
}

func (s *OpenNodeReferenceValueTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *OpenNodeReferenceValueTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenNodeReferenceValueTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenNodeReferenceValueTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOpenNodeReferenceValueType(s)
	}
}

func (s *OpenNodeReferenceValueTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOpenNodeReferenceValueType(s)
	}
}

func (p *GQLParser) OpenNodeReferenceValueType() (localctx IOpenNodeReferenceValueTypeContext) {
	localctx = NewOpenNodeReferenceValueTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, GQLParserRULE_openNodeReferenceValueType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3699)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserANY {
		{
			p.SetState(3698)
			p.Match(GQLParserANY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3701)
		p.NodeSynonym()
	}
	p.SetState(3703)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 410, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3702)
			p.NotNull()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeReferenceValueTypeContext is an interface to support dynamic dispatch.
type IEdgeReferenceValueTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OpenEdgeReferenceValueType() IOpenEdgeReferenceValueTypeContext
	ClosedEdgeReferenceValueType() IClosedEdgeReferenceValueTypeContext

	// IsEdgeReferenceValueTypeContext differentiates from other interfaces.
	IsEdgeReferenceValueTypeContext()
}

type EdgeReferenceValueTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeReferenceValueTypeContext() *EdgeReferenceValueTypeContext {
	var p = new(EdgeReferenceValueTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeReferenceValueType
	return p
}

func InitEmptyEdgeReferenceValueTypeContext(p *EdgeReferenceValueTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeReferenceValueType
}

func (*EdgeReferenceValueTypeContext) IsEdgeReferenceValueTypeContext() {}

func NewEdgeReferenceValueTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeReferenceValueTypeContext {
	var p = new(EdgeReferenceValueTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeReferenceValueType

	return p
}

func (s *EdgeReferenceValueTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeReferenceValueTypeContext) OpenEdgeReferenceValueType() IOpenEdgeReferenceValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenEdgeReferenceValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenEdgeReferenceValueTypeContext)
}

func (s *EdgeReferenceValueTypeContext) ClosedEdgeReferenceValueType() IClosedEdgeReferenceValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosedEdgeReferenceValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosedEdgeReferenceValueTypeContext)
}

func (s *EdgeReferenceValueTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeReferenceValueTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeReferenceValueTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeReferenceValueType(s)
	}
}

func (s *EdgeReferenceValueTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeReferenceValueType(s)
	}
}

func (p *GQLParser) EdgeReferenceValueType() (localctx IEdgeReferenceValueTypeContext) {
	localctx = NewEdgeReferenceValueTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, GQLParserRULE_edgeReferenceValueType)
	p.SetState(3707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3705)
			p.OpenEdgeReferenceValueType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3706)
			p.ClosedEdgeReferenceValueType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClosedEdgeReferenceValueTypeContext is an interface to support dynamic dispatch.
type IClosedEdgeReferenceValueTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EdgeTypeSpecification() IEdgeTypeSpecificationContext
	NotNull() INotNullContext

	// IsClosedEdgeReferenceValueTypeContext differentiates from other interfaces.
	IsClosedEdgeReferenceValueTypeContext()
}

type ClosedEdgeReferenceValueTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosedEdgeReferenceValueTypeContext() *ClosedEdgeReferenceValueTypeContext {
	var p = new(ClosedEdgeReferenceValueTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_closedEdgeReferenceValueType
	return p
}

func InitEmptyClosedEdgeReferenceValueTypeContext(p *ClosedEdgeReferenceValueTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_closedEdgeReferenceValueType
}

func (*ClosedEdgeReferenceValueTypeContext) IsClosedEdgeReferenceValueTypeContext() {}

func NewClosedEdgeReferenceValueTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosedEdgeReferenceValueTypeContext {
	var p = new(ClosedEdgeReferenceValueTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_closedEdgeReferenceValueType

	return p
}

func (s *ClosedEdgeReferenceValueTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosedEdgeReferenceValueTypeContext) EdgeTypeSpecification() IEdgeTypeSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeTypeSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeTypeSpecificationContext)
}

func (s *ClosedEdgeReferenceValueTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *ClosedEdgeReferenceValueTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosedEdgeReferenceValueTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosedEdgeReferenceValueTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterClosedEdgeReferenceValueType(s)
	}
}

func (s *ClosedEdgeReferenceValueTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitClosedEdgeReferenceValueType(s)
	}
}

func (p *GQLParser) ClosedEdgeReferenceValueType() (localctx IClosedEdgeReferenceValueTypeContext) {
	localctx = NewClosedEdgeReferenceValueTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, GQLParserRULE_closedEdgeReferenceValueType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3709)
		p.EdgeTypeSpecification()
	}
	p.SetState(3711)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 412, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3710)
			p.NotNull()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpenEdgeReferenceValueTypeContext is an interface to support dynamic dispatch.
type IOpenEdgeReferenceValueTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EdgeSynonym() IEdgeSynonymContext
	ANY() antlr.TerminalNode
	NotNull() INotNullContext

	// IsOpenEdgeReferenceValueTypeContext differentiates from other interfaces.
	IsOpenEdgeReferenceValueTypeContext()
}

type OpenEdgeReferenceValueTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenEdgeReferenceValueTypeContext() *OpenEdgeReferenceValueTypeContext {
	var p = new(OpenEdgeReferenceValueTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_openEdgeReferenceValueType
	return p
}

func InitEmptyOpenEdgeReferenceValueTypeContext(p *OpenEdgeReferenceValueTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_openEdgeReferenceValueType
}

func (*OpenEdgeReferenceValueTypeContext) IsOpenEdgeReferenceValueTypeContext() {}

func NewOpenEdgeReferenceValueTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenEdgeReferenceValueTypeContext {
	var p = new(OpenEdgeReferenceValueTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_openEdgeReferenceValueType

	return p
}

func (s *OpenEdgeReferenceValueTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenEdgeReferenceValueTypeContext) EdgeSynonym() IEdgeSynonymContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeSynonymContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeSynonymContext)
}

func (s *OpenEdgeReferenceValueTypeContext) ANY() antlr.TerminalNode {
	return s.GetToken(GQLParserANY, 0)
}

func (s *OpenEdgeReferenceValueTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *OpenEdgeReferenceValueTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenEdgeReferenceValueTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenEdgeReferenceValueTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterOpenEdgeReferenceValueType(s)
	}
}

func (s *OpenEdgeReferenceValueTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitOpenEdgeReferenceValueType(s)
	}
}

func (p *GQLParser) OpenEdgeReferenceValueType() (localctx IOpenEdgeReferenceValueTypeContext) {
	localctx = NewOpenEdgeReferenceValueTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, GQLParserRULE_openEdgeReferenceValueType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserANY {
		{
			p.SetState(3713)
			p.Match(GQLParserANY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3716)
		p.EdgeSynonym()
	}
	p.SetState(3718)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3717)
			p.NotNull()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathValueTypeContext is an interface to support dynamic dispatch.
type IPathValueTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PATH() antlr.TerminalNode
	NotNull() INotNullContext

	// IsPathValueTypeContext differentiates from other interfaces.
	IsPathValueTypeContext()
}

type PathValueTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathValueTypeContext() *PathValueTypeContext {
	var p = new(PathValueTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathValueType
	return p
}

func InitEmptyPathValueTypeContext(p *PathValueTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathValueType
}

func (*PathValueTypeContext) IsPathValueTypeContext() {}

func NewPathValueTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathValueTypeContext {
	var p = new(PathValueTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathValueType

	return p
}

func (s *PathValueTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PathValueTypeContext) PATH() antlr.TerminalNode {
	return s.GetToken(GQLParserPATH, 0)
}

func (s *PathValueTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *PathValueTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathValueTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathValueTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathValueType(s)
	}
}

func (s *PathValueTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathValueType(s)
	}
}

func (p *GQLParser) PathValueType() (localctx IPathValueTypeContext) {
	localctx = NewPathValueTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, GQLParserRULE_pathValueType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3720)
		p.Match(GQLParserPATH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3722)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 415, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3721)
			p.NotNull()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListValueTypeNameContext is an interface to support dynamic dispatch.
type IListValueTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ListValueTypeNameSynonym() IListValueTypeNameSynonymContext

	// IsListValueTypeNameContext differentiates from other interfaces.
	IsListValueTypeNameContext()
}

type ListValueTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListValueTypeNameContext() *ListValueTypeNameContext {
	var p = new(ListValueTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listValueTypeName
	return p
}

func InitEmptyListValueTypeNameContext(p *ListValueTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listValueTypeName
}

func (*ListValueTypeNameContext) IsListValueTypeNameContext() {}

func NewListValueTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListValueTypeNameContext {
	var p = new(ListValueTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_listValueTypeName

	return p
}

func (s *ListValueTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ListValueTypeNameContext) ListValueTypeNameSynonym() IListValueTypeNameSynonymContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListValueTypeNameSynonymContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListValueTypeNameSynonymContext)
}

func (s *ListValueTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListValueTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListValueTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterListValueTypeName(s)
	}
}

func (s *ListValueTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitListValueTypeName(s)
	}
}

func (p *GQLParser) ListValueTypeName() (localctx IListValueTypeNameContext) {
	localctx = NewListValueTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, GQLParserRULE_listValueTypeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3724)
		p.ListValueTypeNameSynonym()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListValueTypeNameSynonymContext is an interface to support dynamic dispatch.
type IListValueTypeNameSynonymContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIST() antlr.TerminalNode
	ARRAY() antlr.TerminalNode

	// IsListValueTypeNameSynonymContext differentiates from other interfaces.
	IsListValueTypeNameSynonymContext()
}

type ListValueTypeNameSynonymContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListValueTypeNameSynonymContext() *ListValueTypeNameSynonymContext {
	var p = new(ListValueTypeNameSynonymContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listValueTypeNameSynonym
	return p
}

func InitEmptyListValueTypeNameSynonymContext(p *ListValueTypeNameSynonymContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listValueTypeNameSynonym
}

func (*ListValueTypeNameSynonymContext) IsListValueTypeNameSynonymContext() {}

func NewListValueTypeNameSynonymContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListValueTypeNameSynonymContext {
	var p = new(ListValueTypeNameSynonymContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_listValueTypeNameSynonym

	return p
}

func (s *ListValueTypeNameSynonymContext) GetParser() antlr.Parser { return s.parser }

func (s *ListValueTypeNameSynonymContext) LIST() antlr.TerminalNode {
	return s.GetToken(GQLParserLIST, 0)
}

func (s *ListValueTypeNameSynonymContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(GQLParserARRAY, 0)
}

func (s *ListValueTypeNameSynonymContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListValueTypeNameSynonymContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListValueTypeNameSynonymContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterListValueTypeNameSynonym(s)
	}
}

func (s *ListValueTypeNameSynonymContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitListValueTypeNameSynonym(s)
	}
}

func (p *GQLParser) ListValueTypeNameSynonym() (localctx IListValueTypeNameSynonymContext) {
	localctx = NewListValueTypeNameSynonymContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, GQLParserRULE_listValueTypeNameSynonym)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3726)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserARRAY || _la == GQLParserLIST) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordTypeContext is an interface to support dynamic dispatch.
type IRecordTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECORD() antlr.TerminalNode
	ANY() antlr.TerminalNode
	NotNull() INotNullContext
	FieldTypesSpecification() IFieldTypesSpecificationContext

	// IsRecordTypeContext differentiates from other interfaces.
	IsRecordTypeContext()
}

type RecordTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordTypeContext() *RecordTypeContext {
	var p = new(RecordTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_recordType
	return p
}

func InitEmptyRecordTypeContext(p *RecordTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_recordType
}

func (*RecordTypeContext) IsRecordTypeContext() {}

func NewRecordTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordTypeContext {
	var p = new(RecordTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_recordType

	return p
}

func (s *RecordTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordTypeContext) RECORD() antlr.TerminalNode {
	return s.GetToken(GQLParserRECORD, 0)
}

func (s *RecordTypeContext) ANY() antlr.TerminalNode {
	return s.GetToken(GQLParserANY, 0)
}

func (s *RecordTypeContext) NotNull() INotNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotNullContext)
}

func (s *RecordTypeContext) FieldTypesSpecification() IFieldTypesSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldTypesSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldTypesSpecificationContext)
}

func (s *RecordTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterRecordType(s)
	}
}

func (s *RecordTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitRecordType(s)
	}
}

func (p *GQLParser) RecordType() (localctx IRecordTypeContext) {
	localctx = NewRecordTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, GQLParserRULE_recordType)
	var _la int

	p.SetState(3742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 420, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3729)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserANY {
			{
				p.SetState(3728)
				p.Match(GQLParserANY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3731)
			p.Match(GQLParserRECORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3733)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 417, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3732)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserRECORD {
			{
				p.SetState(3735)
				p.Match(GQLParserRECORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3738)
			p.FieldTypesSpecification()
		}
		p.SetState(3740)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 419, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3739)
				p.NotNull()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldTypesSpecificationContext is an interface to support dynamic dispatch.
type IFieldTypesSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_BRACE() antlr.TerminalNode
	RIGHT_BRACE() antlr.TerminalNode
	FieldTypeList() IFieldTypeListContext

	// IsFieldTypesSpecificationContext differentiates from other interfaces.
	IsFieldTypesSpecificationContext()
}

type FieldTypesSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldTypesSpecificationContext() *FieldTypesSpecificationContext {
	var p = new(FieldTypesSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fieldTypesSpecification
	return p
}

func InitEmptyFieldTypesSpecificationContext(p *FieldTypesSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fieldTypesSpecification
}

func (*FieldTypesSpecificationContext) IsFieldTypesSpecificationContext() {}

func NewFieldTypesSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldTypesSpecificationContext {
	var p = new(FieldTypesSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fieldTypesSpecification

	return p
}

func (s *FieldTypesSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldTypesSpecificationContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACE, 0)
}

func (s *FieldTypesSpecificationContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACE, 0)
}

func (s *FieldTypesSpecificationContext) FieldTypeList() IFieldTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldTypeListContext)
}

func (s *FieldTypesSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldTypesSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldTypesSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFieldTypesSpecification(s)
	}
}

func (s *FieldTypesSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFieldTypesSpecification(s)
	}
}

func (p *GQLParser) FieldTypesSpecification() (localctx IFieldTypesSpecificationContext) {
	localctx = NewFieldTypesSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, GQLParserRULE_fieldTypesSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3744)
		p.Match(GQLParserLEFT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&281474976710655) != 0) {
		{
			p.SetState(3745)
			p.FieldTypeList()
		}

	}
	{
		p.SetState(3748)
		p.Match(GQLParserRIGHT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldTypeListContext is an interface to support dynamic dispatch.
type IFieldTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldType() []IFieldTypeContext
	FieldType(i int) IFieldTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFieldTypeListContext differentiates from other interfaces.
	IsFieldTypeListContext()
}

type FieldTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldTypeListContext() *FieldTypeListContext {
	var p = new(FieldTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fieldTypeList
	return p
}

func InitEmptyFieldTypeListContext(p *FieldTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fieldTypeList
}

func (*FieldTypeListContext) IsFieldTypeListContext() {}

func NewFieldTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldTypeListContext {
	var p = new(FieldTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fieldTypeList

	return p
}

func (s *FieldTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldTypeListContext) AllFieldType() []IFieldTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldTypeContext); ok {
			len++
		}
	}

	tst := make([]IFieldTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldTypeContext); ok {
			tst[i] = t.(IFieldTypeContext)
			i++
		}
	}

	return tst
}

func (s *FieldTypeListContext) FieldType(i int) IFieldTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldTypeContext)
}

func (s *FieldTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *FieldTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *FieldTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFieldTypeList(s)
	}
}

func (s *FieldTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFieldTypeList(s)
	}
}

func (p *GQLParser) FieldTypeList() (localctx IFieldTypeListContext) {
	localctx = NewFieldTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, GQLParserRULE_fieldTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3750)
		p.FieldType()
	}
	p.SetState(3755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(3751)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3752)
			p.FieldType()
		}

		p.SetState(3757)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INotNullContext is an interface to support dynamic dispatch.
type INotNullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT() antlr.TerminalNode
	NULL_KW() antlr.TerminalNode

	// IsNotNullContext differentiates from other interfaces.
	IsNotNullContext()
}

type NotNullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotNullContext() *NotNullContext {
	var p = new(NotNullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_notNull
	return p
}

func InitEmptyNotNullContext(p *NotNullContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_notNull
}

func (*NotNullContext) IsNotNullContext() {}

func NewNotNullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotNullContext {
	var p = new(NotNullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_notNull

	return p
}

func (s *NotNullContext) GetParser() antlr.Parser { return s.parser }

func (s *NotNullContext) NOT() antlr.TerminalNode {
	return s.GetToken(GQLParserNOT, 0)
}

func (s *NotNullContext) NULL_KW() antlr.TerminalNode {
	return s.GetToken(GQLParserNULL_KW, 0)
}

func (s *NotNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotNullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNotNull(s)
	}
}

func (s *NotNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNotNull(s)
	}
}

func (p *GQLParser) NotNull() (localctx INotNullContext) {
	localctx = NewNotNullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, GQLParserRULE_notNull)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3758)
		p.Match(GQLParserNOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3759)
		p.Match(GQLParserNULL_KW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldTypeContext is an interface to support dynamic dispatch.
type IFieldTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	ValueType() IValueTypeContext
	Typed() ITypedContext

	// IsFieldTypeContext differentiates from other interfaces.
	IsFieldTypeContext()
}

type FieldTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldTypeContext() *FieldTypeContext {
	var p = new(FieldTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fieldType
	return p
}

func InitEmptyFieldTypeContext(p *FieldTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fieldType
}

func (*FieldTypeContext) IsFieldTypeContext() {}

func NewFieldTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldTypeContext {
	var p = new(FieldTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fieldType

	return p
}

func (s *FieldTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldTypeContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *FieldTypeContext) ValueType() IValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueTypeContext)
}

func (s *FieldTypeContext) Typed() ITypedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedContext)
}

func (s *FieldTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFieldType(s)
	}
}

func (s *FieldTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFieldType(s)
	}
}

func (p *GQLParser) FieldType() (localctx IFieldTypeContext) {
	localctx = NewFieldTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, GQLParserRULE_fieldType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3761)
		p.FieldName()
	}
	p.SetState(3763)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserTYPED || _la == GQLParserDOUBLE_COLON {
		{
			p.SetState(3762)
			p.Typed()
		}

	}
	{
		p.SetState(3765)
		p.valueType(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISearchConditionContext is an interface to support dynamic dispatch.
type ISearchConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanValueExpression() IBooleanValueExpressionContext

	// IsSearchConditionContext differentiates from other interfaces.
	IsSearchConditionContext()
}

type SearchConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchConditionContext() *SearchConditionContext {
	var p = new(SearchConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_searchCondition
	return p
}

func InitEmptySearchConditionContext(p *SearchConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_searchCondition
}

func (*SearchConditionContext) IsSearchConditionContext() {}

func NewSearchConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchConditionContext {
	var p = new(SearchConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_searchCondition

	return p
}

func (s *SearchConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchConditionContext) BooleanValueExpression() IBooleanValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueExpressionContext)
}

func (s *SearchConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSearchCondition(s)
	}
}

func (s *SearchConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSearchCondition(s)
	}
}

func (p *GQLParser) SearchCondition() (localctx ISearchConditionContext) {
	localctx = NewSearchConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, GQLParserRULE_searchCondition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3767)
		p.BooleanValueExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExistsPredicate() IExistsPredicateContext
	NullPredicate() INullPredicateContext
	ValueTypePredicate() IValueTypePredicateContext
	DirectedPredicate() IDirectedPredicateContext
	LabeledPredicate() ILabeledPredicateContext
	SourceDestinationPredicate() ISourceDestinationPredicateContext
	All_differentPredicate() IAll_differentPredicateContext
	SamePredicate() ISamePredicateContext
	Property_existsPredicate() IProperty_existsPredicateContext

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) ExistsPredicate() IExistsPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExistsPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExistsPredicateContext)
}

func (s *PredicateContext) NullPredicate() INullPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullPredicateContext)
}

func (s *PredicateContext) ValueTypePredicate() IValueTypePredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueTypePredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueTypePredicateContext)
}

func (s *PredicateContext) DirectedPredicate() IDirectedPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectedPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectedPredicateContext)
}

func (s *PredicateContext) LabeledPredicate() ILabeledPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabeledPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabeledPredicateContext)
}

func (s *PredicateContext) SourceDestinationPredicate() ISourceDestinationPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceDestinationPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceDestinationPredicateContext)
}

func (s *PredicateContext) All_differentPredicate() IAll_differentPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAll_differentPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAll_differentPredicateContext)
}

func (s *PredicateContext) SamePredicate() ISamePredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISamePredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISamePredicateContext)
}

func (s *PredicateContext) Property_existsPredicate() IProperty_existsPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProperty_existsPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProperty_existsPredicateContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (p *GQLParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, GQLParserRULE_predicate)
	p.SetState(3778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 424, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3769)
			p.ExistsPredicate()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3770)
			p.NullPredicate()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3771)
			p.ValueTypePredicate()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3772)
			p.DirectedPredicate()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3773)
			p.LabeledPredicate()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3774)
			p.SourceDestinationPredicate()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3775)
			p.All_differentPredicate()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3776)
			p.SamePredicate()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3777)
			p.Property_existsPredicate()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompOpContext is an interface to support dynamic dispatch.
type ICompOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUALS_OPERATOR() antlr.TerminalNode
	NOT_EQUALS_OPERATOR() antlr.TerminalNode
	LEFT_ANGLE_BRACKET() antlr.TerminalNode
	RIGHT_ANGLE_BRACKET() antlr.TerminalNode
	LESS_THAN_OR_EQUALS_OPERATOR() antlr.TerminalNode
	GREATER_THAN_OR_EQUALS_OPERATOR() antlr.TerminalNode

	// IsCompOpContext differentiates from other interfaces.
	IsCompOpContext()
}

type CompOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompOpContext() *CompOpContext {
	var p = new(CompOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_compOp
	return p
}

func InitEmptyCompOpContext(p *CompOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_compOp
}

func (*CompOpContext) IsCompOpContext() {}

func NewCompOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompOpContext {
	var p = new(CompOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_compOp

	return p
}

func (s *CompOpContext) GetParser() antlr.Parser { return s.parser }

func (s *CompOpContext) EQUALS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(GQLParserEQUALS_OPERATOR, 0)
}

func (s *CompOpContext) NOT_EQUALS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(GQLParserNOT_EQUALS_OPERATOR, 0)
}

func (s *CompOpContext) LEFT_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_ANGLE_BRACKET, 0)
}

func (s *CompOpContext) RIGHT_ANGLE_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_ANGLE_BRACKET, 0)
}

func (s *CompOpContext) LESS_THAN_OR_EQUALS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(GQLParserLESS_THAN_OR_EQUALS_OPERATOR, 0)
}

func (s *CompOpContext) GREATER_THAN_OR_EQUALS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(GQLParserGREATER_THAN_OR_EQUALS_OPERATOR, 0)
}

func (s *CompOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCompOp(s)
	}
}

func (s *CompOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCompOp(s)
	}
}

func (p *GQLParser) CompOp() (localctx ICompOpContext) {
	localctx = NewCompOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, GQLParserRULE_compOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3780)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-337)) & ^0x3f) == 0 && ((int64(1)<<(_la-337))&142807664897) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExistsPredicateContext is an interface to support dynamic dispatch.
type IExistsPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXISTS() antlr.TerminalNode
	LEFT_BRACE() antlr.TerminalNode
	GraphPattern() IGraphPatternContext
	RIGHT_BRACE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	MatchStatementBlock() IMatchStatementBlockContext
	NestedQuerySpecification() INestedQuerySpecificationContext

	// IsExistsPredicateContext differentiates from other interfaces.
	IsExistsPredicateContext()
}

type ExistsPredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExistsPredicateContext() *ExistsPredicateContext {
	var p = new(ExistsPredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_existsPredicate
	return p
}

func InitEmptyExistsPredicateContext(p *ExistsPredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_existsPredicate
}

func (*ExistsPredicateContext) IsExistsPredicateContext() {}

func NewExistsPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExistsPredicateContext {
	var p = new(ExistsPredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_existsPredicate

	return p
}

func (s *ExistsPredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *ExistsPredicateContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(GQLParserEXISTS, 0)
}

func (s *ExistsPredicateContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACE, 0)
}

func (s *ExistsPredicateContext) GraphPattern() IGraphPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphPatternContext)
}

func (s *ExistsPredicateContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACE, 0)
}

func (s *ExistsPredicateContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *ExistsPredicateContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *ExistsPredicateContext) MatchStatementBlock() IMatchStatementBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchStatementBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchStatementBlockContext)
}

func (s *ExistsPredicateContext) NestedQuerySpecification() INestedQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedQuerySpecificationContext)
}

func (s *ExistsPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsPredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExistsPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterExistsPredicate(s)
	}
}

func (s *ExistsPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitExistsPredicate(s)
	}
}

func (p *GQLParser) ExistsPredicate() (localctx IExistsPredicateContext) {
	localctx = NewExistsPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, GQLParserRULE_existsPredicate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3782)
		p.Match(GQLParserEXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3800)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 425, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3783)
			p.Match(GQLParserLEFT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3784)
			p.GraphPattern()
		}
		{
			p.SetState(3785)
			p.Match(GQLParserRIGHT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(3787)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3788)
			p.GraphPattern()
		}
		{
			p.SetState(3789)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(3791)
			p.Match(GQLParserLEFT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3792)
			p.MatchStatementBlock()
		}
		{
			p.SetState(3793)
			p.Match(GQLParserRIGHT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(3795)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3796)
			p.MatchStatementBlock()
		}
		{
			p.SetState(3797)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(3799)
			p.NestedQuerySpecification()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullPredicateContext is an interface to support dynamic dispatch.
type INullPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpressionPrimary() IValueExpressionPrimaryContext
	NullPredicatePart2() INullPredicatePart2Context

	// IsNullPredicateContext differentiates from other interfaces.
	IsNullPredicateContext()
}

type NullPredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullPredicateContext() *NullPredicateContext {
	var p = new(NullPredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nullPredicate
	return p
}

func InitEmptyNullPredicateContext(p *NullPredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nullPredicate
}

func (*NullPredicateContext) IsNullPredicateContext() {}

func NewNullPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullPredicateContext {
	var p = new(NullPredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nullPredicate

	return p
}

func (s *NullPredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *NullPredicateContext) ValueExpressionPrimary() IValueExpressionPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionPrimaryContext)
}

func (s *NullPredicateContext) NullPredicatePart2() INullPredicatePart2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullPredicatePart2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullPredicatePart2Context)
}

func (s *NullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullPredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNullPredicate(s)
	}
}

func (s *NullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNullPredicate(s)
	}
}

func (p *GQLParser) NullPredicate() (localctx INullPredicateContext) {
	localctx = NewNullPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, GQLParserRULE_nullPredicate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3802)
		p.valueExpressionPrimary(0)
	}
	{
		p.SetState(3803)
		p.NullPredicatePart2()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullPredicatePart2Context is an interface to support dynamic dispatch.
type INullPredicatePart2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IS() antlr.TerminalNode
	NULL_KW() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsNullPredicatePart2Context differentiates from other interfaces.
	IsNullPredicatePart2Context()
}

type NullPredicatePart2Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullPredicatePart2Context() *NullPredicatePart2Context {
	var p = new(NullPredicatePart2Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nullPredicatePart2
	return p
}

func InitEmptyNullPredicatePart2Context(p *NullPredicatePart2Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nullPredicatePart2
}

func (*NullPredicatePart2Context) IsNullPredicatePart2Context() {}

func NewNullPredicatePart2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullPredicatePart2Context {
	var p = new(NullPredicatePart2Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nullPredicatePart2

	return p
}

func (s *NullPredicatePart2Context) GetParser() antlr.Parser { return s.parser }

func (s *NullPredicatePart2Context) IS() antlr.TerminalNode {
	return s.GetToken(GQLParserIS, 0)
}

func (s *NullPredicatePart2Context) NULL_KW() antlr.TerminalNode {
	return s.GetToken(GQLParserNULL_KW, 0)
}

func (s *NullPredicatePart2Context) NOT() antlr.TerminalNode {
	return s.GetToken(GQLParserNOT, 0)
}

func (s *NullPredicatePart2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullPredicatePart2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullPredicatePart2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNullPredicatePart2(s)
	}
}

func (s *NullPredicatePart2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNullPredicatePart2(s)
	}
}

func (p *GQLParser) NullPredicatePart2() (localctx INullPredicatePart2Context) {
	localctx = NewNullPredicatePart2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, GQLParserRULE_nullPredicatePart2)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3805)
		p.Match(GQLParserIS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserNOT {
		{
			p.SetState(3806)
			p.Match(GQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3809)
		p.Match(GQLParserNULL_KW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueTypePredicateContext is an interface to support dynamic dispatch.
type IValueTypePredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpressionPrimary() IValueExpressionPrimaryContext
	ValueTypePredicatePart2() IValueTypePredicatePart2Context

	// IsValueTypePredicateContext differentiates from other interfaces.
	IsValueTypePredicateContext()
}

type ValueTypePredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueTypePredicateContext() *ValueTypePredicateContext {
	var p = new(ValueTypePredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueTypePredicate
	return p
}

func InitEmptyValueTypePredicateContext(p *ValueTypePredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueTypePredicate
}

func (*ValueTypePredicateContext) IsValueTypePredicateContext() {}

func NewValueTypePredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueTypePredicateContext {
	var p = new(ValueTypePredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_valueTypePredicate

	return p
}

func (s *ValueTypePredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueTypePredicateContext) ValueExpressionPrimary() IValueExpressionPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionPrimaryContext)
}

func (s *ValueTypePredicateContext) ValueTypePredicatePart2() IValueTypePredicatePart2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueTypePredicatePart2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueTypePredicatePart2Context)
}

func (s *ValueTypePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueTypePredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueTypePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterValueTypePredicate(s)
	}
}

func (s *ValueTypePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitValueTypePredicate(s)
	}
}

func (p *GQLParser) ValueTypePredicate() (localctx IValueTypePredicateContext) {
	localctx = NewValueTypePredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, GQLParserRULE_valueTypePredicate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3811)
		p.valueExpressionPrimary(0)
	}
	{
		p.SetState(3812)
		p.ValueTypePredicatePart2()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueTypePredicatePart2Context is an interface to support dynamic dispatch.
type IValueTypePredicatePart2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IS() antlr.TerminalNode
	Typed() ITypedContext
	ValueType() IValueTypeContext
	NOT() antlr.TerminalNode

	// IsValueTypePredicatePart2Context differentiates from other interfaces.
	IsValueTypePredicatePart2Context()
}

type ValueTypePredicatePart2Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueTypePredicatePart2Context() *ValueTypePredicatePart2Context {
	var p = new(ValueTypePredicatePart2Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueTypePredicatePart2
	return p
}

func InitEmptyValueTypePredicatePart2Context(p *ValueTypePredicatePart2Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueTypePredicatePart2
}

func (*ValueTypePredicatePart2Context) IsValueTypePredicatePart2Context() {}

func NewValueTypePredicatePart2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueTypePredicatePart2Context {
	var p = new(ValueTypePredicatePart2Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_valueTypePredicatePart2

	return p
}

func (s *ValueTypePredicatePart2Context) GetParser() antlr.Parser { return s.parser }

func (s *ValueTypePredicatePart2Context) IS() antlr.TerminalNode {
	return s.GetToken(GQLParserIS, 0)
}

func (s *ValueTypePredicatePart2Context) Typed() ITypedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedContext)
}

func (s *ValueTypePredicatePart2Context) ValueType() IValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueTypeContext)
}

func (s *ValueTypePredicatePart2Context) NOT() antlr.TerminalNode {
	return s.GetToken(GQLParserNOT, 0)
}

func (s *ValueTypePredicatePart2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueTypePredicatePart2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueTypePredicatePart2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterValueTypePredicatePart2(s)
	}
}

func (s *ValueTypePredicatePart2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitValueTypePredicatePart2(s)
	}
}

func (p *GQLParser) ValueTypePredicatePart2() (localctx IValueTypePredicatePart2Context) {
	localctx = NewValueTypePredicatePart2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, GQLParserRULE_valueTypePredicatePart2)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3814)
		p.Match(GQLParserIS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3816)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserNOT {
		{
			p.SetState(3815)
			p.Match(GQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3818)
		p.Typed()
	}
	{
		p.SetState(3819)
		p.valueType(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INormalizedPredicatePart2Context is an interface to support dynamic dispatch.
type INormalizedPredicatePart2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IS() antlr.TerminalNode
	NORMALIZED() antlr.TerminalNode
	NOT() antlr.TerminalNode
	NormalForm() INormalFormContext

	// IsNormalizedPredicatePart2Context differentiates from other interfaces.
	IsNormalizedPredicatePart2Context()
}

type NormalizedPredicatePart2Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalizedPredicatePart2Context() *NormalizedPredicatePart2Context {
	var p = new(NormalizedPredicatePart2Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_normalizedPredicatePart2
	return p
}

func InitEmptyNormalizedPredicatePart2Context(p *NormalizedPredicatePart2Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_normalizedPredicatePart2
}

func (*NormalizedPredicatePart2Context) IsNormalizedPredicatePart2Context() {}

func NewNormalizedPredicatePart2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalizedPredicatePart2Context {
	var p = new(NormalizedPredicatePart2Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_normalizedPredicatePart2

	return p
}

func (s *NormalizedPredicatePart2Context) GetParser() antlr.Parser { return s.parser }

func (s *NormalizedPredicatePart2Context) IS() antlr.TerminalNode {
	return s.GetToken(GQLParserIS, 0)
}

func (s *NormalizedPredicatePart2Context) NORMALIZED() antlr.TerminalNode {
	return s.GetToken(GQLParserNORMALIZED, 0)
}

func (s *NormalizedPredicatePart2Context) NOT() antlr.TerminalNode {
	return s.GetToken(GQLParserNOT, 0)
}

func (s *NormalizedPredicatePart2Context) NormalForm() INormalFormContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INormalFormContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INormalFormContext)
}

func (s *NormalizedPredicatePart2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalizedPredicatePart2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalizedPredicatePart2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNormalizedPredicatePart2(s)
	}
}

func (s *NormalizedPredicatePart2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNormalizedPredicatePart2(s)
	}
}

func (p *GQLParser) NormalizedPredicatePart2() (localctx INormalizedPredicatePart2Context) {
	localctx = NewNormalizedPredicatePart2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, GQLParserRULE_normalizedPredicatePart2)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3821)
		p.Match(GQLParserIS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserNOT {
		{
			p.SetState(3822)
			p.Match(GQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-299)) & ^0x3f) == 0 && ((int64(1)<<(_la-299))&15) != 0 {
		{
			p.SetState(3825)
			p.NormalForm()
		}

	}
	{
		p.SetState(3828)
		p.Match(GQLParserNORMALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDirectedPredicateContext is an interface to support dynamic dispatch.
type IDirectedPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementVariableReference() IElementVariableReferenceContext
	DirectedPredicatePart2() IDirectedPredicatePart2Context

	// IsDirectedPredicateContext differentiates from other interfaces.
	IsDirectedPredicateContext()
}

type DirectedPredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectedPredicateContext() *DirectedPredicateContext {
	var p = new(DirectedPredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_directedPredicate
	return p
}

func InitEmptyDirectedPredicateContext(p *DirectedPredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_directedPredicate
}

func (*DirectedPredicateContext) IsDirectedPredicateContext() {}

func NewDirectedPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectedPredicateContext {
	var p = new(DirectedPredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_directedPredicate

	return p
}

func (s *DirectedPredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectedPredicateContext) ElementVariableReference() IElementVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementVariableReferenceContext)
}

func (s *DirectedPredicateContext) DirectedPredicatePart2() IDirectedPredicatePart2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectedPredicatePart2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectedPredicatePart2Context)
}

func (s *DirectedPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectedPredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectedPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDirectedPredicate(s)
	}
}

func (s *DirectedPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDirectedPredicate(s)
	}
}

func (p *GQLParser) DirectedPredicate() (localctx IDirectedPredicateContext) {
	localctx = NewDirectedPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, GQLParserRULE_directedPredicate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3830)
		p.ElementVariableReference()
	}
	{
		p.SetState(3831)
		p.DirectedPredicatePart2()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDirectedPredicatePart2Context is an interface to support dynamic dispatch.
type IDirectedPredicatePart2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IS() antlr.TerminalNode
	DIRECTED() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsDirectedPredicatePart2Context differentiates from other interfaces.
	IsDirectedPredicatePart2Context()
}

type DirectedPredicatePart2Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectedPredicatePart2Context() *DirectedPredicatePart2Context {
	var p = new(DirectedPredicatePart2Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_directedPredicatePart2
	return p
}

func InitEmptyDirectedPredicatePart2Context(p *DirectedPredicatePart2Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_directedPredicatePart2
}

func (*DirectedPredicatePart2Context) IsDirectedPredicatePart2Context() {}

func NewDirectedPredicatePart2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectedPredicatePart2Context {
	var p = new(DirectedPredicatePart2Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_directedPredicatePart2

	return p
}

func (s *DirectedPredicatePart2Context) GetParser() antlr.Parser { return s.parser }

func (s *DirectedPredicatePart2Context) IS() antlr.TerminalNode {
	return s.GetToken(GQLParserIS, 0)
}

func (s *DirectedPredicatePart2Context) DIRECTED() antlr.TerminalNode {
	return s.GetToken(GQLParserDIRECTED, 0)
}

func (s *DirectedPredicatePart2Context) NOT() antlr.TerminalNode {
	return s.GetToken(GQLParserNOT, 0)
}

func (s *DirectedPredicatePart2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectedPredicatePart2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectedPredicatePart2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDirectedPredicatePart2(s)
	}
}

func (s *DirectedPredicatePart2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDirectedPredicatePart2(s)
	}
}

func (p *GQLParser) DirectedPredicatePart2() (localctx IDirectedPredicatePart2Context) {
	localctx = NewDirectedPredicatePart2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, GQLParserRULE_directedPredicatePart2)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3833)
		p.Match(GQLParserIS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3835)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserNOT {
		{
			p.SetState(3834)
			p.Match(GQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3837)
		p.Match(GQLParserDIRECTED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabeledPredicateContext is an interface to support dynamic dispatch.
type ILabeledPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementVariableReference() IElementVariableReferenceContext
	LabeledPredicatePart2() ILabeledPredicatePart2Context

	// IsLabeledPredicateContext differentiates from other interfaces.
	IsLabeledPredicateContext()
}

type LabeledPredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledPredicateContext() *LabeledPredicateContext {
	var p = new(LabeledPredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_labeledPredicate
	return p
}

func InitEmptyLabeledPredicateContext(p *LabeledPredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_labeledPredicate
}

func (*LabeledPredicateContext) IsLabeledPredicateContext() {}

func NewLabeledPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledPredicateContext {
	var p = new(LabeledPredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_labeledPredicate

	return p
}

func (s *LabeledPredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *LabeledPredicateContext) ElementVariableReference() IElementVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementVariableReferenceContext)
}

func (s *LabeledPredicateContext) LabeledPredicatePart2() ILabeledPredicatePart2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabeledPredicatePart2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabeledPredicatePart2Context)
}

func (s *LabeledPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledPredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabeledPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLabeledPredicate(s)
	}
}

func (s *LabeledPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLabeledPredicate(s)
	}
}

func (p *GQLParser) LabeledPredicate() (localctx ILabeledPredicateContext) {
	localctx = NewLabeledPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, GQLParserRULE_labeledPredicate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3839)
		p.ElementVariableReference()
	}
	{
		p.SetState(3840)
		p.LabeledPredicatePart2()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabeledPredicatePart2Context is an interface to support dynamic dispatch.
type ILabeledPredicatePart2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IsLabeledOrColon() IIsLabeledOrColonContext
	LabelExpression() ILabelExpressionContext

	// IsLabeledPredicatePart2Context differentiates from other interfaces.
	IsLabeledPredicatePart2Context()
}

type LabeledPredicatePart2Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledPredicatePart2Context() *LabeledPredicatePart2Context {
	var p = new(LabeledPredicatePart2Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_labeledPredicatePart2
	return p
}

func InitEmptyLabeledPredicatePart2Context(p *LabeledPredicatePart2Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_labeledPredicatePart2
}

func (*LabeledPredicatePart2Context) IsLabeledPredicatePart2Context() {}

func NewLabeledPredicatePart2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledPredicatePart2Context {
	var p = new(LabeledPredicatePart2Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_labeledPredicatePart2

	return p
}

func (s *LabeledPredicatePart2Context) GetParser() antlr.Parser { return s.parser }

func (s *LabeledPredicatePart2Context) IsLabeledOrColon() IIsLabeledOrColonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsLabeledOrColonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsLabeledOrColonContext)
}

func (s *LabeledPredicatePart2Context) LabelExpression() ILabelExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelExpressionContext)
}

func (s *LabeledPredicatePart2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledPredicatePart2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabeledPredicatePart2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLabeledPredicatePart2(s)
	}
}

func (s *LabeledPredicatePart2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLabeledPredicatePart2(s)
	}
}

func (p *GQLParser) LabeledPredicatePart2() (localctx ILabeledPredicatePart2Context) {
	localctx = NewLabeledPredicatePart2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, GQLParserRULE_labeledPredicatePart2)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3842)
		p.IsLabeledOrColon()
	}
	{
		p.SetState(3843)
		p.labelExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsLabeledOrColonContext is an interface to support dynamic dispatch.
type IIsLabeledOrColonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IS() antlr.TerminalNode
	LABELED() antlr.TerminalNode
	NOT() antlr.TerminalNode
	COLON() antlr.TerminalNode

	// IsIsLabeledOrColonContext differentiates from other interfaces.
	IsIsLabeledOrColonContext()
}

type IsLabeledOrColonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsLabeledOrColonContext() *IsLabeledOrColonContext {
	var p = new(IsLabeledOrColonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_isLabeledOrColon
	return p
}

func InitEmptyIsLabeledOrColonContext(p *IsLabeledOrColonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_isLabeledOrColon
}

func (*IsLabeledOrColonContext) IsIsLabeledOrColonContext() {}

func NewIsLabeledOrColonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsLabeledOrColonContext {
	var p = new(IsLabeledOrColonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_isLabeledOrColon

	return p
}

func (s *IsLabeledOrColonContext) GetParser() antlr.Parser { return s.parser }

func (s *IsLabeledOrColonContext) IS() antlr.TerminalNode {
	return s.GetToken(GQLParserIS, 0)
}

func (s *IsLabeledOrColonContext) LABELED() antlr.TerminalNode {
	return s.GetToken(GQLParserLABELED, 0)
}

func (s *IsLabeledOrColonContext) NOT() antlr.TerminalNode {
	return s.GetToken(GQLParserNOT, 0)
}

func (s *IsLabeledOrColonContext) COLON() antlr.TerminalNode {
	return s.GetToken(GQLParserCOLON, 0)
}

func (s *IsLabeledOrColonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsLabeledOrColonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IsLabeledOrColonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterIsLabeledOrColon(s)
	}
}

func (s *IsLabeledOrColonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitIsLabeledOrColon(s)
	}
}

func (p *GQLParser) IsLabeledOrColon() (localctx IIsLabeledOrColonContext) {
	localctx = NewIsLabeledOrColonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, GQLParserRULE_isLabeledOrColon)
	var _la int

	p.SetState(3851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserIS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3845)
			p.Match(GQLParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserNOT {
			{
				p.SetState(3846)
				p.Match(GQLParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3849)
			p.Match(GQLParserLABELED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserCOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3850)
			p.Match(GQLParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISourceDestinationPredicateContext is an interface to support dynamic dispatch.
type ISourceDestinationPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NodeReference() INodeReferenceContext
	SourcePredicatePart2() ISourcePredicatePart2Context
	DestinationPredicatePart2() IDestinationPredicatePart2Context

	// IsSourceDestinationPredicateContext differentiates from other interfaces.
	IsSourceDestinationPredicateContext()
}

type SourceDestinationPredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceDestinationPredicateContext() *SourceDestinationPredicateContext {
	var p = new(SourceDestinationPredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sourceDestinationPredicate
	return p
}

func InitEmptySourceDestinationPredicateContext(p *SourceDestinationPredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sourceDestinationPredicate
}

func (*SourceDestinationPredicateContext) IsSourceDestinationPredicateContext() {}

func NewSourceDestinationPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceDestinationPredicateContext {
	var p = new(SourceDestinationPredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sourceDestinationPredicate

	return p
}

func (s *SourceDestinationPredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceDestinationPredicateContext) NodeReference() INodeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeReferenceContext)
}

func (s *SourceDestinationPredicateContext) SourcePredicatePart2() ISourcePredicatePart2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourcePredicatePart2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourcePredicatePart2Context)
}

func (s *SourceDestinationPredicateContext) DestinationPredicatePart2() IDestinationPredicatePart2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestinationPredicatePart2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestinationPredicatePart2Context)
}

func (s *SourceDestinationPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceDestinationPredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceDestinationPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSourceDestinationPredicate(s)
	}
}

func (s *SourceDestinationPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSourceDestinationPredicate(s)
	}
}

func (p *GQLParser) SourceDestinationPredicate() (localctx ISourceDestinationPredicateContext) {
	localctx = NewSourceDestinationPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, GQLParserRULE_sourceDestinationPredicate)
	p.SetState(3859)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 433, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3853)
			p.NodeReference()
		}
		{
			p.SetState(3854)
			p.SourcePredicatePart2()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3856)
			p.NodeReference()
		}
		{
			p.SetState(3857)
			p.DestinationPredicatePart2()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeReferenceContext is an interface to support dynamic dispatch.
type INodeReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementVariableReference() IElementVariableReferenceContext

	// IsNodeReferenceContext differentiates from other interfaces.
	IsNodeReferenceContext()
}

type NodeReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeReferenceContext() *NodeReferenceContext {
	var p = new(NodeReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeReference
	return p
}

func InitEmptyNodeReferenceContext(p *NodeReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeReference
}

func (*NodeReferenceContext) IsNodeReferenceContext() {}

func NewNodeReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeReferenceContext {
	var p = new(NodeReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nodeReference

	return p
}

func (s *NodeReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeReferenceContext) ElementVariableReference() IElementVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementVariableReferenceContext)
}

func (s *NodeReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNodeReference(s)
	}
}

func (s *NodeReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNodeReference(s)
	}
}

func (p *GQLParser) NodeReference() (localctx INodeReferenceContext) {
	localctx = NewNodeReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, GQLParserRULE_nodeReference)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3861)
		p.ElementVariableReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISourcePredicatePart2Context is an interface to support dynamic dispatch.
type ISourcePredicatePart2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IS() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	OF() antlr.TerminalNode
	EdgeReference() IEdgeReferenceContext
	NOT() antlr.TerminalNode

	// IsSourcePredicatePart2Context differentiates from other interfaces.
	IsSourcePredicatePart2Context()
}

type SourcePredicatePart2Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourcePredicatePart2Context() *SourcePredicatePart2Context {
	var p = new(SourcePredicatePart2Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sourcePredicatePart2
	return p
}

func InitEmptySourcePredicatePart2Context(p *SourcePredicatePart2Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_sourcePredicatePart2
}

func (*SourcePredicatePart2Context) IsSourcePredicatePart2Context() {}

func NewSourcePredicatePart2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourcePredicatePart2Context {
	var p = new(SourcePredicatePart2Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_sourcePredicatePart2

	return p
}

func (s *SourcePredicatePart2Context) GetParser() antlr.Parser { return s.parser }

func (s *SourcePredicatePart2Context) IS() antlr.TerminalNode {
	return s.GetToken(GQLParserIS, 0)
}

func (s *SourcePredicatePart2Context) SOURCE() antlr.TerminalNode {
	return s.GetToken(GQLParserSOURCE, 0)
}

func (s *SourcePredicatePart2Context) OF() antlr.TerminalNode {
	return s.GetToken(GQLParserOF, 0)
}

func (s *SourcePredicatePart2Context) EdgeReference() IEdgeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeReferenceContext)
}

func (s *SourcePredicatePart2Context) NOT() antlr.TerminalNode {
	return s.GetToken(GQLParserNOT, 0)
}

func (s *SourcePredicatePart2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourcePredicatePart2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourcePredicatePart2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSourcePredicatePart2(s)
	}
}

func (s *SourcePredicatePart2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSourcePredicatePart2(s)
	}
}

func (p *GQLParser) SourcePredicatePart2() (localctx ISourcePredicatePart2Context) {
	localctx = NewSourcePredicatePart2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 836, GQLParserRULE_sourcePredicatePart2)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3863)
		p.Match(GQLParserIS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3865)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserNOT {
		{
			p.SetState(3864)
			p.Match(GQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3867)
		p.Match(GQLParserSOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3868)
		p.Match(GQLParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3869)
		p.EdgeReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDestinationPredicatePart2Context is an interface to support dynamic dispatch.
type IDestinationPredicatePart2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IS() antlr.TerminalNode
	DESTINATION() antlr.TerminalNode
	OF() antlr.TerminalNode
	EdgeReference() IEdgeReferenceContext
	NOT() antlr.TerminalNode

	// IsDestinationPredicatePart2Context differentiates from other interfaces.
	IsDestinationPredicatePart2Context()
}

type DestinationPredicatePart2Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestinationPredicatePart2Context() *DestinationPredicatePart2Context {
	var p = new(DestinationPredicatePart2Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_destinationPredicatePart2
	return p
}

func InitEmptyDestinationPredicatePart2Context(p *DestinationPredicatePart2Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_destinationPredicatePart2
}

func (*DestinationPredicatePart2Context) IsDestinationPredicatePart2Context() {}

func NewDestinationPredicatePart2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestinationPredicatePart2Context {
	var p = new(DestinationPredicatePart2Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_destinationPredicatePart2

	return p
}

func (s *DestinationPredicatePart2Context) GetParser() antlr.Parser { return s.parser }

func (s *DestinationPredicatePart2Context) IS() antlr.TerminalNode {
	return s.GetToken(GQLParserIS, 0)
}

func (s *DestinationPredicatePart2Context) DESTINATION() antlr.TerminalNode {
	return s.GetToken(GQLParserDESTINATION, 0)
}

func (s *DestinationPredicatePart2Context) OF() antlr.TerminalNode {
	return s.GetToken(GQLParserOF, 0)
}

func (s *DestinationPredicatePart2Context) EdgeReference() IEdgeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeReferenceContext)
}

func (s *DestinationPredicatePart2Context) NOT() antlr.TerminalNode {
	return s.GetToken(GQLParserNOT, 0)
}

func (s *DestinationPredicatePart2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestinationPredicatePart2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DestinationPredicatePart2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDestinationPredicatePart2(s)
	}
}

func (s *DestinationPredicatePart2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDestinationPredicatePart2(s)
	}
}

func (p *GQLParser) DestinationPredicatePart2() (localctx IDestinationPredicatePart2Context) {
	localctx = NewDestinationPredicatePart2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 838, GQLParserRULE_destinationPredicatePart2)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3871)
		p.Match(GQLParserIS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserNOT {
		{
			p.SetState(3872)
			p.Match(GQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3875)
		p.Match(GQLParserDESTINATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3876)
		p.Match(GQLParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3877)
		p.EdgeReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeReferenceContext is an interface to support dynamic dispatch.
type IEdgeReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ElementVariableReference() IElementVariableReferenceContext

	// IsEdgeReferenceContext differentiates from other interfaces.
	IsEdgeReferenceContext()
}

type EdgeReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeReferenceContext() *EdgeReferenceContext {
	var p = new(EdgeReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeReference
	return p
}

func InitEmptyEdgeReferenceContext(p *EdgeReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeReference
}

func (*EdgeReferenceContext) IsEdgeReferenceContext() {}

func NewEdgeReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeReferenceContext {
	var p = new(EdgeReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeReference

	return p
}

func (s *EdgeReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeReferenceContext) ElementVariableReference() IElementVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementVariableReferenceContext)
}

func (s *EdgeReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeReference(s)
	}
}

func (s *EdgeReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeReference(s)
	}
}

func (p *GQLParser) EdgeReference() (localctx IEdgeReferenceContext) {
	localctx = NewEdgeReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 840, GQLParserRULE_edgeReference)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3879)
		p.ElementVariableReference()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAll_differentPredicateContext is an interface to support dynamic dispatch.
type IAll_differentPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL_DIFFERENT() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	AllElementVariableReference() []IElementVariableReferenceContext
	ElementVariableReference(i int) IElementVariableReferenceContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsAll_differentPredicateContext differentiates from other interfaces.
	IsAll_differentPredicateContext()
}

type All_differentPredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAll_differentPredicateContext() *All_differentPredicateContext {
	var p = new(All_differentPredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_all_differentPredicate
	return p
}

func InitEmptyAll_differentPredicateContext(p *All_differentPredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_all_differentPredicate
}

func (*All_differentPredicateContext) IsAll_differentPredicateContext() {}

func NewAll_differentPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *All_differentPredicateContext {
	var p = new(All_differentPredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_all_differentPredicate

	return p
}

func (s *All_differentPredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *All_differentPredicateContext) ALL_DIFFERENT() antlr.TerminalNode {
	return s.GetToken(GQLParserALL_DIFFERENT, 0)
}

func (s *All_differentPredicateContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *All_differentPredicateContext) AllElementVariableReference() []IElementVariableReferenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementVariableReferenceContext); ok {
			len++
		}
	}

	tst := make([]IElementVariableReferenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementVariableReferenceContext); ok {
			tst[i] = t.(IElementVariableReferenceContext)
			i++
		}
	}

	return tst
}

func (s *All_differentPredicateContext) ElementVariableReference(i int) IElementVariableReferenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementVariableReferenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementVariableReferenceContext)
}

func (s *All_differentPredicateContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *All_differentPredicateContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *All_differentPredicateContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *All_differentPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *All_differentPredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *All_differentPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAll_differentPredicate(s)
	}
}

func (s *All_differentPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAll_differentPredicate(s)
	}
}

func (p *GQLParser) All_differentPredicate() (localctx IAll_differentPredicateContext) {
	localctx = NewAll_differentPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 842, GQLParserRULE_all_differentPredicate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3881)
		p.Match(GQLParserALL_DIFFERENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3882)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3883)
		p.ElementVariableReference()
	}
	{
		p.SetState(3884)
		p.Match(GQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3885)
		p.ElementVariableReference()
	}
	p.SetState(3890)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(3886)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3887)
			p.ElementVariableReference()
		}

		p.SetState(3892)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3893)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISamePredicateContext is an interface to support dynamic dispatch.
type ISamePredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAME() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	AllElementVariableReference() []IElementVariableReferenceContext
	ElementVariableReference(i int) IElementVariableReferenceContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsSamePredicateContext differentiates from other interfaces.
	IsSamePredicateContext()
}

type SamePredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySamePredicateContext() *SamePredicateContext {
	var p = new(SamePredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_samePredicate
	return p
}

func InitEmptySamePredicateContext(p *SamePredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_samePredicate
}

func (*SamePredicateContext) IsSamePredicateContext() {}

func NewSamePredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SamePredicateContext {
	var p = new(SamePredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_samePredicate

	return p
}

func (s *SamePredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *SamePredicateContext) SAME() antlr.TerminalNode {
	return s.GetToken(GQLParserSAME, 0)
}

func (s *SamePredicateContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *SamePredicateContext) AllElementVariableReference() []IElementVariableReferenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementVariableReferenceContext); ok {
			len++
		}
	}

	tst := make([]IElementVariableReferenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementVariableReferenceContext); ok {
			tst[i] = t.(IElementVariableReferenceContext)
			i++
		}
	}

	return tst
}

func (s *SamePredicateContext) ElementVariableReference(i int) IElementVariableReferenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementVariableReferenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementVariableReferenceContext)
}

func (s *SamePredicateContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *SamePredicateContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *SamePredicateContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *SamePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SamePredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SamePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSamePredicate(s)
	}
}

func (s *SamePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSamePredicate(s)
	}
}

func (p *GQLParser) SamePredicate() (localctx ISamePredicateContext) {
	localctx = NewSamePredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 844, GQLParserRULE_samePredicate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3895)
		p.Match(GQLParserSAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3896)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3897)
		p.ElementVariableReference()
	}
	{
		p.SetState(3898)
		p.Match(GQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3899)
		p.ElementVariableReference()
	}
	p.SetState(3904)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(3900)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3901)
			p.ElementVariableReference()
		}

		p.SetState(3906)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3907)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProperty_existsPredicateContext is an interface to support dynamic dispatch.
type IProperty_existsPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROPERTY_EXISTS() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	ElementVariableReference() IElementVariableReferenceContext
	COMMA() antlr.TerminalNode
	PropertyName() IPropertyNameContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsProperty_existsPredicateContext differentiates from other interfaces.
	IsProperty_existsPredicateContext()
}

type Property_existsPredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProperty_existsPredicateContext() *Property_existsPredicateContext {
	var p = new(Property_existsPredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_property_existsPredicate
	return p
}

func InitEmptyProperty_existsPredicateContext(p *Property_existsPredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_property_existsPredicate
}

func (*Property_existsPredicateContext) IsProperty_existsPredicateContext() {}

func NewProperty_existsPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Property_existsPredicateContext {
	var p = new(Property_existsPredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_property_existsPredicate

	return p
}

func (s *Property_existsPredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *Property_existsPredicateContext) PROPERTY_EXISTS() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY_EXISTS, 0)
}

func (s *Property_existsPredicateContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *Property_existsPredicateContext) ElementVariableReference() IElementVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementVariableReferenceContext)
}

func (s *Property_existsPredicateContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *Property_existsPredicateContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *Property_existsPredicateContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *Property_existsPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Property_existsPredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Property_existsPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterProperty_existsPredicate(s)
	}
}

func (s *Property_existsPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitProperty_existsPredicate(s)
	}
}

func (p *GQLParser) Property_existsPredicate() (localctx IProperty_existsPredicateContext) {
	localctx = NewProperty_existsPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 846, GQLParserRULE_property_existsPredicate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3909)
		p.Match(GQLParserPROPERTY_EXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3910)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3911)
		p.ElementVariableReference()
	}
	{
		p.SetState(3912)
		p.Match(GQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3913)
		p.PropertyName()
	}
	{
		p.SetState(3914)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueExpression
	return p
}

func InitEmptyValueExpressionContext(p *ValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueExpression
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyAll(ctx *ValueExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ConjunctiveExprAltContext struct {
	ValueExpressionContext
}

func NewConjunctiveExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConjunctiveExprAltContext {
	var p = new(ConjunctiveExprAltContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ConjunctiveExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConjunctiveExprAltContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConjunctiveExprAltContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ConjunctiveExprAltContext) AND() antlr.TerminalNode {
	return s.GetToken(GQLParserAND, 0)
}

func (s *ConjunctiveExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterConjunctiveExprAlt(s)
	}
}

func (s *ConjunctiveExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitConjunctiveExprAlt(s)
	}
}

type PropertyGraphExprAltContext struct {
	ValueExpressionContext
}

func NewPropertyGraphExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PropertyGraphExprAltContext {
	var p = new(PropertyGraphExprAltContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *PropertyGraphExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyGraphExprAltContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserGRAPH, 0)
}

func (s *PropertyGraphExprAltContext) GraphExpression() IGraphExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphExpressionContext)
}

func (s *PropertyGraphExprAltContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY, 0)
}

func (s *PropertyGraphExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPropertyGraphExprAlt(s)
	}
}

func (s *PropertyGraphExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPropertyGraphExprAlt(s)
	}
}

type MultDivExprAltContext struct {
	ValueExpressionContext
	operator antlr.Token
}

func NewMultDivExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultDivExprAltContext {
	var p = new(MultDivExprAltContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *MultDivExprAltContext) GetOperator() antlr.Token { return s.operator }

func (s *MultDivExprAltContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *MultDivExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultDivExprAltContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultDivExprAltContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *MultDivExprAltContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(GQLParserASTERISK, 0)
}

func (s *MultDivExprAltContext) SOLIDUS() antlr.TerminalNode {
	return s.GetToken(GQLParserSOLIDUS, 0)
}

func (s *MultDivExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterMultDivExprAlt(s)
	}
}

func (s *MultDivExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitMultDivExprAlt(s)
	}
}

type BindingTableExprAltContext struct {
	ValueExpressionContext
}

func NewBindingTableExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BindingTableExprAltContext {
	var p = new(BindingTableExprAltContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *BindingTableExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingTableExprAltContext) TABLE() antlr.TerminalNode {
	return s.GetToken(GQLParserTABLE, 0)
}

func (s *BindingTableExprAltContext) BindingTableExpression() IBindingTableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingTableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingTableExpressionContext)
}

func (s *BindingTableExprAltContext) BINDING() antlr.TerminalNode {
	return s.GetToken(GQLParserBINDING, 0)
}

func (s *BindingTableExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBindingTableExprAlt(s)
	}
}

func (s *BindingTableExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBindingTableExprAlt(s)
	}
}

type SignedExprAltContext struct {
	ValueExpressionContext
	sign antlr.Token
}

func NewSignedExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SignedExprAltContext {
	var p = new(SignedExprAltContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *SignedExprAltContext) GetSign() antlr.Token { return s.sign }

func (s *SignedExprAltContext) SetSign(v antlr.Token) { s.sign = v }

func (s *SignedExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedExprAltContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SignedExprAltContext) PLUS_SIGN() antlr.TerminalNode {
	return s.GetToken(GQLParserPLUS_SIGN, 0)
}

func (s *SignedExprAltContext) MINUS_SIGN() antlr.TerminalNode {
	return s.GetToken(GQLParserMINUS_SIGN, 0)
}

func (s *SignedExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSignedExprAlt(s)
	}
}

func (s *SignedExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSignedExprAlt(s)
	}
}

type IsNotExprAltContext struct {
	ValueExpressionContext
}

func NewIsNotExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsNotExprAltContext {
	var p = new(IsNotExprAltContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *IsNotExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsNotExprAltContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *IsNotExprAltContext) IS() antlr.TerminalNode {
	return s.GetToken(GQLParserIS, 0)
}

func (s *IsNotExprAltContext) TruthValue() ITruthValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruthValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruthValueContext)
}

func (s *IsNotExprAltContext) NOT() antlr.TerminalNode {
	return s.GetToken(GQLParserNOT, 0)
}

func (s *IsNotExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterIsNotExprAlt(s)
	}
}

func (s *IsNotExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitIsNotExprAlt(s)
	}
}

type NormalizedPredicateExprAltContext struct {
	ValueExpressionContext
}

func NewNormalizedPredicateExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NormalizedPredicateExprAltContext {
	var p = new(NormalizedPredicateExprAltContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *NormalizedPredicateExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalizedPredicateExprAltContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *NormalizedPredicateExprAltContext) NormalizedPredicatePart2() INormalizedPredicatePart2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INormalizedPredicatePart2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INormalizedPredicatePart2Context)
}

func (s *NormalizedPredicateExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNormalizedPredicateExprAlt(s)
	}
}

func (s *NormalizedPredicateExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNormalizedPredicateExprAlt(s)
	}
}

type NotExprAltContext struct {
	ValueExpressionContext
}

func NewNotExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExprAltContext {
	var p = new(NotExprAltContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *NotExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExprAltContext) NOT() antlr.TerminalNode {
	return s.GetToken(GQLParserNOT, 0)
}

func (s *NotExprAltContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *NotExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNotExprAlt(s)
	}
}

func (s *NotExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNotExprAlt(s)
	}
}

type ValueFunctionExprAltContext struct {
	ValueExpressionContext
}

func NewValueFunctionExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueFunctionExprAltContext {
	var p = new(ValueFunctionExprAltContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueFunctionExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueFunctionExprAltContext) ValueFunction() IValueFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueFunctionContext)
}

func (s *ValueFunctionExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterValueFunctionExprAlt(s)
	}
}

func (s *ValueFunctionExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitValueFunctionExprAlt(s)
	}
}

type ConcatenationExprAltContext struct {
	ValueExpressionContext
}

func NewConcatenationExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatenationExprAltContext {
	var p = new(ConcatenationExprAltContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ConcatenationExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationExprAltContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConcatenationExprAltContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ConcatenationExprAltContext) CONCATENATION_OPERATOR() antlr.TerminalNode {
	return s.GetToken(GQLParserCONCATENATION_OPERATOR, 0)
}

func (s *ConcatenationExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterConcatenationExprAlt(s)
	}
}

func (s *ConcatenationExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitConcatenationExprAlt(s)
	}
}

type DisjunctiveExprAltContext struct {
	ValueExpressionContext
	operator antlr.Token
}

func NewDisjunctiveExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DisjunctiveExprAltContext {
	var p = new(DisjunctiveExprAltContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *DisjunctiveExprAltContext) GetOperator() antlr.Token { return s.operator }

func (s *DisjunctiveExprAltContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *DisjunctiveExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisjunctiveExprAltContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *DisjunctiveExprAltContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DisjunctiveExprAltContext) OR() antlr.TerminalNode {
	return s.GetToken(GQLParserOR, 0)
}

func (s *DisjunctiveExprAltContext) XOR() antlr.TerminalNode {
	return s.GetToken(GQLParserXOR, 0)
}

func (s *DisjunctiveExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDisjunctiveExprAlt(s)
	}
}

func (s *DisjunctiveExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDisjunctiveExprAlt(s)
	}
}

type ComparisonExprAltContext struct {
	ValueExpressionContext
}

func NewComparisonExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonExprAltContext {
	var p = new(ComparisonExprAltContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ComparisonExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExprAltContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExprAltContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonExprAltContext) CompOp() ICompOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompOpContext)
}

func (s *ComparisonExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterComparisonExprAlt(s)
	}
}

func (s *ComparisonExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitComparisonExprAlt(s)
	}
}

type PrimaryExprAltContext struct {
	ValueExpressionContext
}

func NewPrimaryExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryExprAltContext {
	var p = new(PrimaryExprAltContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *PrimaryExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprAltContext) ValueExpressionPrimary() IValueExpressionPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionPrimaryContext)
}

func (s *PrimaryExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPrimaryExprAlt(s)
	}
}

func (s *PrimaryExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPrimaryExprAlt(s)
	}
}

type AddSubtractExprAltContext struct {
	ValueExpressionContext
	operator antlr.Token
}

func NewAddSubtractExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddSubtractExprAltContext {
	var p = new(AddSubtractExprAltContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *AddSubtractExprAltContext) GetOperator() antlr.Token { return s.operator }

func (s *AddSubtractExprAltContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *AddSubtractExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddSubtractExprAltContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AddSubtractExprAltContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *AddSubtractExprAltContext) PLUS_SIGN() antlr.TerminalNode {
	return s.GetToken(GQLParserPLUS_SIGN, 0)
}

func (s *AddSubtractExprAltContext) MINUS_SIGN() antlr.TerminalNode {
	return s.GetToken(GQLParserMINUS_SIGN, 0)
}

func (s *AddSubtractExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAddSubtractExprAlt(s)
	}
}

func (s *AddSubtractExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAddSubtractExprAlt(s)
	}
}

type PredicateExprAltContext struct {
	ValueExpressionContext
}

func NewPredicateExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExprAltContext {
	var p = new(PredicateExprAltContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *PredicateExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExprAltContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPredicateExprAlt(s)
	}
}

func (s *PredicateExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPredicateExprAlt(s)
	}
}

func (p *GQLParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *GQLParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 848
	p.EnterRecursionRule(localctx, 848, GQLParserRULE_valueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3934)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 440, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSignedExprAltContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(3917)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SignedExprAltContext).sign = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == GQLParserMINUS_SIGN || _la == GQLParserPLUS_SIGN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SignedExprAltContext).sign = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3918)
			p.valueExpression(15)
		}

	case 2:
		localctx = NewPredicateExprAltContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3919)
			p.Predicate()
		}

	case 3:
		localctx = NewNotExprAltContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3920)
			p.Match(GQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3921)
			p.valueExpression(8)
		}

	case 4:
		localctx = NewPropertyGraphExprAltContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(3923)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserPROPERTY {
			{
				p.SetState(3922)
				p.Match(GQLParserPROPERTY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3925)
			p.Match(GQLParserGRAPH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3926)
			p.GraphExpression()
		}

	case 5:
		localctx = NewBindingTableExprAltContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(3928)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserBINDING {
			{
				p.SetState(3927)
				p.Match(GQLParserBINDING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3930)
			p.Match(GQLParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3931)
			p.BindingTableExpression()
		}

	case 6:
		localctx = NewValueFunctionExprAltContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3932)
			p.ValueFunction()
		}

	case 7:
		localctx = NewPrimaryExprAltContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3933)
			p.valueExpressionPrimary(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3965)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 443, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3963)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 442, p.GetParserRuleContext()) {
			case 1:
				localctx = NewMultDivExprAltContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_valueExpression)
				p.SetState(3936)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(3937)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*MultDivExprAltContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GQLParserASTERISK || _la == GQLParserSOLIDUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*MultDivExprAltContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(3938)
					p.valueExpression(15)
				}

			case 2:
				localctx = NewAddSubtractExprAltContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_valueExpression)
				p.SetState(3939)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(3940)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*AddSubtractExprAltContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GQLParserMINUS_SIGN || _la == GQLParserPLUS_SIGN) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*AddSubtractExprAltContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(3941)
					p.valueExpression(14)
				}

			case 3:
				localctx = NewConcatenationExprAltContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_valueExpression)
				p.SetState(3942)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(3943)
					p.Match(GQLParserCONCATENATION_OPERATOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3944)
					p.valueExpression(13)
				}

			case 4:
				localctx = NewComparisonExprAltContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_valueExpression)
				p.SetState(3945)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(3946)
					p.CompOp()
				}
				{
					p.SetState(3947)
					p.valueExpression(12)
				}

			case 5:
				localctx = NewConjunctiveExprAltContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_valueExpression)
				p.SetState(3949)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(3950)
					p.Match(GQLParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3951)
					p.valueExpression(7)
				}

			case 6:
				localctx = NewDisjunctiveExprAltContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_valueExpression)
				p.SetState(3952)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(3953)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*DisjunctiveExprAltContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GQLParserOR || _la == GQLParserXOR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*DisjunctiveExprAltContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(3954)
					p.valueExpression(6)
				}

			case 7:
				localctx = NewNormalizedPredicateExprAltContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_valueExpression)
				p.SetState(3955)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(3956)
					p.NormalizedPredicatePart2()
				}

			case 8:
				localctx = NewIsNotExprAltContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_valueExpression)
				p.SetState(3957)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(3958)
					p.Match(GQLParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3960)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == GQLParserNOT {
					{
						p.SetState(3959)
						p.Match(GQLParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(3962)
					p.TruthValue()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(3967)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 443, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueFunctionContext is an interface to support dynamic dispatch.
type IValueFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericValueFunction() INumericValueFunctionContext
	DatetimeSubtraction() IDatetimeSubtractionContext
	DatetimeValueFunction() IDatetimeValueFunctionContext
	DurationValueFunction() IDurationValueFunctionContext
	CharacterOrByteStringFunction() ICharacterOrByteStringFunctionContext
	ListValueFunction() IListValueFunctionContext

	// IsValueFunctionContext differentiates from other interfaces.
	IsValueFunctionContext()
}

type ValueFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueFunctionContext() *ValueFunctionContext {
	var p = new(ValueFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueFunction
	return p
}

func InitEmptyValueFunctionContext(p *ValueFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueFunction
}

func (*ValueFunctionContext) IsValueFunctionContext() {}

func NewValueFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueFunctionContext {
	var p = new(ValueFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_valueFunction

	return p
}

func (s *ValueFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueFunctionContext) NumericValueFunction() INumericValueFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueFunctionContext)
}

func (s *ValueFunctionContext) DatetimeSubtraction() IDatetimeSubtractionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeSubtractionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeSubtractionContext)
}

func (s *ValueFunctionContext) DatetimeValueFunction() IDatetimeValueFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeValueFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeValueFunctionContext)
}

func (s *ValueFunctionContext) DurationValueFunction() IDurationValueFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDurationValueFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDurationValueFunctionContext)
}

func (s *ValueFunctionContext) CharacterOrByteStringFunction() ICharacterOrByteStringFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacterOrByteStringFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacterOrByteStringFunctionContext)
}

func (s *ValueFunctionContext) ListValueFunction() IListValueFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListValueFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListValueFunctionContext)
}

func (s *ValueFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterValueFunction(s)
	}
}

func (s *ValueFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitValueFunction(s)
	}
}

func (p *GQLParser) ValueFunction() (localctx IValueFunctionContext) {
	localctx = NewValueFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 850, GQLParserRULE_valueFunction)
	p.SetState(3974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 444, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3968)
			p.NumericValueFunction()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3969)
			p.DatetimeSubtraction()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3970)
			p.DatetimeValueFunction()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3971)
			p.DurationValueFunction()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3972)
			p.CharacterOrByteStringFunction()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3973)
			p.ListValueFunction()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanValueExpressionContext is an interface to support dynamic dispatch.
type IBooleanValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsBooleanValueExpressionContext differentiates from other interfaces.
	IsBooleanValueExpressionContext()
}

type BooleanValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueExpressionContext() *BooleanValueExpressionContext {
	var p = new(BooleanValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_booleanValueExpression
	return p
}

func InitEmptyBooleanValueExpressionContext(p *BooleanValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_booleanValueExpression
}

func (*BooleanValueExpressionContext) IsBooleanValueExpressionContext() {}

func NewBooleanValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueExpressionContext {
	var p = new(BooleanValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_booleanValueExpression

	return p
}

func (s *BooleanValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueExpressionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BooleanValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBooleanValueExpression(s)
	}
}

func (s *BooleanValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBooleanValueExpression(s)
	}
}

func (p *GQLParser) BooleanValueExpression() (localctx IBooleanValueExpressionContext) {
	localctx = NewBooleanValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 852, GQLParserRULE_booleanValueExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3976)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharacterOrByteStringFunctionContext is an interface to support dynamic dispatch.
type ICharacterOrByteStringFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SubCharacterOrByteString() ISubCharacterOrByteStringContext
	TrimSingleCharacterOrByteString() ITrimSingleCharacterOrByteStringContext
	FoldCharacterString() IFoldCharacterStringContext
	TrimMultiCharacterCharacterString() ITrimMultiCharacterCharacterStringContext
	NormalizeCharacterString() INormalizeCharacterStringContext

	// IsCharacterOrByteStringFunctionContext differentiates from other interfaces.
	IsCharacterOrByteStringFunctionContext()
}

type CharacterOrByteStringFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacterOrByteStringFunctionContext() *CharacterOrByteStringFunctionContext {
	var p = new(CharacterOrByteStringFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_characterOrByteStringFunction
	return p
}

func InitEmptyCharacterOrByteStringFunctionContext(p *CharacterOrByteStringFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_characterOrByteStringFunction
}

func (*CharacterOrByteStringFunctionContext) IsCharacterOrByteStringFunctionContext() {}

func NewCharacterOrByteStringFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharacterOrByteStringFunctionContext {
	var p = new(CharacterOrByteStringFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_characterOrByteStringFunction

	return p
}

func (s *CharacterOrByteStringFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CharacterOrByteStringFunctionContext) SubCharacterOrByteString() ISubCharacterOrByteStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubCharacterOrByteStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubCharacterOrByteStringContext)
}

func (s *CharacterOrByteStringFunctionContext) TrimSingleCharacterOrByteString() ITrimSingleCharacterOrByteStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrimSingleCharacterOrByteStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrimSingleCharacterOrByteStringContext)
}

func (s *CharacterOrByteStringFunctionContext) FoldCharacterString() IFoldCharacterStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFoldCharacterStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFoldCharacterStringContext)
}

func (s *CharacterOrByteStringFunctionContext) TrimMultiCharacterCharacterString() ITrimMultiCharacterCharacterStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrimMultiCharacterCharacterStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrimMultiCharacterCharacterStringContext)
}

func (s *CharacterOrByteStringFunctionContext) NormalizeCharacterString() INormalizeCharacterStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INormalizeCharacterStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INormalizeCharacterStringContext)
}

func (s *CharacterOrByteStringFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharacterOrByteStringFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharacterOrByteStringFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCharacterOrByteStringFunction(s)
	}
}

func (s *CharacterOrByteStringFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCharacterOrByteStringFunction(s)
	}
}

func (p *GQLParser) CharacterOrByteStringFunction() (localctx ICharacterOrByteStringFunctionContext) {
	localctx = NewCharacterOrByteStringFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 854, GQLParserRULE_characterOrByteStringFunction)
	p.SetState(3983)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserLEFT, GQLParserRIGHT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3978)
			p.SubCharacterOrByteString()
		}

	case GQLParserTRIM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3979)
			p.TrimSingleCharacterOrByteString()
		}

	case GQLParserLOWER, GQLParserUPPER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3980)
			p.FoldCharacterString()
		}

	case GQLParserBTRIM, GQLParserLTRIM, GQLParserRTRIM:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3981)
			p.TrimMultiCharacterCharacterString()
		}

	case GQLParserNORMALIZE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3982)
			p.NormalizeCharacterString()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubCharacterOrByteStringContext is an interface to support dynamic dispatch.
type ISubCharacterOrByteStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	ValueExpression() IValueExpressionContext
	COMMA() antlr.TerminalNode
	StringLength() IStringLengthContext
	RIGHT_PAREN() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	RIGHT() antlr.TerminalNode

	// IsSubCharacterOrByteStringContext differentiates from other interfaces.
	IsSubCharacterOrByteStringContext()
}

type SubCharacterOrByteStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubCharacterOrByteStringContext() *SubCharacterOrByteStringContext {
	var p = new(SubCharacterOrByteStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_subCharacterOrByteString
	return p
}

func InitEmptySubCharacterOrByteStringContext(p *SubCharacterOrByteStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_subCharacterOrByteString
}

func (*SubCharacterOrByteStringContext) IsSubCharacterOrByteStringContext() {}

func NewSubCharacterOrByteStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubCharacterOrByteStringContext {
	var p = new(SubCharacterOrByteStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_subCharacterOrByteString

	return p
}

func (s *SubCharacterOrByteStringContext) GetParser() antlr.Parser { return s.parser }

func (s *SubCharacterOrByteStringContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *SubCharacterOrByteStringContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubCharacterOrByteStringContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *SubCharacterOrByteStringContext) StringLength() IStringLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLengthContext)
}

func (s *SubCharacterOrByteStringContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *SubCharacterOrByteStringContext) LEFT() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT, 0)
}

func (s *SubCharacterOrByteStringContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT, 0)
}

func (s *SubCharacterOrByteStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubCharacterOrByteStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubCharacterOrByteStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSubCharacterOrByteString(s)
	}
}

func (s *SubCharacterOrByteStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSubCharacterOrByteString(s)
	}
}

func (p *GQLParser) SubCharacterOrByteString() (localctx ISubCharacterOrByteStringContext) {
	localctx = NewSubCharacterOrByteStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 856, GQLParserRULE_subCharacterOrByteString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3985)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserLEFT || _la == GQLParserRIGHT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3986)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3987)
		p.valueExpression(0)
	}
	{
		p.SetState(3988)
		p.Match(GQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3989)
		p.StringLength()
	}
	{
		p.SetState(3990)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrimSingleCharacterOrByteStringContext is an interface to support dynamic dispatch.
type ITrimSingleCharacterOrByteStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIM() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	TrimOperands() ITrimOperandsContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsTrimSingleCharacterOrByteStringContext differentiates from other interfaces.
	IsTrimSingleCharacterOrByteStringContext()
}

type TrimSingleCharacterOrByteStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrimSingleCharacterOrByteStringContext() *TrimSingleCharacterOrByteStringContext {
	var p = new(TrimSingleCharacterOrByteStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trimSingleCharacterOrByteString
	return p
}

func InitEmptyTrimSingleCharacterOrByteStringContext(p *TrimSingleCharacterOrByteStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trimSingleCharacterOrByteString
}

func (*TrimSingleCharacterOrByteStringContext) IsTrimSingleCharacterOrByteStringContext() {}

func NewTrimSingleCharacterOrByteStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrimSingleCharacterOrByteStringContext {
	var p = new(TrimSingleCharacterOrByteStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_trimSingleCharacterOrByteString

	return p
}

func (s *TrimSingleCharacterOrByteStringContext) GetParser() antlr.Parser { return s.parser }

func (s *TrimSingleCharacterOrByteStringContext) TRIM() antlr.TerminalNode {
	return s.GetToken(GQLParserTRIM, 0)
}

func (s *TrimSingleCharacterOrByteStringContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *TrimSingleCharacterOrByteStringContext) TrimOperands() ITrimOperandsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrimOperandsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrimOperandsContext)
}

func (s *TrimSingleCharacterOrByteStringContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *TrimSingleCharacterOrByteStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimSingleCharacterOrByteStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrimSingleCharacterOrByteStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTrimSingleCharacterOrByteString(s)
	}
}

func (s *TrimSingleCharacterOrByteStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTrimSingleCharacterOrByteString(s)
	}
}

func (p *GQLParser) TrimSingleCharacterOrByteString() (localctx ITrimSingleCharacterOrByteStringContext) {
	localctx = NewTrimSingleCharacterOrByteStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 858, GQLParserRULE_trimSingleCharacterOrByteString)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3992)
		p.Match(GQLParserTRIM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3993)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3994)
		p.TrimOperands()
	}
	{
		p.SetState(3995)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFoldCharacterStringContext is an interface to support dynamic dispatch.
type IFoldCharacterStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	ValueExpression() IValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode
	UPPER() antlr.TerminalNode
	LOWER() antlr.TerminalNode

	// IsFoldCharacterStringContext differentiates from other interfaces.
	IsFoldCharacterStringContext()
}

type FoldCharacterStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFoldCharacterStringContext() *FoldCharacterStringContext {
	var p = new(FoldCharacterStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_foldCharacterString
	return p
}

func InitEmptyFoldCharacterStringContext(p *FoldCharacterStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_foldCharacterString
}

func (*FoldCharacterStringContext) IsFoldCharacterStringContext() {}

func NewFoldCharacterStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FoldCharacterStringContext {
	var p = new(FoldCharacterStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_foldCharacterString

	return p
}

func (s *FoldCharacterStringContext) GetParser() antlr.Parser { return s.parser }

func (s *FoldCharacterStringContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *FoldCharacterStringContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *FoldCharacterStringContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *FoldCharacterStringContext) UPPER() antlr.TerminalNode {
	return s.GetToken(GQLParserUPPER, 0)
}

func (s *FoldCharacterStringContext) LOWER() antlr.TerminalNode {
	return s.GetToken(GQLParserLOWER, 0)
}

func (s *FoldCharacterStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FoldCharacterStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FoldCharacterStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFoldCharacterString(s)
	}
}

func (s *FoldCharacterStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFoldCharacterString(s)
	}
}

func (p *GQLParser) FoldCharacterString() (localctx IFoldCharacterStringContext) {
	localctx = NewFoldCharacterStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 860, GQLParserRULE_foldCharacterString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3997)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserLOWER || _la == GQLParserUPPER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3998)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3999)
		p.valueExpression(0)
	}
	{
		p.SetState(4000)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrimMultiCharacterCharacterStringContext is an interface to support dynamic dispatch.
type ITrimMultiCharacterCharacterStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode
	BTRIM() antlr.TerminalNode
	LTRIM() antlr.TerminalNode
	RTRIM() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsTrimMultiCharacterCharacterStringContext differentiates from other interfaces.
	IsTrimMultiCharacterCharacterStringContext()
}

type TrimMultiCharacterCharacterStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrimMultiCharacterCharacterStringContext() *TrimMultiCharacterCharacterStringContext {
	var p = new(TrimMultiCharacterCharacterStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trimMultiCharacterCharacterString
	return p
}

func InitEmptyTrimMultiCharacterCharacterStringContext(p *TrimMultiCharacterCharacterStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trimMultiCharacterCharacterString
}

func (*TrimMultiCharacterCharacterStringContext) IsTrimMultiCharacterCharacterStringContext() {}

func NewTrimMultiCharacterCharacterStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrimMultiCharacterCharacterStringContext {
	var p = new(TrimMultiCharacterCharacterStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_trimMultiCharacterCharacterString

	return p
}

func (s *TrimMultiCharacterCharacterStringContext) GetParser() antlr.Parser { return s.parser }

func (s *TrimMultiCharacterCharacterStringContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *TrimMultiCharacterCharacterStringContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TrimMultiCharacterCharacterStringContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *TrimMultiCharacterCharacterStringContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *TrimMultiCharacterCharacterStringContext) BTRIM() antlr.TerminalNode {
	return s.GetToken(GQLParserBTRIM, 0)
}

func (s *TrimMultiCharacterCharacterStringContext) LTRIM() antlr.TerminalNode {
	return s.GetToken(GQLParserLTRIM, 0)
}

func (s *TrimMultiCharacterCharacterStringContext) RTRIM() antlr.TerminalNode {
	return s.GetToken(GQLParserRTRIM, 0)
}

func (s *TrimMultiCharacterCharacterStringContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *TrimMultiCharacterCharacterStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimMultiCharacterCharacterStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrimMultiCharacterCharacterStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTrimMultiCharacterCharacterString(s)
	}
}

func (s *TrimMultiCharacterCharacterStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTrimMultiCharacterCharacterString(s)
	}
}

func (p *GQLParser) TrimMultiCharacterCharacterString() (localctx ITrimMultiCharacterCharacterStringContext) {
	localctx = NewTrimMultiCharacterCharacterStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 862, GQLParserRULE_trimMultiCharacterCharacterString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4002)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserBTRIM || _la == GQLParserLTRIM || _la == GQLParserRTRIM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4003)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4004)
		p.valueExpression(0)
	}
	p.SetState(4007)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserCOMMA {
		{
			p.SetState(4005)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4006)
			p.valueExpression(0)
		}

	}
	{
		p.SetState(4009)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INormalizeCharacterStringContext is an interface to support dynamic dispatch.
type INormalizeCharacterStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NORMALIZE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	ValueExpression() IValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	NormalForm() INormalFormContext

	// IsNormalizeCharacterStringContext differentiates from other interfaces.
	IsNormalizeCharacterStringContext()
}

type NormalizeCharacterStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalizeCharacterStringContext() *NormalizeCharacterStringContext {
	var p = new(NormalizeCharacterStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_normalizeCharacterString
	return p
}

func InitEmptyNormalizeCharacterStringContext(p *NormalizeCharacterStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_normalizeCharacterString
}

func (*NormalizeCharacterStringContext) IsNormalizeCharacterStringContext() {}

func NewNormalizeCharacterStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalizeCharacterStringContext {
	var p = new(NormalizeCharacterStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_normalizeCharacterString

	return p
}

func (s *NormalizeCharacterStringContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalizeCharacterStringContext) NORMALIZE() antlr.TerminalNode {
	return s.GetToken(GQLParserNORMALIZE, 0)
}

func (s *NormalizeCharacterStringContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *NormalizeCharacterStringContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *NormalizeCharacterStringContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *NormalizeCharacterStringContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *NormalizeCharacterStringContext) NormalForm() INormalFormContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INormalFormContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INormalFormContext)
}

func (s *NormalizeCharacterStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalizeCharacterStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalizeCharacterStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNormalizeCharacterString(s)
	}
}

func (s *NormalizeCharacterStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNormalizeCharacterString(s)
	}
}

func (p *GQLParser) NormalizeCharacterString() (localctx INormalizeCharacterStringContext) {
	localctx = NewNormalizeCharacterStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 864, GQLParserRULE_normalizeCharacterString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4011)
		p.Match(GQLParserNORMALIZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4012)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4013)
		p.valueExpression(0)
	}
	p.SetState(4016)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserCOMMA {
		{
			p.SetState(4014)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4015)
			p.NormalForm()
		}

	}
	{
		p.SetState(4018)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeReferenceValueExpressionContext is an interface to support dynamic dispatch.
type INodeReferenceValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpressionPrimary() IValueExpressionPrimaryContext

	// IsNodeReferenceValueExpressionContext differentiates from other interfaces.
	IsNodeReferenceValueExpressionContext()
}

type NodeReferenceValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeReferenceValueExpressionContext() *NodeReferenceValueExpressionContext {
	var p = new(NodeReferenceValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeReferenceValueExpression
	return p
}

func InitEmptyNodeReferenceValueExpressionContext(p *NodeReferenceValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeReferenceValueExpression
}

func (*NodeReferenceValueExpressionContext) IsNodeReferenceValueExpressionContext() {}

func NewNodeReferenceValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeReferenceValueExpressionContext {
	var p = new(NodeReferenceValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nodeReferenceValueExpression

	return p
}

func (s *NodeReferenceValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeReferenceValueExpressionContext) ValueExpressionPrimary() IValueExpressionPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionPrimaryContext)
}

func (s *NodeReferenceValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeReferenceValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeReferenceValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNodeReferenceValueExpression(s)
	}
}

func (s *NodeReferenceValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNodeReferenceValueExpression(s)
	}
}

func (p *GQLParser) NodeReferenceValueExpression() (localctx INodeReferenceValueExpressionContext) {
	localctx = NewNodeReferenceValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 866, GQLParserRULE_nodeReferenceValueExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4020)
		p.valueExpressionPrimary(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeReferenceValueExpressionContext is an interface to support dynamic dispatch.
type IEdgeReferenceValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpressionPrimary() IValueExpressionPrimaryContext

	// IsEdgeReferenceValueExpressionContext differentiates from other interfaces.
	IsEdgeReferenceValueExpressionContext()
}

type EdgeReferenceValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeReferenceValueExpressionContext() *EdgeReferenceValueExpressionContext {
	var p = new(EdgeReferenceValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeReferenceValueExpression
	return p
}

func InitEmptyEdgeReferenceValueExpressionContext(p *EdgeReferenceValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeReferenceValueExpression
}

func (*EdgeReferenceValueExpressionContext) IsEdgeReferenceValueExpressionContext() {}

func NewEdgeReferenceValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeReferenceValueExpressionContext {
	var p = new(EdgeReferenceValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeReferenceValueExpression

	return p
}

func (s *EdgeReferenceValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeReferenceValueExpressionContext) ValueExpressionPrimary() IValueExpressionPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionPrimaryContext)
}

func (s *EdgeReferenceValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeReferenceValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeReferenceValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeReferenceValueExpression(s)
	}
}

func (s *EdgeReferenceValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeReferenceValueExpression(s)
	}
}

func (p *GQLParser) EdgeReferenceValueExpression() (localctx IEdgeReferenceValueExpressionContext) {
	localctx = NewEdgeReferenceValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 868, GQLParserRULE_edgeReferenceValueExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4022)
		p.valueExpressionPrimary(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregatingValueExpressionContext is an interface to support dynamic dispatch.
type IAggregatingValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsAggregatingValueExpressionContext differentiates from other interfaces.
	IsAggregatingValueExpressionContext()
}

type AggregatingValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregatingValueExpressionContext() *AggregatingValueExpressionContext {
	var p = new(AggregatingValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_aggregatingValueExpression
	return p
}

func InitEmptyAggregatingValueExpressionContext(p *AggregatingValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_aggregatingValueExpression
}

func (*AggregatingValueExpressionContext) IsAggregatingValueExpressionContext() {}

func NewAggregatingValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregatingValueExpressionContext {
	var p = new(AggregatingValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_aggregatingValueExpression

	return p
}

func (s *AggregatingValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregatingValueExpressionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *AggregatingValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregatingValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregatingValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAggregatingValueExpression(s)
	}
}

func (s *AggregatingValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAggregatingValueExpression(s)
	}
}

func (p *GQLParser) AggregatingValueExpression() (localctx IAggregatingValueExpressionContext) {
	localctx = NewAggregatingValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 870, GQLParserRULE_aggregatingValueExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4024)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionPrimaryContext is an interface to support dynamic dispatch.
type IValueExpressionPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParenthesizedValueExpression() IParenthesizedValueExpressionContext
	AggregateFunction() IAggregateFunctionContext
	UnsignedValueSpecification() IUnsignedValueSpecificationContext
	PathValueConstructor() IPathValueConstructorContext
	ValueQueryExpression() IValueQueryExpressionContext
	CaseExpression() ICaseExpressionContext
	CastSpecification() ICastSpecificationContext
	Element_idFunction() IElement_idFunctionContext
	LetValueExpression() ILetValueExpressionContext
	BindingVariableReference() IBindingVariableReferenceContext
	ValueExpressionPrimary() IValueExpressionPrimaryContext
	PERIOD() antlr.TerminalNode
	PropertyName() IPropertyNameContext

	// IsValueExpressionPrimaryContext differentiates from other interfaces.
	IsValueExpressionPrimaryContext()
}

type ValueExpressionPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionPrimaryContext() *ValueExpressionPrimaryContext {
	var p = new(ValueExpressionPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueExpressionPrimary
	return p
}

func InitEmptyValueExpressionPrimaryContext(p *ValueExpressionPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueExpressionPrimary
}

func (*ValueExpressionPrimaryContext) IsValueExpressionPrimaryContext() {}

func NewValueExpressionPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionPrimaryContext {
	var p = new(ValueExpressionPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_valueExpressionPrimary

	return p
}

func (s *ValueExpressionPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionPrimaryContext) ParenthesizedValueExpression() IParenthesizedValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesizedValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesizedValueExpressionContext)
}

func (s *ValueExpressionPrimaryContext) AggregateFunction() IAggregateFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregateFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregateFunctionContext)
}

func (s *ValueExpressionPrimaryContext) UnsignedValueSpecification() IUnsignedValueSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedValueSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedValueSpecificationContext)
}

func (s *ValueExpressionPrimaryContext) PathValueConstructor() IPathValueConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathValueConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathValueConstructorContext)
}

func (s *ValueExpressionPrimaryContext) ValueQueryExpression() IValueQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueQueryExpressionContext)
}

func (s *ValueExpressionPrimaryContext) CaseExpression() ICaseExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseExpressionContext)
}

func (s *ValueExpressionPrimaryContext) CastSpecification() ICastSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastSpecificationContext)
}

func (s *ValueExpressionPrimaryContext) Element_idFunction() IElement_idFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElement_idFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElement_idFunctionContext)
}

func (s *ValueExpressionPrimaryContext) LetValueExpression() ILetValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetValueExpressionContext)
}

func (s *ValueExpressionPrimaryContext) BindingVariableReference() IBindingVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableReferenceContext)
}

func (s *ValueExpressionPrimaryContext) ValueExpressionPrimary() IValueExpressionPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionPrimaryContext)
}

func (s *ValueExpressionPrimaryContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(GQLParserPERIOD, 0)
}

func (s *ValueExpressionPrimaryContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *ValueExpressionPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueExpressionPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterValueExpressionPrimary(s)
	}
}

func (s *ValueExpressionPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitValueExpressionPrimary(s)
	}
}

func (p *GQLParser) ValueExpressionPrimary() (localctx IValueExpressionPrimaryContext) {
	return p.valueExpressionPrimary(0)
}

func (p *GQLParser) valueExpressionPrimary(_p int) (localctx IValueExpressionPrimaryContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionPrimaryContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionPrimaryContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 872
	p.EnterRecursionRule(localctx, 872, GQLParserRULE_valueExpressionPrimary, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4037)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserLEFT_PAREN:
		{
			p.SetState(4027)
			p.ParenthesizedValueExpression()
		}

	case GQLParserAVG, GQLParserCOLLECT_LIST, GQLParserCOUNT, GQLParserMAX, GQLParserMIN, GQLParserPERCENTILE_CONT, GQLParserPERCENTILE_DISC, GQLParserSTDDEV_POP, GQLParserSTDDEV_SAMP, GQLParserSUM:
		{
			p.SetState(4028)
			p.AggregateFunction()
		}

	case GQLParserBOOLEAN_LITERAL, GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE, GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, GQLParserBYTE_STRING_LITERAL, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER, GQLParserUNSIGNED_HEXADECIMAL_INTEGER, GQLParserUNSIGNED_OCTAL_INTEGER, GQLParserUNSIGNED_BINARY_INTEGER, GQLParserARRAY, GQLParserDATE, GQLParserDATETIME, GQLParserDURATION, GQLParserLIST, GQLParserNULL_KW, GQLParserRECORD, GQLParserSESSION_USER, GQLParserTIME, GQLParserTIMESTAMP, GQLParserGENERAL_PARAMETER_REFERENCE, GQLParserLEFT_BRACE, GQLParserLEFT_BRACKET:
		{
			p.SetState(4029)
			p.UnsignedValueSpecification()
		}

	case GQLParserPATH:
		{
			p.SetState(4030)
			p.PathValueConstructor()
		}

	case GQLParserVALUE:
		{
			p.SetState(4031)
			p.ValueQueryExpression()
		}

	case GQLParserCASE, GQLParserCOALESCE, GQLParserNULLIF:
		{
			p.SetState(4032)
			p.CaseExpression()
		}

	case GQLParserCAST:
		{
			p.SetState(4033)
			p.CastSpecification()
		}

	case GQLParserELEMENT_ID:
		{
			p.SetState(4034)
			p.Element_idFunction()
		}

	case GQLParserLET:
		{
			p.SetState(4035)
			p.LetValueExpression()
		}

	case GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE, GQLParserREGULAR_IDENTIFIER:
		{
			p.SetState(4036)
			p.BindingVariableReference()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4044)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 449, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewValueExpressionPrimaryContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_valueExpressionPrimary)
			p.SetState(4039)

			if !(p.Precpred(p.GetParserRuleContext(), 7)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				goto errorExit
			}
			{
				p.SetState(4040)
				p.Match(GQLParserPERIOD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4041)
				p.PropertyName()
			}

		}
		p.SetState(4046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 449, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesizedValueExpressionContext is an interface to support dynamic dispatch.
type IParenthesizedValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	ValueExpression() IValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsParenthesizedValueExpressionContext differentiates from other interfaces.
	IsParenthesizedValueExpressionContext()
}

type ParenthesizedValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedValueExpressionContext() *ParenthesizedValueExpressionContext {
	var p = new(ParenthesizedValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_parenthesizedValueExpression
	return p
}

func InitEmptyParenthesizedValueExpressionContext(p *ParenthesizedValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_parenthesizedValueExpression
}

func (*ParenthesizedValueExpressionContext) IsParenthesizedValueExpressionContext() {}

func NewParenthesizedValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedValueExpressionContext {
	var p = new(ParenthesizedValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_parenthesizedValueExpression

	return p
}

func (s *ParenthesizedValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedValueExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *ParenthesizedValueExpressionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ParenthesizedValueExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *ParenthesizedValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesizedValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterParenthesizedValueExpression(s)
	}
}

func (s *ParenthesizedValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitParenthesizedValueExpression(s)
	}
}

func (p *GQLParser) ParenthesizedValueExpression() (localctx IParenthesizedValueExpressionContext) {
	localctx = NewParenthesizedValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 874, GQLParserRULE_parenthesizedValueExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4047)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4048)
		p.valueExpression(0)
	}
	{
		p.SetState(4049)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonParenthesizedValueExpressionPrimaryContext is an interface to support dynamic dispatch.
type INonParenthesizedValueExpressionPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NonParenthesizedValueExpressionPrimarySpecialCase() INonParenthesizedValueExpressionPrimarySpecialCaseContext
	BindingVariableReference() IBindingVariableReferenceContext

	// IsNonParenthesizedValueExpressionPrimaryContext differentiates from other interfaces.
	IsNonParenthesizedValueExpressionPrimaryContext()
}

type NonParenthesizedValueExpressionPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonParenthesizedValueExpressionPrimaryContext() *NonParenthesizedValueExpressionPrimaryContext {
	var p = new(NonParenthesizedValueExpressionPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nonParenthesizedValueExpressionPrimary
	return p
}

func InitEmptyNonParenthesizedValueExpressionPrimaryContext(p *NonParenthesizedValueExpressionPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nonParenthesizedValueExpressionPrimary
}

func (*NonParenthesizedValueExpressionPrimaryContext) IsNonParenthesizedValueExpressionPrimaryContext() {
}

func NewNonParenthesizedValueExpressionPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonParenthesizedValueExpressionPrimaryContext {
	var p = new(NonParenthesizedValueExpressionPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nonParenthesizedValueExpressionPrimary

	return p
}

func (s *NonParenthesizedValueExpressionPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *NonParenthesizedValueExpressionPrimaryContext) NonParenthesizedValueExpressionPrimarySpecialCase() INonParenthesizedValueExpressionPrimarySpecialCaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonParenthesizedValueExpressionPrimarySpecialCaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonParenthesizedValueExpressionPrimarySpecialCaseContext)
}

func (s *NonParenthesizedValueExpressionPrimaryContext) BindingVariableReference() IBindingVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableReferenceContext)
}

func (s *NonParenthesizedValueExpressionPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonParenthesizedValueExpressionPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonParenthesizedValueExpressionPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNonParenthesizedValueExpressionPrimary(s)
	}
}

func (s *NonParenthesizedValueExpressionPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNonParenthesizedValueExpressionPrimary(s)
	}
}

func (p *GQLParser) NonParenthesizedValueExpressionPrimary() (localctx INonParenthesizedValueExpressionPrimaryContext) {
	localctx = NewNonParenthesizedValueExpressionPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 876, GQLParserRULE_nonParenthesizedValueExpressionPrimary)
	p.SetState(4053)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 450, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4051)
			p.NonParenthesizedValueExpressionPrimarySpecialCase()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4052)
			p.BindingVariableReference()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonParenthesizedValueExpressionPrimarySpecialCaseContext is an interface to support dynamic dispatch.
type INonParenthesizedValueExpressionPrimarySpecialCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AggregateFunction() IAggregateFunctionContext
	UnsignedValueSpecification() IUnsignedValueSpecificationContext
	PathValueConstructor() IPathValueConstructorContext
	ValueExpressionPrimary() IValueExpressionPrimaryContext
	PERIOD() antlr.TerminalNode
	PropertyName() IPropertyNameContext
	ValueQueryExpression() IValueQueryExpressionContext
	CaseExpression() ICaseExpressionContext
	CastSpecification() ICastSpecificationContext
	Element_idFunction() IElement_idFunctionContext
	LetValueExpression() ILetValueExpressionContext

	// IsNonParenthesizedValueExpressionPrimarySpecialCaseContext differentiates from other interfaces.
	IsNonParenthesizedValueExpressionPrimarySpecialCaseContext()
}

type NonParenthesizedValueExpressionPrimarySpecialCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonParenthesizedValueExpressionPrimarySpecialCaseContext() *NonParenthesizedValueExpressionPrimarySpecialCaseContext {
	var p = new(NonParenthesizedValueExpressionPrimarySpecialCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nonParenthesizedValueExpressionPrimarySpecialCase
	return p
}

func InitEmptyNonParenthesizedValueExpressionPrimarySpecialCaseContext(p *NonParenthesizedValueExpressionPrimarySpecialCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nonParenthesizedValueExpressionPrimarySpecialCase
}

func (*NonParenthesizedValueExpressionPrimarySpecialCaseContext) IsNonParenthesizedValueExpressionPrimarySpecialCaseContext() {
}

func NewNonParenthesizedValueExpressionPrimarySpecialCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonParenthesizedValueExpressionPrimarySpecialCaseContext {
	var p = new(NonParenthesizedValueExpressionPrimarySpecialCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nonParenthesizedValueExpressionPrimarySpecialCase

	return p
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) AggregateFunction() IAggregateFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregateFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregateFunctionContext)
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) UnsignedValueSpecification() IUnsignedValueSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedValueSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedValueSpecificationContext)
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) PathValueConstructor() IPathValueConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathValueConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathValueConstructorContext)
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) ValueExpressionPrimary() IValueExpressionPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionPrimaryContext)
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(GQLParserPERIOD, 0)
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) PropertyName() IPropertyNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyNameContext)
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) ValueQueryExpression() IValueQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueQueryExpressionContext)
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) CaseExpression() ICaseExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseExpressionContext)
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) CastSpecification() ICastSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastSpecificationContext)
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) Element_idFunction() IElement_idFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElement_idFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElement_idFunctionContext)
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) LetValueExpression() ILetValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetValueExpressionContext)
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNonParenthesizedValueExpressionPrimarySpecialCase(s)
	}
}

func (s *NonParenthesizedValueExpressionPrimarySpecialCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNonParenthesizedValueExpressionPrimarySpecialCase(s)
	}
}

func (p *GQLParser) NonParenthesizedValueExpressionPrimarySpecialCase() (localctx INonParenthesizedValueExpressionPrimarySpecialCaseContext) {
	localctx = NewNonParenthesizedValueExpressionPrimarySpecialCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 878, GQLParserRULE_nonParenthesizedValueExpressionPrimarySpecialCase)
	p.SetState(4067)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 451, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4055)
			p.AggregateFunction()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4056)
			p.UnsignedValueSpecification()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4057)
			p.PathValueConstructor()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4058)
			p.valueExpressionPrimary(0)
		}
		{
			p.SetState(4059)
			p.Match(GQLParserPERIOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4060)
			p.PropertyName()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4062)
			p.ValueQueryExpression()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4063)
			p.CaseExpression()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4064)
			p.CastSpecification()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4065)
			p.Element_idFunction()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4066)
			p.LetValueExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedValueSpecificationContext is an interface to support dynamic dispatch.
type IUnsignedValueSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedLiteral() IUnsignedLiteralContext
	GeneralValueSpecification() IGeneralValueSpecificationContext

	// IsUnsignedValueSpecificationContext differentiates from other interfaces.
	IsUnsignedValueSpecificationContext()
}

type UnsignedValueSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedValueSpecificationContext() *UnsignedValueSpecificationContext {
	var p = new(UnsignedValueSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_unsignedValueSpecification
	return p
}

func InitEmptyUnsignedValueSpecificationContext(p *UnsignedValueSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_unsignedValueSpecification
}

func (*UnsignedValueSpecificationContext) IsUnsignedValueSpecificationContext() {}

func NewUnsignedValueSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedValueSpecificationContext {
	var p = new(UnsignedValueSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_unsignedValueSpecification

	return p
}

func (s *UnsignedValueSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedValueSpecificationContext) UnsignedLiteral() IUnsignedLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedLiteralContext)
}

func (s *UnsignedValueSpecificationContext) GeneralValueSpecification() IGeneralValueSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralValueSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralValueSpecificationContext)
}

func (s *UnsignedValueSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedValueSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedValueSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterUnsignedValueSpecification(s)
	}
}

func (s *UnsignedValueSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitUnsignedValueSpecification(s)
	}
}

func (p *GQLParser) UnsignedValueSpecification() (localctx IUnsignedValueSpecificationContext) {
	localctx = NewUnsignedValueSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 880, GQLParserRULE_unsignedValueSpecification)
	p.SetState(4071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserBOOLEAN_LITERAL, GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE, GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, GQLParserBYTE_STRING_LITERAL, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER, GQLParserUNSIGNED_HEXADECIMAL_INTEGER, GQLParserUNSIGNED_OCTAL_INTEGER, GQLParserUNSIGNED_BINARY_INTEGER, GQLParserARRAY, GQLParserDATE, GQLParserDATETIME, GQLParserDURATION, GQLParserLIST, GQLParserNULL_KW, GQLParserRECORD, GQLParserTIME, GQLParserTIMESTAMP, GQLParserLEFT_BRACE, GQLParserLEFT_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4069)
			p.UnsignedLiteral()
		}

	case GQLParserSESSION_USER, GQLParserGENERAL_PARAMETER_REFERENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4070)
			p.GeneralValueSpecification()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonNegativeIntegerSpecificationContext is an interface to support dynamic dispatch.
type INonNegativeIntegerSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedInteger() IUnsignedIntegerContext
	DynamicParameterSpecification() IDynamicParameterSpecificationContext

	// IsNonNegativeIntegerSpecificationContext differentiates from other interfaces.
	IsNonNegativeIntegerSpecificationContext()
}

type NonNegativeIntegerSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonNegativeIntegerSpecificationContext() *NonNegativeIntegerSpecificationContext {
	var p = new(NonNegativeIntegerSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nonNegativeIntegerSpecification
	return p
}

func InitEmptyNonNegativeIntegerSpecificationContext(p *NonNegativeIntegerSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nonNegativeIntegerSpecification
}

func (*NonNegativeIntegerSpecificationContext) IsNonNegativeIntegerSpecificationContext() {}

func NewNonNegativeIntegerSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonNegativeIntegerSpecificationContext {
	var p = new(NonNegativeIntegerSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nonNegativeIntegerSpecification

	return p
}

func (s *NonNegativeIntegerSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *NonNegativeIntegerSpecificationContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *NonNegativeIntegerSpecificationContext) DynamicParameterSpecification() IDynamicParameterSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDynamicParameterSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDynamicParameterSpecificationContext)
}

func (s *NonNegativeIntegerSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonNegativeIntegerSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonNegativeIntegerSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNonNegativeIntegerSpecification(s)
	}
}

func (s *NonNegativeIntegerSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNonNegativeIntegerSpecification(s)
	}
}

func (p *GQLParser) NonNegativeIntegerSpecification() (localctx INonNegativeIntegerSpecificationContext) {
	localctx = NewNonNegativeIntegerSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 882, GQLParserRULE_nonNegativeIntegerSpecification)
	p.SetState(4075)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserUNSIGNED_DECIMAL_INTEGER, GQLParserUNSIGNED_HEXADECIMAL_INTEGER, GQLParserUNSIGNED_OCTAL_INTEGER, GQLParserUNSIGNED_BINARY_INTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4073)
			p.UnsignedInteger()
		}

	case GQLParserGENERAL_PARAMETER_REFERENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4074)
			p.DynamicParameterSpecification()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneralValueSpecificationContext is an interface to support dynamic dispatch.
type IGeneralValueSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DynamicParameterSpecification() IDynamicParameterSpecificationContext
	SESSION_USER() antlr.TerminalNode

	// IsGeneralValueSpecificationContext differentiates from other interfaces.
	IsGeneralValueSpecificationContext()
}

type GeneralValueSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralValueSpecificationContext() *GeneralValueSpecificationContext {
	var p = new(GeneralValueSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalValueSpecification
	return p
}

func InitEmptyGeneralValueSpecificationContext(p *GeneralValueSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalValueSpecification
}

func (*GeneralValueSpecificationContext) IsGeneralValueSpecificationContext() {}

func NewGeneralValueSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralValueSpecificationContext {
	var p = new(GeneralValueSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_generalValueSpecification

	return p
}

func (s *GeneralValueSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralValueSpecificationContext) DynamicParameterSpecification() IDynamicParameterSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDynamicParameterSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDynamicParameterSpecificationContext)
}

func (s *GeneralValueSpecificationContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(GQLParserSESSION_USER, 0)
}

func (s *GeneralValueSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralValueSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralValueSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGeneralValueSpecification(s)
	}
}

func (s *GeneralValueSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGeneralValueSpecification(s)
	}
}

func (p *GQLParser) GeneralValueSpecification() (localctx IGeneralValueSpecificationContext) {
	localctx = NewGeneralValueSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 884, GQLParserRULE_generalValueSpecification)
	p.SetState(4079)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserGENERAL_PARAMETER_REFERENCE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4077)
			p.DynamicParameterSpecification()
		}

	case GQLParserSESSION_USER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4078)
			p.Match(GQLParserSESSION_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDynamicParameterSpecificationContext is an interface to support dynamic dispatch.
type IDynamicParameterSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GENERAL_PARAMETER_REFERENCE() antlr.TerminalNode

	// IsDynamicParameterSpecificationContext differentiates from other interfaces.
	IsDynamicParameterSpecificationContext()
}

type DynamicParameterSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDynamicParameterSpecificationContext() *DynamicParameterSpecificationContext {
	var p = new(DynamicParameterSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dynamicParameterSpecification
	return p
}

func InitEmptyDynamicParameterSpecificationContext(p *DynamicParameterSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dynamicParameterSpecification
}

func (*DynamicParameterSpecificationContext) IsDynamicParameterSpecificationContext() {}

func NewDynamicParameterSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DynamicParameterSpecificationContext {
	var p = new(DynamicParameterSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_dynamicParameterSpecification

	return p
}

func (s *DynamicParameterSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *DynamicParameterSpecificationContext) GENERAL_PARAMETER_REFERENCE() antlr.TerminalNode {
	return s.GetToken(GQLParserGENERAL_PARAMETER_REFERENCE, 0)
}

func (s *DynamicParameterSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DynamicParameterSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DynamicParameterSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDynamicParameterSpecification(s)
	}
}

func (s *DynamicParameterSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDynamicParameterSpecification(s)
	}
}

func (p *GQLParser) DynamicParameterSpecification() (localctx IDynamicParameterSpecificationContext) {
	localctx = NewDynamicParameterSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 886, GQLParserRULE_dynamicParameterSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4081)
		p.Match(GQLParserGENERAL_PARAMETER_REFERENCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetValueExpressionContext is an interface to support dynamic dispatch.
type ILetValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LET() antlr.TerminalNode
	LetVariableDefinitionList() ILetVariableDefinitionListContext
	IN() antlr.TerminalNode
	ValueExpression() IValueExpressionContext
	END() antlr.TerminalNode

	// IsLetValueExpressionContext differentiates from other interfaces.
	IsLetValueExpressionContext()
}

type LetValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetValueExpressionContext() *LetValueExpressionContext {
	var p = new(LetValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_letValueExpression
	return p
}

func InitEmptyLetValueExpressionContext(p *LetValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_letValueExpression
}

func (*LetValueExpressionContext) IsLetValueExpressionContext() {}

func NewLetValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetValueExpressionContext {
	var p = new(LetValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_letValueExpression

	return p
}

func (s *LetValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LetValueExpressionContext) LET() antlr.TerminalNode {
	return s.GetToken(GQLParserLET, 0)
}

func (s *LetValueExpressionContext) LetVariableDefinitionList() ILetVariableDefinitionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetVariableDefinitionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetVariableDefinitionListContext)
}

func (s *LetValueExpressionContext) IN() antlr.TerminalNode {
	return s.GetToken(GQLParserIN, 0)
}

func (s *LetValueExpressionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LetValueExpressionContext) END() antlr.TerminalNode {
	return s.GetToken(GQLParserEND, 0)
}

func (s *LetValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLetValueExpression(s)
	}
}

func (s *LetValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLetValueExpression(s)
	}
}

func (p *GQLParser) LetValueExpression() (localctx ILetValueExpressionContext) {
	localctx = NewLetValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 888, GQLParserRULE_letValueExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4083)
		p.Match(GQLParserLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4084)
		p.LetVariableDefinitionList()
	}
	{
		p.SetState(4085)
		p.Match(GQLParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4086)
		p.valueExpression(0)
	}
	{
		p.SetState(4087)
		p.Match(GQLParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueQueryExpressionContext is an interface to support dynamic dispatch.
type IValueQueryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUE() antlr.TerminalNode
	NestedQuerySpecification() INestedQuerySpecificationContext

	// IsValueQueryExpressionContext differentiates from other interfaces.
	IsValueQueryExpressionContext()
}

type ValueQueryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueQueryExpressionContext() *ValueQueryExpressionContext {
	var p = new(ValueQueryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueQueryExpression
	return p
}

func InitEmptyValueQueryExpressionContext(p *ValueQueryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_valueQueryExpression
}

func (*ValueQueryExpressionContext) IsValueQueryExpressionContext() {}

func NewValueQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueQueryExpressionContext {
	var p = new(ValueQueryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_valueQueryExpression

	return p
}

func (s *ValueQueryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueQueryExpressionContext) VALUE() antlr.TerminalNode {
	return s.GetToken(GQLParserVALUE, 0)
}

func (s *ValueQueryExpressionContext) NestedQuerySpecification() INestedQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedQuerySpecificationContext)
}

func (s *ValueQueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueQueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueQueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterValueQueryExpression(s)
	}
}

func (s *ValueQueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitValueQueryExpression(s)
	}
}

func (p *GQLParser) ValueQueryExpression() (localctx IValueQueryExpressionContext) {
	localctx = NewValueQueryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 890, GQLParserRULE_valueQueryExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4089)
		p.Match(GQLParserVALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4090)
		p.NestedQuerySpecification()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseExpressionContext is an interface to support dynamic dispatch.
type ICaseExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CaseAbbreviation() ICaseAbbreviationContext
	CaseSpecification() ICaseSpecificationContext

	// IsCaseExpressionContext differentiates from other interfaces.
	IsCaseExpressionContext()
}

type CaseExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseExpressionContext() *CaseExpressionContext {
	var p = new(CaseExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_caseExpression
	return p
}

func InitEmptyCaseExpressionContext(p *CaseExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_caseExpression
}

func (*CaseExpressionContext) IsCaseExpressionContext() {}

func NewCaseExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseExpressionContext {
	var p = new(CaseExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_caseExpression

	return p
}

func (s *CaseExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseExpressionContext) CaseAbbreviation() ICaseAbbreviationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseAbbreviationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseAbbreviationContext)
}

func (s *CaseExpressionContext) CaseSpecification() ICaseSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseSpecificationContext)
}

func (s *CaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCaseExpression(s)
	}
}

func (s *CaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCaseExpression(s)
	}
}

func (p *GQLParser) CaseExpression() (localctx ICaseExpressionContext) {
	localctx = NewCaseExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 892, GQLParserRULE_caseExpression)
	p.SetState(4094)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserCOALESCE, GQLParserNULLIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4092)
			p.CaseAbbreviation()
		}

	case GQLParserCASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4093)
			p.CaseSpecification()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseAbbreviationContext is an interface to support dynamic dispatch.
type ICaseAbbreviationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULLIF() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	COALESCE() antlr.TerminalNode

	// IsCaseAbbreviationContext differentiates from other interfaces.
	IsCaseAbbreviationContext()
}

type CaseAbbreviationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseAbbreviationContext() *CaseAbbreviationContext {
	var p = new(CaseAbbreviationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_caseAbbreviation
	return p
}

func InitEmptyCaseAbbreviationContext(p *CaseAbbreviationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_caseAbbreviation
}

func (*CaseAbbreviationContext) IsCaseAbbreviationContext() {}

func NewCaseAbbreviationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseAbbreviationContext {
	var p = new(CaseAbbreviationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_caseAbbreviation

	return p
}

func (s *CaseAbbreviationContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseAbbreviationContext) NULLIF() antlr.TerminalNode {
	return s.GetToken(GQLParserNULLIF, 0)
}

func (s *CaseAbbreviationContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *CaseAbbreviationContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CaseAbbreviationContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *CaseAbbreviationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *CaseAbbreviationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *CaseAbbreviationContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *CaseAbbreviationContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(GQLParserCOALESCE, 0)
}

func (s *CaseAbbreviationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseAbbreviationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseAbbreviationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCaseAbbreviation(s)
	}
}

func (s *CaseAbbreviationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCaseAbbreviation(s)
	}
}

func (p *GQLParser) CaseAbbreviation() (localctx ICaseAbbreviationContext) {
	localctx = NewCaseAbbreviationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 894, GQLParserRULE_caseAbbreviation)
	var _la int

	p.SetState(4114)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserNULLIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4096)
			p.Match(GQLParserNULLIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4097)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4098)
			p.valueExpression(0)
		}
		{
			p.SetState(4099)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4100)
			p.valueExpression(0)
		}
		{
			p.SetState(4101)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserCOALESCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4103)
			p.Match(GQLParserCOALESCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4104)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4105)
			p.valueExpression(0)
		}
		p.SetState(4108)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == GQLParserCOMMA {
			{
				p.SetState(4106)
				p.Match(GQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4107)
				p.valueExpression(0)
			}

			p.SetState(4110)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4112)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseSpecificationContext is an interface to support dynamic dispatch.
type ICaseSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleCase() ISimpleCaseContext
	SearchedCase() ISearchedCaseContext

	// IsCaseSpecificationContext differentiates from other interfaces.
	IsCaseSpecificationContext()
}

type CaseSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseSpecificationContext() *CaseSpecificationContext {
	var p = new(CaseSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_caseSpecification
	return p
}

func InitEmptyCaseSpecificationContext(p *CaseSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_caseSpecification
}

func (*CaseSpecificationContext) IsCaseSpecificationContext() {}

func NewCaseSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseSpecificationContext {
	var p = new(CaseSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_caseSpecification

	return p
}

func (s *CaseSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseSpecificationContext) SimpleCase() ISimpleCaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleCaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleCaseContext)
}

func (s *CaseSpecificationContext) SearchedCase() ISearchedCaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchedCaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchedCaseContext)
}

func (s *CaseSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCaseSpecification(s)
	}
}

func (s *CaseSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCaseSpecification(s)
	}
}

func (p *GQLParser) CaseSpecification() (localctx ICaseSpecificationContext) {
	localctx = NewCaseSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 896, GQLParserRULE_caseSpecification)
	p.SetState(4118)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 458, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4116)
			p.SimpleCase()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4117)
			p.SearchedCase()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleCaseContext is an interface to support dynamic dispatch.
type ISimpleCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	CaseOperand() ICaseOperandContext
	END() antlr.TerminalNode
	AllSimpleWhenClause() []ISimpleWhenClauseContext
	SimpleWhenClause(i int) ISimpleWhenClauseContext
	ElseClause() IElseClauseContext

	// IsSimpleCaseContext differentiates from other interfaces.
	IsSimpleCaseContext()
}

type SimpleCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleCaseContext() *SimpleCaseContext {
	var p = new(SimpleCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleCase
	return p
}

func InitEmptySimpleCaseContext(p *SimpleCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleCase
}

func (*SimpleCaseContext) IsSimpleCaseContext() {}

func NewSimpleCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simpleCase

	return p
}

func (s *SimpleCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(GQLParserCASE, 0)
}

func (s *SimpleCaseContext) CaseOperand() ICaseOperandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseOperandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseOperandContext)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(GQLParserEND, 0)
}

func (s *SimpleCaseContext) AllSimpleWhenClause() []ISimpleWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]ISimpleWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleWhenClauseContext); ok {
			tst[i] = t.(ISimpleWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) SimpleWhenClause(i int) ISimpleWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleWhenClauseContext)
}

func (s *SimpleCaseContext) ElseClause() IElseClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseClauseContext)
}

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

func (p *GQLParser) SimpleCase() (localctx ISimpleCaseContext) {
	localctx = NewSimpleCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 898, GQLParserRULE_simpleCase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4120)
		p.Match(GQLParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4121)
		p.CaseOperand()
	}
	p.SetState(4123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == GQLParserWHEN {
		{
			p.SetState(4122)
			p.SimpleWhenClause()
		}

		p.SetState(4125)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4128)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserELSE {
		{
			p.SetState(4127)
			p.ElseClause()
		}

	}
	{
		p.SetState(4130)
		p.Match(GQLParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISearchedCaseContext is an interface to support dynamic dispatch.
type ISearchedCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	END() antlr.TerminalNode
	AllSearchedWhenClause() []ISearchedWhenClauseContext
	SearchedWhenClause(i int) ISearchedWhenClauseContext
	ElseClause() IElseClauseContext

	// IsSearchedCaseContext differentiates from other interfaces.
	IsSearchedCaseContext()
}

type SearchedCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchedCaseContext() *SearchedCaseContext {
	var p = new(SearchedCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_searchedCase
	return p
}

func InitEmptySearchedCaseContext(p *SearchedCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_searchedCase
}

func (*SearchedCaseContext) IsSearchedCaseContext() {}

func NewSearchedCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_searchedCase

	return p
}

func (s *SearchedCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(GQLParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(GQLParserEND, 0)
}

func (s *SearchedCaseContext) AllSearchedWhenClause() []ISearchedWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISearchedWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]ISearchedWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISearchedWhenClauseContext); ok {
			tst[i] = t.(ISearchedWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) SearchedWhenClause(i int) ISearchedWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchedWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchedWhenClauseContext)
}

func (s *SearchedCaseContext) ElseClause() IElseClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseClauseContext)
}

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

func (p *GQLParser) SearchedCase() (localctx ISearchedCaseContext) {
	localctx = NewSearchedCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 900, GQLParserRULE_searchedCase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4132)
		p.Match(GQLParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == GQLParserWHEN {
		{
			p.SetState(4133)
			p.SearchedWhenClause()
		}

		p.SetState(4136)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserELSE {
		{
			p.SetState(4138)
			p.ElseClause()
		}

	}
	{
		p.SetState(4141)
		p.Match(GQLParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleWhenClauseContext is an interface to support dynamic dispatch.
type ISimpleWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	WhenOperandList() IWhenOperandListContext
	THEN() antlr.TerminalNode
	Result() IResultContext

	// IsSimpleWhenClauseContext differentiates from other interfaces.
	IsSimpleWhenClauseContext()
}

type SimpleWhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleWhenClauseContext() *SimpleWhenClauseContext {
	var p = new(SimpleWhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleWhenClause
	return p
}

func InitEmptySimpleWhenClauseContext(p *SimpleWhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_simpleWhenClause
}

func (*SimpleWhenClauseContext) IsSimpleWhenClauseContext() {}

func NewSimpleWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleWhenClauseContext {
	var p = new(SimpleWhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_simpleWhenClause

	return p
}

func (s *SimpleWhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleWhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(GQLParserWHEN, 0)
}

func (s *SimpleWhenClauseContext) WhenOperandList() IWhenOperandListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenOperandListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenOperandListContext)
}

func (s *SimpleWhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(GQLParserTHEN, 0)
}

func (s *SimpleWhenClauseContext) Result() IResultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultContext)
}

func (s *SimpleWhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleWhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleWhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSimpleWhenClause(s)
	}
}

func (s *SimpleWhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSimpleWhenClause(s)
	}
}

func (p *GQLParser) SimpleWhenClause() (localctx ISimpleWhenClauseContext) {
	localctx = NewSimpleWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 902, GQLParserRULE_simpleWhenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4143)
		p.Match(GQLParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4144)
		p.WhenOperandList()
	}
	{
		p.SetState(4145)
		p.Match(GQLParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4146)
		p.Result()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISearchedWhenClauseContext is an interface to support dynamic dispatch.
type ISearchedWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	SearchCondition() ISearchConditionContext
	THEN() antlr.TerminalNode
	Result() IResultContext

	// IsSearchedWhenClauseContext differentiates from other interfaces.
	IsSearchedWhenClauseContext()
}

type SearchedWhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchedWhenClauseContext() *SearchedWhenClauseContext {
	var p = new(SearchedWhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_searchedWhenClause
	return p
}

func InitEmptySearchedWhenClauseContext(p *SearchedWhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_searchedWhenClause
}

func (*SearchedWhenClauseContext) IsSearchedWhenClauseContext() {}

func NewSearchedWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchedWhenClauseContext {
	var p = new(SearchedWhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_searchedWhenClause

	return p
}

func (s *SearchedWhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchedWhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(GQLParserWHEN, 0)
}

func (s *SearchedWhenClauseContext) SearchCondition() ISearchConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchConditionContext)
}

func (s *SearchedWhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(GQLParserTHEN, 0)
}

func (s *SearchedWhenClauseContext) Result() IResultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultContext)
}

func (s *SearchedWhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedWhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchedWhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSearchedWhenClause(s)
	}
}

func (s *SearchedWhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSearchedWhenClause(s)
	}
}

func (p *GQLParser) SearchedWhenClause() (localctx ISearchedWhenClauseContext) {
	localctx = NewSearchedWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 904, GQLParserRULE_searchedWhenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4148)
		p.Match(GQLParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4149)
		p.SearchCondition()
	}
	{
		p.SetState(4150)
		p.Match(GQLParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4151)
		p.Result()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElseClauseContext is an interface to support dynamic dispatch.
type IElseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE() antlr.TerminalNode
	Result() IResultContext

	// IsElseClauseContext differentiates from other interfaces.
	IsElseClauseContext()
}

type ElseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseClauseContext() *ElseClauseContext {
	var p = new(ElseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elseClause
	return p
}

func InitEmptyElseClauseContext(p *ElseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elseClause
}

func (*ElseClauseContext) IsElseClauseContext() {}

func NewElseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseClauseContext {
	var p = new(ElseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_elseClause

	return p
}

func (s *ElseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseClauseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(GQLParserELSE, 0)
}

func (s *ElseClauseContext) Result() IResultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultContext)
}

func (s *ElseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterElseClause(s)
	}
}

func (s *ElseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitElseClause(s)
	}
}

func (p *GQLParser) ElseClause() (localctx IElseClauseContext) {
	localctx = NewElseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 906, GQLParserRULE_elseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4153)
		p.Match(GQLParserELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4154)
		p.Result()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseOperandContext is an interface to support dynamic dispatch.
type ICaseOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NonParenthesizedValueExpressionPrimary() INonParenthesizedValueExpressionPrimaryContext
	ElementVariableReference() IElementVariableReferenceContext

	// IsCaseOperandContext differentiates from other interfaces.
	IsCaseOperandContext()
}

type CaseOperandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseOperandContext() *CaseOperandContext {
	var p = new(CaseOperandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_caseOperand
	return p
}

func InitEmptyCaseOperandContext(p *CaseOperandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_caseOperand
}

func (*CaseOperandContext) IsCaseOperandContext() {}

func NewCaseOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseOperandContext {
	var p = new(CaseOperandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_caseOperand

	return p
}

func (s *CaseOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseOperandContext) NonParenthesizedValueExpressionPrimary() INonParenthesizedValueExpressionPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonParenthesizedValueExpressionPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonParenthesizedValueExpressionPrimaryContext)
}

func (s *CaseOperandContext) ElementVariableReference() IElementVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementVariableReferenceContext)
}

func (s *CaseOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCaseOperand(s)
	}
}

func (s *CaseOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCaseOperand(s)
	}
}

func (p *GQLParser) CaseOperand() (localctx ICaseOperandContext) {
	localctx = NewCaseOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 908, GQLParserRULE_caseOperand)
	p.SetState(4158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 463, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4156)
			p.NonParenthesizedValueExpressionPrimary()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4157)
			p.ElementVariableReference()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenOperandListContext is an interface to support dynamic dispatch.
type IWhenOperandListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWhenOperand() []IWhenOperandContext
	WhenOperand(i int) IWhenOperandContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWhenOperandListContext differentiates from other interfaces.
	IsWhenOperandListContext()
}

type WhenOperandListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenOperandListContext() *WhenOperandListContext {
	var p = new(WhenOperandListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_whenOperandList
	return p
}

func InitEmptyWhenOperandListContext(p *WhenOperandListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_whenOperandList
}

func (*WhenOperandListContext) IsWhenOperandListContext() {}

func NewWhenOperandListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenOperandListContext {
	var p = new(WhenOperandListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_whenOperandList

	return p
}

func (s *WhenOperandListContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenOperandListContext) AllWhenOperand() []IWhenOperandContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenOperandContext); ok {
			len++
		}
	}

	tst := make([]IWhenOperandContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenOperandContext); ok {
			tst[i] = t.(IWhenOperandContext)
			i++
		}
	}

	return tst
}

func (s *WhenOperandListContext) WhenOperand(i int) IWhenOperandContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenOperandContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenOperandContext)
}

func (s *WhenOperandListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *WhenOperandListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *WhenOperandListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenOperandListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenOperandListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterWhenOperandList(s)
	}
}

func (s *WhenOperandListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitWhenOperandList(s)
	}
}

func (p *GQLParser) WhenOperandList() (localctx IWhenOperandListContext) {
	localctx = NewWhenOperandListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 910, GQLParserRULE_whenOperandList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4160)
		p.WhenOperand()
	}
	p.SetState(4165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(4161)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4162)
			p.WhenOperand()
		}

		p.SetState(4167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenOperandContext is an interface to support dynamic dispatch.
type IWhenOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NonParenthesizedValueExpressionPrimary() INonParenthesizedValueExpressionPrimaryContext
	CompOp() ICompOpContext
	ValueExpression() IValueExpressionContext
	NullPredicatePart2() INullPredicatePart2Context
	ValueTypePredicatePart2() IValueTypePredicatePart2Context
	NormalizedPredicatePart2() INormalizedPredicatePart2Context
	DirectedPredicatePart2() IDirectedPredicatePart2Context
	LabeledPredicatePart2() ILabeledPredicatePart2Context
	SourcePredicatePart2() ISourcePredicatePart2Context
	DestinationPredicatePart2() IDestinationPredicatePart2Context

	// IsWhenOperandContext differentiates from other interfaces.
	IsWhenOperandContext()
}

type WhenOperandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenOperandContext() *WhenOperandContext {
	var p = new(WhenOperandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_whenOperand
	return p
}

func InitEmptyWhenOperandContext(p *WhenOperandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_whenOperand
}

func (*WhenOperandContext) IsWhenOperandContext() {}

func NewWhenOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenOperandContext {
	var p = new(WhenOperandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_whenOperand

	return p
}

func (s *WhenOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenOperandContext) NonParenthesizedValueExpressionPrimary() INonParenthesizedValueExpressionPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonParenthesizedValueExpressionPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonParenthesizedValueExpressionPrimaryContext)
}

func (s *WhenOperandContext) CompOp() ICompOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompOpContext)
}

func (s *WhenOperandContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *WhenOperandContext) NullPredicatePart2() INullPredicatePart2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullPredicatePart2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullPredicatePart2Context)
}

func (s *WhenOperandContext) ValueTypePredicatePart2() IValueTypePredicatePart2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueTypePredicatePart2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueTypePredicatePart2Context)
}

func (s *WhenOperandContext) NormalizedPredicatePart2() INormalizedPredicatePart2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INormalizedPredicatePart2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INormalizedPredicatePart2Context)
}

func (s *WhenOperandContext) DirectedPredicatePart2() IDirectedPredicatePart2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectedPredicatePart2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectedPredicatePart2Context)
}

func (s *WhenOperandContext) LabeledPredicatePart2() ILabeledPredicatePart2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabeledPredicatePart2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabeledPredicatePart2Context)
}

func (s *WhenOperandContext) SourcePredicatePart2() ISourcePredicatePart2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourcePredicatePart2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourcePredicatePart2Context)
}

func (s *WhenOperandContext) DestinationPredicatePart2() IDestinationPredicatePart2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestinationPredicatePart2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestinationPredicatePart2Context)
}

func (s *WhenOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterWhenOperand(s)
	}
}

func (s *WhenOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitWhenOperand(s)
	}
}

func (p *GQLParser) WhenOperand() (localctx IWhenOperandContext) {
	localctx = NewWhenOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 912, GQLParserRULE_whenOperand)
	p.SetState(4179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 465, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4168)
			p.NonParenthesizedValueExpressionPrimary()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4169)
			p.CompOp()
		}
		{
			p.SetState(4170)
			p.valueExpression(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4172)
			p.NullPredicatePart2()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4173)
			p.ValueTypePredicatePart2()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4174)
			p.NormalizedPredicatePart2()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4175)
			p.DirectedPredicatePart2()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4176)
			p.LabeledPredicatePart2()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4177)
			p.SourcePredicatePart2()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4178)
			p.DestinationPredicatePart2()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResultContext is an interface to support dynamic dispatch.
type IResultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ResultExpression() IResultExpressionContext
	NullLiteral() INullLiteralContext

	// IsResultContext differentiates from other interfaces.
	IsResultContext()
}

type ResultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultContext() *ResultContext {
	var p = new(ResultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_result
	return p
}

func InitEmptyResultContext(p *ResultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_result
}

func (*ResultContext) IsResultContext() {}

func NewResultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultContext {
	var p = new(ResultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_result

	return p
}

func (s *ResultContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultContext) ResultExpression() IResultExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultExpressionContext)
}

func (s *ResultContext) NullLiteral() INullLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullLiteralContext)
}

func (s *ResultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterResult(s)
	}
}

func (s *ResultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitResult(s)
	}
}

func (p *GQLParser) Result() (localctx IResultContext) {
	localctx = NewResultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 914, GQLParserRULE_result)
	p.SetState(4183)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 466, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4181)
			p.ResultExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4182)
			p.NullLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResultExpressionContext is an interface to support dynamic dispatch.
type IResultExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsResultExpressionContext differentiates from other interfaces.
	IsResultExpressionContext()
}

type ResultExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultExpressionContext() *ResultExpressionContext {
	var p = new(ResultExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_resultExpression
	return p
}

func InitEmptyResultExpressionContext(p *ResultExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_resultExpression
}

func (*ResultExpressionContext) IsResultExpressionContext() {}

func NewResultExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultExpressionContext {
	var p = new(ResultExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_resultExpression

	return p
}

func (s *ResultExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultExpressionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ResultExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterResultExpression(s)
	}
}

func (s *ResultExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitResultExpression(s)
	}
}

func (p *GQLParser) ResultExpression() (localctx IResultExpressionContext) {
	localctx = NewResultExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 916, GQLParserRULE_resultExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4185)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastSpecificationContext is an interface to support dynamic dispatch.
type ICastSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CAST() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	CastOperand() ICastOperandContext
	AS() antlr.TerminalNode
	CastTarget() ICastTargetContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsCastSpecificationContext differentiates from other interfaces.
	IsCastSpecificationContext()
}

type CastSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastSpecificationContext() *CastSpecificationContext {
	var p = new(CastSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_castSpecification
	return p
}

func InitEmptyCastSpecificationContext(p *CastSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_castSpecification
}

func (*CastSpecificationContext) IsCastSpecificationContext() {}

func NewCastSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastSpecificationContext {
	var p = new(CastSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_castSpecification

	return p
}

func (s *CastSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *CastSpecificationContext) CAST() antlr.TerminalNode {
	return s.GetToken(GQLParserCAST, 0)
}

func (s *CastSpecificationContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *CastSpecificationContext) CastOperand() ICastOperandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastOperandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastOperandContext)
}

func (s *CastSpecificationContext) AS() antlr.TerminalNode {
	return s.GetToken(GQLParserAS, 0)
}

func (s *CastSpecificationContext) CastTarget() ICastTargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastTargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastTargetContext)
}

func (s *CastSpecificationContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *CastSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCastSpecification(s)
	}
}

func (s *CastSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCastSpecification(s)
	}
}

func (p *GQLParser) CastSpecification() (localctx ICastSpecificationContext) {
	localctx = NewCastSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 918, GQLParserRULE_castSpecification)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4187)
		p.Match(GQLParserCAST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4188)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4189)
		p.CastOperand()
	}
	{
		p.SetState(4190)
		p.Match(GQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4191)
		p.CastTarget()
	}
	{
		p.SetState(4192)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastOperandContext is an interface to support dynamic dispatch.
type ICastOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext
	NullLiteral() INullLiteralContext

	// IsCastOperandContext differentiates from other interfaces.
	IsCastOperandContext()
}

type CastOperandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastOperandContext() *CastOperandContext {
	var p = new(CastOperandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_castOperand
	return p
}

func InitEmptyCastOperandContext(p *CastOperandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_castOperand
}

func (*CastOperandContext) IsCastOperandContext() {}

func NewCastOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastOperandContext {
	var p = new(CastOperandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_castOperand

	return p
}

func (s *CastOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *CastOperandContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *CastOperandContext) NullLiteral() INullLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullLiteralContext)
}

func (s *CastOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCastOperand(s)
	}
}

func (s *CastOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCastOperand(s)
	}
}

func (p *GQLParser) CastOperand() (localctx ICastOperandContext) {
	localctx = NewCastOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 920, GQLParserRULE_castOperand)
	p.SetState(4196)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 467, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4194)
			p.valueExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4195)
			p.NullLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastTargetContext is an interface to support dynamic dispatch.
type ICastTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueType() IValueTypeContext

	// IsCastTargetContext differentiates from other interfaces.
	IsCastTargetContext()
}

type CastTargetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastTargetContext() *CastTargetContext {
	var p = new(CastTargetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_castTarget
	return p
}

func InitEmptyCastTargetContext(p *CastTargetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_castTarget
}

func (*CastTargetContext) IsCastTargetContext() {}

func NewCastTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastTargetContext {
	var p = new(CastTargetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_castTarget

	return p
}

func (s *CastTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *CastTargetContext) ValueType() IValueTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueTypeContext)
}

func (s *CastTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCastTarget(s)
	}
}

func (s *CastTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCastTarget(s)
	}
}

func (p *GQLParser) CastTarget() (localctx ICastTargetContext) {
	localctx = NewCastTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 922, GQLParserRULE_castTarget)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4198)
		p.valueType(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregateFunctionContext is an interface to support dynamic dispatch.
type IAggregateFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COUNT() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	GeneralSetFunction() IGeneralSetFunctionContext
	BinarySetFunction() IBinarySetFunctionContext

	// IsAggregateFunctionContext differentiates from other interfaces.
	IsAggregateFunctionContext()
}

type AggregateFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregateFunctionContext() *AggregateFunctionContext {
	var p = new(AggregateFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_aggregateFunction
	return p
}

func InitEmptyAggregateFunctionContext(p *AggregateFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_aggregateFunction
}

func (*AggregateFunctionContext) IsAggregateFunctionContext() {}

func NewAggregateFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregateFunctionContext {
	var p = new(AggregateFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_aggregateFunction

	return p
}

func (s *AggregateFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregateFunctionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(GQLParserCOUNT, 0)
}

func (s *AggregateFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *AggregateFunctionContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(GQLParserASTERISK, 0)
}

func (s *AggregateFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *AggregateFunctionContext) GeneralSetFunction() IGeneralSetFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralSetFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralSetFunctionContext)
}

func (s *AggregateFunctionContext) BinarySetFunction() IBinarySetFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinarySetFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinarySetFunctionContext)
}

func (s *AggregateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAggregateFunction(s)
	}
}

func (s *AggregateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAggregateFunction(s)
	}
}

func (p *GQLParser) AggregateFunction() (localctx IAggregateFunctionContext) {
	localctx = NewAggregateFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 924, GQLParserRULE_aggregateFunction)
	p.SetState(4206)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 468, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4200)
			p.Match(GQLParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4201)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4202)
			p.Match(GQLParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4203)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4204)
			p.GeneralSetFunction()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4205)
			p.BinarySetFunction()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneralSetFunctionContext is an interface to support dynamic dispatch.
type IGeneralSetFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GeneralSetFunctionType() IGeneralSetFunctionTypeContext
	LEFT_PAREN() antlr.TerminalNode
	ValueExpression() IValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode
	SetQuantifier() ISetQuantifierContext

	// IsGeneralSetFunctionContext differentiates from other interfaces.
	IsGeneralSetFunctionContext()
}

type GeneralSetFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralSetFunctionContext() *GeneralSetFunctionContext {
	var p = new(GeneralSetFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalSetFunction
	return p
}

func InitEmptyGeneralSetFunctionContext(p *GeneralSetFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalSetFunction
}

func (*GeneralSetFunctionContext) IsGeneralSetFunctionContext() {}

func NewGeneralSetFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralSetFunctionContext {
	var p = new(GeneralSetFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_generalSetFunction

	return p
}

func (s *GeneralSetFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralSetFunctionContext) GeneralSetFunctionType() IGeneralSetFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralSetFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralSetFunctionTypeContext)
}

func (s *GeneralSetFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *GeneralSetFunctionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *GeneralSetFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *GeneralSetFunctionContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *GeneralSetFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralSetFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralSetFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGeneralSetFunction(s)
	}
}

func (s *GeneralSetFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGeneralSetFunction(s)
	}
}

func (p *GQLParser) GeneralSetFunction() (localctx IGeneralSetFunctionContext) {
	localctx = NewGeneralSetFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 926, GQLParserRULE_generalSetFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4208)
		p.GeneralSetFunctionType()
	}
	{
		p.SetState(4209)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4211)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserALL || _la == GQLParserDISTINCT {
		{
			p.SetState(4210)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(4213)
		p.valueExpression(0)
	}
	{
		p.SetState(4214)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBinarySetFunctionContext is an interface to support dynamic dispatch.
type IBinarySetFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BinarySetFunctionType() IBinarySetFunctionTypeContext
	LEFT_PAREN() antlr.TerminalNode
	DependentValueExpression() IDependentValueExpressionContext
	COMMA() antlr.TerminalNode
	IndependentValueExpression() IIndependentValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsBinarySetFunctionContext differentiates from other interfaces.
	IsBinarySetFunctionContext()
}

type BinarySetFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinarySetFunctionContext() *BinarySetFunctionContext {
	var p = new(BinarySetFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_binarySetFunction
	return p
}

func InitEmptyBinarySetFunctionContext(p *BinarySetFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_binarySetFunction
}

func (*BinarySetFunctionContext) IsBinarySetFunctionContext() {}

func NewBinarySetFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinarySetFunctionContext {
	var p = new(BinarySetFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_binarySetFunction

	return p
}

func (s *BinarySetFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *BinarySetFunctionContext) BinarySetFunctionType() IBinarySetFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinarySetFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinarySetFunctionTypeContext)
}

func (s *BinarySetFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *BinarySetFunctionContext) DependentValueExpression() IDependentValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDependentValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDependentValueExpressionContext)
}

func (s *BinarySetFunctionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *BinarySetFunctionContext) IndependentValueExpression() IIndependentValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndependentValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndependentValueExpressionContext)
}

func (s *BinarySetFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *BinarySetFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinarySetFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinarySetFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBinarySetFunction(s)
	}
}

func (s *BinarySetFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBinarySetFunction(s)
	}
}

func (p *GQLParser) BinarySetFunction() (localctx IBinarySetFunctionContext) {
	localctx = NewBinarySetFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 928, GQLParserRULE_binarySetFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4216)
		p.BinarySetFunctionType()
	}
	{
		p.SetState(4217)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4218)
		p.DependentValueExpression()
	}
	{
		p.SetState(4219)
		p.Match(GQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4220)
		p.IndependentValueExpression()
	}
	{
		p.SetState(4221)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneralSetFunctionTypeContext is an interface to support dynamic dispatch.
type IGeneralSetFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AVG() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	SUM() antlr.TerminalNode
	COLLECT_LIST() antlr.TerminalNode
	STDDEV_SAMP() antlr.TerminalNode
	STDDEV_POP() antlr.TerminalNode

	// IsGeneralSetFunctionTypeContext differentiates from other interfaces.
	IsGeneralSetFunctionTypeContext()
}

type GeneralSetFunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralSetFunctionTypeContext() *GeneralSetFunctionTypeContext {
	var p = new(GeneralSetFunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalSetFunctionType
	return p
}

func InitEmptyGeneralSetFunctionTypeContext(p *GeneralSetFunctionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalSetFunctionType
}

func (*GeneralSetFunctionTypeContext) IsGeneralSetFunctionTypeContext() {}

func NewGeneralSetFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralSetFunctionTypeContext {
	var p = new(GeneralSetFunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_generalSetFunctionType

	return p
}

func (s *GeneralSetFunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralSetFunctionTypeContext) AVG() antlr.TerminalNode {
	return s.GetToken(GQLParserAVG, 0)
}

func (s *GeneralSetFunctionTypeContext) COUNT() antlr.TerminalNode {
	return s.GetToken(GQLParserCOUNT, 0)
}

func (s *GeneralSetFunctionTypeContext) MAX() antlr.TerminalNode {
	return s.GetToken(GQLParserMAX, 0)
}

func (s *GeneralSetFunctionTypeContext) MIN() antlr.TerminalNode {
	return s.GetToken(GQLParserMIN, 0)
}

func (s *GeneralSetFunctionTypeContext) SUM() antlr.TerminalNode {
	return s.GetToken(GQLParserSUM, 0)
}

func (s *GeneralSetFunctionTypeContext) COLLECT_LIST() antlr.TerminalNode {
	return s.GetToken(GQLParserCOLLECT_LIST, 0)
}

func (s *GeneralSetFunctionTypeContext) STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(GQLParserSTDDEV_SAMP, 0)
}

func (s *GeneralSetFunctionTypeContext) STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(GQLParserSTDDEV_POP, 0)
}

func (s *GeneralSetFunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralSetFunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralSetFunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGeneralSetFunctionType(s)
	}
}

func (s *GeneralSetFunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGeneralSetFunctionType(s)
	}
}

func (p *GQLParser) GeneralSetFunctionType() (localctx IGeneralSetFunctionTypeContext) {
	localctx = NewGeneralSetFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 930, GQLParserRULE_generalSetFunctionType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4223)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-36)) & ^0x3f) == 0 && ((int64(1)<<(_la-36))&545259521) != 0) || ((int64((_la-147)) & ^0x3f) == 0 && ((int64(1)<<(_la-147))&792633534417207299) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setQuantifier
	return p
}

func InitEmptySetQuantifierContext(p *SetQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_setQuantifier
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(GQLParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(GQLParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (p *GQLParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 932, GQLParserRULE_setQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4225)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserALL || _la == GQLParserDISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBinarySetFunctionTypeContext is an interface to support dynamic dispatch.
type IBinarySetFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PERCENTILE_CONT() antlr.TerminalNode
	PERCENTILE_DISC() antlr.TerminalNode

	// IsBinarySetFunctionTypeContext differentiates from other interfaces.
	IsBinarySetFunctionTypeContext()
}

type BinarySetFunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinarySetFunctionTypeContext() *BinarySetFunctionTypeContext {
	var p = new(BinarySetFunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_binarySetFunctionType
	return p
}

func InitEmptyBinarySetFunctionTypeContext(p *BinarySetFunctionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_binarySetFunctionType
}

func (*BinarySetFunctionTypeContext) IsBinarySetFunctionTypeContext() {}

func NewBinarySetFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinarySetFunctionTypeContext {
	var p = new(BinarySetFunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_binarySetFunctionType

	return p
}

func (s *BinarySetFunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BinarySetFunctionTypeContext) PERCENTILE_CONT() antlr.TerminalNode {
	return s.GetToken(GQLParserPERCENTILE_CONT, 0)
}

func (s *BinarySetFunctionTypeContext) PERCENTILE_DISC() antlr.TerminalNode {
	return s.GetToken(GQLParserPERCENTILE_DISC, 0)
}

func (s *BinarySetFunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinarySetFunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinarySetFunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBinarySetFunctionType(s)
	}
}

func (s *BinarySetFunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBinarySetFunctionType(s)
	}
}

func (p *GQLParser) BinarySetFunctionType() (localctx IBinarySetFunctionTypeContext) {
	localctx = NewBinarySetFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 934, GQLParserRULE_binarySetFunctionType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4227)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserPERCENTILE_CONT || _la == GQLParserPERCENTILE_DISC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDependentValueExpressionContext is an interface to support dynamic dispatch.
type IDependentValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericValueExpression() INumericValueExpressionContext
	SetQuantifier() ISetQuantifierContext

	// IsDependentValueExpressionContext differentiates from other interfaces.
	IsDependentValueExpressionContext()
}

type DependentValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDependentValueExpressionContext() *DependentValueExpressionContext {
	var p = new(DependentValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dependentValueExpression
	return p
}

func InitEmptyDependentValueExpressionContext(p *DependentValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dependentValueExpression
}

func (*DependentValueExpressionContext) IsDependentValueExpressionContext() {}

func NewDependentValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DependentValueExpressionContext {
	var p = new(DependentValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_dependentValueExpression

	return p
}

func (s *DependentValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DependentValueExpressionContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *DependentValueExpressionContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *DependentValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DependentValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DependentValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDependentValueExpression(s)
	}
}

func (s *DependentValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDependentValueExpression(s)
	}
}

func (p *GQLParser) DependentValueExpression() (localctx IDependentValueExpressionContext) {
	localctx = NewDependentValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 936, GQLParserRULE_dependentValueExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4230)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserALL || _la == GQLParserDISTINCT {
		{
			p.SetState(4229)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(4232)
		p.numericValueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndependentValueExpressionContext is an interface to support dynamic dispatch.
type IIndependentValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericValueExpression() INumericValueExpressionContext

	// IsIndependentValueExpressionContext differentiates from other interfaces.
	IsIndependentValueExpressionContext()
}

type IndependentValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndependentValueExpressionContext() *IndependentValueExpressionContext {
	var p = new(IndependentValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_independentValueExpression
	return p
}

func InitEmptyIndependentValueExpressionContext(p *IndependentValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_independentValueExpression
}

func (*IndependentValueExpressionContext) IsIndependentValueExpressionContext() {}

func NewIndependentValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndependentValueExpressionContext {
	var p = new(IndependentValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_independentValueExpression

	return p
}

func (s *IndependentValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndependentValueExpressionContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *IndependentValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndependentValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndependentValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterIndependentValueExpression(s)
	}
}

func (s *IndependentValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitIndependentValueExpression(s)
	}
}

func (p *GQLParser) IndependentValueExpression() (localctx IIndependentValueExpressionContext) {
	localctx = NewIndependentValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 938, GQLParserRULE_independentValueExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4234)
		p.numericValueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElement_idFunctionContext is an interface to support dynamic dispatch.
type IElement_idFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELEMENT_ID() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	ElementVariableReference() IElementVariableReferenceContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsElement_idFunctionContext differentiates from other interfaces.
	IsElement_idFunctionContext()
}

type Element_idFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElement_idFunctionContext() *Element_idFunctionContext {
	var p = new(Element_idFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_element_idFunction
	return p
}

func InitEmptyElement_idFunctionContext(p *Element_idFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_element_idFunction
}

func (*Element_idFunctionContext) IsElement_idFunctionContext() {}

func NewElement_idFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Element_idFunctionContext {
	var p = new(Element_idFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_element_idFunction

	return p
}

func (s *Element_idFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *Element_idFunctionContext) ELEMENT_ID() antlr.TerminalNode {
	return s.GetToken(GQLParserELEMENT_ID, 0)
}

func (s *Element_idFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *Element_idFunctionContext) ElementVariableReference() IElementVariableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementVariableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementVariableReferenceContext)
}

func (s *Element_idFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *Element_idFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Element_idFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Element_idFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterElement_idFunction(s)
	}
}

func (s *Element_idFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitElement_idFunction(s)
	}
}

func (p *GQLParser) Element_idFunction() (localctx IElement_idFunctionContext) {
	localctx = NewElement_idFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 940, GQLParserRULE_element_idFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4236)
		p.Match(GQLParserELEMENT_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4237)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4238)
		p.ElementVariableReference()
	}
	{
		p.SetState(4239)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindingVariableReferenceContext is an interface to support dynamic dispatch.
type IBindingVariableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingVariable() IBindingVariableContext

	// IsBindingVariableReferenceContext differentiates from other interfaces.
	IsBindingVariableReferenceContext()
}

type BindingVariableReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingVariableReferenceContext() *BindingVariableReferenceContext {
	var p = new(BindingVariableReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingVariableReference
	return p
}

func InitEmptyBindingVariableReferenceContext(p *BindingVariableReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingVariableReference
}

func (*BindingVariableReferenceContext) IsBindingVariableReferenceContext() {}

func NewBindingVariableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingVariableReferenceContext {
	var p = new(BindingVariableReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_bindingVariableReference

	return p
}

func (s *BindingVariableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingVariableReferenceContext) BindingVariable() IBindingVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableContext)
}

func (s *BindingVariableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingVariableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingVariableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBindingVariableReference(s)
	}
}

func (s *BindingVariableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBindingVariableReference(s)
	}
}

func (p *GQLParser) BindingVariableReference() (localctx IBindingVariableReferenceContext) {
	localctx = NewBindingVariableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 942, GQLParserRULE_bindingVariableReference)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4241)
		p.BindingVariable()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathValueExpressionContext is an interface to support dynamic dispatch.
type IPathValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsPathValueExpressionContext differentiates from other interfaces.
	IsPathValueExpressionContext()
}

type PathValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathValueExpressionContext() *PathValueExpressionContext {
	var p = new(PathValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathValueExpression
	return p
}

func InitEmptyPathValueExpressionContext(p *PathValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathValueExpression
}

func (*PathValueExpressionContext) IsPathValueExpressionContext() {}

func NewPathValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathValueExpressionContext {
	var p = new(PathValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathValueExpression

	return p
}

func (s *PathValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PathValueExpressionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PathValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathValueExpression(s)
	}
}

func (s *PathValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathValueExpression(s)
	}
}

func (p *GQLParser) PathValueExpression() (localctx IPathValueExpressionContext) {
	localctx = NewPathValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 944, GQLParserRULE_pathValueExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4243)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathValueConstructorContext is an interface to support dynamic dispatch.
type IPathValueConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PathValueConstructorByEnumeration() IPathValueConstructorByEnumerationContext

	// IsPathValueConstructorContext differentiates from other interfaces.
	IsPathValueConstructorContext()
}

type PathValueConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathValueConstructorContext() *PathValueConstructorContext {
	var p = new(PathValueConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathValueConstructor
	return p
}

func InitEmptyPathValueConstructorContext(p *PathValueConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathValueConstructor
}

func (*PathValueConstructorContext) IsPathValueConstructorContext() {}

func NewPathValueConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathValueConstructorContext {
	var p = new(PathValueConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathValueConstructor

	return p
}

func (s *PathValueConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *PathValueConstructorContext) PathValueConstructorByEnumeration() IPathValueConstructorByEnumerationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathValueConstructorByEnumerationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathValueConstructorByEnumerationContext)
}

func (s *PathValueConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathValueConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathValueConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathValueConstructor(s)
	}
}

func (s *PathValueConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathValueConstructor(s)
	}
}

func (p *GQLParser) PathValueConstructor() (localctx IPathValueConstructorContext) {
	localctx = NewPathValueConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 946, GQLParserRULE_pathValueConstructor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4245)
		p.PathValueConstructorByEnumeration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathValueConstructorByEnumerationContext is an interface to support dynamic dispatch.
type IPathValueConstructorByEnumerationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PATH() antlr.TerminalNode
	LEFT_BRACKET() antlr.TerminalNode
	PathElementList() IPathElementListContext
	RIGHT_BRACKET() antlr.TerminalNode

	// IsPathValueConstructorByEnumerationContext differentiates from other interfaces.
	IsPathValueConstructorByEnumerationContext()
}

type PathValueConstructorByEnumerationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathValueConstructorByEnumerationContext() *PathValueConstructorByEnumerationContext {
	var p = new(PathValueConstructorByEnumerationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathValueConstructorByEnumeration
	return p
}

func InitEmptyPathValueConstructorByEnumerationContext(p *PathValueConstructorByEnumerationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathValueConstructorByEnumeration
}

func (*PathValueConstructorByEnumerationContext) IsPathValueConstructorByEnumerationContext() {}

func NewPathValueConstructorByEnumerationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathValueConstructorByEnumerationContext {
	var p = new(PathValueConstructorByEnumerationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathValueConstructorByEnumeration

	return p
}

func (s *PathValueConstructorByEnumerationContext) GetParser() antlr.Parser { return s.parser }

func (s *PathValueConstructorByEnumerationContext) PATH() antlr.TerminalNode {
	return s.GetToken(GQLParserPATH, 0)
}

func (s *PathValueConstructorByEnumerationContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACKET, 0)
}

func (s *PathValueConstructorByEnumerationContext) PathElementList() IPathElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathElementListContext)
}

func (s *PathValueConstructorByEnumerationContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET, 0)
}

func (s *PathValueConstructorByEnumerationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathValueConstructorByEnumerationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathValueConstructorByEnumerationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathValueConstructorByEnumeration(s)
	}
}

func (s *PathValueConstructorByEnumerationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathValueConstructorByEnumeration(s)
	}
}

func (p *GQLParser) PathValueConstructorByEnumeration() (localctx IPathValueConstructorByEnumerationContext) {
	localctx = NewPathValueConstructorByEnumerationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 948, GQLParserRULE_pathValueConstructorByEnumeration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4247)
		p.Match(GQLParserPATH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4248)
		p.Match(GQLParserLEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4249)
		p.PathElementList()
	}
	{
		p.SetState(4250)
		p.Match(GQLParserRIGHT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathElementListContext is an interface to support dynamic dispatch.
type IPathElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PathElementListStart() IPathElementListStartContext
	AllPathElementListStep() []IPathElementListStepContext
	PathElementListStep(i int) IPathElementListStepContext

	// IsPathElementListContext differentiates from other interfaces.
	IsPathElementListContext()
}

type PathElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathElementListContext() *PathElementListContext {
	var p = new(PathElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathElementList
	return p
}

func InitEmptyPathElementListContext(p *PathElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathElementList
}

func (*PathElementListContext) IsPathElementListContext() {}

func NewPathElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathElementListContext {
	var p = new(PathElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathElementList

	return p
}

func (s *PathElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *PathElementListContext) PathElementListStart() IPathElementListStartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathElementListStartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathElementListStartContext)
}

func (s *PathElementListContext) AllPathElementListStep() []IPathElementListStepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPathElementListStepContext); ok {
			len++
		}
	}

	tst := make([]IPathElementListStepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPathElementListStepContext); ok {
			tst[i] = t.(IPathElementListStepContext)
			i++
		}
	}

	return tst
}

func (s *PathElementListContext) PathElementListStep(i int) IPathElementListStepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathElementListStepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathElementListStepContext)
}

func (s *PathElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathElementList(s)
	}
}

func (s *PathElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathElementList(s)
	}
}

func (p *GQLParser) PathElementList() (localctx IPathElementListContext) {
	localctx = NewPathElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 950, GQLParserRULE_pathElementList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4252)
		p.PathElementListStart()
	}
	p.SetState(4256)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(4253)
			p.PathElementListStep()
		}

		p.SetState(4258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathElementListStartContext is an interface to support dynamic dispatch.
type IPathElementListStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NodeReferenceValueExpression() INodeReferenceValueExpressionContext

	// IsPathElementListStartContext differentiates from other interfaces.
	IsPathElementListStartContext()
}

type PathElementListStartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathElementListStartContext() *PathElementListStartContext {
	var p = new(PathElementListStartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathElementListStart
	return p
}

func InitEmptyPathElementListStartContext(p *PathElementListStartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathElementListStart
}

func (*PathElementListStartContext) IsPathElementListStartContext() {}

func NewPathElementListStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathElementListStartContext {
	var p = new(PathElementListStartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathElementListStart

	return p
}

func (s *PathElementListStartContext) GetParser() antlr.Parser { return s.parser }

func (s *PathElementListStartContext) NodeReferenceValueExpression() INodeReferenceValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeReferenceValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeReferenceValueExpressionContext)
}

func (s *PathElementListStartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathElementListStartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathElementListStartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathElementListStart(s)
	}
}

func (s *PathElementListStartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathElementListStart(s)
	}
}

func (p *GQLParser) PathElementListStart() (localctx IPathElementListStartContext) {
	localctx = NewPathElementListStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 952, GQLParserRULE_pathElementListStart)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4259)
		p.NodeReferenceValueExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathElementListStepContext is an interface to support dynamic dispatch.
type IPathElementListStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	EdgeReferenceValueExpression() IEdgeReferenceValueExpressionContext
	NodeReferenceValueExpression() INodeReferenceValueExpressionContext

	// IsPathElementListStepContext differentiates from other interfaces.
	IsPathElementListStepContext()
}

type PathElementListStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathElementListStepContext() *PathElementListStepContext {
	var p = new(PathElementListStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathElementListStep
	return p
}

func InitEmptyPathElementListStepContext(p *PathElementListStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathElementListStep
}

func (*PathElementListStepContext) IsPathElementListStepContext() {}

func NewPathElementListStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathElementListStepContext {
	var p = new(PathElementListStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathElementListStep

	return p
}

func (s *PathElementListStepContext) GetParser() antlr.Parser { return s.parser }

func (s *PathElementListStepContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *PathElementListStepContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *PathElementListStepContext) EdgeReferenceValueExpression() IEdgeReferenceValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEdgeReferenceValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEdgeReferenceValueExpressionContext)
}

func (s *PathElementListStepContext) NodeReferenceValueExpression() INodeReferenceValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INodeReferenceValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INodeReferenceValueExpressionContext)
}

func (s *PathElementListStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathElementListStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathElementListStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathElementListStep(s)
	}
}

func (s *PathElementListStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathElementListStep(s)
	}
}

func (p *GQLParser) PathElementListStep() (localctx IPathElementListStepContext) {
	localctx = NewPathElementListStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 954, GQLParserRULE_pathElementListStep)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4261)
		p.Match(GQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4262)
		p.EdgeReferenceValueExpression()
	}
	{
		p.SetState(4263)
		p.Match(GQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4264)
		p.NodeReferenceValueExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListValueExpressionContext is an interface to support dynamic dispatch.
type IListValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsListValueExpressionContext differentiates from other interfaces.
	IsListValueExpressionContext()
}

type ListValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListValueExpressionContext() *ListValueExpressionContext {
	var p = new(ListValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listValueExpression
	return p
}

func InitEmptyListValueExpressionContext(p *ListValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listValueExpression
}

func (*ListValueExpressionContext) IsListValueExpressionContext() {}

func NewListValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListValueExpressionContext {
	var p = new(ListValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_listValueExpression

	return p
}

func (s *ListValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ListValueExpressionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ListValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterListValueExpression(s)
	}
}

func (s *ListValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitListValueExpression(s)
	}
}

func (p *GQLParser) ListValueExpression() (localctx IListValueExpressionContext) {
	localctx = NewListValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 956, GQLParserRULE_listValueExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4266)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListValueFunctionContext is an interface to support dynamic dispatch.
type IListValueFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TrimListFunction() ITrimListFunctionContext
	ElementsFunction() IElementsFunctionContext

	// IsListValueFunctionContext differentiates from other interfaces.
	IsListValueFunctionContext()
}

type ListValueFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListValueFunctionContext() *ListValueFunctionContext {
	var p = new(ListValueFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listValueFunction
	return p
}

func InitEmptyListValueFunctionContext(p *ListValueFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listValueFunction
}

func (*ListValueFunctionContext) IsListValueFunctionContext() {}

func NewListValueFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListValueFunctionContext {
	var p = new(ListValueFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_listValueFunction

	return p
}

func (s *ListValueFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ListValueFunctionContext) TrimListFunction() ITrimListFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrimListFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrimListFunctionContext)
}

func (s *ListValueFunctionContext) ElementsFunction() IElementsFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementsFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementsFunctionContext)
}

func (s *ListValueFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListValueFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListValueFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterListValueFunction(s)
	}
}

func (s *ListValueFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitListValueFunction(s)
	}
}

func (p *GQLParser) ListValueFunction() (localctx IListValueFunctionContext) {
	localctx = NewListValueFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 958, GQLParserRULE_listValueFunction)
	p.SetState(4270)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserTRIM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4268)
			p.TrimListFunction()
		}

	case GQLParserELEMENTS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4269)
			p.ElementsFunction()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrimListFunctionContext is an interface to support dynamic dispatch.
type ITrimListFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIM() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	ListValueExpression() IListValueExpressionContext
	COMMA() antlr.TerminalNode
	NumericValueExpression() INumericValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsTrimListFunctionContext differentiates from other interfaces.
	IsTrimListFunctionContext()
}

type TrimListFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrimListFunctionContext() *TrimListFunctionContext {
	var p = new(TrimListFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trimListFunction
	return p
}

func InitEmptyTrimListFunctionContext(p *TrimListFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trimListFunction
}

func (*TrimListFunctionContext) IsTrimListFunctionContext() {}

func NewTrimListFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrimListFunctionContext {
	var p = new(TrimListFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_trimListFunction

	return p
}

func (s *TrimListFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *TrimListFunctionContext) TRIM() antlr.TerminalNode {
	return s.GetToken(GQLParserTRIM, 0)
}

func (s *TrimListFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *TrimListFunctionContext) ListValueExpression() IListValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListValueExpressionContext)
}

func (s *TrimListFunctionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *TrimListFunctionContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *TrimListFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *TrimListFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimListFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrimListFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTrimListFunction(s)
	}
}

func (s *TrimListFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTrimListFunction(s)
	}
}

func (p *GQLParser) TrimListFunction() (localctx ITrimListFunctionContext) {
	localctx = NewTrimListFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 960, GQLParserRULE_trimListFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4272)
		p.Match(GQLParserTRIM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4273)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4274)
		p.ListValueExpression()
	}
	{
		p.SetState(4275)
		p.Match(GQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4276)
		p.numericValueExpression(0)
	}
	{
		p.SetState(4277)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementsFunctionContext is an interface to support dynamic dispatch.
type IElementsFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELEMENTS() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	PathValueExpression() IPathValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsElementsFunctionContext differentiates from other interfaces.
	IsElementsFunctionContext()
}

type ElementsFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementsFunctionContext() *ElementsFunctionContext {
	var p = new(ElementsFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementsFunction
	return p
}

func InitEmptyElementsFunctionContext(p *ElementsFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementsFunction
}

func (*ElementsFunctionContext) IsElementsFunctionContext() {}

func NewElementsFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementsFunctionContext {
	var p = new(ElementsFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_elementsFunction

	return p
}

func (s *ElementsFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementsFunctionContext) ELEMENTS() antlr.TerminalNode {
	return s.GetToken(GQLParserELEMENTS, 0)
}

func (s *ElementsFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *ElementsFunctionContext) PathValueExpression() IPathValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathValueExpressionContext)
}

func (s *ElementsFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *ElementsFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementsFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementsFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterElementsFunction(s)
	}
}

func (s *ElementsFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitElementsFunction(s)
	}
}

func (p *GQLParser) ElementsFunction() (localctx IElementsFunctionContext) {
	localctx = NewElementsFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 962, GQLParserRULE_elementsFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4279)
		p.Match(GQLParserELEMENTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4280)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4281)
		p.PathValueExpression()
	}
	{
		p.SetState(4282)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListValueConstructorContext is an interface to support dynamic dispatch.
type IListValueConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ListValueConstructorByEnumeration() IListValueConstructorByEnumerationContext

	// IsListValueConstructorContext differentiates from other interfaces.
	IsListValueConstructorContext()
}

type ListValueConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListValueConstructorContext() *ListValueConstructorContext {
	var p = new(ListValueConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listValueConstructor
	return p
}

func InitEmptyListValueConstructorContext(p *ListValueConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listValueConstructor
}

func (*ListValueConstructorContext) IsListValueConstructorContext() {}

func NewListValueConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListValueConstructorContext {
	var p = new(ListValueConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_listValueConstructor

	return p
}

func (s *ListValueConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *ListValueConstructorContext) ListValueConstructorByEnumeration() IListValueConstructorByEnumerationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListValueConstructorByEnumerationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListValueConstructorByEnumerationContext)
}

func (s *ListValueConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListValueConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListValueConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterListValueConstructor(s)
	}
}

func (s *ListValueConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitListValueConstructor(s)
	}
}

func (p *GQLParser) ListValueConstructor() (localctx IListValueConstructorContext) {
	localctx = NewListValueConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 964, GQLParserRULE_listValueConstructor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4284)
		p.ListValueConstructorByEnumeration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListValueConstructorByEnumerationContext is an interface to support dynamic dispatch.
type IListValueConstructorByEnumerationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_BRACKET() antlr.TerminalNode
	RIGHT_BRACKET() antlr.TerminalNode
	ListValueTypeName() IListValueTypeNameContext
	ListElementList() IListElementListContext

	// IsListValueConstructorByEnumerationContext differentiates from other interfaces.
	IsListValueConstructorByEnumerationContext()
}

type ListValueConstructorByEnumerationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListValueConstructorByEnumerationContext() *ListValueConstructorByEnumerationContext {
	var p = new(ListValueConstructorByEnumerationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listValueConstructorByEnumeration
	return p
}

func InitEmptyListValueConstructorByEnumerationContext(p *ListValueConstructorByEnumerationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listValueConstructorByEnumeration
}

func (*ListValueConstructorByEnumerationContext) IsListValueConstructorByEnumerationContext() {}

func NewListValueConstructorByEnumerationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListValueConstructorByEnumerationContext {
	var p = new(ListValueConstructorByEnumerationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_listValueConstructorByEnumeration

	return p
}

func (s *ListValueConstructorByEnumerationContext) GetParser() antlr.Parser { return s.parser }

func (s *ListValueConstructorByEnumerationContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACKET, 0)
}

func (s *ListValueConstructorByEnumerationContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACKET, 0)
}

func (s *ListValueConstructorByEnumerationContext) ListValueTypeName() IListValueTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListValueTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListValueTypeNameContext)
}

func (s *ListValueConstructorByEnumerationContext) ListElementList() IListElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListElementListContext)
}

func (s *ListValueConstructorByEnumerationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListValueConstructorByEnumerationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListValueConstructorByEnumerationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterListValueConstructorByEnumeration(s)
	}
}

func (s *ListValueConstructorByEnumerationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitListValueConstructorByEnumeration(s)
	}
}

func (p *GQLParser) ListValueConstructorByEnumeration() (localctx IListValueConstructorByEnumerationContext) {
	localctx = NewListValueConstructorByEnumerationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 966, GQLParserRULE_listValueConstructorByEnumeration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4287)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserARRAY || _la == GQLParserLIST {
		{
			p.SetState(4286)
			p.ListValueTypeName()
		}

	}
	{
		p.SetState(4289)
		p.Match(GQLParserLEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3684181877393982240) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&275712591755) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&-8011702113698201677) != 0) || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&26393111092643) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&844424930131967) != 0) || ((int64((_la-371)) & ^0x3f) == 0 && ((int64(1)<<(_la-371))&151) != 0) {
		{
			p.SetState(4290)
			p.ListElementList()
		}

	}
	{
		p.SetState(4293)
		p.Match(GQLParserRIGHT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListElementListContext is an interface to support dynamic dispatch.
type IListElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllListElement() []IListElementContext
	ListElement(i int) IListElementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsListElementListContext differentiates from other interfaces.
	IsListElementListContext()
}

type ListElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListElementListContext() *ListElementListContext {
	var p = new(ListElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listElementList
	return p
}

func InitEmptyListElementListContext(p *ListElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listElementList
}

func (*ListElementListContext) IsListElementListContext() {}

func NewListElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListElementListContext {
	var p = new(ListElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_listElementList

	return p
}

func (s *ListElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *ListElementListContext) AllListElement() []IListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IListElementContext); ok {
			len++
		}
	}

	tst := make([]IListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IListElementContext); ok {
			tst[i] = t.(IListElementContext)
			i++
		}
	}

	return tst
}

func (s *ListElementListContext) ListElement(i int) IListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListElementContext)
}

func (s *ListElementListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *ListElementListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *ListElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterListElementList(s)
	}
}

func (s *ListElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitListElementList(s)
	}
}

func (p *GQLParser) ListElementList() (localctx IListElementListContext) {
	localctx = NewListElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 968, GQLParserRULE_listElementList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4295)
		p.ListElement()
	}
	p.SetState(4300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(4296)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4297)
			p.ListElement()
		}

		p.SetState(4302)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListElementContext is an interface to support dynamic dispatch.
type IListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsListElementContext differentiates from other interfaces.
	IsListElementContext()
}

type ListElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListElementContext() *ListElementContext {
	var p = new(ListElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listElement
	return p
}

func InitEmptyListElementContext(p *ListElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listElement
}

func (*ListElementContext) IsListElementContext() {}

func NewListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListElementContext {
	var p = new(ListElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_listElement

	return p
}

func (s *ListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ListElementContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterListElement(s)
	}
}

func (s *ListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitListElement(s)
	}
}

func (p *GQLParser) ListElement() (localctx IListElementContext) {
	localctx = NewListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 970, GQLParserRULE_listElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4303)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordConstructorContext is an interface to support dynamic dispatch.
type IRecordConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldsSpecification() IFieldsSpecificationContext
	RECORD() antlr.TerminalNode

	// IsRecordConstructorContext differentiates from other interfaces.
	IsRecordConstructorContext()
}

type RecordConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordConstructorContext() *RecordConstructorContext {
	var p = new(RecordConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_recordConstructor
	return p
}

func InitEmptyRecordConstructorContext(p *RecordConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_recordConstructor
}

func (*RecordConstructorContext) IsRecordConstructorContext() {}

func NewRecordConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordConstructorContext {
	var p = new(RecordConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_recordConstructor

	return p
}

func (s *RecordConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordConstructorContext) FieldsSpecification() IFieldsSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldsSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldsSpecificationContext)
}

func (s *RecordConstructorContext) RECORD() antlr.TerminalNode {
	return s.GetToken(GQLParserRECORD, 0)
}

func (s *RecordConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterRecordConstructor(s)
	}
}

func (s *RecordConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitRecordConstructor(s)
	}
}

func (p *GQLParser) RecordConstructor() (localctx IRecordConstructorContext) {
	localctx = NewRecordConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 972, GQLParserRULE_recordConstructor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4306)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserRECORD {
		{
			p.SetState(4305)
			p.Match(GQLParserRECORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4308)
		p.FieldsSpecification()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldsSpecificationContext is an interface to support dynamic dispatch.
type IFieldsSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_BRACE() antlr.TerminalNode
	RIGHT_BRACE() antlr.TerminalNode
	FieldList() IFieldListContext

	// IsFieldsSpecificationContext differentiates from other interfaces.
	IsFieldsSpecificationContext()
}

type FieldsSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldsSpecificationContext() *FieldsSpecificationContext {
	var p = new(FieldsSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fieldsSpecification
	return p
}

func InitEmptyFieldsSpecificationContext(p *FieldsSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fieldsSpecification
}

func (*FieldsSpecificationContext) IsFieldsSpecificationContext() {}

func NewFieldsSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldsSpecificationContext {
	var p = new(FieldsSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fieldsSpecification

	return p
}

func (s *FieldsSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldsSpecificationContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_BRACE, 0)
}

func (s *FieldsSpecificationContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_BRACE, 0)
}

func (s *FieldsSpecificationContext) FieldList() IFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *FieldsSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldsSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldsSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFieldsSpecification(s)
	}
}

func (s *FieldsSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFieldsSpecification(s)
	}
}

func (p *GQLParser) FieldsSpecification() (localctx IFieldsSpecificationContext) {
	localctx = NewFieldsSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 974, GQLParserRULE_fieldsSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4310)
		p.Match(GQLParserLEFT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4312)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&281474976710655) != 0) {
		{
			p.SetState(4311)
			p.FieldList()
		}

	}
	{
		p.SetState(4314)
		p.Match(GQLParserRIGHT_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldListContext is an interface to support dynamic dispatch.
type IFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllField() []IFieldContext
	Field(i int) IFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFieldListContext differentiates from other interfaces.
	IsFieldListContext()
}

type FieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldListContext() *FieldListContext {
	var p = new(FieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fieldList
	return p
}

func InitEmptyFieldListContext(p *FieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fieldList
}

func (*FieldListContext) IsFieldListContext() {}

func NewFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldListContext {
	var p = new(FieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fieldList

	return p
}

func (s *FieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldListContext) AllField() []IFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldContext); ok {
			len++
		}
	}

	tst := make([]IFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldContext); ok {
			tst[i] = t.(IFieldContext)
			i++
		}
	}

	return tst
}

func (s *FieldListContext) Field(i int) IFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *FieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GQLParserCOMMA)
}

func (s *FieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, i)
}

func (s *FieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFieldList(s)
	}
}

func (s *FieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFieldList(s)
	}
}

func (p *GQLParser) FieldList() (localctx IFieldListContext) {
	localctx = NewFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 976, GQLParserRULE_fieldList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4316)
		p.Field()
	}
	p.SetState(4321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == GQLParserCOMMA {
		{
			p.SetState(4317)
			p.Match(GQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4318)
			p.Field()
		}

		p.SetState(4323)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldContext is an interface to support dynamic dispatch.
type IFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldName() IFieldNameContext
	COLON() antlr.TerminalNode
	ValueExpression() IValueExpressionContext

	// IsFieldContext differentiates from other interfaces.
	IsFieldContext()
}

type FieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldContext() *FieldContext {
	var p = new(FieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_field
	return p
}

func InitEmptyFieldContext(p *FieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_field
}

func (*FieldContext) IsFieldContext() {}

func NewFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldContext {
	var p = new(FieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_field

	return p
}

func (s *FieldContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldContext) FieldName() IFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldNameContext)
}

func (s *FieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(GQLParserCOLON, 0)
}

func (s *FieldContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *FieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterField(s)
	}
}

func (s *FieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitField(s)
	}
}

func (p *GQLParser) Field() (localctx IFieldContext) {
	localctx = NewFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 978, GQLParserRULE_field)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4324)
		p.FieldName()
	}
	{
		p.SetState(4325)
		p.Match(GQLParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4326)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruthValueContext is an interface to support dynamic dispatch.
type ITruthValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BOOLEAN_LITERAL() antlr.TerminalNode

	// IsTruthValueContext differentiates from other interfaces.
	IsTruthValueContext()
}

type TruthValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruthValueContext() *TruthValueContext {
	var p = new(TruthValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_truthValue
	return p
}

func InitEmptyTruthValueContext(p *TruthValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_truthValue
}

func (*TruthValueContext) IsTruthValueContext() {}

func NewTruthValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruthValueContext {
	var p = new(TruthValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_truthValue

	return p
}

func (s *TruthValueContext) GetParser() antlr.Parser { return s.parser }

func (s *TruthValueContext) BOOLEAN_LITERAL() antlr.TerminalNode {
	return s.GetToken(GQLParserBOOLEAN_LITERAL, 0)
}

func (s *TruthValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruthValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruthValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTruthValue(s)
	}
}

func (s *TruthValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTruthValue(s)
	}
}

func (p *GQLParser) TruthValue() (localctx ITruthValueContext) {
	localctx = NewTruthValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 980, GQLParserRULE_truthValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4328)
		p.Match(GQLParserBOOLEAN_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumericValueExpressionContext is an interface to support dynamic dispatch.
type INumericValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSign returns the sign token.
	GetSign() antlr.Token

	// GetOperator returns the operator token.
	GetOperator() antlr.Token

	// SetSign sets the sign token.
	SetSign(antlr.Token)

	// SetOperator sets the operator token.
	SetOperator(antlr.Token)

	// Getter signatures
	AllNumericValueExpression() []INumericValueExpressionContext
	NumericValueExpression(i int) INumericValueExpressionContext
	PLUS_SIGN() antlr.TerminalNode
	MINUS_SIGN() antlr.TerminalNode
	ValueExpressionPrimary() IValueExpressionPrimaryContext
	NumericValueFunction() INumericValueFunctionContext
	ASTERISK() antlr.TerminalNode
	SOLIDUS() antlr.TerminalNode

	// IsNumericValueExpressionContext differentiates from other interfaces.
	IsNumericValueExpressionContext()
}

type NumericValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	sign     antlr.Token
	operator antlr.Token
}

func NewEmptyNumericValueExpressionContext() *NumericValueExpressionContext {
	var p = new(NumericValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numericValueExpression
	return p
}

func InitEmptyNumericValueExpressionContext(p *NumericValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numericValueExpression
}

func (*NumericValueExpressionContext) IsNumericValueExpressionContext() {}

func NewNumericValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericValueExpressionContext {
	var p = new(NumericValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_numericValueExpression

	return p
}

func (s *NumericValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericValueExpressionContext) GetSign() antlr.Token { return s.sign }

func (s *NumericValueExpressionContext) GetOperator() antlr.Token { return s.operator }

func (s *NumericValueExpressionContext) SetSign(v antlr.Token) { s.sign = v }

func (s *NumericValueExpressionContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *NumericValueExpressionContext) AllNumericValueExpression() []INumericValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]INumericValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INumericValueExpressionContext); ok {
			tst[i] = t.(INumericValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NumericValueExpressionContext) NumericValueExpression(i int) INumericValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *NumericValueExpressionContext) PLUS_SIGN() antlr.TerminalNode {
	return s.GetToken(GQLParserPLUS_SIGN, 0)
}

func (s *NumericValueExpressionContext) MINUS_SIGN() antlr.TerminalNode {
	return s.GetToken(GQLParserMINUS_SIGN, 0)
}

func (s *NumericValueExpressionContext) ValueExpressionPrimary() IValueExpressionPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionPrimaryContext)
}

func (s *NumericValueExpressionContext) NumericValueFunction() INumericValueFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueFunctionContext)
}

func (s *NumericValueExpressionContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(GQLParserASTERISK, 0)
}

func (s *NumericValueExpressionContext) SOLIDUS() antlr.TerminalNode {
	return s.GetToken(GQLParserSOLIDUS, 0)
}

func (s *NumericValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNumericValueExpression(s)
	}
}

func (s *NumericValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNumericValueExpression(s)
	}
}

func (p *GQLParser) NumericValueExpression() (localctx INumericValueExpressionContext) {
	return p.numericValueExpression(0)
}

func (p *GQLParser) numericValueExpression(_p int) (localctx INumericValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewNumericValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx INumericValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 982
	p.EnterRecursionRule(localctx, 982, GQLParserRULE_numericValueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4335)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserMINUS_SIGN, GQLParserPLUS_SIGN:
		{
			p.SetState(4331)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NumericValueExpressionContext).sign = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == GQLParserMINUS_SIGN || _la == GQLParserPLUS_SIGN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NumericValueExpressionContext).sign = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4332)
			p.numericValueExpression(5)
		}

	case GQLParserBOOLEAN_LITERAL, GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE, GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, GQLParserBYTE_STRING_LITERAL, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER, GQLParserUNSIGNED_HEXADECIMAL_INTEGER, GQLParserUNSIGNED_OCTAL_INTEGER, GQLParserUNSIGNED_BINARY_INTEGER, GQLParserARRAY, GQLParserAVG, GQLParserCASE, GQLParserCAST, GQLParserCOALESCE, GQLParserCOLLECT_LIST, GQLParserCOUNT, GQLParserDATE, GQLParserDATETIME, GQLParserDURATION, GQLParserELEMENT_ID, GQLParserLET, GQLParserLIST, GQLParserMAX, GQLParserMIN, GQLParserNULL_KW, GQLParserNULLIF, GQLParserPATH, GQLParserPERCENTILE_CONT, GQLParserPERCENTILE_DISC, GQLParserRECORD, GQLParserSESSION_USER, GQLParserSTDDEV_POP, GQLParserSTDDEV_SAMP, GQLParserSUM, GQLParserTIME, GQLParserTIMESTAMP, GQLParserVALUE, GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE, GQLParserREGULAR_IDENTIFIER, GQLParserGENERAL_PARAMETER_REFERENCE, GQLParserLEFT_BRACE, GQLParserLEFT_BRACKET, GQLParserLEFT_PAREN:
		{
			p.SetState(4333)
			p.valueExpressionPrimary(0)
		}

	case GQLParserABS, GQLParserACOS, GQLParserASIN, GQLParserATAN, GQLParserBYTE_LENGTH, GQLParserCARDINALITY, GQLParserCEIL, GQLParserCEILING, GQLParserCHAR_LENGTH, GQLParserCHARACTER_LENGTH, GQLParserCOS, GQLParserCOSH, GQLParserCOT, GQLParserDEGREES, GQLParserEXP, GQLParserFLOOR, GQLParserLN, GQLParserLOG_KW, GQLParserLOG10, GQLParserMOD, GQLParserOCTET_LENGTH, GQLParserPATH_LENGTH, GQLParserPOWER, GQLParserRADIANS, GQLParserSIN, GQLParserSINH, GQLParserSIZE, GQLParserSQRT, GQLParserTAN, GQLParserTANH:
		{
			p.SetState(4334)
			p.NumericValueFunction()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 481, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(4343)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 480, p.GetParserRuleContext()) {
			case 1:
				localctx = NewNumericValueExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_numericValueExpression)
				p.SetState(4337)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(4338)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*NumericValueExpressionContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GQLParserASTERISK || _la == GQLParserSOLIDUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*NumericValueExpressionContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(4339)
					p.numericValueExpression(5)
				}

			case 2:
				localctx = NewNumericValueExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, GQLParserRULE_numericValueExpression)
				p.SetState(4340)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(4341)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*NumericValueExpressionContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GQLParserMINUS_SIGN || _la == GQLParserPLUS_SIGN) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*NumericValueExpressionContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(4342)
					p.numericValueExpression(4)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(4347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 481, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumericValueFunctionContext is an interface to support dynamic dispatch.
type INumericValueFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LengthExpression() ILengthExpressionContext
	CardinalityExpression() ICardinalityExpressionContext
	AbsoluteValueExpression() IAbsoluteValueExpressionContext
	ModulusExpression() IModulusExpressionContext
	TrigonometricFunction() ITrigonometricFunctionContext
	GeneralLogarithmFunction() IGeneralLogarithmFunctionContext
	CommonLogarithm() ICommonLogarithmContext
	NaturalLogarithm() INaturalLogarithmContext
	ExponentialFunction() IExponentialFunctionContext
	PowerFunction() IPowerFunctionContext
	SquareRoot() ISquareRootContext
	FloorFunction() IFloorFunctionContext
	CeilingFunction() ICeilingFunctionContext

	// IsNumericValueFunctionContext differentiates from other interfaces.
	IsNumericValueFunctionContext()
}

type NumericValueFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericValueFunctionContext() *NumericValueFunctionContext {
	var p = new(NumericValueFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numericValueFunction
	return p
}

func InitEmptyNumericValueFunctionContext(p *NumericValueFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numericValueFunction
}

func (*NumericValueFunctionContext) IsNumericValueFunctionContext() {}

func NewNumericValueFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericValueFunctionContext {
	var p = new(NumericValueFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_numericValueFunction

	return p
}

func (s *NumericValueFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericValueFunctionContext) LengthExpression() ILengthExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthExpressionContext)
}

func (s *NumericValueFunctionContext) CardinalityExpression() ICardinalityExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICardinalityExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICardinalityExpressionContext)
}

func (s *NumericValueFunctionContext) AbsoluteValueExpression() IAbsoluteValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbsoluteValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbsoluteValueExpressionContext)
}

func (s *NumericValueFunctionContext) ModulusExpression() IModulusExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModulusExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModulusExpressionContext)
}

func (s *NumericValueFunctionContext) TrigonometricFunction() ITrigonometricFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrigonometricFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrigonometricFunctionContext)
}

func (s *NumericValueFunctionContext) GeneralLogarithmFunction() IGeneralLogarithmFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralLogarithmFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralLogarithmFunctionContext)
}

func (s *NumericValueFunctionContext) CommonLogarithm() ICommonLogarithmContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonLogarithmContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonLogarithmContext)
}

func (s *NumericValueFunctionContext) NaturalLogarithm() INaturalLogarithmContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INaturalLogarithmContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INaturalLogarithmContext)
}

func (s *NumericValueFunctionContext) ExponentialFunction() IExponentialFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExponentialFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExponentialFunctionContext)
}

func (s *NumericValueFunctionContext) PowerFunction() IPowerFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPowerFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPowerFunctionContext)
}

func (s *NumericValueFunctionContext) SquareRoot() ISquareRootContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISquareRootContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISquareRootContext)
}

func (s *NumericValueFunctionContext) FloorFunction() IFloorFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloorFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloorFunctionContext)
}

func (s *NumericValueFunctionContext) CeilingFunction() ICeilingFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICeilingFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICeilingFunctionContext)
}

func (s *NumericValueFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericValueFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericValueFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNumericValueFunction(s)
	}
}

func (s *NumericValueFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNumericValueFunction(s)
	}
}

func (p *GQLParser) NumericValueFunction() (localctx INumericValueFunctionContext) {
	localctx = NewNumericValueFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 984, GQLParserRULE_numericValueFunction)
	p.SetState(4361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserBYTE_LENGTH, GQLParserCHAR_LENGTH, GQLParserCHARACTER_LENGTH, GQLParserOCTET_LENGTH, GQLParserPATH_LENGTH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4348)
			p.LengthExpression()
		}

	case GQLParserCARDINALITY, GQLParserSIZE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4349)
			p.CardinalityExpression()
		}

	case GQLParserABS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4350)
			p.AbsoluteValueExpression()
		}

	case GQLParserMOD:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4351)
			p.ModulusExpression()
		}

	case GQLParserACOS, GQLParserASIN, GQLParserATAN, GQLParserCOS, GQLParserCOSH, GQLParserCOT, GQLParserDEGREES, GQLParserRADIANS, GQLParserSIN, GQLParserSINH, GQLParserTAN, GQLParserTANH:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4352)
			p.TrigonometricFunction()
		}

	case GQLParserLOG_KW:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4353)
			p.GeneralLogarithmFunction()
		}

	case GQLParserLOG10:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4354)
			p.CommonLogarithm()
		}

	case GQLParserLN:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4355)
			p.NaturalLogarithm()
		}

	case GQLParserEXP:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4356)
			p.ExponentialFunction()
		}

	case GQLParserPOWER:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4357)
			p.PowerFunction()
		}

	case GQLParserSQRT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4358)
			p.SquareRoot()
		}

	case GQLParserFLOOR:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4359)
			p.FloorFunction()
		}

	case GQLParserCEIL, GQLParserCEILING:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(4360)
			p.CeilingFunction()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILengthExpressionContext is an interface to support dynamic dispatch.
type ILengthExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CharLengthExpression() ICharLengthExpressionContext
	ByteLengthExpression() IByteLengthExpressionContext
	PathLengthExpression() IPathLengthExpressionContext

	// IsLengthExpressionContext differentiates from other interfaces.
	IsLengthExpressionContext()
}

type LengthExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthExpressionContext() *LengthExpressionContext {
	var p = new(LengthExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_lengthExpression
	return p
}

func InitEmptyLengthExpressionContext(p *LengthExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_lengthExpression
}

func (*LengthExpressionContext) IsLengthExpressionContext() {}

func NewLengthExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthExpressionContext {
	var p = new(LengthExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_lengthExpression

	return p
}

func (s *LengthExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthExpressionContext) CharLengthExpression() ICharLengthExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharLengthExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharLengthExpressionContext)
}

func (s *LengthExpressionContext) ByteLengthExpression() IByteLengthExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IByteLengthExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IByteLengthExpressionContext)
}

func (s *LengthExpressionContext) PathLengthExpression() IPathLengthExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathLengthExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathLengthExpressionContext)
}

func (s *LengthExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLengthExpression(s)
	}
}

func (s *LengthExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLengthExpression(s)
	}
}

func (p *GQLParser) LengthExpression() (localctx ILengthExpressionContext) {
	localctx = NewLengthExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 986, GQLParserRULE_lengthExpression)
	p.SetState(4366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserCHAR_LENGTH, GQLParserCHARACTER_LENGTH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4363)
			p.CharLengthExpression()
		}

	case GQLParserBYTE_LENGTH, GQLParserOCTET_LENGTH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4364)
			p.ByteLengthExpression()
		}

	case GQLParserPATH_LENGTH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4365)
			p.PathLengthExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICardinalityExpressionContext is an interface to support dynamic dispatch.
type ICardinalityExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CARDINALITY() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	CardinalityExpressionArgument() ICardinalityExpressionArgumentContext
	RIGHT_PAREN() antlr.TerminalNode
	SIZE() antlr.TerminalNode
	ListValueExpression() IListValueExpressionContext

	// IsCardinalityExpressionContext differentiates from other interfaces.
	IsCardinalityExpressionContext()
}

type CardinalityExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCardinalityExpressionContext() *CardinalityExpressionContext {
	var p = new(CardinalityExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_cardinalityExpression
	return p
}

func InitEmptyCardinalityExpressionContext(p *CardinalityExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_cardinalityExpression
}

func (*CardinalityExpressionContext) IsCardinalityExpressionContext() {}

func NewCardinalityExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CardinalityExpressionContext {
	var p = new(CardinalityExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_cardinalityExpression

	return p
}

func (s *CardinalityExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CardinalityExpressionContext) CARDINALITY() antlr.TerminalNode {
	return s.GetToken(GQLParserCARDINALITY, 0)
}

func (s *CardinalityExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *CardinalityExpressionContext) CardinalityExpressionArgument() ICardinalityExpressionArgumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICardinalityExpressionArgumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICardinalityExpressionArgumentContext)
}

func (s *CardinalityExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *CardinalityExpressionContext) SIZE() antlr.TerminalNode {
	return s.GetToken(GQLParserSIZE, 0)
}

func (s *CardinalityExpressionContext) ListValueExpression() IListValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListValueExpressionContext)
}

func (s *CardinalityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CardinalityExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CardinalityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCardinalityExpression(s)
	}
}

func (s *CardinalityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCardinalityExpression(s)
	}
}

func (p *GQLParser) CardinalityExpression() (localctx ICardinalityExpressionContext) {
	localctx = NewCardinalityExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 988, GQLParserRULE_cardinalityExpression)
	p.SetState(4378)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserCARDINALITY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4368)
			p.Match(GQLParserCARDINALITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4369)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4370)
			p.CardinalityExpressionArgument()
		}
		{
			p.SetState(4371)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserSIZE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4373)
			p.Match(GQLParserSIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4374)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4375)
			p.ListValueExpression()
		}
		{
			p.SetState(4376)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICardinalityExpressionArgumentContext is an interface to support dynamic dispatch.
type ICardinalityExpressionArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsCardinalityExpressionArgumentContext differentiates from other interfaces.
	IsCardinalityExpressionArgumentContext()
}

type CardinalityExpressionArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCardinalityExpressionArgumentContext() *CardinalityExpressionArgumentContext {
	var p = new(CardinalityExpressionArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_cardinalityExpressionArgument
	return p
}

func InitEmptyCardinalityExpressionArgumentContext(p *CardinalityExpressionArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_cardinalityExpressionArgument
}

func (*CardinalityExpressionArgumentContext) IsCardinalityExpressionArgumentContext() {}

func NewCardinalityExpressionArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CardinalityExpressionArgumentContext {
	var p = new(CardinalityExpressionArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_cardinalityExpressionArgument

	return p
}

func (s *CardinalityExpressionArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *CardinalityExpressionArgumentContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *CardinalityExpressionArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CardinalityExpressionArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CardinalityExpressionArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCardinalityExpressionArgument(s)
	}
}

func (s *CardinalityExpressionArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCardinalityExpressionArgument(s)
	}
}

func (p *GQLParser) CardinalityExpressionArgument() (localctx ICardinalityExpressionArgumentContext) {
	localctx = NewCardinalityExpressionArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 990, GQLParserRULE_cardinalityExpressionArgument)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4380)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharLengthExpressionContext is an interface to support dynamic dispatch.
type ICharLengthExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	CharacterStringValueExpression() ICharacterStringValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode
	CHAR_LENGTH() antlr.TerminalNode
	CHARACTER_LENGTH() antlr.TerminalNode

	// IsCharLengthExpressionContext differentiates from other interfaces.
	IsCharLengthExpressionContext()
}

type CharLengthExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharLengthExpressionContext() *CharLengthExpressionContext {
	var p = new(CharLengthExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_charLengthExpression
	return p
}

func InitEmptyCharLengthExpressionContext(p *CharLengthExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_charLengthExpression
}

func (*CharLengthExpressionContext) IsCharLengthExpressionContext() {}

func NewCharLengthExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharLengthExpressionContext {
	var p = new(CharLengthExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_charLengthExpression

	return p
}

func (s *CharLengthExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CharLengthExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *CharLengthExpressionContext) CharacterStringValueExpression() ICharacterStringValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacterStringValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacterStringValueExpressionContext)
}

func (s *CharLengthExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *CharLengthExpressionContext) CHAR_LENGTH() antlr.TerminalNode {
	return s.GetToken(GQLParserCHAR_LENGTH, 0)
}

func (s *CharLengthExpressionContext) CHARACTER_LENGTH() antlr.TerminalNode {
	return s.GetToken(GQLParserCHARACTER_LENGTH, 0)
}

func (s *CharLengthExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharLengthExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharLengthExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCharLengthExpression(s)
	}
}

func (s *CharLengthExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCharLengthExpression(s)
	}
}

func (p *GQLParser) CharLengthExpression() (localctx ICharLengthExpressionContext) {
	localctx = NewCharLengthExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 992, GQLParserRULE_charLengthExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4382)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserCHAR_LENGTH || _la == GQLParserCHARACTER_LENGTH) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4383)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4384)
		p.CharacterStringValueExpression()
	}
	{
		p.SetState(4385)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IByteLengthExpressionContext is an interface to support dynamic dispatch.
type IByteLengthExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	ByteStringValueExpression() IByteStringValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode
	BYTE_LENGTH() antlr.TerminalNode
	OCTET_LENGTH() antlr.TerminalNode

	// IsByteLengthExpressionContext differentiates from other interfaces.
	IsByteLengthExpressionContext()
}

type ByteLengthExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyByteLengthExpressionContext() *ByteLengthExpressionContext {
	var p = new(ByteLengthExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_byteLengthExpression
	return p
}

func InitEmptyByteLengthExpressionContext(p *ByteLengthExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_byteLengthExpression
}

func (*ByteLengthExpressionContext) IsByteLengthExpressionContext() {}

func NewByteLengthExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ByteLengthExpressionContext {
	var p = new(ByteLengthExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_byteLengthExpression

	return p
}

func (s *ByteLengthExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ByteLengthExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *ByteLengthExpressionContext) ByteStringValueExpression() IByteStringValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IByteStringValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IByteStringValueExpressionContext)
}

func (s *ByteLengthExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *ByteLengthExpressionContext) BYTE_LENGTH() antlr.TerminalNode {
	return s.GetToken(GQLParserBYTE_LENGTH, 0)
}

func (s *ByteLengthExpressionContext) OCTET_LENGTH() antlr.TerminalNode {
	return s.GetToken(GQLParserOCTET_LENGTH, 0)
}

func (s *ByteLengthExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ByteLengthExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ByteLengthExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterByteLengthExpression(s)
	}
}

func (s *ByteLengthExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitByteLengthExpression(s)
	}
}

func (p *GQLParser) ByteLengthExpression() (localctx IByteLengthExpressionContext) {
	localctx = NewByteLengthExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 994, GQLParserRULE_byteLengthExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4387)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserBYTE_LENGTH || _la == GQLParserOCTET_LENGTH) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4388)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4389)
		p.ByteStringValueExpression()
	}
	{
		p.SetState(4390)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathLengthExpressionContext is an interface to support dynamic dispatch.
type IPathLengthExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PATH_LENGTH() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	PathValueExpression() IPathValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsPathLengthExpressionContext differentiates from other interfaces.
	IsPathLengthExpressionContext()
}

type PathLengthExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathLengthExpressionContext() *PathLengthExpressionContext {
	var p = new(PathLengthExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathLengthExpression
	return p
}

func InitEmptyPathLengthExpressionContext(p *PathLengthExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathLengthExpression
}

func (*PathLengthExpressionContext) IsPathLengthExpressionContext() {}

func NewPathLengthExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathLengthExpressionContext {
	var p = new(PathLengthExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathLengthExpression

	return p
}

func (s *PathLengthExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PathLengthExpressionContext) PATH_LENGTH() antlr.TerminalNode {
	return s.GetToken(GQLParserPATH_LENGTH, 0)
}

func (s *PathLengthExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *PathLengthExpressionContext) PathValueExpression() IPathValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPathValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPathValueExpressionContext)
}

func (s *PathLengthExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *PathLengthExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathLengthExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathLengthExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathLengthExpression(s)
	}
}

func (s *PathLengthExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathLengthExpression(s)
	}
}

func (p *GQLParser) PathLengthExpression() (localctx IPathLengthExpressionContext) {
	localctx = NewPathLengthExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 996, GQLParserRULE_pathLengthExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4392)
		p.Match(GQLParserPATH_LENGTH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4393)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4394)
		p.PathValueExpression()
	}
	{
		p.SetState(4395)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbsoluteValueExpressionContext is an interface to support dynamic dispatch.
type IAbsoluteValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABS() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	ValueExpression() IValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsAbsoluteValueExpressionContext differentiates from other interfaces.
	IsAbsoluteValueExpressionContext()
}

type AbsoluteValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbsoluteValueExpressionContext() *AbsoluteValueExpressionContext {
	var p = new(AbsoluteValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_absoluteValueExpression
	return p
}

func InitEmptyAbsoluteValueExpressionContext(p *AbsoluteValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_absoluteValueExpression
}

func (*AbsoluteValueExpressionContext) IsAbsoluteValueExpressionContext() {}

func NewAbsoluteValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbsoluteValueExpressionContext {
	var p = new(AbsoluteValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_absoluteValueExpression

	return p
}

func (s *AbsoluteValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AbsoluteValueExpressionContext) ABS() antlr.TerminalNode {
	return s.GetToken(GQLParserABS, 0)
}

func (s *AbsoluteValueExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *AbsoluteValueExpressionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *AbsoluteValueExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *AbsoluteValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbsoluteValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbsoluteValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterAbsoluteValueExpression(s)
	}
}

func (s *AbsoluteValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitAbsoluteValueExpression(s)
	}
}

func (p *GQLParser) AbsoluteValueExpression() (localctx IAbsoluteValueExpressionContext) {
	localctx = NewAbsoluteValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 998, GQLParserRULE_absoluteValueExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4397)
		p.Match(GQLParserABS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4398)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4399)
		p.valueExpression(0)
	}
	{
		p.SetState(4400)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModulusExpressionContext is an interface to support dynamic dispatch.
type IModulusExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MOD() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	NumericValueExpressionDividend() INumericValueExpressionDividendContext
	COMMA() antlr.TerminalNode
	NumericValueExpressionDivisor() INumericValueExpressionDivisorContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsModulusExpressionContext differentiates from other interfaces.
	IsModulusExpressionContext()
}

type ModulusExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModulusExpressionContext() *ModulusExpressionContext {
	var p = new(ModulusExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_modulusExpression
	return p
}

func InitEmptyModulusExpressionContext(p *ModulusExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_modulusExpression
}

func (*ModulusExpressionContext) IsModulusExpressionContext() {}

func NewModulusExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModulusExpressionContext {
	var p = new(ModulusExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_modulusExpression

	return p
}

func (s *ModulusExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ModulusExpressionContext) MOD() antlr.TerminalNode {
	return s.GetToken(GQLParserMOD, 0)
}

func (s *ModulusExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *ModulusExpressionContext) NumericValueExpressionDividend() INumericValueExpressionDividendContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionDividendContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionDividendContext)
}

func (s *ModulusExpressionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *ModulusExpressionContext) NumericValueExpressionDivisor() INumericValueExpressionDivisorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionDivisorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionDivisorContext)
}

func (s *ModulusExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *ModulusExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModulusExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModulusExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterModulusExpression(s)
	}
}

func (s *ModulusExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitModulusExpression(s)
	}
}

func (p *GQLParser) ModulusExpression() (localctx IModulusExpressionContext) {
	localctx = NewModulusExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1000, GQLParserRULE_modulusExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4402)
		p.Match(GQLParserMOD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4403)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4404)
		p.NumericValueExpressionDividend()
	}
	{
		p.SetState(4405)
		p.Match(GQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4406)
		p.NumericValueExpressionDivisor()
	}
	{
		p.SetState(4407)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumericValueExpressionDividendContext is an interface to support dynamic dispatch.
type INumericValueExpressionDividendContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericValueExpression() INumericValueExpressionContext

	// IsNumericValueExpressionDividendContext differentiates from other interfaces.
	IsNumericValueExpressionDividendContext()
}

type NumericValueExpressionDividendContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericValueExpressionDividendContext() *NumericValueExpressionDividendContext {
	var p = new(NumericValueExpressionDividendContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numericValueExpressionDividend
	return p
}

func InitEmptyNumericValueExpressionDividendContext(p *NumericValueExpressionDividendContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numericValueExpressionDividend
}

func (*NumericValueExpressionDividendContext) IsNumericValueExpressionDividendContext() {}

func NewNumericValueExpressionDividendContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericValueExpressionDividendContext {
	var p = new(NumericValueExpressionDividendContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_numericValueExpressionDividend

	return p
}

func (s *NumericValueExpressionDividendContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericValueExpressionDividendContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *NumericValueExpressionDividendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericValueExpressionDividendContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericValueExpressionDividendContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNumericValueExpressionDividend(s)
	}
}

func (s *NumericValueExpressionDividendContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNumericValueExpressionDividend(s)
	}
}

func (p *GQLParser) NumericValueExpressionDividend() (localctx INumericValueExpressionDividendContext) {
	localctx = NewNumericValueExpressionDividendContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1002, GQLParserRULE_numericValueExpressionDividend)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4409)
		p.numericValueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumericValueExpressionDivisorContext is an interface to support dynamic dispatch.
type INumericValueExpressionDivisorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericValueExpression() INumericValueExpressionContext

	// IsNumericValueExpressionDivisorContext differentiates from other interfaces.
	IsNumericValueExpressionDivisorContext()
}

type NumericValueExpressionDivisorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericValueExpressionDivisorContext() *NumericValueExpressionDivisorContext {
	var p = new(NumericValueExpressionDivisorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numericValueExpressionDivisor
	return p
}

func InitEmptyNumericValueExpressionDivisorContext(p *NumericValueExpressionDivisorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numericValueExpressionDivisor
}

func (*NumericValueExpressionDivisorContext) IsNumericValueExpressionDivisorContext() {}

func NewNumericValueExpressionDivisorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericValueExpressionDivisorContext {
	var p = new(NumericValueExpressionDivisorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_numericValueExpressionDivisor

	return p
}

func (s *NumericValueExpressionDivisorContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericValueExpressionDivisorContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *NumericValueExpressionDivisorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericValueExpressionDivisorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericValueExpressionDivisorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNumericValueExpressionDivisor(s)
	}
}

func (s *NumericValueExpressionDivisorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNumericValueExpressionDivisor(s)
	}
}

func (p *GQLParser) NumericValueExpressionDivisor() (localctx INumericValueExpressionDivisorContext) {
	localctx = NewNumericValueExpressionDivisorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1004, GQLParserRULE_numericValueExpressionDivisor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4411)
		p.numericValueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrigonometricFunctionContext is an interface to support dynamic dispatch.
type ITrigonometricFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TrigonometricFunctionName() ITrigonometricFunctionNameContext
	LEFT_PAREN() antlr.TerminalNode
	NumericValueExpression() INumericValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsTrigonometricFunctionContext differentiates from other interfaces.
	IsTrigonometricFunctionContext()
}

type TrigonometricFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrigonometricFunctionContext() *TrigonometricFunctionContext {
	var p = new(TrigonometricFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trigonometricFunction
	return p
}

func InitEmptyTrigonometricFunctionContext(p *TrigonometricFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trigonometricFunction
}

func (*TrigonometricFunctionContext) IsTrigonometricFunctionContext() {}

func NewTrigonometricFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrigonometricFunctionContext {
	var p = new(TrigonometricFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_trigonometricFunction

	return p
}

func (s *TrigonometricFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *TrigonometricFunctionContext) TrigonometricFunctionName() ITrigonometricFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrigonometricFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrigonometricFunctionNameContext)
}

func (s *TrigonometricFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *TrigonometricFunctionContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *TrigonometricFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *TrigonometricFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrigonometricFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrigonometricFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTrigonometricFunction(s)
	}
}

func (s *TrigonometricFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTrigonometricFunction(s)
	}
}

func (p *GQLParser) TrigonometricFunction() (localctx ITrigonometricFunctionContext) {
	localctx = NewTrigonometricFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1006, GQLParserRULE_trigonometricFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4413)
		p.TrigonometricFunctionName()
	}
	{
		p.SetState(4414)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4415)
		p.numericValueExpression(0)
	}
	{
		p.SetState(4416)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrigonometricFunctionNameContext is an interface to support dynamic dispatch.
type ITrigonometricFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SIN() antlr.TerminalNode
	COS() antlr.TerminalNode
	TAN() antlr.TerminalNode
	COT() antlr.TerminalNode
	SINH() antlr.TerminalNode
	COSH() antlr.TerminalNode
	TANH() antlr.TerminalNode
	ASIN() antlr.TerminalNode
	ACOS() antlr.TerminalNode
	ATAN() antlr.TerminalNode
	DEGREES() antlr.TerminalNode
	RADIANS() antlr.TerminalNode

	// IsTrigonometricFunctionNameContext differentiates from other interfaces.
	IsTrigonometricFunctionNameContext()
}

type TrigonometricFunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrigonometricFunctionNameContext() *TrigonometricFunctionNameContext {
	var p = new(TrigonometricFunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trigonometricFunctionName
	return p
}

func InitEmptyTrigonometricFunctionNameContext(p *TrigonometricFunctionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trigonometricFunctionName
}

func (*TrigonometricFunctionNameContext) IsTrigonometricFunctionNameContext() {}

func NewTrigonometricFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrigonometricFunctionNameContext {
	var p = new(TrigonometricFunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_trigonometricFunctionName

	return p
}

func (s *TrigonometricFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TrigonometricFunctionNameContext) SIN() antlr.TerminalNode {
	return s.GetToken(GQLParserSIN, 0)
}

func (s *TrigonometricFunctionNameContext) COS() antlr.TerminalNode {
	return s.GetToken(GQLParserCOS, 0)
}

func (s *TrigonometricFunctionNameContext) TAN() antlr.TerminalNode {
	return s.GetToken(GQLParserTAN, 0)
}

func (s *TrigonometricFunctionNameContext) COT() antlr.TerminalNode {
	return s.GetToken(GQLParserCOT, 0)
}

func (s *TrigonometricFunctionNameContext) SINH() antlr.TerminalNode {
	return s.GetToken(GQLParserSINH, 0)
}

func (s *TrigonometricFunctionNameContext) COSH() antlr.TerminalNode {
	return s.GetToken(GQLParserCOSH, 0)
}

func (s *TrigonometricFunctionNameContext) TANH() antlr.TerminalNode {
	return s.GetToken(GQLParserTANH, 0)
}

func (s *TrigonometricFunctionNameContext) ASIN() antlr.TerminalNode {
	return s.GetToken(GQLParserASIN, 0)
}

func (s *TrigonometricFunctionNameContext) ACOS() antlr.TerminalNode {
	return s.GetToken(GQLParserACOS, 0)
}

func (s *TrigonometricFunctionNameContext) ATAN() antlr.TerminalNode {
	return s.GetToken(GQLParserATAN, 0)
}

func (s *TrigonometricFunctionNameContext) DEGREES() antlr.TerminalNode {
	return s.GetToken(GQLParserDEGREES, 0)
}

func (s *TrigonometricFunctionNameContext) RADIANS() antlr.TerminalNode {
	return s.GetToken(GQLParserRADIANS, 0)
}

func (s *TrigonometricFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrigonometricFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrigonometricFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTrigonometricFunctionName(s)
	}
}

func (s *TrigonometricFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTrigonometricFunctionName(s)
	}
}

func (p *GQLParser) TrigonometricFunctionName() (localctx ITrigonometricFunctionNameContext) {
	localctx = NewTrigonometricFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1008, GQLParserRULE_trigonometricFunctionName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4418)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&18016322654833153) != 0) || ((int64((_la-177)) & ^0x3f) == 0 && ((int64(1)<<(_la-177))&3222011905) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneralLogarithmFunctionContext is an interface to support dynamic dispatch.
type IGeneralLogarithmFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOG_KW() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	GeneralLogarithmBase() IGeneralLogarithmBaseContext
	COMMA() antlr.TerminalNode
	GeneralLogarithmArgument() IGeneralLogarithmArgumentContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsGeneralLogarithmFunctionContext differentiates from other interfaces.
	IsGeneralLogarithmFunctionContext()
}

type GeneralLogarithmFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralLogarithmFunctionContext() *GeneralLogarithmFunctionContext {
	var p = new(GeneralLogarithmFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalLogarithmFunction
	return p
}

func InitEmptyGeneralLogarithmFunctionContext(p *GeneralLogarithmFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalLogarithmFunction
}

func (*GeneralLogarithmFunctionContext) IsGeneralLogarithmFunctionContext() {}

func NewGeneralLogarithmFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralLogarithmFunctionContext {
	var p = new(GeneralLogarithmFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_generalLogarithmFunction

	return p
}

func (s *GeneralLogarithmFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralLogarithmFunctionContext) LOG_KW() antlr.TerminalNode {
	return s.GetToken(GQLParserLOG_KW, 0)
}

func (s *GeneralLogarithmFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *GeneralLogarithmFunctionContext) GeneralLogarithmBase() IGeneralLogarithmBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralLogarithmBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralLogarithmBaseContext)
}

func (s *GeneralLogarithmFunctionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *GeneralLogarithmFunctionContext) GeneralLogarithmArgument() IGeneralLogarithmArgumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralLogarithmArgumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralLogarithmArgumentContext)
}

func (s *GeneralLogarithmFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *GeneralLogarithmFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralLogarithmFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralLogarithmFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGeneralLogarithmFunction(s)
	}
}

func (s *GeneralLogarithmFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGeneralLogarithmFunction(s)
	}
}

func (p *GQLParser) GeneralLogarithmFunction() (localctx IGeneralLogarithmFunctionContext) {
	localctx = NewGeneralLogarithmFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1010, GQLParserRULE_generalLogarithmFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4420)
		p.Match(GQLParserLOG_KW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4421)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4422)
		p.GeneralLogarithmBase()
	}
	{
		p.SetState(4423)
		p.Match(GQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4424)
		p.GeneralLogarithmArgument()
	}
	{
		p.SetState(4425)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneralLogarithmBaseContext is an interface to support dynamic dispatch.
type IGeneralLogarithmBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericValueExpression() INumericValueExpressionContext

	// IsGeneralLogarithmBaseContext differentiates from other interfaces.
	IsGeneralLogarithmBaseContext()
}

type GeneralLogarithmBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralLogarithmBaseContext() *GeneralLogarithmBaseContext {
	var p = new(GeneralLogarithmBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalLogarithmBase
	return p
}

func InitEmptyGeneralLogarithmBaseContext(p *GeneralLogarithmBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalLogarithmBase
}

func (*GeneralLogarithmBaseContext) IsGeneralLogarithmBaseContext() {}

func NewGeneralLogarithmBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralLogarithmBaseContext {
	var p = new(GeneralLogarithmBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_generalLogarithmBase

	return p
}

func (s *GeneralLogarithmBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralLogarithmBaseContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *GeneralLogarithmBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralLogarithmBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralLogarithmBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGeneralLogarithmBase(s)
	}
}

func (s *GeneralLogarithmBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGeneralLogarithmBase(s)
	}
}

func (p *GQLParser) GeneralLogarithmBase() (localctx IGeneralLogarithmBaseContext) {
	localctx = NewGeneralLogarithmBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1012, GQLParserRULE_generalLogarithmBase)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4427)
		p.numericValueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneralLogarithmArgumentContext is an interface to support dynamic dispatch.
type IGeneralLogarithmArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericValueExpression() INumericValueExpressionContext

	// IsGeneralLogarithmArgumentContext differentiates from other interfaces.
	IsGeneralLogarithmArgumentContext()
}

type GeneralLogarithmArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralLogarithmArgumentContext() *GeneralLogarithmArgumentContext {
	var p = new(GeneralLogarithmArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalLogarithmArgument
	return p
}

func InitEmptyGeneralLogarithmArgumentContext(p *GeneralLogarithmArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalLogarithmArgument
}

func (*GeneralLogarithmArgumentContext) IsGeneralLogarithmArgumentContext() {}

func NewGeneralLogarithmArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralLogarithmArgumentContext {
	var p = new(GeneralLogarithmArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_generalLogarithmArgument

	return p
}

func (s *GeneralLogarithmArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralLogarithmArgumentContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *GeneralLogarithmArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralLogarithmArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralLogarithmArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGeneralLogarithmArgument(s)
	}
}

func (s *GeneralLogarithmArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGeneralLogarithmArgument(s)
	}
}

func (p *GQLParser) GeneralLogarithmArgument() (localctx IGeneralLogarithmArgumentContext) {
	localctx = NewGeneralLogarithmArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1014, GQLParserRULE_generalLogarithmArgument)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4429)
		p.numericValueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommonLogarithmContext is an interface to support dynamic dispatch.
type ICommonLogarithmContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOG10() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	NumericValueExpression() INumericValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsCommonLogarithmContext differentiates from other interfaces.
	IsCommonLogarithmContext()
}

type CommonLogarithmContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommonLogarithmContext() *CommonLogarithmContext {
	var p = new(CommonLogarithmContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_commonLogarithm
	return p
}

func InitEmptyCommonLogarithmContext(p *CommonLogarithmContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_commonLogarithm
}

func (*CommonLogarithmContext) IsCommonLogarithmContext() {}

func NewCommonLogarithmContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommonLogarithmContext {
	var p = new(CommonLogarithmContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_commonLogarithm

	return p
}

func (s *CommonLogarithmContext) GetParser() antlr.Parser { return s.parser }

func (s *CommonLogarithmContext) LOG10() antlr.TerminalNode {
	return s.GetToken(GQLParserLOG10, 0)
}

func (s *CommonLogarithmContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *CommonLogarithmContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *CommonLogarithmContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *CommonLogarithmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommonLogarithmContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommonLogarithmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCommonLogarithm(s)
	}
}

func (s *CommonLogarithmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCommonLogarithm(s)
	}
}

func (p *GQLParser) CommonLogarithm() (localctx ICommonLogarithmContext) {
	localctx = NewCommonLogarithmContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1016, GQLParserRULE_commonLogarithm)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4431)
		p.Match(GQLParserLOG10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4432)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4433)
		p.numericValueExpression(0)
	}
	{
		p.SetState(4434)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INaturalLogarithmContext is an interface to support dynamic dispatch.
type INaturalLogarithmContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LN() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	NumericValueExpression() INumericValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsNaturalLogarithmContext differentiates from other interfaces.
	IsNaturalLogarithmContext()
}

type NaturalLogarithmContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNaturalLogarithmContext() *NaturalLogarithmContext {
	var p = new(NaturalLogarithmContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_naturalLogarithm
	return p
}

func InitEmptyNaturalLogarithmContext(p *NaturalLogarithmContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_naturalLogarithm
}

func (*NaturalLogarithmContext) IsNaturalLogarithmContext() {}

func NewNaturalLogarithmContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NaturalLogarithmContext {
	var p = new(NaturalLogarithmContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_naturalLogarithm

	return p
}

func (s *NaturalLogarithmContext) GetParser() antlr.Parser { return s.parser }

func (s *NaturalLogarithmContext) LN() antlr.TerminalNode {
	return s.GetToken(GQLParserLN, 0)
}

func (s *NaturalLogarithmContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *NaturalLogarithmContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *NaturalLogarithmContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *NaturalLogarithmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NaturalLogarithmContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NaturalLogarithmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNaturalLogarithm(s)
	}
}

func (s *NaturalLogarithmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNaturalLogarithm(s)
	}
}

func (p *GQLParser) NaturalLogarithm() (localctx INaturalLogarithmContext) {
	localctx = NewNaturalLogarithmContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1018, GQLParserRULE_naturalLogarithm)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4436)
		p.Match(GQLParserLN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4437)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4438)
		p.numericValueExpression(0)
	}
	{
		p.SetState(4439)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExponentialFunctionContext is an interface to support dynamic dispatch.
type IExponentialFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXP() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	NumericValueExpression() INumericValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsExponentialFunctionContext differentiates from other interfaces.
	IsExponentialFunctionContext()
}

type ExponentialFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExponentialFunctionContext() *ExponentialFunctionContext {
	var p = new(ExponentialFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_exponentialFunction
	return p
}

func InitEmptyExponentialFunctionContext(p *ExponentialFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_exponentialFunction
}

func (*ExponentialFunctionContext) IsExponentialFunctionContext() {}

func NewExponentialFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExponentialFunctionContext {
	var p = new(ExponentialFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_exponentialFunction

	return p
}

func (s *ExponentialFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExponentialFunctionContext) EXP() antlr.TerminalNode {
	return s.GetToken(GQLParserEXP, 0)
}

func (s *ExponentialFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *ExponentialFunctionContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *ExponentialFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *ExponentialFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExponentialFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExponentialFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterExponentialFunction(s)
	}
}

func (s *ExponentialFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitExponentialFunction(s)
	}
}

func (p *GQLParser) ExponentialFunction() (localctx IExponentialFunctionContext) {
	localctx = NewExponentialFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1020, GQLParserRULE_exponentialFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4441)
		p.Match(GQLParserEXP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4442)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4443)
		p.numericValueExpression(0)
	}
	{
		p.SetState(4444)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPowerFunctionContext is an interface to support dynamic dispatch.
type IPowerFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	POWER() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	NumericValueExpressionBase() INumericValueExpressionBaseContext
	COMMA() antlr.TerminalNode
	NumericValueExpressionExponent() INumericValueExpressionExponentContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsPowerFunctionContext differentiates from other interfaces.
	IsPowerFunctionContext()
}

type PowerFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerFunctionContext() *PowerFunctionContext {
	var p = new(PowerFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_powerFunction
	return p
}

func InitEmptyPowerFunctionContext(p *PowerFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_powerFunction
}

func (*PowerFunctionContext) IsPowerFunctionContext() {}

func NewPowerFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerFunctionContext {
	var p = new(PowerFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_powerFunction

	return p
}

func (s *PowerFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerFunctionContext) POWER() antlr.TerminalNode {
	return s.GetToken(GQLParserPOWER, 0)
}

func (s *PowerFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *PowerFunctionContext) NumericValueExpressionBase() INumericValueExpressionBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionBaseContext)
}

func (s *PowerFunctionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *PowerFunctionContext) NumericValueExpressionExponent() INumericValueExpressionExponentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionExponentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionExponentContext)
}

func (s *PowerFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *PowerFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPowerFunction(s)
	}
}

func (s *PowerFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPowerFunction(s)
	}
}

func (p *GQLParser) PowerFunction() (localctx IPowerFunctionContext) {
	localctx = NewPowerFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1022, GQLParserRULE_powerFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4446)
		p.Match(GQLParserPOWER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4447)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4448)
		p.NumericValueExpressionBase()
	}
	{
		p.SetState(4449)
		p.Match(GQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4450)
		p.NumericValueExpressionExponent()
	}
	{
		p.SetState(4451)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumericValueExpressionBaseContext is an interface to support dynamic dispatch.
type INumericValueExpressionBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericValueExpression() INumericValueExpressionContext

	// IsNumericValueExpressionBaseContext differentiates from other interfaces.
	IsNumericValueExpressionBaseContext()
}

type NumericValueExpressionBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericValueExpressionBaseContext() *NumericValueExpressionBaseContext {
	var p = new(NumericValueExpressionBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numericValueExpressionBase
	return p
}

func InitEmptyNumericValueExpressionBaseContext(p *NumericValueExpressionBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numericValueExpressionBase
}

func (*NumericValueExpressionBaseContext) IsNumericValueExpressionBaseContext() {}

func NewNumericValueExpressionBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericValueExpressionBaseContext {
	var p = new(NumericValueExpressionBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_numericValueExpressionBase

	return p
}

func (s *NumericValueExpressionBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericValueExpressionBaseContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *NumericValueExpressionBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericValueExpressionBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericValueExpressionBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNumericValueExpressionBase(s)
	}
}

func (s *NumericValueExpressionBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNumericValueExpressionBase(s)
	}
}

func (p *GQLParser) NumericValueExpressionBase() (localctx INumericValueExpressionBaseContext) {
	localctx = NewNumericValueExpressionBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1024, GQLParserRULE_numericValueExpressionBase)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4453)
		p.numericValueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumericValueExpressionExponentContext is an interface to support dynamic dispatch.
type INumericValueExpressionExponentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericValueExpression() INumericValueExpressionContext

	// IsNumericValueExpressionExponentContext differentiates from other interfaces.
	IsNumericValueExpressionExponentContext()
}

type NumericValueExpressionExponentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericValueExpressionExponentContext() *NumericValueExpressionExponentContext {
	var p = new(NumericValueExpressionExponentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numericValueExpressionExponent
	return p
}

func InitEmptyNumericValueExpressionExponentContext(p *NumericValueExpressionExponentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_numericValueExpressionExponent
}

func (*NumericValueExpressionExponentContext) IsNumericValueExpressionExponentContext() {}

func NewNumericValueExpressionExponentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericValueExpressionExponentContext {
	var p = new(NumericValueExpressionExponentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_numericValueExpressionExponent

	return p
}

func (s *NumericValueExpressionExponentContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericValueExpressionExponentContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *NumericValueExpressionExponentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericValueExpressionExponentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericValueExpressionExponentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNumericValueExpressionExponent(s)
	}
}

func (s *NumericValueExpressionExponentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNumericValueExpressionExponent(s)
	}
}

func (p *GQLParser) NumericValueExpressionExponent() (localctx INumericValueExpressionExponentContext) {
	localctx = NewNumericValueExpressionExponentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1026, GQLParserRULE_numericValueExpressionExponent)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4455)
		p.numericValueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISquareRootContext is an interface to support dynamic dispatch.
type ISquareRootContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SQRT() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	NumericValueExpression() INumericValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsSquareRootContext differentiates from other interfaces.
	IsSquareRootContext()
}

type SquareRootContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySquareRootContext() *SquareRootContext {
	var p = new(SquareRootContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_squareRoot
	return p
}

func InitEmptySquareRootContext(p *SquareRootContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_squareRoot
}

func (*SquareRootContext) IsSquareRootContext() {}

func NewSquareRootContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SquareRootContext {
	var p = new(SquareRootContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_squareRoot

	return p
}

func (s *SquareRootContext) GetParser() antlr.Parser { return s.parser }

func (s *SquareRootContext) SQRT() antlr.TerminalNode {
	return s.GetToken(GQLParserSQRT, 0)
}

func (s *SquareRootContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *SquareRootContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *SquareRootContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *SquareRootContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SquareRootContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SquareRootContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSquareRoot(s)
	}
}

func (s *SquareRootContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSquareRoot(s)
	}
}

func (p *GQLParser) SquareRoot() (localctx ISquareRootContext) {
	localctx = NewSquareRootContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1028, GQLParserRULE_squareRoot)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4457)
		p.Match(GQLParserSQRT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4458)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4459)
		p.numericValueExpression(0)
	}
	{
		p.SetState(4460)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFloorFunctionContext is an interface to support dynamic dispatch.
type IFloorFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOOR() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	NumericValueExpression() INumericValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsFloorFunctionContext differentiates from other interfaces.
	IsFloorFunctionContext()
}

type FloorFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloorFunctionContext() *FloorFunctionContext {
	var p = new(FloorFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_floorFunction
	return p
}

func InitEmptyFloorFunctionContext(p *FloorFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_floorFunction
}

func (*FloorFunctionContext) IsFloorFunctionContext() {}

func NewFloorFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloorFunctionContext {
	var p = new(FloorFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_floorFunction

	return p
}

func (s *FloorFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *FloorFunctionContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(GQLParserFLOOR, 0)
}

func (s *FloorFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *FloorFunctionContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *FloorFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *FloorFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloorFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloorFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFloorFunction(s)
	}
}

func (s *FloorFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFloorFunction(s)
	}
}

func (p *GQLParser) FloorFunction() (localctx IFloorFunctionContext) {
	localctx = NewFloorFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1030, GQLParserRULE_floorFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4462)
		p.Match(GQLParserFLOOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4463)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4464)
		p.numericValueExpression(0)
	}
	{
		p.SetState(4465)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICeilingFunctionContext is an interface to support dynamic dispatch.
type ICeilingFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	NumericValueExpression() INumericValueExpressionContext
	RIGHT_PAREN() antlr.TerminalNode
	CEIL() antlr.TerminalNode
	CEILING() antlr.TerminalNode

	// IsCeilingFunctionContext differentiates from other interfaces.
	IsCeilingFunctionContext()
}

type CeilingFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCeilingFunctionContext() *CeilingFunctionContext {
	var p = new(CeilingFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_ceilingFunction
	return p
}

func InitEmptyCeilingFunctionContext(p *CeilingFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_ceilingFunction
}

func (*CeilingFunctionContext) IsCeilingFunctionContext() {}

func NewCeilingFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CeilingFunctionContext {
	var p = new(CeilingFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_ceilingFunction

	return p
}

func (s *CeilingFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CeilingFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *CeilingFunctionContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *CeilingFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *CeilingFunctionContext) CEIL() antlr.TerminalNode {
	return s.GetToken(GQLParserCEIL, 0)
}

func (s *CeilingFunctionContext) CEILING() antlr.TerminalNode {
	return s.GetToken(GQLParserCEILING, 0)
}

func (s *CeilingFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CeilingFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CeilingFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCeilingFunction(s)
	}
}

func (s *CeilingFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCeilingFunction(s)
	}
}

func (p *GQLParser) CeilingFunction() (localctx ICeilingFunctionContext) {
	localctx = NewCeilingFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1032, GQLParserRULE_ceilingFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4467)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserCEIL || _la == GQLParserCEILING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4468)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4469)
		p.numericValueExpression(0)
	}
	{
		p.SetState(4470)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharacterStringValueExpressionContext is an interface to support dynamic dispatch.
type ICharacterStringValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsCharacterStringValueExpressionContext differentiates from other interfaces.
	IsCharacterStringValueExpressionContext()
}

type CharacterStringValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacterStringValueExpressionContext() *CharacterStringValueExpressionContext {
	var p = new(CharacterStringValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_characterStringValueExpression
	return p
}

func InitEmptyCharacterStringValueExpressionContext(p *CharacterStringValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_characterStringValueExpression
}

func (*CharacterStringValueExpressionContext) IsCharacterStringValueExpressionContext() {}

func NewCharacterStringValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharacterStringValueExpressionContext {
	var p = new(CharacterStringValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_characterStringValueExpression

	return p
}

func (s *CharacterStringValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CharacterStringValueExpressionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *CharacterStringValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharacterStringValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharacterStringValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCharacterStringValueExpression(s)
	}
}

func (s *CharacterStringValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCharacterStringValueExpression(s)
	}
}

func (p *GQLParser) CharacterStringValueExpression() (localctx ICharacterStringValueExpressionContext) {
	localctx = NewCharacterStringValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1034, GQLParserRULE_characterStringValueExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4472)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IByteStringValueExpressionContext is an interface to support dynamic dispatch.
type IByteStringValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsByteStringValueExpressionContext differentiates from other interfaces.
	IsByteStringValueExpressionContext()
}

type ByteStringValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyByteStringValueExpressionContext() *ByteStringValueExpressionContext {
	var p = new(ByteStringValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_byteStringValueExpression
	return p
}

func InitEmptyByteStringValueExpressionContext(p *ByteStringValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_byteStringValueExpression
}

func (*ByteStringValueExpressionContext) IsByteStringValueExpressionContext() {}

func NewByteStringValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ByteStringValueExpressionContext {
	var p = new(ByteStringValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_byteStringValueExpression

	return p
}

func (s *ByteStringValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ByteStringValueExpressionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ByteStringValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ByteStringValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ByteStringValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterByteStringValueExpression(s)
	}
}

func (s *ByteStringValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitByteStringValueExpression(s)
	}
}

func (p *GQLParser) ByteStringValueExpression() (localctx IByteStringValueExpressionContext) {
	localctx = NewByteStringValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1036, GQLParserRULE_byteStringValueExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4474)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrimOperandsContext is an interface to support dynamic dispatch.
type ITrimOperandsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TrimCharacterOrByteStringSource() ITrimCharacterOrByteStringSourceContext
	FROM() antlr.TerminalNode
	TrimSpecification() ITrimSpecificationContext
	TrimCharacterOrByteString() ITrimCharacterOrByteStringContext

	// IsTrimOperandsContext differentiates from other interfaces.
	IsTrimOperandsContext()
}

type TrimOperandsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrimOperandsContext() *TrimOperandsContext {
	var p = new(TrimOperandsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trimOperands
	return p
}

func InitEmptyTrimOperandsContext(p *TrimOperandsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trimOperands
}

func (*TrimOperandsContext) IsTrimOperandsContext() {}

func NewTrimOperandsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrimOperandsContext {
	var p = new(TrimOperandsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_trimOperands

	return p
}

func (s *TrimOperandsContext) GetParser() antlr.Parser { return s.parser }

func (s *TrimOperandsContext) TrimCharacterOrByteStringSource() ITrimCharacterOrByteStringSourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrimCharacterOrByteStringSourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrimCharacterOrByteStringSourceContext)
}

func (s *TrimOperandsContext) FROM() antlr.TerminalNode {
	return s.GetToken(GQLParserFROM, 0)
}

func (s *TrimOperandsContext) TrimSpecification() ITrimSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrimSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrimSpecificationContext)
}

func (s *TrimOperandsContext) TrimCharacterOrByteString() ITrimCharacterOrByteStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrimCharacterOrByteStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrimCharacterOrByteStringContext)
}

func (s *TrimOperandsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimOperandsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrimOperandsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTrimOperands(s)
	}
}

func (s *TrimOperandsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTrimOperands(s)
	}
}

func (p *GQLParser) TrimOperands() (localctx ITrimOperandsContext) {
	localctx = NewTrimOperandsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1038, GQLParserRULE_trimOperands)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4483)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 487, p.GetParserRuleContext()) == 1 {
		p.SetState(4477)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserBOTH || _la == GQLParserLEADING || _la == GQLParserTRAILING {
			{
				p.SetState(4476)
				p.TrimSpecification()
			}

		}
		p.SetState(4480)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3684181877393982240) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&275712591755) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&-8011702113698201677) != 0) || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&26393111092643) != 0) || ((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&844424930131967) != 0) || ((int64((_la-371)) & ^0x3f) == 0 && ((int64(1)<<(_la-371))&151) != 0) {
			{
				p.SetState(4479)
				p.TrimCharacterOrByteString()
			}

		}
		{
			p.SetState(4482)
			p.Match(GQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4485)
		p.TrimCharacterOrByteStringSource()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrimCharacterOrByteStringSourceContext is an interface to support dynamic dispatch.
type ITrimCharacterOrByteStringSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsTrimCharacterOrByteStringSourceContext differentiates from other interfaces.
	IsTrimCharacterOrByteStringSourceContext()
}

type TrimCharacterOrByteStringSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrimCharacterOrByteStringSourceContext() *TrimCharacterOrByteStringSourceContext {
	var p = new(TrimCharacterOrByteStringSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trimCharacterOrByteStringSource
	return p
}

func InitEmptyTrimCharacterOrByteStringSourceContext(p *TrimCharacterOrByteStringSourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trimCharacterOrByteStringSource
}

func (*TrimCharacterOrByteStringSourceContext) IsTrimCharacterOrByteStringSourceContext() {}

func NewTrimCharacterOrByteStringSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrimCharacterOrByteStringSourceContext {
	var p = new(TrimCharacterOrByteStringSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_trimCharacterOrByteStringSource

	return p
}

func (s *TrimCharacterOrByteStringSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *TrimCharacterOrByteStringSourceContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *TrimCharacterOrByteStringSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimCharacterOrByteStringSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrimCharacterOrByteStringSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTrimCharacterOrByteStringSource(s)
	}
}

func (s *TrimCharacterOrByteStringSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTrimCharacterOrByteStringSource(s)
	}
}

func (p *GQLParser) TrimCharacterOrByteStringSource() (localctx ITrimCharacterOrByteStringSourceContext) {
	localctx = NewTrimCharacterOrByteStringSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1040, GQLParserRULE_trimCharacterOrByteStringSource)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4487)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrimSpecificationContext is an interface to support dynamic dispatch.
type ITrimSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEADING() antlr.TerminalNode
	TRAILING() antlr.TerminalNode
	BOTH() antlr.TerminalNode

	// IsTrimSpecificationContext differentiates from other interfaces.
	IsTrimSpecificationContext()
}

type TrimSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrimSpecificationContext() *TrimSpecificationContext {
	var p = new(TrimSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trimSpecification
	return p
}

func InitEmptyTrimSpecificationContext(p *TrimSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trimSpecification
}

func (*TrimSpecificationContext) IsTrimSpecificationContext() {}

func NewTrimSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrimSpecificationContext {
	var p = new(TrimSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_trimSpecification

	return p
}

func (s *TrimSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *TrimSpecificationContext) LEADING() antlr.TerminalNode {
	return s.GetToken(GQLParserLEADING, 0)
}

func (s *TrimSpecificationContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(GQLParserTRAILING, 0)
}

func (s *TrimSpecificationContext) BOTH() antlr.TerminalNode {
	return s.GetToken(GQLParserBOTH, 0)
}

func (s *TrimSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrimSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTrimSpecification(s)
	}
}

func (s *TrimSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTrimSpecification(s)
	}
}

func (p *GQLParser) TrimSpecification() (localctx ITrimSpecificationContext) {
	localctx = NewTrimSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1042, GQLParserRULE_trimSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4489)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserBOTH || _la == GQLParserLEADING || _la == GQLParserTRAILING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrimCharacterOrByteStringContext is an interface to support dynamic dispatch.
type ITrimCharacterOrByteStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsTrimCharacterOrByteStringContext differentiates from other interfaces.
	IsTrimCharacterOrByteStringContext()
}

type TrimCharacterOrByteStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrimCharacterOrByteStringContext() *TrimCharacterOrByteStringContext {
	var p = new(TrimCharacterOrByteStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trimCharacterOrByteString
	return p
}

func InitEmptyTrimCharacterOrByteStringContext(p *TrimCharacterOrByteStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_trimCharacterOrByteString
}

func (*TrimCharacterOrByteStringContext) IsTrimCharacterOrByteStringContext() {}

func NewTrimCharacterOrByteStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrimCharacterOrByteStringContext {
	var p = new(TrimCharacterOrByteStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_trimCharacterOrByteString

	return p
}

func (s *TrimCharacterOrByteStringContext) GetParser() antlr.Parser { return s.parser }

func (s *TrimCharacterOrByteStringContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *TrimCharacterOrByteStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimCharacterOrByteStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrimCharacterOrByteStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTrimCharacterOrByteString(s)
	}
}

func (s *TrimCharacterOrByteStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTrimCharacterOrByteString(s)
	}
}

func (p *GQLParser) TrimCharacterOrByteString() (localctx ITrimCharacterOrByteStringContext) {
	localctx = NewTrimCharacterOrByteStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1044, GQLParserRULE_trimCharacterOrByteString)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4491)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INormalFormContext is an interface to support dynamic dispatch.
type INormalFormContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NFC() antlr.TerminalNode
	NFD() antlr.TerminalNode
	NFKC() antlr.TerminalNode
	NFKD() antlr.TerminalNode

	// IsNormalFormContext differentiates from other interfaces.
	IsNormalFormContext()
}

type NormalFormContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalFormContext() *NormalFormContext {
	var p = new(NormalFormContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_normalForm
	return p
}

func InitEmptyNormalFormContext(p *NormalFormContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_normalForm
}

func (*NormalFormContext) IsNormalFormContext() {}

func NewNormalFormContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalFormContext {
	var p = new(NormalFormContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_normalForm

	return p
}

func (s *NormalFormContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalFormContext) NFC() antlr.TerminalNode {
	return s.GetToken(GQLParserNFC, 0)
}

func (s *NormalFormContext) NFD() antlr.TerminalNode {
	return s.GetToken(GQLParserNFD, 0)
}

func (s *NormalFormContext) NFKC() antlr.TerminalNode {
	return s.GetToken(GQLParserNFKC, 0)
}

func (s *NormalFormContext) NFKD() antlr.TerminalNode {
	return s.GetToken(GQLParserNFKD, 0)
}

func (s *NormalFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalFormContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNormalForm(s)
	}
}

func (s *NormalFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNormalForm(s)
	}
}

func (p *GQLParser) NormalForm() (localctx INormalFormContext) {
	localctx = NewNormalFormContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1046, GQLParserRULE_normalForm)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4493)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-299)) & ^0x3f) == 0 && ((int64(1)<<(_la-299))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLengthContext is an interface to support dynamic dispatch.
type IStringLengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumericValueExpression() INumericValueExpressionContext

	// IsStringLengthContext differentiates from other interfaces.
	IsStringLengthContext()
}

type StringLengthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLengthContext() *StringLengthContext {
	var p = new(StringLengthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_stringLength
	return p
}

func InitEmptyStringLengthContext(p *StringLengthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_stringLength
}

func (*StringLengthContext) IsStringLengthContext() {}

func NewStringLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLengthContext {
	var p = new(StringLengthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_stringLength

	return p
}

func (s *StringLengthContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLengthContext) NumericValueExpression() INumericValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericValueExpressionContext)
}

func (s *StringLengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterStringLength(s)
	}
}

func (s *StringLengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitStringLength(s)
	}
}

func (p *GQLParser) StringLength() (localctx IStringLengthContext) {
	localctx = NewStringLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1048, GQLParserRULE_stringLength)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4495)
		p.numericValueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatetimeValueExpressionContext is an interface to support dynamic dispatch.
type IDatetimeValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsDatetimeValueExpressionContext differentiates from other interfaces.
	IsDatetimeValueExpressionContext()
}

type DatetimeValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetimeValueExpressionContext() *DatetimeValueExpressionContext {
	var p = new(DatetimeValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeValueExpression
	return p
}

func InitEmptyDatetimeValueExpressionContext(p *DatetimeValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeValueExpression
}

func (*DatetimeValueExpressionContext) IsDatetimeValueExpressionContext() {}

func NewDatetimeValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatetimeValueExpressionContext {
	var p = new(DatetimeValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_datetimeValueExpression

	return p
}

func (s *DatetimeValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DatetimeValueExpressionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DatetimeValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatetimeValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatetimeValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDatetimeValueExpression(s)
	}
}

func (s *DatetimeValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDatetimeValueExpression(s)
	}
}

func (p *GQLParser) DatetimeValueExpression() (localctx IDatetimeValueExpressionContext) {
	localctx = NewDatetimeValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1050, GQLParserRULE_datetimeValueExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4497)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatetimeValueFunctionContext is an interface to support dynamic dispatch.
type IDatetimeValueFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DateFunction() IDateFunctionContext
	TimeFunction() ITimeFunctionContext
	DatetimeFunction() IDatetimeFunctionContext
	LocaltimeFunction() ILocaltimeFunctionContext
	LocaldatetimeFunction() ILocaldatetimeFunctionContext

	// IsDatetimeValueFunctionContext differentiates from other interfaces.
	IsDatetimeValueFunctionContext()
}

type DatetimeValueFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetimeValueFunctionContext() *DatetimeValueFunctionContext {
	var p = new(DatetimeValueFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeValueFunction
	return p
}

func InitEmptyDatetimeValueFunctionContext(p *DatetimeValueFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeValueFunction
}

func (*DatetimeValueFunctionContext) IsDatetimeValueFunctionContext() {}

func NewDatetimeValueFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatetimeValueFunctionContext {
	var p = new(DatetimeValueFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_datetimeValueFunction

	return p
}

func (s *DatetimeValueFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DatetimeValueFunctionContext) DateFunction() IDateFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateFunctionContext)
}

func (s *DatetimeValueFunctionContext) TimeFunction() ITimeFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeFunctionContext)
}

func (s *DatetimeValueFunctionContext) DatetimeFunction() IDatetimeFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeFunctionContext)
}

func (s *DatetimeValueFunctionContext) LocaltimeFunction() ILocaltimeFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocaltimeFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocaltimeFunctionContext)
}

func (s *DatetimeValueFunctionContext) LocaldatetimeFunction() ILocaldatetimeFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocaldatetimeFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocaldatetimeFunctionContext)
}

func (s *DatetimeValueFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatetimeValueFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatetimeValueFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDatetimeValueFunction(s)
	}
}

func (s *DatetimeValueFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDatetimeValueFunction(s)
	}
}

func (p *GQLParser) DatetimeValueFunction() (localctx IDatetimeValueFunctionContext) {
	localctx = NewDatetimeValueFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1052, GQLParserRULE_datetimeValueFunction)
	p.SetState(4504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserCURRENT_DATE, GQLParserDATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4499)
			p.DateFunction()
		}

	case GQLParserCURRENT_TIME, GQLParserZONED_TIME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4500)
			p.TimeFunction()
		}

	case GQLParserCURRENT_TIMESTAMP, GQLParserZONED_DATETIME:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4501)
			p.DatetimeFunction()
		}

	case GQLParserLOCAL_TIME:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4502)
			p.LocaltimeFunction()
		}

	case GQLParserLOCAL_DATETIME, GQLParserLOCAL_TIMESTAMP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4503)
			p.LocaldatetimeFunction()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateFunctionContext is an interface to support dynamic dispatch.
type IDateFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT_DATE() antlr.TerminalNode
	DATE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	DateFunctionParameters() IDateFunctionParametersContext

	// IsDateFunctionContext differentiates from other interfaces.
	IsDateFunctionContext()
}

type DateFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateFunctionContext() *DateFunctionContext {
	var p = new(DateFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dateFunction
	return p
}

func InitEmptyDateFunctionContext(p *DateFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dateFunction
}

func (*DateFunctionContext) IsDateFunctionContext() {}

func NewDateFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateFunctionContext {
	var p = new(DateFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_dateFunction

	return p
}

func (s *DateFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DateFunctionContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(GQLParserCURRENT_DATE, 0)
}

func (s *DateFunctionContext) DATE() antlr.TerminalNode {
	return s.GetToken(GQLParserDATE, 0)
}

func (s *DateFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *DateFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *DateFunctionContext) DateFunctionParameters() IDateFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateFunctionParametersContext)
}

func (s *DateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDateFunction(s)
	}
}

func (s *DateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDateFunction(s)
	}
}

func (p *GQLParser) DateFunction() (localctx IDateFunctionContext) {
	localctx = NewDateFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1054, GQLParserRULE_dateFunction)
	var _la int

	p.SetState(4513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserCURRENT_DATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4506)
			p.Match(GQLParserCURRENT_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserDATE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4507)
			p.Match(GQLParserDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4508)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserRECORD || _la == GQLParserLEFT_BRACE {
			{
				p.SetState(4509)
				p.DateFunctionParameters()
			}

		}
		{
			p.SetState(4512)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeFunctionContext is an interface to support dynamic dispatch.
type ITimeFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT_TIME() antlr.TerminalNode
	ZONED_TIME() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	TimeFunctionParameters() ITimeFunctionParametersContext

	// IsTimeFunctionContext differentiates from other interfaces.
	IsTimeFunctionContext()
}

type TimeFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeFunctionContext() *TimeFunctionContext {
	var p = new(TimeFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_timeFunction
	return p
}

func InitEmptyTimeFunctionContext(p *TimeFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_timeFunction
}

func (*TimeFunctionContext) IsTimeFunctionContext() {}

func NewTimeFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeFunctionContext {
	var p = new(TimeFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_timeFunction

	return p
}

func (s *TimeFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeFunctionContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(GQLParserCURRENT_TIME, 0)
}

func (s *TimeFunctionContext) ZONED_TIME() antlr.TerminalNode {
	return s.GetToken(GQLParserZONED_TIME, 0)
}

func (s *TimeFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *TimeFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *TimeFunctionContext) TimeFunctionParameters() ITimeFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeFunctionParametersContext)
}

func (s *TimeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTimeFunction(s)
	}
}

func (s *TimeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTimeFunction(s)
	}
}

func (p *GQLParser) TimeFunction() (localctx ITimeFunctionContext) {
	localctx = NewTimeFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1056, GQLParserRULE_timeFunction)
	var _la int

	p.SetState(4522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserCURRENT_TIME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4515)
			p.Match(GQLParserCURRENT_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserZONED_TIME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4516)
			p.Match(GQLParserZONED_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4517)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserRECORD || _la == GQLParserLEFT_BRACE {
			{
				p.SetState(4518)
				p.TimeFunctionParameters()
			}

		}
		{
			p.SetState(4521)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocaltimeFunctionContext is an interface to support dynamic dispatch.
type ILocaltimeFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL_TIME() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	TimeFunctionParameters() ITimeFunctionParametersContext

	// IsLocaltimeFunctionContext differentiates from other interfaces.
	IsLocaltimeFunctionContext()
}

type LocaltimeFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocaltimeFunctionContext() *LocaltimeFunctionContext {
	var p = new(LocaltimeFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_localtimeFunction
	return p
}

func InitEmptyLocaltimeFunctionContext(p *LocaltimeFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_localtimeFunction
}

func (*LocaltimeFunctionContext) IsLocaltimeFunctionContext() {}

func NewLocaltimeFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocaltimeFunctionContext {
	var p = new(LocaltimeFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_localtimeFunction

	return p
}

func (s *LocaltimeFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *LocaltimeFunctionContext) LOCAL_TIME() antlr.TerminalNode {
	return s.GetToken(GQLParserLOCAL_TIME, 0)
}

func (s *LocaltimeFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *LocaltimeFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *LocaltimeFunctionContext) TimeFunctionParameters() ITimeFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeFunctionParametersContext)
}

func (s *LocaltimeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocaltimeFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocaltimeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLocaltimeFunction(s)
	}
}

func (s *LocaltimeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLocaltimeFunction(s)
	}
}

func (p *GQLParser) LocaltimeFunction() (localctx ILocaltimeFunctionContext) {
	localctx = NewLocaltimeFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1058, GQLParserRULE_localtimeFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4524)
		p.Match(GQLParserLOCAL_TIME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4530)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 494, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4525)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4527)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserRECORD || _la == GQLParserLEFT_BRACE {
			{
				p.SetState(4526)
				p.TimeFunctionParameters()
			}

		}
		{
			p.SetState(4529)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatetimeFunctionContext is an interface to support dynamic dispatch.
type IDatetimeFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT_TIMESTAMP() antlr.TerminalNode
	ZONED_DATETIME() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	DatetimeFunctionParameters() IDatetimeFunctionParametersContext

	// IsDatetimeFunctionContext differentiates from other interfaces.
	IsDatetimeFunctionContext()
}

type DatetimeFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetimeFunctionContext() *DatetimeFunctionContext {
	var p = new(DatetimeFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeFunction
	return p
}

func InitEmptyDatetimeFunctionContext(p *DatetimeFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeFunction
}

func (*DatetimeFunctionContext) IsDatetimeFunctionContext() {}

func NewDatetimeFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatetimeFunctionContext {
	var p = new(DatetimeFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_datetimeFunction

	return p
}

func (s *DatetimeFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DatetimeFunctionContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(GQLParserCURRENT_TIMESTAMP, 0)
}

func (s *DatetimeFunctionContext) ZONED_DATETIME() antlr.TerminalNode {
	return s.GetToken(GQLParserZONED_DATETIME, 0)
}

func (s *DatetimeFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *DatetimeFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *DatetimeFunctionContext) DatetimeFunctionParameters() IDatetimeFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeFunctionParametersContext)
}

func (s *DatetimeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatetimeFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatetimeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDatetimeFunction(s)
	}
}

func (s *DatetimeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDatetimeFunction(s)
	}
}

func (p *GQLParser) DatetimeFunction() (localctx IDatetimeFunctionContext) {
	localctx = NewDatetimeFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1060, GQLParserRULE_datetimeFunction)
	var _la int

	p.SetState(4539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserCURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4532)
			p.Match(GQLParserCURRENT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserZONED_DATETIME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4533)
			p.Match(GQLParserZONED_DATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4534)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4536)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserRECORD || _la == GQLParserLEFT_BRACE {
			{
				p.SetState(4535)
				p.DatetimeFunctionParameters()
			}

		}
		{
			p.SetState(4538)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocaldatetimeFunctionContext is an interface to support dynamic dispatch.
type ILocaldatetimeFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL_TIMESTAMP() antlr.TerminalNode
	LOCAL_DATETIME() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	DatetimeFunctionParameters() IDatetimeFunctionParametersContext

	// IsLocaldatetimeFunctionContext differentiates from other interfaces.
	IsLocaldatetimeFunctionContext()
}

type LocaldatetimeFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocaldatetimeFunctionContext() *LocaldatetimeFunctionContext {
	var p = new(LocaldatetimeFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_localdatetimeFunction
	return p
}

func InitEmptyLocaldatetimeFunctionContext(p *LocaldatetimeFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_localdatetimeFunction
}

func (*LocaldatetimeFunctionContext) IsLocaldatetimeFunctionContext() {}

func NewLocaldatetimeFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocaldatetimeFunctionContext {
	var p = new(LocaldatetimeFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_localdatetimeFunction

	return p
}

func (s *LocaldatetimeFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *LocaldatetimeFunctionContext) LOCAL_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(GQLParserLOCAL_TIMESTAMP, 0)
}

func (s *LocaldatetimeFunctionContext) LOCAL_DATETIME() antlr.TerminalNode {
	return s.GetToken(GQLParserLOCAL_DATETIME, 0)
}

func (s *LocaldatetimeFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *LocaldatetimeFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *LocaldatetimeFunctionContext) DatetimeFunctionParameters() IDatetimeFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeFunctionParametersContext)
}

func (s *LocaldatetimeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocaldatetimeFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocaldatetimeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLocaldatetimeFunction(s)
	}
}

func (s *LocaldatetimeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLocaldatetimeFunction(s)
	}
}

func (p *GQLParser) LocaldatetimeFunction() (localctx ILocaldatetimeFunctionContext) {
	localctx = NewLocaldatetimeFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1062, GQLParserRULE_localdatetimeFunction)
	var _la int

	p.SetState(4548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserLOCAL_TIMESTAMP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4541)
			p.Match(GQLParserLOCAL_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserLOCAL_DATETIME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4542)
			p.Match(GQLParserLOCAL_DATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4543)
			p.Match(GQLParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4545)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserRECORD || _la == GQLParserLEFT_BRACE {
			{
				p.SetState(4544)
				p.DatetimeFunctionParameters()
			}

		}
		{
			p.SetState(4547)
			p.Match(GQLParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateFunctionParametersContext is an interface to support dynamic dispatch.
type IDateFunctionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DateString() IDateStringContext
	RecordConstructor() IRecordConstructorContext

	// IsDateFunctionParametersContext differentiates from other interfaces.
	IsDateFunctionParametersContext()
}

type DateFunctionParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateFunctionParametersContext() *DateFunctionParametersContext {
	var p = new(DateFunctionParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dateFunctionParameters
	return p
}

func InitEmptyDateFunctionParametersContext(p *DateFunctionParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dateFunctionParameters
}

func (*DateFunctionParametersContext) IsDateFunctionParametersContext() {}

func NewDateFunctionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateFunctionParametersContext {
	var p = new(DateFunctionParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_dateFunctionParameters

	return p
}

func (s *DateFunctionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *DateFunctionParametersContext) DateString() IDateStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateStringContext)
}

func (s *DateFunctionParametersContext) RecordConstructor() IRecordConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordConstructorContext)
}

func (s *DateFunctionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateFunctionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateFunctionParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDateFunctionParameters(s)
	}
}

func (s *DateFunctionParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDateFunctionParameters(s)
	}
}

func (p *GQLParser) DateFunctionParameters() (localctx IDateFunctionParametersContext) {
	localctx = NewDateFunctionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1064, GQLParserRULE_dateFunctionParameters)
	p.SetState(4552)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE, GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4550)
			p.DateString()
		}

	case GQLParserRECORD, GQLParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4551)
			p.RecordConstructor()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeFunctionParametersContext is an interface to support dynamic dispatch.
type ITimeFunctionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TimeString() ITimeStringContext
	RecordConstructor() IRecordConstructorContext

	// IsTimeFunctionParametersContext differentiates from other interfaces.
	IsTimeFunctionParametersContext()
}

type TimeFunctionParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeFunctionParametersContext() *TimeFunctionParametersContext {
	var p = new(TimeFunctionParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_timeFunctionParameters
	return p
}

func InitEmptyTimeFunctionParametersContext(p *TimeFunctionParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_timeFunctionParameters
}

func (*TimeFunctionParametersContext) IsTimeFunctionParametersContext() {}

func NewTimeFunctionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeFunctionParametersContext {
	var p = new(TimeFunctionParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_timeFunctionParameters

	return p
}

func (s *TimeFunctionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeFunctionParametersContext) TimeString() ITimeStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeStringContext)
}

func (s *TimeFunctionParametersContext) RecordConstructor() IRecordConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordConstructorContext)
}

func (s *TimeFunctionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeFunctionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeFunctionParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTimeFunctionParameters(s)
	}
}

func (s *TimeFunctionParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTimeFunctionParameters(s)
	}
}

func (p *GQLParser) TimeFunctionParameters() (localctx ITimeFunctionParametersContext) {
	localctx = NewTimeFunctionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1066, GQLParserRULE_timeFunctionParameters)
	p.SetState(4556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE, GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4554)
			p.TimeString()
		}

	case GQLParserRECORD, GQLParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4555)
			p.RecordConstructor()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatetimeFunctionParametersContext is an interface to support dynamic dispatch.
type IDatetimeFunctionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DatetimeString() IDatetimeStringContext
	RecordConstructor() IRecordConstructorContext

	// IsDatetimeFunctionParametersContext differentiates from other interfaces.
	IsDatetimeFunctionParametersContext()
}

type DatetimeFunctionParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetimeFunctionParametersContext() *DatetimeFunctionParametersContext {
	var p = new(DatetimeFunctionParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeFunctionParameters
	return p
}

func InitEmptyDatetimeFunctionParametersContext(p *DatetimeFunctionParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeFunctionParameters
}

func (*DatetimeFunctionParametersContext) IsDatetimeFunctionParametersContext() {}

func NewDatetimeFunctionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatetimeFunctionParametersContext {
	var p = new(DatetimeFunctionParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_datetimeFunctionParameters

	return p
}

func (s *DatetimeFunctionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *DatetimeFunctionParametersContext) DatetimeString() IDatetimeStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeStringContext)
}

func (s *DatetimeFunctionParametersContext) RecordConstructor() IRecordConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordConstructorContext)
}

func (s *DatetimeFunctionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatetimeFunctionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatetimeFunctionParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDatetimeFunctionParameters(s)
	}
}

func (s *DatetimeFunctionParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDatetimeFunctionParameters(s)
	}
}

func (p *GQLParser) DatetimeFunctionParameters() (localctx IDatetimeFunctionParametersContext) {
	localctx = NewDatetimeFunctionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1068, GQLParserRULE_datetimeFunctionParameters)
	p.SetState(4560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE, GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4558)
			p.DatetimeString()
		}

	case GQLParserRECORD, GQLParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4559)
			p.RecordConstructor()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDurationValueExpressionContext is an interface to support dynamic dispatch.
type IDurationValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueExpression() IValueExpressionContext

	// IsDurationValueExpressionContext differentiates from other interfaces.
	IsDurationValueExpressionContext()
}

type DurationValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDurationValueExpressionContext() *DurationValueExpressionContext {
	var p = new(DurationValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_durationValueExpression
	return p
}

func InitEmptyDurationValueExpressionContext(p *DurationValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_durationValueExpression
}

func (*DurationValueExpressionContext) IsDurationValueExpressionContext() {}

func NewDurationValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DurationValueExpressionContext {
	var p = new(DurationValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_durationValueExpression

	return p
}

func (s *DurationValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DurationValueExpressionContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DurationValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurationValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DurationValueExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDurationValueExpression(s)
	}
}

func (s *DurationValueExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDurationValueExpression(s)
	}
}

func (p *GQLParser) DurationValueExpression() (localctx IDurationValueExpressionContext) {
	localctx = NewDurationValueExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1070, GQLParserRULE_durationValueExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4562)
		p.valueExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatetimeSubtractionContext is an interface to support dynamic dispatch.
type IDatetimeSubtractionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DURATION_BETWEEN() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	DatetimeSubtractionParameters() IDatetimeSubtractionParametersContext
	RIGHT_PAREN() antlr.TerminalNode
	TemporalDurationQualifier() ITemporalDurationQualifierContext

	// IsDatetimeSubtractionContext differentiates from other interfaces.
	IsDatetimeSubtractionContext()
}

type DatetimeSubtractionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetimeSubtractionContext() *DatetimeSubtractionContext {
	var p = new(DatetimeSubtractionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeSubtraction
	return p
}

func InitEmptyDatetimeSubtractionContext(p *DatetimeSubtractionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeSubtraction
}

func (*DatetimeSubtractionContext) IsDatetimeSubtractionContext() {}

func NewDatetimeSubtractionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatetimeSubtractionContext {
	var p = new(DatetimeSubtractionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_datetimeSubtraction

	return p
}

func (s *DatetimeSubtractionContext) GetParser() antlr.Parser { return s.parser }

func (s *DatetimeSubtractionContext) DURATION_BETWEEN() antlr.TerminalNode {
	return s.GetToken(GQLParserDURATION_BETWEEN, 0)
}

func (s *DatetimeSubtractionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *DatetimeSubtractionContext) DatetimeSubtractionParameters() IDatetimeSubtractionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeSubtractionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeSubtractionParametersContext)
}

func (s *DatetimeSubtractionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *DatetimeSubtractionContext) TemporalDurationQualifier() ITemporalDurationQualifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemporalDurationQualifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemporalDurationQualifierContext)
}

func (s *DatetimeSubtractionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatetimeSubtractionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatetimeSubtractionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDatetimeSubtraction(s)
	}
}

func (s *DatetimeSubtractionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDatetimeSubtraction(s)
	}
}

func (p *GQLParser) DatetimeSubtraction() (localctx IDatetimeSubtractionContext) {
	localctx = NewDatetimeSubtractionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1072, GQLParserRULE_datetimeSubtraction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4564)
		p.Match(GQLParserDURATION_BETWEEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4565)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4566)
		p.DatetimeSubtractionParameters()
	}
	{
		p.SetState(4567)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4569)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 502, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4568)
			p.TemporalDurationQualifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatetimeSubtractionParametersContext is an interface to support dynamic dispatch.
type IDatetimeSubtractionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DatetimeValueExpression1() IDatetimeValueExpression1Context
	COMMA() antlr.TerminalNode
	DatetimeValueExpression2() IDatetimeValueExpression2Context

	// IsDatetimeSubtractionParametersContext differentiates from other interfaces.
	IsDatetimeSubtractionParametersContext()
}

type DatetimeSubtractionParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetimeSubtractionParametersContext() *DatetimeSubtractionParametersContext {
	var p = new(DatetimeSubtractionParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeSubtractionParameters
	return p
}

func InitEmptyDatetimeSubtractionParametersContext(p *DatetimeSubtractionParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeSubtractionParameters
}

func (*DatetimeSubtractionParametersContext) IsDatetimeSubtractionParametersContext() {}

func NewDatetimeSubtractionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatetimeSubtractionParametersContext {
	var p = new(DatetimeSubtractionParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_datetimeSubtractionParameters

	return p
}

func (s *DatetimeSubtractionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *DatetimeSubtractionParametersContext) DatetimeValueExpression1() IDatetimeValueExpression1Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeValueExpression1Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeValueExpression1Context)
}

func (s *DatetimeSubtractionParametersContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GQLParserCOMMA, 0)
}

func (s *DatetimeSubtractionParametersContext) DatetimeValueExpression2() IDatetimeValueExpression2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeValueExpression2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeValueExpression2Context)
}

func (s *DatetimeSubtractionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatetimeSubtractionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatetimeSubtractionParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDatetimeSubtractionParameters(s)
	}
}

func (s *DatetimeSubtractionParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDatetimeSubtractionParameters(s)
	}
}

func (p *GQLParser) DatetimeSubtractionParameters() (localctx IDatetimeSubtractionParametersContext) {
	localctx = NewDatetimeSubtractionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1074, GQLParserRULE_datetimeSubtractionParameters)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4571)
		p.DatetimeValueExpression1()
	}
	{
		p.SetState(4572)
		p.Match(GQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4573)
		p.DatetimeValueExpression2()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatetimeValueExpression1Context is an interface to support dynamic dispatch.
type IDatetimeValueExpression1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DatetimeValueExpression() IDatetimeValueExpressionContext

	// IsDatetimeValueExpression1Context differentiates from other interfaces.
	IsDatetimeValueExpression1Context()
}

type DatetimeValueExpression1Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetimeValueExpression1Context() *DatetimeValueExpression1Context {
	var p = new(DatetimeValueExpression1Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeValueExpression1
	return p
}

func InitEmptyDatetimeValueExpression1Context(p *DatetimeValueExpression1Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeValueExpression1
}

func (*DatetimeValueExpression1Context) IsDatetimeValueExpression1Context() {}

func NewDatetimeValueExpression1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatetimeValueExpression1Context {
	var p = new(DatetimeValueExpression1Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_datetimeValueExpression1

	return p
}

func (s *DatetimeValueExpression1Context) GetParser() antlr.Parser { return s.parser }

func (s *DatetimeValueExpression1Context) DatetimeValueExpression() IDatetimeValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeValueExpressionContext)
}

func (s *DatetimeValueExpression1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatetimeValueExpression1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatetimeValueExpression1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDatetimeValueExpression1(s)
	}
}

func (s *DatetimeValueExpression1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDatetimeValueExpression1(s)
	}
}

func (p *GQLParser) DatetimeValueExpression1() (localctx IDatetimeValueExpression1Context) {
	localctx = NewDatetimeValueExpression1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1076, GQLParserRULE_datetimeValueExpression1)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4575)
		p.DatetimeValueExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatetimeValueExpression2Context is an interface to support dynamic dispatch.
type IDatetimeValueExpression2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DatetimeValueExpression() IDatetimeValueExpressionContext

	// IsDatetimeValueExpression2Context differentiates from other interfaces.
	IsDatetimeValueExpression2Context()
}

type DatetimeValueExpression2Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetimeValueExpression2Context() *DatetimeValueExpression2Context {
	var p = new(DatetimeValueExpression2Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeValueExpression2
	return p
}

func InitEmptyDatetimeValueExpression2Context(p *DatetimeValueExpression2Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeValueExpression2
}

func (*DatetimeValueExpression2Context) IsDatetimeValueExpression2Context() {}

func NewDatetimeValueExpression2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatetimeValueExpression2Context {
	var p = new(DatetimeValueExpression2Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_datetimeValueExpression2

	return p
}

func (s *DatetimeValueExpression2Context) GetParser() antlr.Parser { return s.parser }

func (s *DatetimeValueExpression2Context) DatetimeValueExpression() IDatetimeValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeValueExpressionContext)
}

func (s *DatetimeValueExpression2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatetimeValueExpression2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatetimeValueExpression2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDatetimeValueExpression2(s)
	}
}

func (s *DatetimeValueExpression2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDatetimeValueExpression2(s)
	}
}

func (p *GQLParser) DatetimeValueExpression2() (localctx IDatetimeValueExpression2Context) {
	localctx = NewDatetimeValueExpression2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1078, GQLParserRULE_datetimeValueExpression2)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4577)
		p.DatetimeValueExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDurationValueFunctionContext is an interface to support dynamic dispatch.
type IDurationValueFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DurationFunction() IDurationFunctionContext
	AbsoluteValueExpression() IAbsoluteValueExpressionContext

	// IsDurationValueFunctionContext differentiates from other interfaces.
	IsDurationValueFunctionContext()
}

type DurationValueFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDurationValueFunctionContext() *DurationValueFunctionContext {
	var p = new(DurationValueFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_durationValueFunction
	return p
}

func InitEmptyDurationValueFunctionContext(p *DurationValueFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_durationValueFunction
}

func (*DurationValueFunctionContext) IsDurationValueFunctionContext() {}

func NewDurationValueFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DurationValueFunctionContext {
	var p = new(DurationValueFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_durationValueFunction

	return p
}

func (s *DurationValueFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DurationValueFunctionContext) DurationFunction() IDurationFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDurationFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDurationFunctionContext)
}

func (s *DurationValueFunctionContext) AbsoluteValueExpression() IAbsoluteValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbsoluteValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbsoluteValueExpressionContext)
}

func (s *DurationValueFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurationValueFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DurationValueFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDurationValueFunction(s)
	}
}

func (s *DurationValueFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDurationValueFunction(s)
	}
}

func (p *GQLParser) DurationValueFunction() (localctx IDurationValueFunctionContext) {
	localctx = NewDurationValueFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1080, GQLParserRULE_durationValueFunction)
	p.SetState(4581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserDURATION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4579)
			p.DurationFunction()
		}

	case GQLParserABS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4580)
			p.AbsoluteValueExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDurationFunctionContext is an interface to support dynamic dispatch.
type IDurationFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DURATION() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	DurationFunctionParameters() IDurationFunctionParametersContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsDurationFunctionContext differentiates from other interfaces.
	IsDurationFunctionContext()
}

type DurationFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDurationFunctionContext() *DurationFunctionContext {
	var p = new(DurationFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_durationFunction
	return p
}

func InitEmptyDurationFunctionContext(p *DurationFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_durationFunction
}

func (*DurationFunctionContext) IsDurationFunctionContext() {}

func NewDurationFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DurationFunctionContext {
	var p = new(DurationFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_durationFunction

	return p
}

func (s *DurationFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DurationFunctionContext) DURATION() antlr.TerminalNode {
	return s.GetToken(GQLParserDURATION, 0)
}

func (s *DurationFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserLEFT_PAREN, 0)
}

func (s *DurationFunctionContext) DurationFunctionParameters() IDurationFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDurationFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDurationFunctionParametersContext)
}

func (s *DurationFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(GQLParserRIGHT_PAREN, 0)
}

func (s *DurationFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurationFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DurationFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDurationFunction(s)
	}
}

func (s *DurationFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDurationFunction(s)
	}
}

func (p *GQLParser) DurationFunction() (localctx IDurationFunctionContext) {
	localctx = NewDurationFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1082, GQLParserRULE_durationFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4583)
		p.Match(GQLParserDURATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4584)
		p.Match(GQLParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4585)
		p.DurationFunctionParameters()
	}
	{
		p.SetState(4586)
		p.Match(GQLParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDurationFunctionParametersContext is an interface to support dynamic dispatch.
type IDurationFunctionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DurationString() IDurationStringContext
	RecordConstructor() IRecordConstructorContext

	// IsDurationFunctionParametersContext differentiates from other interfaces.
	IsDurationFunctionParametersContext()
}

type DurationFunctionParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDurationFunctionParametersContext() *DurationFunctionParametersContext {
	var p = new(DurationFunctionParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_durationFunctionParameters
	return p
}

func InitEmptyDurationFunctionParametersContext(p *DurationFunctionParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_durationFunctionParameters
}

func (*DurationFunctionParametersContext) IsDurationFunctionParametersContext() {}

func NewDurationFunctionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DurationFunctionParametersContext {
	var p = new(DurationFunctionParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_durationFunctionParameters

	return p
}

func (s *DurationFunctionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *DurationFunctionParametersContext) DurationString() IDurationStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDurationStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDurationStringContext)
}

func (s *DurationFunctionParametersContext) RecordConstructor() IRecordConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordConstructorContext)
}

func (s *DurationFunctionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurationFunctionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DurationFunctionParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDurationFunctionParameters(s)
	}
}

func (s *DurationFunctionParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDurationFunctionParameters(s)
	}
}

func (p *GQLParser) DurationFunctionParameters() (localctx IDurationFunctionParametersContext) {
	localctx = NewDurationFunctionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1084, GQLParserRULE_durationFunctionParameters)
	p.SetState(4590)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE, GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4588)
			p.DurationString()
		}

	case GQLParserRECORD, GQLParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4589)
			p.RecordConstructor()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectNameContext is an interface to support dynamic dispatch.
type IObjectNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsObjectNameContext differentiates from other interfaces.
	IsObjectNameContext()
}

type ObjectNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectNameContext() *ObjectNameContext {
	var p = new(ObjectNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_objectName
	return p
}

func InitEmptyObjectNameContext(p *ObjectNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_objectName
}

func (*ObjectNameContext) IsObjectNameContext() {}

func NewObjectNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectNameContext {
	var p = new(ObjectNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_objectName

	return p
}

func (s *ObjectNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ObjectNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterObjectName(s)
	}
}

func (s *ObjectNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitObjectName(s)
	}
}

func (p *GQLParser) ObjectName() (localctx IObjectNameContext) {
	localctx = NewObjectNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1086, GQLParserRULE_objectName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4592)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectNameOrBindingVariableContext is an interface to support dynamic dispatch.
type IObjectNameOrBindingVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RegularIdentifier() IRegularIdentifierContext

	// IsObjectNameOrBindingVariableContext differentiates from other interfaces.
	IsObjectNameOrBindingVariableContext()
}

type ObjectNameOrBindingVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectNameOrBindingVariableContext() *ObjectNameOrBindingVariableContext {
	var p = new(ObjectNameOrBindingVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_objectNameOrBindingVariable
	return p
}

func InitEmptyObjectNameOrBindingVariableContext(p *ObjectNameOrBindingVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_objectNameOrBindingVariable
}

func (*ObjectNameOrBindingVariableContext) IsObjectNameOrBindingVariableContext() {}

func NewObjectNameOrBindingVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectNameOrBindingVariableContext {
	var p = new(ObjectNameOrBindingVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_objectNameOrBindingVariable

	return p
}

func (s *ObjectNameOrBindingVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectNameOrBindingVariableContext) RegularIdentifier() IRegularIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegularIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegularIdentifierContext)
}

func (s *ObjectNameOrBindingVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectNameOrBindingVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectNameOrBindingVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterObjectNameOrBindingVariable(s)
	}
}

func (s *ObjectNameOrBindingVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitObjectNameOrBindingVariable(s)
	}
}

func (p *GQLParser) ObjectNameOrBindingVariable() (localctx IObjectNameOrBindingVariableContext) {
	localctx = NewObjectNameOrBindingVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1088, GQLParserRULE_objectNameOrBindingVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4594)
		p.RegularIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDirectoryNameContext is an interface to support dynamic dispatch.
type IDirectoryNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsDirectoryNameContext differentiates from other interfaces.
	IsDirectoryNameContext()
}

type DirectoryNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectoryNameContext() *DirectoryNameContext {
	var p = new(DirectoryNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_directoryName
	return p
}

func InitEmptyDirectoryNameContext(p *DirectoryNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_directoryName
}

func (*DirectoryNameContext) IsDirectoryNameContext() {}

func NewDirectoryNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectoryNameContext {
	var p = new(DirectoryNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_directoryName

	return p
}

func (s *DirectoryNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectoryNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DirectoryNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectoryNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectoryNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDirectoryName(s)
	}
}

func (s *DirectoryNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDirectoryName(s)
	}
}

func (p *GQLParser) DirectoryName() (localctx IDirectoryNameContext) {
	localctx = NewDirectoryNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1090, GQLParserRULE_directoryName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4596)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaNameContext is an interface to support dynamic dispatch.
type ISchemaNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsSchemaNameContext differentiates from other interfaces.
	IsSchemaNameContext()
}

type SchemaNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaNameContext() *SchemaNameContext {
	var p = new(SchemaNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_schemaName
	return p
}

func InitEmptySchemaNameContext(p *SchemaNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_schemaName
}

func (*SchemaNameContext) IsSchemaNameContext() {}

func NewSchemaNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaNameContext {
	var p = new(SchemaNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_schemaName

	return p
}

func (s *SchemaNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SchemaNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSchemaName(s)
	}
}

func (s *SchemaNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSchemaName(s)
	}
}

func (p *GQLParser) SchemaName() (localctx ISchemaNameContext) {
	localctx = NewSchemaNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1092, GQLParserRULE_schemaName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4598)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphNameContext is an interface to support dynamic dispatch.
type IGraphNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RegularIdentifier() IRegularIdentifierContext
	DelimitedGraphName() IDelimitedGraphNameContext

	// IsGraphNameContext differentiates from other interfaces.
	IsGraphNameContext()
}

type GraphNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphNameContext() *GraphNameContext {
	var p = new(GraphNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphName
	return p
}

func InitEmptyGraphNameContext(p *GraphNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphName
}

func (*GraphNameContext) IsGraphNameContext() {}

func NewGraphNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphNameContext {
	var p = new(GraphNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphName

	return p
}

func (s *GraphNameContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphNameContext) RegularIdentifier() IRegularIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegularIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegularIdentifierContext)
}

func (s *GraphNameContext) DelimitedGraphName() IDelimitedGraphNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelimitedGraphNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelimitedGraphNameContext)
}

func (s *GraphNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphName(s)
	}
}

func (s *GraphNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphName(s)
	}
}

func (p *GQLParser) GraphName() (localctx IGraphNameContext) {
	localctx = NewGraphNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1094, GQLParserRULE_graphName)
	p.SetState(4602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE, GQLParserREGULAR_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4600)
			p.RegularIdentifier()
		}

	case GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4601)
			p.DelimitedGraphName()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelimitedGraphNameContext is an interface to support dynamic dispatch.
type IDelimitedGraphNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOUBLE_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode
	ACCENT_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode

	// IsDelimitedGraphNameContext differentiates from other interfaces.
	IsDelimitedGraphNameContext()
}

type DelimitedGraphNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelimitedGraphNameContext() *DelimitedGraphNameContext {
	var p = new(DelimitedGraphNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_delimitedGraphName
	return p
}

func InitEmptyDelimitedGraphNameContext(p *DelimitedGraphNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_delimitedGraphName
}

func (*DelimitedGraphNameContext) IsDelimitedGraphNameContext() {}

func NewDelimitedGraphNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelimitedGraphNameContext {
	var p = new(DelimitedGraphNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_delimitedGraphName

	return p
}

func (s *DelimitedGraphNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DelimitedGraphNameContext) DOUBLE_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode {
	return s.GetToken(GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, 0)
}

func (s *DelimitedGraphNameContext) ACCENT_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode {
	return s.GetToken(GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE, 0)
}

func (s *DelimitedGraphNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelimitedGraphNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelimitedGraphNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDelimitedGraphName(s)
	}
}

func (s *DelimitedGraphNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDelimitedGraphName(s)
	}
}

func (p *GQLParser) DelimitedGraphName() (localctx IDelimitedGraphNameContext) {
	localctx = NewDelimitedGraphNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1096, GQLParserRULE_delimitedGraphName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4604)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphTypeNameContext is an interface to support dynamic dispatch.
type IGraphTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsGraphTypeNameContext differentiates from other interfaces.
	IsGraphTypeNameContext()
}

type GraphTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphTypeNameContext() *GraphTypeNameContext {
	var p = new(GraphTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphTypeName
	return p
}

func InitEmptyGraphTypeNameContext(p *GraphTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_graphTypeName
}

func (*GraphTypeNameContext) IsGraphTypeNameContext() {}

func NewGraphTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphTypeNameContext {
	var p = new(GraphTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_graphTypeName

	return p
}

func (s *GraphTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphTypeNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GraphTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGraphTypeName(s)
	}
}

func (s *GraphTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGraphTypeName(s)
	}
}

func (p *GQLParser) GraphTypeName() (localctx IGraphTypeNameContext) {
	localctx = NewGraphTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1098, GQLParserRULE_graphTypeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4606)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeTypeNameContext is an interface to support dynamic dispatch.
type INodeTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsNodeTypeNameContext differentiates from other interfaces.
	IsNodeTypeNameContext()
}

type NodeTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeTypeNameContext() *NodeTypeNameContext {
	var p = new(NodeTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypeName
	return p
}

func InitEmptyNodeTypeNameContext(p *NodeTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeTypeName
}

func (*NodeTypeNameContext) IsNodeTypeNameContext() {}

func NewNodeTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeTypeNameContext {
	var p = new(NodeTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nodeTypeName

	return p
}

func (s *NodeTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeTypeNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NodeTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNodeTypeName(s)
	}
}

func (s *NodeTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNodeTypeName(s)
	}
}

func (p *GQLParser) NodeTypeName() (localctx INodeTypeNameContext) {
	localctx = NewNodeTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1100, GQLParserRULE_nodeTypeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4608)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeTypeNameContext is an interface to support dynamic dispatch.
type IEdgeTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsEdgeTypeNameContext differentiates from other interfaces.
	IsEdgeTypeNameContext()
}

type EdgeTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeTypeNameContext() *EdgeTypeNameContext {
	var p = new(EdgeTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypeName
	return p
}

func InitEmptyEdgeTypeNameContext(p *EdgeTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeTypeName
}

func (*EdgeTypeNameContext) IsEdgeTypeNameContext() {}

func NewEdgeTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeTypeNameContext {
	var p = new(EdgeTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeTypeName

	return p
}

func (s *EdgeTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeTypeNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EdgeTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeTypeName(s)
	}
}

func (s *EdgeTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeTypeName(s)
	}
}

func (p *GQLParser) EdgeTypeName() (localctx IEdgeTypeNameContext) {
	localctx = NewEdgeTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1102, GQLParserRULE_edgeTypeName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4610)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindingTableNameContext is an interface to support dynamic dispatch.
type IBindingTableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RegularIdentifier() IRegularIdentifierContext
	DelimitedBindingTableName() IDelimitedBindingTableNameContext

	// IsBindingTableNameContext differentiates from other interfaces.
	IsBindingTableNameContext()
}

type BindingTableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingTableNameContext() *BindingTableNameContext {
	var p = new(BindingTableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingTableName
	return p
}

func InitEmptyBindingTableNameContext(p *BindingTableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingTableName
}

func (*BindingTableNameContext) IsBindingTableNameContext() {}

func NewBindingTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingTableNameContext {
	var p = new(BindingTableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_bindingTableName

	return p
}

func (s *BindingTableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingTableNameContext) RegularIdentifier() IRegularIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegularIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegularIdentifierContext)
}

func (s *BindingTableNameContext) DelimitedBindingTableName() IDelimitedBindingTableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelimitedBindingTableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelimitedBindingTableNameContext)
}

func (s *BindingTableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingTableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingTableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBindingTableName(s)
	}
}

func (s *BindingTableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBindingTableName(s)
	}
}

func (p *GQLParser) BindingTableName() (localctx IBindingTableNameContext) {
	localctx = NewBindingTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1104, GQLParserRULE_bindingTableName)
	p.SetState(4614)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE, GQLParserREGULAR_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4612)
			p.RegularIdentifier()
		}

	case GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4613)
			p.DelimitedBindingTableName()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelimitedBindingTableNameContext is an interface to support dynamic dispatch.
type IDelimitedBindingTableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOUBLE_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode
	ACCENT_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode

	// IsDelimitedBindingTableNameContext differentiates from other interfaces.
	IsDelimitedBindingTableNameContext()
}

type DelimitedBindingTableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelimitedBindingTableNameContext() *DelimitedBindingTableNameContext {
	var p = new(DelimitedBindingTableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_delimitedBindingTableName
	return p
}

func InitEmptyDelimitedBindingTableNameContext(p *DelimitedBindingTableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_delimitedBindingTableName
}

func (*DelimitedBindingTableNameContext) IsDelimitedBindingTableNameContext() {}

func NewDelimitedBindingTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelimitedBindingTableNameContext {
	var p = new(DelimitedBindingTableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_delimitedBindingTableName

	return p
}

func (s *DelimitedBindingTableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DelimitedBindingTableNameContext) DOUBLE_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode {
	return s.GetToken(GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, 0)
}

func (s *DelimitedBindingTableNameContext) ACCENT_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode {
	return s.GetToken(GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE, 0)
}

func (s *DelimitedBindingTableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelimitedBindingTableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelimitedBindingTableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDelimitedBindingTableName(s)
	}
}

func (s *DelimitedBindingTableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDelimitedBindingTableName(s)
	}
}

func (p *GQLParser) DelimitedBindingTableName() (localctx IDelimitedBindingTableNameContext) {
	localctx = NewDelimitedBindingTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1106, GQLParserRULE_delimitedBindingTableName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4616)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureNameContext is an interface to support dynamic dispatch.
type IProcedureNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsProcedureNameContext differentiates from other interfaces.
	IsProcedureNameContext()
}

type ProcedureNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureNameContext() *ProcedureNameContext {
	var p = new(ProcedureNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_procedureName
	return p
}

func InitEmptyProcedureNameContext(p *ProcedureNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_procedureName
}

func (*ProcedureNameContext) IsProcedureNameContext() {}

func NewProcedureNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureNameContext {
	var p = new(ProcedureNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_procedureName

	return p
}

func (s *ProcedureNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProcedureNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterProcedureName(s)
	}
}

func (s *ProcedureNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitProcedureName(s)
	}
}

func (p *GQLParser) ProcedureName() (localctx IProcedureNameContext) {
	localctx = NewProcedureNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1108, GQLParserRULE_procedureName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4618)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelNameContext is an interface to support dynamic dispatch.
type ILabelNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsLabelNameContext differentiates from other interfaces.
	IsLabelNameContext()
}

type LabelNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelNameContext() *LabelNameContext {
	var p = new(LabelNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_labelName
	return p
}

func InitEmptyLabelNameContext(p *LabelNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_labelName
}

func (*LabelNameContext) IsLabelNameContext() {}

func NewLabelNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelNameContext {
	var p = new(LabelNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_labelName

	return p
}

func (s *LabelNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabelNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterLabelName(s)
	}
}

func (s *LabelNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitLabelName(s)
	}
}

func (p *GQLParser) LabelName() (localctx ILabelNameContext) {
	localctx = NewLabelNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1110, GQLParserRULE_labelName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4620)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyNameContext is an interface to support dynamic dispatch.
type IPropertyNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsPropertyNameContext differentiates from other interfaces.
	IsPropertyNameContext()
}

type PropertyNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyNameContext() *PropertyNameContext {
	var p = new(PropertyNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_propertyName
	return p
}

func InitEmptyPropertyNameContext(p *PropertyNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_propertyName
}

func (*PropertyNameContext) IsPropertyNameContext() {}

func NewPropertyNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyNameContext {
	var p = new(PropertyNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_propertyName

	return p
}

func (s *PropertyNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPropertyName(s)
	}
}

func (s *PropertyNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPropertyName(s)
	}
}

func (p *GQLParser) PropertyName() (localctx IPropertyNameContext) {
	localctx = NewPropertyNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1112, GQLParserRULE_propertyName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4622)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldNameContext is an interface to support dynamic dispatch.
type IFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsFieldNameContext differentiates from other interfaces.
	IsFieldNameContext()
}

type FieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldNameContext() *FieldNameContext {
	var p = new(FieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fieldName
	return p
}

func InitEmptyFieldNameContext(p *FieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_fieldName
}

func (*FieldNameContext) IsFieldNameContext() {}

func NewFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldNameContext {
	var p = new(FieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_fieldName

	return p
}

func (s *FieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterFieldName(s)
	}
}

func (s *FieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitFieldName(s)
	}
}

func (p *GQLParser) FieldName() (localctx IFieldNameContext) {
	localctx = NewFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1114, GQLParserRULE_fieldName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4624)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementVariableContext is an interface to support dynamic dispatch.
type IElementVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingVariable() IBindingVariableContext

	// IsElementVariableContext differentiates from other interfaces.
	IsElementVariableContext()
}

type ElementVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementVariableContext() *ElementVariableContext {
	var p = new(ElementVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementVariable
	return p
}

func InitEmptyElementVariableContext(p *ElementVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_elementVariable
}

func (*ElementVariableContext) IsElementVariableContext() {}

func NewElementVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementVariableContext {
	var p = new(ElementVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_elementVariable

	return p
}

func (s *ElementVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementVariableContext) BindingVariable() IBindingVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableContext)
}

func (s *ElementVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterElementVariable(s)
	}
}

func (s *ElementVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitElementVariable(s)
	}
}

func (p *GQLParser) ElementVariable() (localctx IElementVariableContext) {
	localctx = NewElementVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1116, GQLParserRULE_elementVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4626)
		p.BindingVariable()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPathVariableContext is an interface to support dynamic dispatch.
type IPathVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BindingVariable() IBindingVariableContext

	// IsPathVariableContext differentiates from other interfaces.
	IsPathVariableContext()
}

type PathVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathVariableContext() *PathVariableContext {
	var p = new(PathVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathVariable
	return p
}

func InitEmptyPathVariableContext(p *PathVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_pathVariable
}

func (*PathVariableContext) IsPathVariableContext() {}

func NewPathVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathVariableContext {
	var p = new(PathVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_pathVariable

	return p
}

func (s *PathVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *PathVariableContext) BindingVariable() IBindingVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBindingVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBindingVariableContext)
}

func (s *PathVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterPathVariable(s)
	}
}

func (s *PathVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitPathVariable(s)
	}
}

func (p *GQLParser) PathVariable() (localctx IPathVariableContext) {
	localctx = NewPathVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1118, GQLParserRULE_pathVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4628)
		p.BindingVariable()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubpathVariableContext is an interface to support dynamic dispatch.
type ISubpathVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RegularIdentifier() IRegularIdentifierContext

	// IsSubpathVariableContext differentiates from other interfaces.
	IsSubpathVariableContext()
}

type SubpathVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpathVariableContext() *SubpathVariableContext {
	var p = new(SubpathVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_subpathVariable
	return p
}

func InitEmptySubpathVariableContext(p *SubpathVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_subpathVariable
}

func (*SubpathVariableContext) IsSubpathVariableContext() {}

func NewSubpathVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpathVariableContext {
	var p = new(SubpathVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_subpathVariable

	return p
}

func (s *SubpathVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpathVariableContext) RegularIdentifier() IRegularIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegularIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegularIdentifierContext)
}

func (s *SubpathVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpathVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubpathVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterSubpathVariable(s)
	}
}

func (s *SubpathVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitSubpathVariable(s)
	}
}

func (p *GQLParser) SubpathVariable() (localctx ISubpathVariableContext) {
	localctx = NewSubpathVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1120, GQLParserRULE_subpathVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4630)
		p.RegularIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBindingVariableContext is an interface to support dynamic dispatch.
type IBindingVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RegularIdentifier() IRegularIdentifierContext

	// IsBindingVariableContext differentiates from other interfaces.
	IsBindingVariableContext()
}

type BindingVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindingVariableContext() *BindingVariableContext {
	var p = new(BindingVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingVariable
	return p
}

func InitEmptyBindingVariableContext(p *BindingVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_bindingVariable
}

func (*BindingVariableContext) IsBindingVariableContext() {}

func NewBindingVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindingVariableContext {
	var p = new(BindingVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_bindingVariable

	return p
}

func (s *BindingVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *BindingVariableContext) RegularIdentifier() IRegularIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegularIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegularIdentifierContext)
}

func (s *BindingVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindingVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindingVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterBindingVariable(s)
	}
}

func (s *BindingVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitBindingVariable(s)
	}
}

func (p *GQLParser) BindingVariable() (localctx IBindingVariableContext) {
	localctx = NewBindingVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1122, GQLParserRULE_bindingVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4632)
		p.RegularIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedLiteralContext is an interface to support dynamic dispatch.
type IUnsignedLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsignedNumericLiteral() IUnsignedNumericLiteralContext
	GeneralLiteral() IGeneralLiteralContext

	// IsUnsignedLiteralContext differentiates from other interfaces.
	IsUnsignedLiteralContext()
}

type UnsignedLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedLiteralContext() *UnsignedLiteralContext {
	var p = new(UnsignedLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_unsignedLiteral
	return p
}

func InitEmptyUnsignedLiteralContext(p *UnsignedLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_unsignedLiteral
}

func (*UnsignedLiteralContext) IsUnsignedLiteralContext() {}

func NewUnsignedLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedLiteralContext {
	var p = new(UnsignedLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_unsignedLiteral

	return p
}

func (s *UnsignedLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedLiteralContext) UnsignedNumericLiteral() IUnsignedNumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedNumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedNumericLiteralContext)
}

func (s *UnsignedLiteralContext) GeneralLiteral() IGeneralLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneralLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneralLiteralContext)
}

func (s *UnsignedLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterUnsignedLiteral(s)
	}
}

func (s *UnsignedLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitUnsignedLiteral(s)
	}
}

func (p *GQLParser) UnsignedLiteral() (localctx IUnsignedLiteralContext) {
	localctx = NewUnsignedLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1124, GQLParserRULE_unsignedLiteral)
	p.SetState(4636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER, GQLParserUNSIGNED_HEXADECIMAL_INTEGER, GQLParserUNSIGNED_OCTAL_INTEGER, GQLParserUNSIGNED_BINARY_INTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4634)
			p.UnsignedNumericLiteral()
		}

	case GQLParserBOOLEAN_LITERAL, GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE, GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, GQLParserBYTE_STRING_LITERAL, GQLParserARRAY, GQLParserDATE, GQLParserDATETIME, GQLParserDURATION, GQLParserLIST, GQLParserNULL_KW, GQLParserRECORD, GQLParserTIME, GQLParserTIMESTAMP, GQLParserLEFT_BRACE, GQLParserLEFT_BRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4635)
			p.GeneralLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneralLiteralContext is an interface to support dynamic dispatch.
type IGeneralLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BOOLEAN_LITERAL() antlr.TerminalNode
	CharacterStringLiteral() ICharacterStringLiteralContext
	BYTE_STRING_LITERAL() antlr.TerminalNode
	TemporalLiteral() ITemporalLiteralContext
	DurationLiteral() IDurationLiteralContext
	NullLiteral() INullLiteralContext
	ListLiteral() IListLiteralContext
	RecordLiteral() IRecordLiteralContext

	// IsGeneralLiteralContext differentiates from other interfaces.
	IsGeneralLiteralContext()
}

type GeneralLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralLiteralContext() *GeneralLiteralContext {
	var p = new(GeneralLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalLiteral
	return p
}

func InitEmptyGeneralLiteralContext(p *GeneralLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_generalLiteral
}

func (*GeneralLiteralContext) IsGeneralLiteralContext() {}

func NewGeneralLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralLiteralContext {
	var p = new(GeneralLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_generalLiteral

	return p
}

func (s *GeneralLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralLiteralContext) BOOLEAN_LITERAL() antlr.TerminalNode {
	return s.GetToken(GQLParserBOOLEAN_LITERAL, 0)
}

func (s *GeneralLiteralContext) CharacterStringLiteral() ICharacterStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacterStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacterStringLiteralContext)
}

func (s *GeneralLiteralContext) BYTE_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(GQLParserBYTE_STRING_LITERAL, 0)
}

func (s *GeneralLiteralContext) TemporalLiteral() ITemporalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemporalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemporalLiteralContext)
}

func (s *GeneralLiteralContext) DurationLiteral() IDurationLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDurationLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDurationLiteralContext)
}

func (s *GeneralLiteralContext) NullLiteral() INullLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullLiteralContext)
}

func (s *GeneralLiteralContext) ListLiteral() IListLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListLiteralContext)
}

func (s *GeneralLiteralContext) RecordLiteral() IRecordLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordLiteralContext)
}

func (s *GeneralLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterGeneralLiteral(s)
	}
}

func (s *GeneralLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitGeneralLiteral(s)
	}
}

func (p *GQLParser) GeneralLiteral() (localctx IGeneralLiteralContext) {
	localctx = NewGeneralLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1126, GQLParserRULE_generalLiteral)
	p.SetState(4646)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserBOOLEAN_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4638)
			p.Match(GQLParserBOOLEAN_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE, GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4639)
			p.CharacterStringLiteral()
		}

	case GQLParserBYTE_STRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4640)
			p.Match(GQLParserBYTE_STRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserDATE, GQLParserDATETIME, GQLParserTIME, GQLParserTIMESTAMP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4641)
			p.TemporalLiteral()
		}

	case GQLParserDURATION:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4642)
			p.DurationLiteral()
		}

	case GQLParserNULL_KW:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4643)
			p.NullLiteral()
		}

	case GQLParserARRAY, GQLParserLIST, GQLParserLEFT_BRACKET:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4644)
			p.ListLiteral()
		}

	case GQLParserRECORD, GQLParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4645)
			p.RecordLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemporalLiteralContext is an interface to support dynamic dispatch.
type ITemporalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DateLiteral() IDateLiteralContext
	TimeLiteral() ITimeLiteralContext
	DatetimeLiteral() IDatetimeLiteralContext

	// IsTemporalLiteralContext differentiates from other interfaces.
	IsTemporalLiteralContext()
}

type TemporalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemporalLiteralContext() *TemporalLiteralContext {
	var p = new(TemporalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_temporalLiteral
	return p
}

func InitEmptyTemporalLiteralContext(p *TemporalLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_temporalLiteral
}

func (*TemporalLiteralContext) IsTemporalLiteralContext() {}

func NewTemporalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemporalLiteralContext {
	var p = new(TemporalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_temporalLiteral

	return p
}

func (s *TemporalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TemporalLiteralContext) DateLiteral() IDateLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateLiteralContext)
}

func (s *TemporalLiteralContext) TimeLiteral() ITimeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeLiteralContext)
}

func (s *TemporalLiteralContext) DatetimeLiteral() IDatetimeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeLiteralContext)
}

func (s *TemporalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemporalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemporalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTemporalLiteral(s)
	}
}

func (s *TemporalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTemporalLiteral(s)
	}
}

func (p *GQLParser) TemporalLiteral() (localctx ITemporalLiteralContext) {
	localctx = NewTemporalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1128, GQLParserRULE_temporalLiteral)
	p.SetState(4651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserDATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4648)
			p.DateLiteral()
		}

	case GQLParserTIME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4649)
			p.TimeLiteral()
		}

	case GQLParserDATETIME, GQLParserTIMESTAMP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4650)
			p.DatetimeLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateLiteralContext is an interface to support dynamic dispatch.
type IDateLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATE() antlr.TerminalNode
	DateString() IDateStringContext

	// IsDateLiteralContext differentiates from other interfaces.
	IsDateLiteralContext()
}

type DateLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateLiteralContext() *DateLiteralContext {
	var p = new(DateLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dateLiteral
	return p
}

func InitEmptyDateLiteralContext(p *DateLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dateLiteral
}

func (*DateLiteralContext) IsDateLiteralContext() {}

func NewDateLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateLiteralContext {
	var p = new(DateLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_dateLiteral

	return p
}

func (s *DateLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DateLiteralContext) DATE() antlr.TerminalNode {
	return s.GetToken(GQLParserDATE, 0)
}

func (s *DateLiteralContext) DateString() IDateStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateStringContext)
}

func (s *DateLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDateLiteral(s)
	}
}

func (s *DateLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDateLiteral(s)
	}
}

func (p *GQLParser) DateLiteral() (localctx IDateLiteralContext) {
	localctx = NewDateLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1130, GQLParserRULE_dateLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4653)
		p.Match(GQLParserDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4654)
		p.DateString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeLiteralContext is an interface to support dynamic dispatch.
type ITimeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TIME() antlr.TerminalNode
	TimeString() ITimeStringContext

	// IsTimeLiteralContext differentiates from other interfaces.
	IsTimeLiteralContext()
}

type TimeLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeLiteralContext() *TimeLiteralContext {
	var p = new(TimeLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_timeLiteral
	return p
}

func InitEmptyTimeLiteralContext(p *TimeLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_timeLiteral
}

func (*TimeLiteralContext) IsTimeLiteralContext() {}

func NewTimeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeLiteralContext {
	var p = new(TimeLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_timeLiteral

	return p
}

func (s *TimeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeLiteralContext) TIME() antlr.TerminalNode {
	return s.GetToken(GQLParserTIME, 0)
}

func (s *TimeLiteralContext) TimeString() ITimeStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeStringContext)
}

func (s *TimeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTimeLiteral(s)
	}
}

func (s *TimeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTimeLiteral(s)
	}
}

func (p *GQLParser) TimeLiteral() (localctx ITimeLiteralContext) {
	localctx = NewTimeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1132, GQLParserRULE_timeLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4656)
		p.Match(GQLParserTIME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4657)
		p.TimeString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatetimeLiteralContext is an interface to support dynamic dispatch.
type IDatetimeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DatetimeString() IDatetimeStringContext
	DATETIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode

	// IsDatetimeLiteralContext differentiates from other interfaces.
	IsDatetimeLiteralContext()
}

type DatetimeLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetimeLiteralContext() *DatetimeLiteralContext {
	var p = new(DatetimeLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeLiteral
	return p
}

func InitEmptyDatetimeLiteralContext(p *DatetimeLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeLiteral
}

func (*DatetimeLiteralContext) IsDatetimeLiteralContext() {}

func NewDatetimeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatetimeLiteralContext {
	var p = new(DatetimeLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_datetimeLiteral

	return p
}

func (s *DatetimeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DatetimeLiteralContext) DatetimeString() IDatetimeStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatetimeStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatetimeStringContext)
}

func (s *DatetimeLiteralContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(GQLParserDATETIME, 0)
}

func (s *DatetimeLiteralContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(GQLParserTIMESTAMP, 0)
}

func (s *DatetimeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatetimeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatetimeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDatetimeLiteral(s)
	}
}

func (s *DatetimeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDatetimeLiteral(s)
	}
}

func (p *GQLParser) DatetimeLiteral() (localctx IDatetimeLiteralContext) {
	localctx = NewDatetimeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1134, GQLParserRULE_datetimeLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4659)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserDATETIME || _la == GQLParserTIMESTAMP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4660)
		p.DatetimeString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListLiteralContext is an interface to support dynamic dispatch.
type IListLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ListValueConstructorByEnumeration() IListValueConstructorByEnumerationContext

	// IsListLiteralContext differentiates from other interfaces.
	IsListLiteralContext()
}

type ListLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListLiteralContext() *ListLiteralContext {
	var p = new(ListLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listLiteral
	return p
}

func InitEmptyListLiteralContext(p *ListLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_listLiteral
}

func (*ListLiteralContext) IsListLiteralContext() {}

func NewListLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListLiteralContext {
	var p = new(ListLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_listLiteral

	return p
}

func (s *ListLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ListLiteralContext) ListValueConstructorByEnumeration() IListValueConstructorByEnumerationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListValueConstructorByEnumerationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListValueConstructorByEnumerationContext)
}

func (s *ListLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterListLiteral(s)
	}
}

func (s *ListLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitListLiteral(s)
	}
}

func (p *GQLParser) ListLiteral() (localctx IListLiteralContext) {
	localctx = NewListLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1136, GQLParserRULE_listLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4662)
		p.ListValueConstructorByEnumeration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecordLiteralContext is an interface to support dynamic dispatch.
type IRecordLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RecordConstructor() IRecordConstructorContext

	// IsRecordLiteralContext differentiates from other interfaces.
	IsRecordLiteralContext()
}

type RecordLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordLiteralContext() *RecordLiteralContext {
	var p = new(RecordLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_recordLiteral
	return p
}

func InitEmptyRecordLiteralContext(p *RecordLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_recordLiteral
}

func (*RecordLiteralContext) IsRecordLiteralContext() {}

func NewRecordLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordLiteralContext {
	var p = new(RecordLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_recordLiteral

	return p
}

func (s *RecordLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordLiteralContext) RecordConstructor() IRecordConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordConstructorContext)
}

func (s *RecordLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterRecordLiteral(s)
	}
}

func (s *RecordLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitRecordLiteral(s)
	}
}

func (p *GQLParser) RecordLiteral() (localctx IRecordLiteralContext) {
	localctx = NewRecordLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1138, GQLParserRULE_recordLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4664)
		p.RecordConstructor()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RegularIdentifier() IRegularIdentifierContext
	DOUBLE_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode
	ACCENT_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) RegularIdentifier() IRegularIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegularIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegularIdentifierContext)
}

func (s *IdentifierContext) DOUBLE_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode {
	return s.GetToken(GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, 0)
}

func (s *IdentifierContext) ACCENT_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode {
	return s.GetToken(GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *GQLParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1140, GQLParserRULE_identifier)
	p.SetState(4669)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE, GQLParserREGULAR_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4666)
			p.RegularIdentifier()
		}

	case GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4667)
			p.Match(GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4668)
			p.Match(GQLParserACCENT_QUOTED_CHARACTER_SEQUENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRegularIdentifierContext is an interface to support dynamic dispatch.
type IRegularIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REGULAR_IDENTIFIER() antlr.TerminalNode
	NonReservedWords() INonReservedWordsContext

	// IsRegularIdentifierContext differentiates from other interfaces.
	IsRegularIdentifierContext()
}

type RegularIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRegularIdentifierContext() *RegularIdentifierContext {
	var p = new(RegularIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_regularIdentifier
	return p
}

func InitEmptyRegularIdentifierContext(p *RegularIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_regularIdentifier
}

func (*RegularIdentifierContext) IsRegularIdentifierContext() {}

func NewRegularIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RegularIdentifierContext {
	var p = new(RegularIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_regularIdentifier

	return p
}

func (s *RegularIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *RegularIdentifierContext) REGULAR_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(GQLParserREGULAR_IDENTIFIER, 0)
}

func (s *RegularIdentifierContext) NonReservedWords() INonReservedWordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedWordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedWordsContext)
}

func (s *RegularIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RegularIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterRegularIdentifier(s)
	}
}

func (s *RegularIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitRegularIdentifier(s)
	}
}

func (p *GQLParser) RegularIdentifier() (localctx IRegularIdentifierContext) {
	localctx = NewRegularIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1142, GQLParserRULE_regularIdentifier)
	p.SetState(4673)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserREGULAR_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4671)
			p.Match(GQLParserREGULAR_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserACYCLIC, GQLParserBINDING, GQLParserBINDINGS, GQLParserCONNECTING, GQLParserDESTINATION, GQLParserDIFFERENT, GQLParserDIRECTED, GQLParserEDGE, GQLParserEDGES, GQLParserELEMENT, GQLParserELEMENTS, GQLParserFIRST, GQLParserGRAPH, GQLParserGROUPS, GQLParserKEEP, GQLParserLABEL, GQLParserLABELED, GQLParserLABELS, GQLParserLAST, GQLParserNFC, GQLParserNFD, GQLParserNFKC, GQLParserNFKD, GQLParserNO, GQLParserNODE, GQLParserNORMALIZED, GQLParserONLY, GQLParserORDINALITY, GQLParserPROPERTY, GQLParserREAD, GQLParserRELATIONSHIP, GQLParserRELATIONSHIPS, GQLParserREPEATABLE, GQLParserSHORTEST, GQLParserSIMPLE, GQLParserSOURCE, GQLParserTABLE, GQLParserTO, GQLParserTRAIL, GQLParserTRANSACTION, GQLParserTYPE, GQLParserUNDIRECTED, GQLParserVERTEX, GQLParserWALK, GQLParserWITHOUT, GQLParserWRITE, GQLParserZONE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4672)
			p.NonReservedWords()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeZoneStringContext is an interface to support dynamic dispatch.
type ITimeZoneStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CharacterStringLiteral() ICharacterStringLiteralContext

	// IsTimeZoneStringContext differentiates from other interfaces.
	IsTimeZoneStringContext()
}

type TimeZoneStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeZoneStringContext() *TimeZoneStringContext {
	var p = new(TimeZoneStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_timeZoneString
	return p
}

func InitEmptyTimeZoneStringContext(p *TimeZoneStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_timeZoneString
}

func (*TimeZoneStringContext) IsTimeZoneStringContext() {}

func NewTimeZoneStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeZoneStringContext {
	var p = new(TimeZoneStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_timeZoneString

	return p
}

func (s *TimeZoneStringContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeZoneStringContext) CharacterStringLiteral() ICharacterStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacterStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacterStringLiteralContext)
}

func (s *TimeZoneStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeZoneStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTimeZoneString(s)
	}
}

func (s *TimeZoneStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTimeZoneString(s)
	}
}

func (p *GQLParser) TimeZoneString() (localctx ITimeZoneStringContext) {
	localctx = NewTimeZoneStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1144, GQLParserRULE_timeZoneString)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4675)
		p.CharacterStringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharacterStringLiteralContext is an interface to support dynamic dispatch.
type ICharacterStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SINGLE_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode
	DOUBLE_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode

	// IsCharacterStringLiteralContext differentiates from other interfaces.
	IsCharacterStringLiteralContext()
}

type CharacterStringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacterStringLiteralContext() *CharacterStringLiteralContext {
	var p = new(CharacterStringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_characterStringLiteral
	return p
}

func InitEmptyCharacterStringLiteralContext(p *CharacterStringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_characterStringLiteral
}

func (*CharacterStringLiteralContext) IsCharacterStringLiteralContext() {}

func NewCharacterStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharacterStringLiteralContext {
	var p = new(CharacterStringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_characterStringLiteral

	return p
}

func (s *CharacterStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *CharacterStringLiteralContext) SINGLE_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode {
	return s.GetToken(GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE, 0)
}

func (s *CharacterStringLiteralContext) DOUBLE_QUOTED_CHARACTER_SEQUENCE() antlr.TerminalNode {
	return s.GetToken(GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE, 0)
}

func (s *CharacterStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharacterStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharacterStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterCharacterStringLiteral(s)
	}
}

func (s *CharacterStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitCharacterStringLiteral(s)
	}
}

func (p *GQLParser) CharacterStringLiteral() (localctx ICharacterStringLiteralContext) {
	localctx = NewCharacterStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1146, GQLParserRULE_characterStringLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4677)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserSINGLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParserDOUBLE_QUOTED_CHARACTER_SEQUENCE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedNumericLiteralContext is an interface to support dynamic dispatch.
type IUnsignedNumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExactNumericLiteral() IExactNumericLiteralContext
	ApproximateNumericLiteral() IApproximateNumericLiteralContext

	// IsUnsignedNumericLiteralContext differentiates from other interfaces.
	IsUnsignedNumericLiteralContext()
}

type UnsignedNumericLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedNumericLiteralContext() *UnsignedNumericLiteralContext {
	var p = new(UnsignedNumericLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_unsignedNumericLiteral
	return p
}

func InitEmptyUnsignedNumericLiteralContext(p *UnsignedNumericLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_unsignedNumericLiteral
}

func (*UnsignedNumericLiteralContext) IsUnsignedNumericLiteralContext() {}

func NewUnsignedNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedNumericLiteralContext {
	var p = new(UnsignedNumericLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_unsignedNumericLiteral

	return p
}

func (s *UnsignedNumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedNumericLiteralContext) ExactNumericLiteral() IExactNumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExactNumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExactNumericLiteralContext)
}

func (s *UnsignedNumericLiteralContext) ApproximateNumericLiteral() IApproximateNumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IApproximateNumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IApproximateNumericLiteralContext)
}

func (s *UnsignedNumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedNumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedNumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterUnsignedNumericLiteral(s)
	}
}

func (s *UnsignedNumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitUnsignedNumericLiteral(s)
	}
}

func (p *GQLParser) UnsignedNumericLiteral() (localctx IUnsignedNumericLiteralContext) {
	localctx = NewUnsignedNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1148, GQLParserRULE_unsignedNumericLiteral)
	p.SetState(4681)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER, GQLParserUNSIGNED_HEXADECIMAL_INTEGER, GQLParserUNSIGNED_OCTAL_INTEGER, GQLParserUNSIGNED_BINARY_INTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4679)
			p.ExactNumericLiteral()
		}

	case GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4680)
			p.ApproximateNumericLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExactNumericLiteralContext is an interface to support dynamic dispatch.
type IExactNumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX() antlr.TerminalNode
	UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX() antlr.TerminalNode
	UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX() antlr.TerminalNode
	UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX() antlr.TerminalNode
	UnsignedInteger() IUnsignedIntegerContext

	// IsExactNumericLiteralContext differentiates from other interfaces.
	IsExactNumericLiteralContext()
}

type ExactNumericLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExactNumericLiteralContext() *ExactNumericLiteralContext {
	var p = new(ExactNumericLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_exactNumericLiteral
	return p
}

func InitEmptyExactNumericLiteralContext(p *ExactNumericLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_exactNumericLiteral
}

func (*ExactNumericLiteralContext) IsExactNumericLiteralContext() {}

func NewExactNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExactNumericLiteralContext {
	var p = new(ExactNumericLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_exactNumericLiteral

	return p
}

func (s *ExactNumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ExactNumericLiteralContext) UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX, 0)
}

func (s *ExactNumericLiteralContext) UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX, 0)
}

func (s *ExactNumericLiteralContext) UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX, 0)
}

func (s *ExactNumericLiteralContext) UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX, 0)
}

func (s *ExactNumericLiteralContext) UnsignedInteger() IUnsignedIntegerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsignedIntegerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerContext)
}

func (s *ExactNumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExactNumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExactNumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterExactNumericLiteral(s)
	}
}

func (s *ExactNumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitExactNumericLiteral(s)
	}
}

func (p *GQLParser) ExactNumericLiteral() (localctx IExactNumericLiteralContext) {
	localctx = NewExactNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1150, GQLParserRULE_exactNumericLiteral)
	p.SetState(4688)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4683)
			p.Match(GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4684)
			p.Match(GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4685)
			p.Match(GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4686)
			p.Match(GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case GQLParserUNSIGNED_DECIMAL_INTEGER, GQLParserUNSIGNED_HEXADECIMAL_INTEGER, GQLParserUNSIGNED_OCTAL_INTEGER, GQLParserUNSIGNED_BINARY_INTEGER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4687)
			p.UnsignedInteger()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IApproximateNumericLiteralContext is an interface to support dynamic dispatch.
type IApproximateNumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX() antlr.TerminalNode
	UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX() antlr.TerminalNode
	UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX() antlr.TerminalNode
	UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX() antlr.TerminalNode

	// IsApproximateNumericLiteralContext differentiates from other interfaces.
	IsApproximateNumericLiteralContext()
}

type ApproximateNumericLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApproximateNumericLiteralContext() *ApproximateNumericLiteralContext {
	var p = new(ApproximateNumericLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_approximateNumericLiteral
	return p
}

func InitEmptyApproximateNumericLiteralContext(p *ApproximateNumericLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_approximateNumericLiteral
}

func (*ApproximateNumericLiteralContext) IsApproximateNumericLiteralContext() {}

func NewApproximateNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ApproximateNumericLiteralContext {
	var p = new(ApproximateNumericLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_approximateNumericLiteral

	return p
}

func (s *ApproximateNumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ApproximateNumericLiteralContext) UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, 0)
}

func (s *ApproximateNumericLiteralContext) UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX, 0)
}

func (s *ApproximateNumericLiteralContext) UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX, 0)
}

func (s *ApproximateNumericLiteralContext) UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX, 0)
}

func (s *ApproximateNumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApproximateNumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ApproximateNumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterApproximateNumericLiteral(s)
	}
}

func (s *ApproximateNumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitApproximateNumericLiteral(s)
	}
}

func (p *GQLParser) ApproximateNumericLiteral() (localctx IApproximateNumericLiteralContext) {
	localctx = NewApproximateNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1152, GQLParserRULE_approximateNumericLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4690)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&339968) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedIntegerContext is an interface to support dynamic dispatch.
type IUnsignedIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNSIGNED_DECIMAL_INTEGER() antlr.TerminalNode
	UNSIGNED_HEXADECIMAL_INTEGER() antlr.TerminalNode
	UNSIGNED_OCTAL_INTEGER() antlr.TerminalNode
	UNSIGNED_BINARY_INTEGER() antlr.TerminalNode

	// IsUnsignedIntegerContext differentiates from other interfaces.
	IsUnsignedIntegerContext()
}

type UnsignedIntegerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedIntegerContext() *UnsignedIntegerContext {
	var p = new(UnsignedIntegerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_unsignedInteger
	return p
}

func InitEmptyUnsignedIntegerContext(p *UnsignedIntegerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_unsignedInteger
}

func (*UnsignedIntegerContext) IsUnsignedIntegerContext() {}

func NewUnsignedIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedIntegerContext {
	var p = new(UnsignedIntegerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_unsignedInteger

	return p
}

func (s *UnsignedIntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedIntegerContext) UNSIGNED_DECIMAL_INTEGER() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED_DECIMAL_INTEGER, 0)
}

func (s *UnsignedIntegerContext) UNSIGNED_HEXADECIMAL_INTEGER() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED_HEXADECIMAL_INTEGER, 0)
}

func (s *UnsignedIntegerContext) UNSIGNED_OCTAL_INTEGER() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED_OCTAL_INTEGER, 0)
}

func (s *UnsignedIntegerContext) UNSIGNED_BINARY_INTEGER() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED_BINARY_INTEGER, 0)
}

func (s *UnsignedIntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedIntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedIntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterUnsignedInteger(s)
	}
}

func (s *UnsignedIntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitUnsignedInteger(s)
	}
}

func (p *GQLParser) UnsignedInteger() (localctx IUnsignedIntegerContext) {
	localctx = NewUnsignedIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1154, GQLParserRULE_unsignedInteger)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4692)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&7864320) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsignedDecimalIntegerContext is an interface to support dynamic dispatch.
type IUnsignedDecimalIntegerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNSIGNED_DECIMAL_INTEGER() antlr.TerminalNode

	// IsUnsignedDecimalIntegerContext differentiates from other interfaces.
	IsUnsignedDecimalIntegerContext()
}

type UnsignedDecimalIntegerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedDecimalIntegerContext() *UnsignedDecimalIntegerContext {
	var p = new(UnsignedDecimalIntegerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_unsignedDecimalInteger
	return p
}

func InitEmptyUnsignedDecimalIntegerContext(p *UnsignedDecimalIntegerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_unsignedDecimalInteger
}

func (*UnsignedDecimalIntegerContext) IsUnsignedDecimalIntegerContext() {}

func NewUnsignedDecimalIntegerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedDecimalIntegerContext {
	var p = new(UnsignedDecimalIntegerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_unsignedDecimalInteger

	return p
}

func (s *UnsignedDecimalIntegerContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedDecimalIntegerContext) UNSIGNED_DECIMAL_INTEGER() antlr.TerminalNode {
	return s.GetToken(GQLParserUNSIGNED_DECIMAL_INTEGER, 0)
}

func (s *UnsignedDecimalIntegerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedDecimalIntegerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedDecimalIntegerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterUnsignedDecimalInteger(s)
	}
}

func (s *UnsignedDecimalIntegerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitUnsignedDecimalInteger(s)
	}
}

func (p *GQLParser) UnsignedDecimalInteger() (localctx IUnsignedDecimalIntegerContext) {
	localctx = NewUnsignedDecimalIntegerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1156, GQLParserRULE_unsignedDecimalInteger)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4694)
		p.Match(GQLParserUNSIGNED_DECIMAL_INTEGER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullLiteralContext is an interface to support dynamic dispatch.
type INullLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_KW() antlr.TerminalNode

	// IsNullLiteralContext differentiates from other interfaces.
	IsNullLiteralContext()
}

type NullLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullLiteralContext() *NullLiteralContext {
	var p = new(NullLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nullLiteral
	return p
}

func InitEmptyNullLiteralContext(p *NullLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nullLiteral
}

func (*NullLiteralContext) IsNullLiteralContext() {}

func NewNullLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullLiteralContext {
	var p = new(NullLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nullLiteral

	return p
}

func (s *NullLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NullLiteralContext) NULL_KW() antlr.TerminalNode {
	return s.GetToken(GQLParserNULL_KW, 0)
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

func (p *GQLParser) NullLiteral() (localctx INullLiteralContext) {
	localctx = NewNullLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1158, GQLParserRULE_nullLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4696)
		p.Match(GQLParserNULL_KW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateStringContext is an interface to support dynamic dispatch.
type IDateStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CharacterStringLiteral() ICharacterStringLiteralContext

	// IsDateStringContext differentiates from other interfaces.
	IsDateStringContext()
}

type DateStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateStringContext() *DateStringContext {
	var p = new(DateStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dateString
	return p
}

func InitEmptyDateStringContext(p *DateStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_dateString
}

func (*DateStringContext) IsDateStringContext() {}

func NewDateStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateStringContext {
	var p = new(DateStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_dateString

	return p
}

func (s *DateStringContext) GetParser() antlr.Parser { return s.parser }

func (s *DateStringContext) CharacterStringLiteral() ICharacterStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacterStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacterStringLiteralContext)
}

func (s *DateStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDateString(s)
	}
}

func (s *DateStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDateString(s)
	}
}

func (p *GQLParser) DateString() (localctx IDateStringContext) {
	localctx = NewDateStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1160, GQLParserRULE_dateString)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4698)
		p.CharacterStringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeStringContext is an interface to support dynamic dispatch.
type ITimeStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CharacterStringLiteral() ICharacterStringLiteralContext

	// IsTimeStringContext differentiates from other interfaces.
	IsTimeStringContext()
}

type TimeStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeStringContext() *TimeStringContext {
	var p = new(TimeStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_timeString
	return p
}

func InitEmptyTimeStringContext(p *TimeStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_timeString
}

func (*TimeStringContext) IsTimeStringContext() {}

func NewTimeStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeStringContext {
	var p = new(TimeStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_timeString

	return p
}

func (s *TimeStringContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeStringContext) CharacterStringLiteral() ICharacterStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacterStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacterStringLiteralContext)
}

func (s *TimeStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterTimeString(s)
	}
}

func (s *TimeStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitTimeString(s)
	}
}

func (p *GQLParser) TimeString() (localctx ITimeStringContext) {
	localctx = NewTimeStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1162, GQLParserRULE_timeString)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4700)
		p.CharacterStringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatetimeStringContext is an interface to support dynamic dispatch.
type IDatetimeStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CharacterStringLiteral() ICharacterStringLiteralContext

	// IsDatetimeStringContext differentiates from other interfaces.
	IsDatetimeStringContext()
}

type DatetimeStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatetimeStringContext() *DatetimeStringContext {
	var p = new(DatetimeStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeString
	return p
}

func InitEmptyDatetimeStringContext(p *DatetimeStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_datetimeString
}

func (*DatetimeStringContext) IsDatetimeStringContext() {}

func NewDatetimeStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatetimeStringContext {
	var p = new(DatetimeStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_datetimeString

	return p
}

func (s *DatetimeStringContext) GetParser() antlr.Parser { return s.parser }

func (s *DatetimeStringContext) CharacterStringLiteral() ICharacterStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacterStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacterStringLiteralContext)
}

func (s *DatetimeStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatetimeStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatetimeStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDatetimeString(s)
	}
}

func (s *DatetimeStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDatetimeString(s)
	}
}

func (p *GQLParser) DatetimeString() (localctx IDatetimeStringContext) {
	localctx = NewDatetimeStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1164, GQLParserRULE_datetimeString)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4702)
		p.CharacterStringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDurationLiteralContext is an interface to support dynamic dispatch.
type IDurationLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DURATION() antlr.TerminalNode
	DurationString() IDurationStringContext

	// IsDurationLiteralContext differentiates from other interfaces.
	IsDurationLiteralContext()
}

type DurationLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDurationLiteralContext() *DurationLiteralContext {
	var p = new(DurationLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_durationLiteral
	return p
}

func InitEmptyDurationLiteralContext(p *DurationLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_durationLiteral
}

func (*DurationLiteralContext) IsDurationLiteralContext() {}

func NewDurationLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DurationLiteralContext {
	var p = new(DurationLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_durationLiteral

	return p
}

func (s *DurationLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DurationLiteralContext) DURATION() antlr.TerminalNode {
	return s.GetToken(GQLParserDURATION, 0)
}

func (s *DurationLiteralContext) DurationString() IDurationStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDurationStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDurationStringContext)
}

func (s *DurationLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurationLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DurationLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDurationLiteral(s)
	}
}

func (s *DurationLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDurationLiteral(s)
	}
}

func (p *GQLParser) DurationLiteral() (localctx IDurationLiteralContext) {
	localctx = NewDurationLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1166, GQLParserRULE_durationLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4704)
		p.Match(GQLParserDURATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4705)
		p.DurationString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDurationStringContext is an interface to support dynamic dispatch.
type IDurationStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CharacterStringLiteral() ICharacterStringLiteralContext

	// IsDurationStringContext differentiates from other interfaces.
	IsDurationStringContext()
}

type DurationStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDurationStringContext() *DurationStringContext {
	var p = new(DurationStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_durationString
	return p
}

func InitEmptyDurationStringContext(p *DurationStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_durationString
}

func (*DurationStringContext) IsDurationStringContext() {}

func NewDurationStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DurationStringContext {
	var p = new(DurationStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_durationString

	return p
}

func (s *DurationStringContext) GetParser() antlr.Parser { return s.parser }

func (s *DurationStringContext) CharacterStringLiteral() ICharacterStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacterStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacterStringLiteralContext)
}

func (s *DurationStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurationStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DurationStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterDurationString(s)
	}
}

func (s *DurationStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitDurationString(s)
	}
}

func (p *GQLParser) DurationString() (localctx IDurationStringContext) {
	localctx = NewDurationStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1168, GQLParserRULE_durationString)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4707)
		p.CharacterStringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INodeSynonymContext is an interface to support dynamic dispatch.
type INodeSynonymContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NODE() antlr.TerminalNode
	VERTEX() antlr.TerminalNode

	// IsNodeSynonymContext differentiates from other interfaces.
	IsNodeSynonymContext()
}

type NodeSynonymContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodeSynonymContext() *NodeSynonymContext {
	var p = new(NodeSynonymContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeSynonym
	return p
}

func InitEmptyNodeSynonymContext(p *NodeSynonymContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nodeSynonym
}

func (*NodeSynonymContext) IsNodeSynonymContext() {}

func NewNodeSynonymContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodeSynonymContext {
	var p = new(NodeSynonymContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nodeSynonym

	return p
}

func (s *NodeSynonymContext) GetParser() antlr.Parser { return s.parser }

func (s *NodeSynonymContext) NODE() antlr.TerminalNode {
	return s.GetToken(GQLParserNODE, 0)
}

func (s *NodeSynonymContext) VERTEX() antlr.TerminalNode {
	return s.GetToken(GQLParserVERTEX, 0)
}

func (s *NodeSynonymContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodeSynonymContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NodeSynonymContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNodeSynonym(s)
	}
}

func (s *NodeSynonymContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNodeSynonym(s)
	}
}

func (p *GQLParser) NodeSynonym() (localctx INodeSynonymContext) {
	localctx = NewNodeSynonymContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1170, GQLParserRULE_nodeSynonym)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4709)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserNODE || _la == GQLParserVERTEX) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgesSynonymContext is an interface to support dynamic dispatch.
type IEdgesSynonymContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EDGES() antlr.TerminalNode
	RELATIONSHIPS() antlr.TerminalNode

	// IsEdgesSynonymContext differentiates from other interfaces.
	IsEdgesSynonymContext()
}

type EdgesSynonymContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgesSynonymContext() *EdgesSynonymContext {
	var p = new(EdgesSynonymContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgesSynonym
	return p
}

func InitEmptyEdgesSynonymContext(p *EdgesSynonymContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgesSynonym
}

func (*EdgesSynonymContext) IsEdgesSynonymContext() {}

func NewEdgesSynonymContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgesSynonymContext {
	var p = new(EdgesSynonymContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgesSynonym

	return p
}

func (s *EdgesSynonymContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgesSynonymContext) EDGES() antlr.TerminalNode {
	return s.GetToken(GQLParserEDGES, 0)
}

func (s *EdgesSynonymContext) RELATIONSHIPS() antlr.TerminalNode {
	return s.GetToken(GQLParserRELATIONSHIPS, 0)
}

func (s *EdgesSynonymContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgesSynonymContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgesSynonymContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgesSynonym(s)
	}
}

func (s *EdgesSynonymContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgesSynonym(s)
	}
}

func (p *GQLParser) EdgesSynonym() (localctx IEdgesSynonymContext) {
	localctx = NewEdgesSynonymContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1172, GQLParserRULE_edgesSynonym)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4711)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserEDGES || _la == GQLParserRELATIONSHIPS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEdgeSynonymContext is an interface to support dynamic dispatch.
type IEdgeSynonymContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EDGE() antlr.TerminalNode
	RELATIONSHIP() antlr.TerminalNode

	// IsEdgeSynonymContext differentiates from other interfaces.
	IsEdgeSynonymContext()
}

type EdgeSynonymContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEdgeSynonymContext() *EdgeSynonymContext {
	var p = new(EdgeSynonymContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeSynonym
	return p
}

func InitEmptyEdgeSynonymContext(p *EdgeSynonymContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_edgeSynonym
}

func (*EdgeSynonymContext) IsEdgeSynonymContext() {}

func NewEdgeSynonymContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EdgeSynonymContext {
	var p = new(EdgeSynonymContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_edgeSynonym

	return p
}

func (s *EdgeSynonymContext) GetParser() antlr.Parser { return s.parser }

func (s *EdgeSynonymContext) EDGE() antlr.TerminalNode {
	return s.GetToken(GQLParserEDGE, 0)
}

func (s *EdgeSynonymContext) RELATIONSHIP() antlr.TerminalNode {
	return s.GetToken(GQLParserRELATIONSHIP, 0)
}

func (s *EdgeSynonymContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EdgeSynonymContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EdgeSynonymContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterEdgeSynonym(s)
	}
}

func (s *EdgeSynonymContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitEdgeSynonym(s)
	}
}

func (p *GQLParser) EdgeSynonym() (localctx IEdgeSynonymContext) {
	localctx = NewEdgeSynonymContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1174, GQLParserRULE_edgeSynonym)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4713)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GQLParserEDGE || _la == GQLParserRELATIONSHIP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedWordsContext is an interface to support dynamic dispatch.
type INonReservedWordsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACYCLIC() antlr.TerminalNode
	BINDING() antlr.TerminalNode
	BINDINGS() antlr.TerminalNode
	CONNECTING() antlr.TerminalNode
	DESTINATION() antlr.TerminalNode
	DIFFERENT() antlr.TerminalNode
	DIRECTED() antlr.TerminalNode
	EDGE() antlr.TerminalNode
	EDGES() antlr.TerminalNode
	ELEMENT() antlr.TerminalNode
	ELEMENTS() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	GRAPH() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	KEEP() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	LABELED() antlr.TerminalNode
	LABELS() antlr.TerminalNode
	LAST() antlr.TerminalNode
	NFC() antlr.TerminalNode
	NFD() antlr.TerminalNode
	NFKC() antlr.TerminalNode
	NFKD() antlr.TerminalNode
	NO() antlr.TerminalNode
	NODE() antlr.TerminalNode
	NORMALIZED() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	ORDINALITY() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	READ() antlr.TerminalNode
	RELATIONSHIP() antlr.TerminalNode
	RELATIONSHIPS() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	SHORTEST() antlr.TerminalNode
	SIMPLE() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TO() antlr.TerminalNode
	TRAIL() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	UNDIRECTED() antlr.TerminalNode
	VERTEX() antlr.TerminalNode
	WALK() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	ZONE() antlr.TerminalNode

	// IsNonReservedWordsContext differentiates from other interfaces.
	IsNonReservedWordsContext()
}

type NonReservedWordsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedWordsContext() *NonReservedWordsContext {
	var p = new(NonReservedWordsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nonReservedWords
	return p
}

func InitEmptyNonReservedWordsContext(p *NonReservedWordsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = GQLParserRULE_nonReservedWords
}

func (*NonReservedWordsContext) IsNonReservedWordsContext() {}

func NewNonReservedWordsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedWordsContext {
	var p = new(NonReservedWordsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = GQLParserRULE_nonReservedWords

	return p
}

func (s *NonReservedWordsContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedWordsContext) ACYCLIC() antlr.TerminalNode {
	return s.GetToken(GQLParserACYCLIC, 0)
}

func (s *NonReservedWordsContext) BINDING() antlr.TerminalNode {
	return s.GetToken(GQLParserBINDING, 0)
}

func (s *NonReservedWordsContext) BINDINGS() antlr.TerminalNode {
	return s.GetToken(GQLParserBINDINGS, 0)
}

func (s *NonReservedWordsContext) CONNECTING() antlr.TerminalNode {
	return s.GetToken(GQLParserCONNECTING, 0)
}

func (s *NonReservedWordsContext) DESTINATION() antlr.TerminalNode {
	return s.GetToken(GQLParserDESTINATION, 0)
}

func (s *NonReservedWordsContext) DIFFERENT() antlr.TerminalNode {
	return s.GetToken(GQLParserDIFFERENT, 0)
}

func (s *NonReservedWordsContext) DIRECTED() antlr.TerminalNode {
	return s.GetToken(GQLParserDIRECTED, 0)
}

func (s *NonReservedWordsContext) EDGE() antlr.TerminalNode {
	return s.GetToken(GQLParserEDGE, 0)
}

func (s *NonReservedWordsContext) EDGES() antlr.TerminalNode {
	return s.GetToken(GQLParserEDGES, 0)
}

func (s *NonReservedWordsContext) ELEMENT() antlr.TerminalNode {
	return s.GetToken(GQLParserELEMENT, 0)
}

func (s *NonReservedWordsContext) ELEMENTS() antlr.TerminalNode {
	return s.GetToken(GQLParserELEMENTS, 0)
}

func (s *NonReservedWordsContext) FIRST() antlr.TerminalNode {
	return s.GetToken(GQLParserFIRST, 0)
}

func (s *NonReservedWordsContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(GQLParserGRAPH, 0)
}

func (s *NonReservedWordsContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(GQLParserGROUPS, 0)
}

func (s *NonReservedWordsContext) KEEP() antlr.TerminalNode {
	return s.GetToken(GQLParserKEEP, 0)
}

func (s *NonReservedWordsContext) LABEL() antlr.TerminalNode {
	return s.GetToken(GQLParserLABEL, 0)
}

func (s *NonReservedWordsContext) LABELED() antlr.TerminalNode {
	return s.GetToken(GQLParserLABELED, 0)
}

func (s *NonReservedWordsContext) LABELS() antlr.TerminalNode {
	return s.GetToken(GQLParserLABELS, 0)
}

func (s *NonReservedWordsContext) LAST() antlr.TerminalNode {
	return s.GetToken(GQLParserLAST, 0)
}

func (s *NonReservedWordsContext) NFC() antlr.TerminalNode {
	return s.GetToken(GQLParserNFC, 0)
}

func (s *NonReservedWordsContext) NFD() antlr.TerminalNode {
	return s.GetToken(GQLParserNFD, 0)
}

func (s *NonReservedWordsContext) NFKC() antlr.TerminalNode {
	return s.GetToken(GQLParserNFKC, 0)
}

func (s *NonReservedWordsContext) NFKD() antlr.TerminalNode {
	return s.GetToken(GQLParserNFKD, 0)
}

func (s *NonReservedWordsContext) NO() antlr.TerminalNode {
	return s.GetToken(GQLParserNO, 0)
}

func (s *NonReservedWordsContext) NODE() antlr.TerminalNode {
	return s.GetToken(GQLParserNODE, 0)
}

func (s *NonReservedWordsContext) NORMALIZED() antlr.TerminalNode {
	return s.GetToken(GQLParserNORMALIZED, 0)
}

func (s *NonReservedWordsContext) ONLY() antlr.TerminalNode {
	return s.GetToken(GQLParserONLY, 0)
}

func (s *NonReservedWordsContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(GQLParserORDINALITY, 0)
}

func (s *NonReservedWordsContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(GQLParserPROPERTY, 0)
}

func (s *NonReservedWordsContext) READ() antlr.TerminalNode {
	return s.GetToken(GQLParserREAD, 0)
}

func (s *NonReservedWordsContext) RELATIONSHIP() antlr.TerminalNode {
	return s.GetToken(GQLParserRELATIONSHIP, 0)
}

func (s *NonReservedWordsContext) RELATIONSHIPS() antlr.TerminalNode {
	return s.GetToken(GQLParserRELATIONSHIPS, 0)
}

func (s *NonReservedWordsContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(GQLParserREPEATABLE, 0)
}

func (s *NonReservedWordsContext) SHORTEST() antlr.TerminalNode {
	return s.GetToken(GQLParserSHORTEST, 0)
}

func (s *NonReservedWordsContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(GQLParserSIMPLE, 0)
}

func (s *NonReservedWordsContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(GQLParserSOURCE, 0)
}

func (s *NonReservedWordsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(GQLParserTABLE, 0)
}

func (s *NonReservedWordsContext) TO() antlr.TerminalNode {
	return s.GetToken(GQLParserTO, 0)
}

func (s *NonReservedWordsContext) TRAIL() antlr.TerminalNode {
	return s.GetToken(GQLParserTRAIL, 0)
}

func (s *NonReservedWordsContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(GQLParserTRANSACTION, 0)
}

func (s *NonReservedWordsContext) TYPE() antlr.TerminalNode {
	return s.GetToken(GQLParserTYPE, 0)
}

func (s *NonReservedWordsContext) UNDIRECTED() antlr.TerminalNode {
	return s.GetToken(GQLParserUNDIRECTED, 0)
}

func (s *NonReservedWordsContext) VERTEX() antlr.TerminalNode {
	return s.GetToken(GQLParserVERTEX, 0)
}

func (s *NonReservedWordsContext) WALK() antlr.TerminalNode {
	return s.GetToken(GQLParserWALK, 0)
}

func (s *NonReservedWordsContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(GQLParserWITHOUT, 0)
}

func (s *NonReservedWordsContext) WRITE() antlr.TerminalNode {
	return s.GetToken(GQLParserWRITE, 0)
}

func (s *NonReservedWordsContext) ZONE() antlr.TerminalNode {
	return s.GetToken(GQLParserZONE, 0)
}

func (s *NonReservedWordsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedWordsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedWordsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.EnterNonReservedWords(s)
	}
}

func (s *NonReservedWordsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GQLListener); ok {
		listenerT.ExitNonReservedWords(s)
	}
}

func (p *GQLParser) NonReservedWords() (localctx INonReservedWordsContext) {
	localctx = NewNonReservedWordsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1176, GQLParserRULE_nonReservedWords)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4715)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-280)) & ^0x3f) == 0 && ((int64(1)<<(_la-280))&140737488355327) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *GQLParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 92:
		var t *CompositeQueryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*CompositeQueryExpressionContext)
		}
		return p.CompositeQueryExpression_Sempred(t, predIndex)

	case 214:
		var t *LabelExpressionContext = nil
		if localctx != nil {
			t = localctx.(*LabelExpressionContext)
		}
		return p.LabelExpression_Sempred(t, predIndex)

	case 233:
		var t *SimplifiedTermContext = nil
		if localctx != nil {
			t = localctx.(*SimplifiedTermContext)
		}
		return p.SimplifiedTerm_Sempred(t, predIndex)

	case 234:
		var t *SimplifiedFactorLowContext = nil
		if localctx != nil {
			t = localctx.(*SimplifiedFactorLowContext)
		}
		return p.SimplifiedFactorLow_Sempred(t, predIndex)

	case 352:
		var t *ValueTypeContext = nil
		if localctx != nil {
			t = localctx.(*ValueTypeContext)
		}
		return p.ValueType_Sempred(t, predIndex)

	case 424:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 436:
		var t *ValueExpressionPrimaryContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionPrimaryContext)
		}
		return p.ValueExpressionPrimary_Sempred(t, predIndex)

	case 491:
		var t *NumericValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*NumericValueExpressionContext)
		}
		return p.NumericValueExpression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *GQLParser) CompositeQueryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GQLParser) LabelExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GQLParser) SimplifiedTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GQLParser) SimplifiedFactorLow_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GQLParser) ValueType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 7)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GQLParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 7)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GQLParser) ValueExpressionPrimary_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 15:
		return p.Precpred(p.GetParserRuleContext(), 7)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GQLParser) NumericValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 16:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
